<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ana Macanovic" />

<meta name="date" content="2024-01-28" />

<title>Untitled</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a>
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="index.html">Code homepage</a>
</li>
<li>
  <a href="OpenAlex_Altmetric_data_download.html">Open Alex and Altmetric data download</a>
</li>
<li>
  <a href="Gender_inference.html">Gender inference</a>
</li>
<li>
  <a href="Mention_url_extraction.html">News full text and author names</a>
</li>
<li>
  <a href="Overall_descriptives.html">Database description and coverage</a>
</li>
<li>
  <a href="Data_descriptives.html">Professor-level descriptives</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/amacanovic/dutch_media_profs">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Untitled</h1>
<h4 class="author">Ana Macanovic</h4>
<h4 class="date">2024-01-28</h4>

</div>


<pre class="r"><code>library(groundhog)
packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;openalexR&quot;,
                      &quot;ggplot2&quot;, &quot;stringr&quot;, &quot;tidyr&quot;,
                      &quot;jsonlite&quot;, &quot;xml2&quot;, &quot;tidyverse&quot;,
                      &quot;RPostgres&quot;, &quot;lubridate&quot;,&quot;digest&quot;,
                      &quot;DBI&quot;, &quot;RODBC&quot;, &quot;odbc&quot;, &quot;foreach&quot;,
                      &quot;doParallel&quot;)
groundhog.library(packages_to_load, date = &quot;2023-12-01&quot;)</code></pre>
<pre class="r"><code>port &lt;- 5432
user &lt;- &quot;postgres&quot;
password &lt;- &quot;dutchmediaprofssql&quot;
database_name &lt;- &quot;postgres&quot;


## Altmetric explorer (Ana&#39;s key)
api_secret &lt;- &#39;c55fc3a742e74ac5b0d3a6f2bc5090b7&#39;
api_key &lt;- &#39;bad7d623c7204f75ad0d53acd2fe5d85&#39;

con &lt;- RPostgres::dbConnect(RPostgres::Postgres(),
                 dbname= database_name,
                 port = port,
                 user = user, 
                 password = password)</code></pre>
<pre class="r"><code>cores=detectCores()
cl &lt;- makeCluster(cores[1]-6) #not to overload your computer
registerDoParallel(cl)

prof_batch_size &lt;- 1000
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(coauthor_oa), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(coauthor_oa)+1)


output &lt;- foreach(i= 1:5, .combine = combine, .multicombine = TRUE) %dopar% {
  # get the narcis ids from the batch
  prof_batch &lt;- coauthor_oa[batches[i]:(batches[i+1]-1)]
  prof_coauthor_info_oa &lt;- NA
  
  try(prof_coauthor_info_oa &lt;- oa_fetch(
    entity = &quot;authors&quot;, 
    openalex_id = prof_batch))
  
  if (!all(is.na(prof_coauthor_info_oa))){
    
    # unnest the data 
    prof_coauthor_info_oa_unnest &lt;- unnest(prof_coauthor_info_oa, cols = c(counts_by_year), names_sep = &quot;_&quot;)%&gt;%
      select(-x_concepts)
    
    # get their names
    # first, get all the name alternatives as well
    coauthor_name_variations &lt;- prof_coauthor_info_oa %&gt;%
      select(id, display_name, display_name_alternatives)%&gt;%
      unnest(., cols = c(display_name_alternatives))
    # wide to long, with all variations
    coauthor_name_variations &lt;- gather(coauthor_name_variations,
                                       type, 
                                       full_name, 
                                       display_name:display_name_alternatives, 
                                       factor_key=FALSE)
    
    # now, identify which ones are actualy names, and not just initials
    # get the first word, and detect if longer than 1 character and/or does not contain any full stops
    coauthor_name_variations$first &lt;- word(coauthor_name_variations$full_name, 1)
    coauthor_name_variations$valid_name &lt;- ifelse(str_detect(coauthor_name_variations$first, &quot;\\.&quot;),
                                                  &quot;FALSE&quot;,
                                                  &quot;TRUE&quot;)
    # get the name variation lengths
    coauthor_name_variations$length_first &lt;-  nchar(coauthor_name_variations$first) 
    coauthor_names &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))
    # leave only the ones where we seem to have a shortest name longer than 2 characters
    coauthor_names &lt;- filter(coauthor_name_variations, valid_name == TRUE)%&gt;%
      group_by(id)%&gt;%
      slice(which.max(length_first))%&gt;%
      filter(., length_first &gt; 2)%&gt;%
      select(-valid_name, -length_first, -type)
    
    # select prof info
    coauthor_info &lt;- data.frame(matrix(NA, nrow = 0, ncol = 14))
    columns &lt;- c(&quot;id&quot;, &quot;display_name&quot;, &quot;orcid&quot;, &quot;works_count&quot;,
                 &quot;cited_by_count&quot;, &quot;counts_by_year_year&quot;, &quot;counts_by_year_works_count&quot;, 
                 &quot;counts_by_year_cited_by_count&quot;, &quot;affiliation_display_name&quot;, 
                 &quot;affiliation_id&quot;, &quot;affiliation_ror&quot;, &quot;affiliation_country_code&quot;,
                 &quot;affiliation_type&quot;, &quot;works_api_url&quot;)
    # padding in case some columns are missing
    if(!all(columns %in% colnames(prof_coauthor_info_oa_unnest))){
      n_missing &lt;- which(!columns %in% colnames(prof_coauthor_info_oa_unnest))
      padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
      colnames(padding) &lt;- columns[which(!columns %in% colnames(prof_coauthor_info_oa_unnest))]
      prof_coauthor_info_oa_unnest &lt;- bind_cols(prof_coauthor_info_oa_unnest,
                                                padding)
      prof_coauthor_info_oa_unnest &lt;- prof_coauthor_info_oa_unnest[columns]
    }
    
    coauthor_info &lt;- prof_coauthor_info_oa_unnest%&gt;%
      select(id, display_name, orcid, works_count,
             cited_by_count, counts_by_year_year, counts_by_year_works_count, 
             counts_by_year_cited_by_count, affiliation_display_name, 
             affiliation_id, affiliation_ror, affiliation_country_code,
             affiliation_type, works_api_url)
    
    list(coauthor_names, coauthor_info)
    
  }
}

#stop cluster
stopCluster(cl)


lapply(purrr::transpose(tmp), function(l) do.call(rbind, l))</code></pre>
<p>Missing ones:</p>
<pre class="r"><code>missing_oa &lt;- coauthor_oa[which(! coauthor_oa %in% coauthor_info_list$id)]

prof_batch_size &lt;- 500
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(missing_oa), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(missing_oa)+1)


# query additional prof info
for(i in 1:(length(batches)-1)){
  # get the narcis ids from the batch
  prof_batch &lt;- missing_oa[batches[i]:(batches[i+1]-1)]
  prof_coauthor_info_oa &lt;- NA
  
  try(prof_coauthor_info_oa &lt;- oa_fetch(
    entity = &quot;authors&quot;, 
    openalex_id = prof_batch))
  
  if (!all(is.na(prof_coauthor_info_oa))){
    
    # unnest the data 
    prof_coauthor_info_oa_unnest &lt;- unnest(prof_coauthor_info_oa, cols = c(counts_by_year), names_sep = &quot;_&quot;)%&gt;%
      select(-x_concepts)
    
    # get their names
    # first, get all the name alternatives as well
    coauthor_name_variations &lt;- prof_coauthor_info_oa %&gt;%
      select(id, display_name, display_name_alternatives)%&gt;%
      unnest(., cols = c(display_name_alternatives))
    # wide to long, with all variations
    coauthor_name_variations &lt;- gather(coauthor_name_variations,
                                       type, 
                                       full_name, 
                                       display_name:display_name_alternatives, 
                                       factor_key=FALSE)
    
    # now, identify which ones are actualy names, and not just initials
    # get the first word, and detect if longer than 1 character and/or does not contain any full stops
    coauthor_name_variations$first &lt;- word(coauthor_name_variations$full_name, 1)
    coauthor_name_variations$valid_name &lt;- ifelse(str_detect(coauthor_name_variations$first, &quot;\\.&quot;),
                                                  &quot;FALSE&quot;,
                                                  &quot;TRUE&quot;)
    # get the name variation lengths
    coauthor_name_variations$length_first &lt;-  nchar(coauthor_name_variations$first) 
    coauthor_names &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))
    # leave only the ones where we seem to have a shortest name longer than 2 characters
    coauthor_names &lt;- filter(coauthor_name_variations, valid_name == TRUE)%&gt;%
      group_by(id)%&gt;%
      slice(which.max(length_first))%&gt;%
      filter(., length_first &gt; 2)%&gt;%
      select(-valid_name, -length_first, -type)
    
    # append the new names to the names dataframe
    if (!all(is.na(coauthor_names))){
      new_names &lt;- filter(coauthor_names, 
                          ! id %in% coauthor_name_list$id)
      coauthor_name_list &lt;- rbind(coauthor_name_list,
                                  new_names)
    }
    
    # select prof info
    coauthor_info &lt;- data.frame(matrix(NA, nrow = 0, ncol = 14))
    columns &lt;- c(&quot;id&quot;, &quot;display_name&quot;, &quot;orcid&quot;, &quot;works_count&quot;,
                 &quot;cited_by_count&quot;, &quot;counts_by_year_year&quot;, &quot;counts_by_year_works_count&quot;, 
                 &quot;counts_by_year_cited_by_count&quot;, &quot;affiliation_display_name&quot;, 
                 &quot;affiliation_id&quot;, &quot;affiliation_ror&quot;, &quot;affiliation_country_code&quot;,
                 &quot;affiliation_type&quot;, &quot;works_api_url&quot;)
    # padding in case some columns are missing
    if(!all(columns %in% colnames(prof_coauthor_info_oa_unnest))){
      n_missing &lt;- which(!columns %in% colnames(prof_coauthor_info_oa_unnest))
      padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
      colnames(padding) &lt;- columns[which(!columns %in% colnames(prof_coauthor_info_oa_unnest))]
      prof_coauthor_info_oa_unnest &lt;- bind_cols(prof_coauthor_info_oa_unnest,
                                                padding)
      prof_coauthor_info_oa_unnest &lt;- prof_coauthor_info_oa_unnest[columns]
    }
    
    coauthor_info &lt;- prof_coauthor_info_oa_unnest%&gt;%
      select(id, display_name, orcid, works_count,
             cited_by_count, counts_by_year_year, counts_by_year_works_count, 
             counts_by_year_cited_by_count, affiliation_display_name, 
             affiliation_id, affiliation_ror, affiliation_country_code,
             affiliation_type, works_api_url)
    
    # append the new info to the info dataframe
    if (!all(is.na(coauthor_info))){
      new_info &lt;- filter(coauthor_info, 
                         ! id %in% coauthor_info_list$id)
      
      coauthor_info_list &lt;- rbind(coauthor_info_list,
                                  new_info)
    }
  }
  
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(batches)-1))
}</code></pre>
<pre class="r"><code>library(groundhog)
packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;openalexR&quot;,
                      &quot;ggplot2&quot;, &quot;stringr&quot;, &quot;tidyr&quot;,
                      &quot;jsonlite&quot;, &quot;xml2&quot;, &quot;tidyverse&quot;,
                      &quot;RPostgres&quot;, &quot;lubridate&quot;,&quot;digest&quot;,
                      &quot;DBI&quot;, &quot;RODBC&quot;, &quot;odbc&quot;, &quot;foreach&quot;,
                      &quot;doParallel&quot;, &quot;doSNOW&quot;)
groundhog.library(packages_to_load, date = &quot;2023-12-01&quot;)</code></pre>
<pre class="r"><code>port &lt;- 5432
user &lt;- &quot;postgres&quot;
password &lt;- &quot;dutchmediaprofssql&quot;
database_name &lt;- &quot;postgres&quot;


## Altmetric explorer (Ana&#39;s key)
api_secret &lt;- &#39;c55fc3a742e74ac5b0d3a6f2bc5090b7&#39;
api_key &lt;- &#39;bad7d623c7204f75ad0d53acd2fe5d85&#39;

con &lt;- RPostgres::dbConnect(RPostgres::Postgres(),
                 dbname= database_name,
                 port = port,
                 user = user, 
                 password = password)</code></pre>
<pre class="r"><code># get all the coauthor info
coauthor_list &lt;- dbGetQuery(conn = con, statement = paste0(&quot;select * from coauthor_info;&quot;))

#get the ubique OA IDs of coauthors
coauthor_oa &lt;- unique(coauthor_list$au_id)
# drop redundant data
rm(coauthor_list)
gc()</code></pre>
<p>Parallelizing this process:</p>
<pre class="r"><code># detect cores and set the preferred number (we have 16 and want to use 10)
cores=detectCores()
cl &lt;- makeCluster(cores[1]-6)
registerDoParallel(cl)

# set the preferred batch size for OA calls
prof_batch_size &lt;- 100
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(coauthor_oa), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(coauthor_oa)+1)

# load some stuff for the progress bar

#parallelize the extraction of seller names and extended info
output &lt;- foreach(i= 20:21, .packages=c(&#39;openalexR&#39;, &#39;dplyr&#39;, &#39;tidyr&#39;, &#39;stringr&#39;),
                  .verbose = T) %do% {
  # get the narcis ids from the batch
  prof_batch &lt;- coauthor_oa[batches[i]:(batches[i+1]-1)]
  loop_output &lt;- coauthor_oa_fetches(prof_batch)
  return(loop_output)
  }

stopCluster(cl)
# tidy up the output
coauthor_names &lt;- lapply(purrr::transpose(output), function(l) do.call(rbind, l))[[&quot;names&quot;]]
coauthor_info &lt;- lapply(purrr::transpose(output), function(l) do.call(rbind, l))[[&quot;info&quot;]]</code></pre>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlVudGl0bGVkIg0KYXV0aG9yOiAiQW5hIE1hY2Fub3ZpYyINCmRhdGU6ICIyMDI0LTAxLTI4Ig0Kb3V0cHV0OiBodG1sX2RvY3VtZW50DQotLS0NCmBgYHtyIGluY2x1ZGU9RkFMU0V9DQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpDQprbml0cjo6b3B0c19jaHVuayRzZXQoZXZhbCA9IEZBTFNFKQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KHdhcm5pbmcgPSBGQUxTRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChtZXNzYWdlID0gRkFMU0UpDQpgYGANCg0KDQpgYGB7cn0NCmxpYnJhcnkoZ3JvdW5kaG9nKQ0KcGFja2FnZXNfdG9fbG9hZCA8LSBjKCJyZWFkciIsICJkcGx5ciIsICJvcGVuYWxleFIiLA0KICAgICAgICAgICAgICAgICAgICAgICJnZ3Bsb3QyIiwgInN0cmluZ3IiLCAidGlkeXIiLA0KICAgICAgICAgICAgICAgICAgICAgICJqc29ubGl0ZSIsICJ4bWwyIiwgInRpZHl2ZXJzZSIsDQogICAgICAgICAgICAgICAgICAgICAgIlJQb3N0Z3JlcyIsICJsdWJyaWRhdGUiLCJkaWdlc3QiLA0KICAgICAgICAgICAgICAgICAgICAgICJEQkkiLCAiUk9EQkMiLCAib2RiYyIsICJmb3JlYWNoIiwNCiAgICAgICAgICAgICAgICAgICAgICAiZG9QYXJhbGxlbCIpDQpncm91bmRob2cubGlicmFyeShwYWNrYWdlc190b19sb2FkLCBkYXRlID0gIjIwMjMtMTItMDEiKQ0KDQpgYGANCg0KYGBge3J9DQpwb3J0IDwtIDU0MzINCnVzZXIgPC0gInBvc3RncmVzIg0KcGFzc3dvcmQgPC0gImR1dGNobWVkaWFwcm9mc3NxbCINCmRhdGFiYXNlX25hbWUgPC0gInBvc3RncmVzIg0KDQoNCiMjIEFsdG1ldHJpYyBleHBsb3JlciAoQW5hJ3Mga2V5KQ0KYXBpX3NlY3JldCA8LSAnYzU1ZmMzYTc0MmU3NGFjNWIwZDNhNmYyYmM1MDkwYjcnDQphcGlfa2V5IDwtICdiYWQ3ZDYyM2M3MjA0Zjc1YWQwZDUzYWNkMmZlNWQ4NScNCg0KY29uIDwtIFJQb3N0Z3Jlczo6ZGJDb25uZWN0KFJQb3N0Z3Jlczo6UG9zdGdyZXMoKSwNCiAgICAgICAgICAgICAgICAgZGJuYW1lPSBkYXRhYmFzZV9uYW1lLA0KICAgICAgICAgICAgICAgICBwb3J0ID0gcG9ydCwNCiAgICAgICAgICAgICAgICAgdXNlciA9IHVzZXIsIA0KICAgICAgICAgICAgICAgICBwYXNzd29yZCA9IHBhc3N3b3JkKQ0KYGBgDQoNCg0KYGBge3J9DQpjb3Jlcz1kZXRlY3RDb3JlcygpDQpjbCA8LSBtYWtlQ2x1c3Rlcihjb3Jlc1sxXS02KSAjbm90IHRvIG92ZXJsb2FkIHlvdXIgY29tcHV0ZXINCnJlZ2lzdGVyRG9QYXJhbGxlbChjbCkNCg0KcHJvZl9iYXRjaF9zaXplIDwtIDEwMDANCiMgdmVjdG9yIG9mIGluZGljZXMgdG8gbG9vcCB0aHJvdWdoDQpiYXRjaGVzIDwtIHNlcShmcm9tPTEsIHRvPWxlbmd0aChjb2F1dGhvcl9vYSksIGJ5PXByb2ZfYmF0Y2hfc2l6ZSkNCiMgdG8gYmUgYWJsZSB0byBzdWJzZXQsIGFsc28gYWRkIHRoZSBmaW5hbCBpbmRleCsxDQpiYXRjaGVzIDwtIGMoYmF0Y2hlcywgbGVuZ3RoKGNvYXV0aG9yX29hKSsxKQ0KDQoNCm91dHB1dCA8LSBmb3JlYWNoKGk9IDE6NSwgLmNvbWJpbmUgPSBjb21iaW5lLCAubXVsdGljb21iaW5lID0gVFJVRSkgJWRvcGFyJSB7DQogICMgZ2V0IHRoZSBuYXJjaXMgaWRzIGZyb20gdGhlIGJhdGNoDQogIHByb2ZfYmF0Y2ggPC0gY29hdXRob3Jfb2FbYmF0Y2hlc1tpXTooYmF0Y2hlc1tpKzFdLTEpXQ0KICBwcm9mX2NvYXV0aG9yX2luZm9fb2EgPC0gTkENCiAgDQogIHRyeShwcm9mX2NvYXV0aG9yX2luZm9fb2EgPC0gb2FfZmV0Y2goDQogICAgZW50aXR5ID0gImF1dGhvcnMiLCANCiAgICBvcGVuYWxleF9pZCA9IHByb2ZfYmF0Y2gpKQ0KICANCiAgaWYgKCFhbGwoaXMubmEocHJvZl9jb2F1dGhvcl9pbmZvX29hKSkpew0KICAgIA0KICAgICMgdW5uZXN0IHRoZSBkYXRhIA0KICAgIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QgPC0gdW5uZXN0KHByb2ZfY29hdXRob3JfaW5mb19vYSwgY29scyA9IGMoY291bnRzX2J5X3llYXIpLCBuYW1lc19zZXAgPSAiXyIpJT4lDQogICAgICBzZWxlY3QoLXhfY29uY2VwdHMpDQogICAgDQogICAgIyBnZXQgdGhlaXIgbmFtZXMNCiAgICAjIGZpcnN0LCBnZXQgYWxsIHRoZSBuYW1lIGFsdGVybmF0aXZlcyBhcyB3ZWxsDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zIDwtIHByb2ZfY29hdXRob3JfaW5mb19vYSAlPiUNCiAgICAgIHNlbGVjdChpZCwgZGlzcGxheV9uYW1lLCBkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzKSU+JQ0KICAgICAgdW5uZXN0KC4sIGNvbHMgPSBjKGRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMpKQ0KICAgICMgd2lkZSB0byBsb25nLCB3aXRoIGFsbCB2YXJpYXRpb25zDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zIDwtIGdhdGhlcihjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxfbmFtZSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6ZGlzcGxheV9uYW1lX2FsdGVybmF0aXZlcywgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3Jfa2V5PUZBTFNFKQ0KICAgIA0KICAgICMgbm93LCBpZGVudGlmeSB3aGljaCBvbmVzIGFyZSBhY3R1YWx5IG5hbWVzLCBhbmQgbm90IGp1c3QgaW5pdGlhbHMNCiAgICAjIGdldCB0aGUgZmlyc3Qgd29yZCwgYW5kIGRldGVjdCBpZiBsb25nZXIgdGhhbiAxIGNoYXJhY3RlciBhbmQvb3IgZG9lcyBub3QgY29udGFpbiBhbnkgZnVsbCBzdG9wcw0KICAgIGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRmaXJzdCA8LSB3b3JkKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRmdWxsX25hbWUsIDEpDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zJHZhbGlkX25hbWUgPC0gaWZlbHNlKHN0cl9kZXRlY3QoY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZpcnN0LCAiXFwuIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJGQUxTRSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJUUlVFIikNCiAgICAjIGdldCB0aGUgbmFtZSB2YXJpYXRpb24gbGVuZ3Rocw0KICAgIGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRsZW5ndGhfZmlyc3QgPC0gIG5jaGFyKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRmaXJzdCkgDQogICAgY29hdXRob3JfbmFtZXMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQogICAgIyBsZWF2ZSBvbmx5IHRoZSBvbmVzIHdoZXJlIHdlIHNlZW0gdG8gaGF2ZSBhIHNob3J0ZXN0IG5hbWUgbG9uZ2VyIHRoYW4gMiBjaGFyYWN0ZXJzDQogICAgY29hdXRob3JfbmFtZXMgPC0gZmlsdGVyKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucywgdmFsaWRfbmFtZSA9PSBUUlVFKSU+JQ0KICAgICAgZ3JvdXBfYnkoaWQpJT4lDQogICAgICBzbGljZSh3aGljaC5tYXgobGVuZ3RoX2ZpcnN0KSklPiUNCiAgICAgIGZpbHRlciguLCBsZW5ndGhfZmlyc3QgPiAyKSU+JQ0KICAgICAgc2VsZWN0KC12YWxpZF9uYW1lLCAtbGVuZ3RoX2ZpcnN0LCAtdHlwZSkNCiAgICANCiAgICAjIHNlbGVjdCBwcm9mIGluZm8NCiAgICBjb2F1dGhvcl9pbmZvIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDE0KSkNCiAgICBjb2x1bW5zIDwtIGMoImlkIiwgImRpc3BsYXlfbmFtZSIsICJvcmNpZCIsICJ3b3Jrc19jb3VudCIsDQogICAgICAgICAgICAgICAgICJjaXRlZF9ieV9jb3VudCIsICJjb3VudHNfYnlfeWVhcl95ZWFyIiwgImNvdW50c19ieV95ZWFyX3dvcmtzX2NvdW50IiwgDQogICAgICAgICAgICAgICAgICJjb3VudHNfYnlfeWVhcl9jaXRlZF9ieV9jb3VudCIsICJhZmZpbGlhdGlvbl9kaXNwbGF5X25hbWUiLCANCiAgICAgICAgICAgICAgICAgImFmZmlsaWF0aW9uX2lkIiwgImFmZmlsaWF0aW9uX3JvciIsICJhZmZpbGlhdGlvbl9jb3VudHJ5X2NvZGUiLA0KICAgICAgICAgICAgICAgICAiYWZmaWxpYXRpb25fdHlwZSIsICJ3b3Jrc19hcGlfdXJsIikNCiAgICAjIHBhZGRpbmcgaW4gY2FzZSBzb21lIGNvbHVtbnMgYXJlIG1pc3NpbmcNCiAgICBpZighYWxsKGNvbHVtbnMgJWluJSBjb2xuYW1lcyhwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0KSkpew0KICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFjb2x1bW5zICVpbiUgY29sbmFtZXMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCkpDQogICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBjb2x1bW5zW3doaWNoKCFjb2x1bW5zICVpbiUgY29sbmFtZXMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCkpXQ0KICAgICAgcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCA8LSBiaW5kX2NvbHMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0IDwtIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3RbY29sdW1uc10NCiAgICB9DQogICAgDQogICAgY29hdXRob3JfaW5mbyA8LSBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0JT4lDQogICAgICBzZWxlY3QoaWQsIGRpc3BsYXlfbmFtZSwgb3JjaWQsIHdvcmtzX2NvdW50LA0KICAgICAgICAgICAgIGNpdGVkX2J5X2NvdW50LCBjb3VudHNfYnlfeWVhcl95ZWFyLCBjb3VudHNfYnlfeWVhcl93b3Jrc19jb3VudCwgDQogICAgICAgICAgICAgY291bnRzX2J5X3llYXJfY2l0ZWRfYnlfY291bnQsIGFmZmlsaWF0aW9uX2Rpc3BsYXlfbmFtZSwgDQogICAgICAgICAgICAgYWZmaWxpYXRpb25faWQsIGFmZmlsaWF0aW9uX3JvciwgYWZmaWxpYXRpb25fY291bnRyeV9jb2RlLA0KICAgICAgICAgICAgIGFmZmlsaWF0aW9uX3R5cGUsIHdvcmtzX2FwaV91cmwpDQogICAgDQogICAgbGlzdChjb2F1dGhvcl9uYW1lcywgY29hdXRob3JfaW5mbykNCiAgICANCiAgfQ0KfQ0KDQojc3RvcCBjbHVzdGVyDQpzdG9wQ2x1c3RlcihjbCkNCg0KDQpsYXBwbHkocHVycnI6OnRyYW5zcG9zZSh0bXApLCBmdW5jdGlvbihsKSBkby5jYWxsKHJiaW5kLCBsKSkNCmBgYA0KDQpgYGB7ciBzZXR1cCwgaW5jbHVkZT1GQUxTRX0NCiMgZ2V0IGFsbCB0aGUgY29hdXRob3IgaW5mbw0KY29hdXRob3JfbGlzdCA8LSBkYkdldFF1ZXJ5KGNvbm4gPSBjb24sIHN0YXRlbWVudCA9IHBhc3RlMCgic2VsZWN0ICogZnJvbSBjb2F1dGhvcl9pbmZvOyIpKQ0KDQojZ2V0IHRoZSB1YmlxdWUgT0EgSURzIG9mIGNvYXV0aG9ycw0KY29hdXRob3Jfb2EgPC0gdW5pcXVlKGNvYXV0aG9yX2xpc3QkYXVfaWQpDQojIGRyb3AgcmVkdW5kYW50IGRhdGENCnJtKGNvYXV0aG9yX2xpc3QpDQpnYygpDQoNCg0KIyBjb2F1dGhvciBhZmZpbGlhdGlvbiBldGMgbGlzdA0KY29hdXRob3JfaW5mb19saXN0IDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDE0KSkNCiMga2VlcCBhIGxpc3Qgb2YgY28tYXV0aG9yIG5hbWVzIHdpdGggaW5mZXJyZWQgZ2VuZGVycyB0aGF0IHdlIGNhbiBjb21wbGVtZW50IGZ1cnRoZXIgYW5kIGZ1cnRoZXINCiMgYXMgd2UgbG9vcCB0aHJvdWdoIHRoZSBkYXRhDQpjb2F1dGhvcl9uYW1lX2xpc3QgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQoNCnByb2ZfYmF0Y2hfc2l6ZSA8LSAxMDAwDQojIHZlY3RvciBvZiBpbmRpY2VzIHRvIGxvb3AgdGhyb3VnaA0KYmF0Y2hlcyA8LSBzZXEoZnJvbT0xLCB0bz1sZW5ndGgoY29hdXRob3Jfb2EpLCBieT1wcm9mX2JhdGNoX3NpemUpDQojIHRvIGJlIGFibGUgdG8gc3Vic2V0LCBhbHNvIGFkZCB0aGUgZmluYWwgaW5kZXgrMQ0KYmF0Y2hlcyA8LSBjKGJhdGNoZXMsIGxlbmd0aChjb2F1dGhvcl9vYSkrMSkNCg0KDQojIHF1ZXJ5IGFkZGl0aW9uYWwgcHJvZiBpbmZvDQpmb3IoaSBpbiAxOihsZW5ndGgoYmF0Y2hlcyktMSkpew0KICAjIGdldCB0aGUgbmFyY2lzIGlkcyBmcm9tIHRoZSBiYXRjaA0KICBwcm9mX2JhdGNoIDwtIGNvYXV0aG9yX29hW2JhdGNoZXNbaV06KGJhdGNoZXNbaSsxXS0xKV0NCiAgcHJvZl9jb2F1dGhvcl9pbmZvX29hIDwtIE5BDQogIA0KICB0cnkocHJvZl9jb2F1dGhvcl9pbmZvX29hIDwtIG9hX2ZldGNoKA0KICAgIGVudGl0eSA9ICJhdXRob3JzIiwgDQogICAgb3BlbmFsZXhfaWQgPSBwcm9mX2JhdGNoKSkNCiAgDQogIGlmICghYWxsKGlzLm5hKHByb2ZfY29hdXRob3JfaW5mb19vYSkpKXsNCiAgICANCiAgICAjIHVubmVzdCB0aGUgZGF0YSANCiAgICBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0IDwtIHVubmVzdChwcm9mX2NvYXV0aG9yX2luZm9fb2EsIGNvbHMgPSBjKGNvdW50c19ieV95ZWFyKSwgbmFtZXNfc2VwID0gIl8iKSU+JQ0KICAgICAgc2VsZWN0KC14X2NvbmNlcHRzKQ0KICAgIA0KICAgICMgZ2V0IHRoZWlyIG5hbWVzDQogICAgIyBmaXJzdCwgZ2V0IGFsbCB0aGUgbmFtZSBhbHRlcm5hdGl2ZXMgYXMgd2VsbA0KICAgIGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyA8LSBwcm9mX2NvYXV0aG9yX2luZm9fb2EgJT4lDQogICAgICBzZWxlY3QoaWQsIGRpc3BsYXlfbmFtZSwgZGlzcGxheV9uYW1lX2FsdGVybmF0aXZlcyklPiUNCiAgICAgIHVubmVzdCguLCBjb2xzID0gYyhkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzKSkNCiAgICAjIHdpZGUgdG8gbG9uZywgd2l0aCBhbGwgdmFyaWF0aW9ucw0KICAgIGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyA8LSBnYXRoZXIoY29hdXRob3JfbmFtZV92YXJpYXRpb25zLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsX25hbWUsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOmRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yX2tleT1GQUxTRSkNCiAgICANCiAgICAjIG5vdywgaWRlbnRpZnkgd2hpY2ggb25lcyBhcmUgYWN0dWFseSBuYW1lcywgYW5kIG5vdCBqdXN0IGluaXRpYWxzDQogICAgIyBnZXQgdGhlIGZpcnN0IHdvcmQsIGFuZCBkZXRlY3QgaWYgbG9uZ2VyIHRoYW4gMSBjaGFyYWN0ZXIgYW5kL29yIGRvZXMgbm90IGNvbnRhaW4gYW55IGZ1bGwgc3RvcHMNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkZmlyc3QgPC0gd29yZChjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkZnVsbF9uYW1lLCAxKQ0KICAgIGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyR2YWxpZF9uYW1lIDwtIGlmZWxzZShzdHJfZGV0ZWN0KGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRmaXJzdCwgIlxcLiIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiRkFMU0UiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiVFJVRSIpDQogICAgIyBnZXQgdGhlIG5hbWUgdmFyaWF0aW9uIGxlbmd0aHMNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkbGVuZ3RoX2ZpcnN0IDwtICBuY2hhcihjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkZmlyc3QpIA0KICAgIGNvYXV0aG9yX25hbWVzIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDMpKQ0KICAgICMgbGVhdmUgb25seSB0aGUgb25lcyB3aGVyZSB3ZSBzZWVtIHRvIGhhdmUgYSBzaG9ydGVzdCBuYW1lIGxvbmdlciB0aGFuIDIgY2hhcmFjdGVycw0KICAgIGNvYXV0aG9yX25hbWVzIDwtIGZpbHRlcihjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMsIHZhbGlkX25hbWUgPT0gVFJVRSklPiUNCiAgICAgIGdyb3VwX2J5KGlkKSU+JQ0KICAgICAgc2xpY2Uod2hpY2gubWF4KGxlbmd0aF9maXJzdCkpJT4lDQogICAgICBmaWx0ZXIoLiwgbGVuZ3RoX2ZpcnN0ID4gMiklPiUNCiAgICAgIHNlbGVjdCgtdmFsaWRfbmFtZSwgLWxlbmd0aF9maXJzdCwgLXR5cGUpDQogICAgDQogICAgIyBhcHBlbmQgdGhlIG5ldyBuYW1lcyB0byB0aGUgbmFtZXMgZGF0YWZyYW1lDQogICAgaWYgKCFhbGwoaXMubmEoY29hdXRob3JfbmFtZXMpKSl7DQogICAgICBuZXdfbmFtZXMgPC0gZmlsdGVyKGNvYXV0aG9yX25hbWVzLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgISBpZCAlaW4lIGNvYXV0aG9yX25hbWVfbGlzdCRpZCkNCiAgICAgIGNvYXV0aG9yX25hbWVfbGlzdCA8LSByYmluZChjb2F1dGhvcl9uYW1lX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X25hbWVzKQ0KICAgIH0NCiAgICANCiAgICAjIHNlbGVjdCBwcm9mIGluZm8NCiAgICBjb2F1dGhvcl9pbmZvIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDE0KSkNCiAgICBjb2x1bW5zIDwtIGMoImlkIiwgImRpc3BsYXlfbmFtZSIsICJvcmNpZCIsICJ3b3Jrc19jb3VudCIsDQogICAgICAgICAgICAgICAgICJjaXRlZF9ieV9jb3VudCIsICJjb3VudHNfYnlfeWVhcl95ZWFyIiwgImNvdW50c19ieV95ZWFyX3dvcmtzX2NvdW50IiwgDQogICAgICAgICAgICAgICAgICJjb3VudHNfYnlfeWVhcl9jaXRlZF9ieV9jb3VudCIsICJhZmZpbGlhdGlvbl9kaXNwbGF5X25hbWUiLCANCiAgICAgICAgICAgICAgICAgImFmZmlsaWF0aW9uX2lkIiwgImFmZmlsaWF0aW9uX3JvciIsICJhZmZpbGlhdGlvbl9jb3VudHJ5X2NvZGUiLA0KICAgICAgICAgICAgICAgICAiYWZmaWxpYXRpb25fdHlwZSIsICJ3b3Jrc19hcGlfdXJsIikNCiAgICAjIHBhZGRpbmcgaW4gY2FzZSBzb21lIGNvbHVtbnMgYXJlIG1pc3NpbmcNCiAgICBpZighYWxsKGNvbHVtbnMgJWluJSBjb2xuYW1lcyhwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0KSkpew0KICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFjb2x1bW5zICVpbiUgY29sbmFtZXMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCkpDQogICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBjb2x1bW5zW3doaWNoKCFjb2x1bW5zICVpbiUgY29sbmFtZXMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCkpXQ0KICAgICAgcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCA8LSBiaW5kX2NvbHMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0IDwtIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3RbY29sdW1uc10NCiAgICB9DQogICAgDQogICAgY29hdXRob3JfaW5mbyA8LSBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0JT4lDQogICAgICBzZWxlY3QoaWQsIGRpc3BsYXlfbmFtZSwgb3JjaWQsIHdvcmtzX2NvdW50LA0KICAgICAgICAgICAgIGNpdGVkX2J5X2NvdW50LCBjb3VudHNfYnlfeWVhcl95ZWFyLCBjb3VudHNfYnlfeWVhcl93b3Jrc19jb3VudCwgDQogICAgICAgICAgICAgY291bnRzX2J5X3llYXJfY2l0ZWRfYnlfY291bnQsIGFmZmlsaWF0aW9uX2Rpc3BsYXlfbmFtZSwgDQogICAgICAgICAgICAgYWZmaWxpYXRpb25faWQsIGFmZmlsaWF0aW9uX3JvciwgYWZmaWxpYXRpb25fY291bnRyeV9jb2RlLA0KICAgICAgICAgICAgIGFmZmlsaWF0aW9uX3R5cGUsIHdvcmtzX2FwaV91cmwpDQogICAgDQogICAgIyBhcHBlbmQgdGhlIG5ldyBpbmZvIHRvIHRoZSBpbmZvIGRhdGFmcmFtZQ0KICAgIGlmICghYWxsKGlzLm5hKGNvYXV0aG9yX2luZm8pKSl7DQogICAgICBuZXdfaW5mbyA8LSBmaWx0ZXIoY29hdXRob3JfaW5mbywgDQogICAgICAgICAgICAgICAgICAgICAgICAgISBpZCAlaW4lIGNvYXV0aG9yX2luZm9fbGlzdCRpZCkNCiAgICAgIA0KICAgICAgY29hdXRob3JfaW5mb19saXN0IDwtIHJiaW5kKGNvYXV0aG9yX2luZm9fbGlzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfaW5mbykNCiAgICB9DQogIH0NCiAgDQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKGJhdGNoZXMpKSkNCn0NCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX2NvYXV0aG9yX2luZm9fZnVsbCIsIGNvYXV0aG9yX2luZm9fbGlzdCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX2NvYXV0aG9yX25hbWVfbGlzdCIsIGNvYXV0aG9yX25hbWVfbGlzdCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQoNCk1pc3Npbmcgb25lczoNCmBgYHtyfQ0KbWlzc2luZ19vYSA8LSBjb2F1dGhvcl9vYVt3aGljaCghIGNvYXV0aG9yX29hICVpbiUgY29hdXRob3JfaW5mb19saXN0JGlkKV0NCg0KcHJvZl9iYXRjaF9zaXplIDwtIDUwMA0KIyB2ZWN0b3Igb2YgaW5kaWNlcyB0byBsb29wIHRocm91Z2gNCmJhdGNoZXMgPC0gc2VxKGZyb209MSwgdG89bGVuZ3RoKG1pc3Npbmdfb2EpLCBieT1wcm9mX2JhdGNoX3NpemUpDQojIHRvIGJlIGFibGUgdG8gc3Vic2V0LCBhbHNvIGFkZCB0aGUgZmluYWwgaW5kZXgrMQ0KYmF0Y2hlcyA8LSBjKGJhdGNoZXMsIGxlbmd0aChtaXNzaW5nX29hKSsxKQ0KDQoNCiMgcXVlcnkgYWRkaXRpb25hbCBwcm9mIGluZm8NCmZvcihpIGluIDE6KGxlbmd0aChiYXRjaGVzKS0xKSl7DQogICMgZ2V0IHRoZSBuYXJjaXMgaWRzIGZyb20gdGhlIGJhdGNoDQogIHByb2ZfYmF0Y2ggPC0gbWlzc2luZ19vYVtiYXRjaGVzW2ldOihiYXRjaGVzW2krMV0tMSldDQogIHByb2ZfY29hdXRob3JfaW5mb19vYSA8LSBOQQ0KICANCiAgdHJ5KHByb2ZfY29hdXRob3JfaW5mb19vYSA8LSBvYV9mZXRjaCgNCiAgICBlbnRpdHkgPSAiYXV0aG9ycyIsIA0KICAgIG9wZW5hbGV4X2lkID0gcHJvZl9iYXRjaCkpDQogIA0KICBpZiAoIWFsbChpcy5uYShwcm9mX2NvYXV0aG9yX2luZm9fb2EpKSl7DQogICAgDQogICAgIyB1bm5lc3QgdGhlIGRhdGEgDQogICAgcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCA8LSB1bm5lc3QocHJvZl9jb2F1dGhvcl9pbmZvX29hLCBjb2xzID0gYyhjb3VudHNfYnlfeWVhciksIG5hbWVzX3NlcCA9ICJfIiklPiUNCiAgICAgIHNlbGVjdCgteF9jb25jZXB0cykNCiAgICANCiAgICAjIGdldCB0aGVpciBuYW1lcw0KICAgICMgZmlyc3QsIGdldCBhbGwgdGhlIG5hbWUgYWx0ZXJuYXRpdmVzIGFzIHdlbGwNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMgPC0gcHJvZl9jb2F1dGhvcl9pbmZvX29hICU+JQ0KICAgICAgc2VsZWN0KGlkLCBkaXNwbGF5X25hbWUsIGRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMpJT4lDQogICAgICB1bm5lc3QoLiwgY29scyA9IGMoZGlzcGxheV9uYW1lX2FsdGVybmF0aXZlcykpDQogICAgIyB3aWRlIHRvIGxvbmcsIHdpdGggYWxsIHZhcmlhdGlvbnMNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMgPC0gZ2F0aGVyKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbF9uYW1lLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTpkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3Rvcl9rZXk9RkFMU0UpDQogICAgDQogICAgIyBub3csIGlkZW50aWZ5IHdoaWNoIG9uZXMgYXJlIGFjdHVhbHkgbmFtZXMsIGFuZCBub3QganVzdCBpbml0aWFscw0KICAgICMgZ2V0IHRoZSBmaXJzdCB3b3JkLCBhbmQgZGV0ZWN0IGlmIGxvbmdlciB0aGFuIDEgY2hhcmFjdGVyIGFuZC9vciBkb2VzIG5vdCBjb250YWluIGFueSBmdWxsIHN0b3BzDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZpcnN0IDwtIHdvcmQoY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZ1bGxfbmFtZSwgMSkNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkdmFsaWRfbmFtZSA8LSBpZmVsc2Uoc3RyX2RldGVjdChjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkZmlyc3QsICJcXC4iKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkZBTFNFIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlRSVUUiKQ0KICAgICMgZ2V0IHRoZSBuYW1lIHZhcmlhdGlvbiBsZW5ndGhzDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGxlbmd0aF9maXJzdCA8LSAgbmNoYXIoY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZpcnN0KSANCiAgICBjb2F1dGhvcl9uYW1lcyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAzKSkNCiAgICAjIGxlYXZlIG9ubHkgdGhlIG9uZXMgd2hlcmUgd2Ugc2VlbSB0byBoYXZlIGEgc2hvcnRlc3QgbmFtZSBsb25nZXIgdGhhbiAyIGNoYXJhY3RlcnMNCiAgICBjb2F1dGhvcl9uYW1lcyA8LSBmaWx0ZXIoY29hdXRob3JfbmFtZV92YXJpYXRpb25zLCB2YWxpZF9uYW1lID09IFRSVUUpJT4lDQogICAgICBncm91cF9ieShpZCklPiUNCiAgICAgIHNsaWNlKHdoaWNoLm1heChsZW5ndGhfZmlyc3QpKSU+JQ0KICAgICAgZmlsdGVyKC4sIGxlbmd0aF9maXJzdCA+IDIpJT4lDQogICAgICBzZWxlY3QoLXZhbGlkX25hbWUsIC1sZW5ndGhfZmlyc3QsIC10eXBlKQ0KICAgIA0KICAgICMgYXBwZW5kIHRoZSBuZXcgbmFtZXMgdG8gdGhlIG5hbWVzIGRhdGFmcmFtZQ0KICAgIGlmICghYWxsKGlzLm5hKGNvYXV0aG9yX25hbWVzKSkpew0KICAgICAgbmV3X25hbWVzIDwtIGZpbHRlcihjb2F1dGhvcl9uYW1lcywgDQogICAgICAgICAgICAgICAgICAgICAgICAgICEgaWQgJWluJSBjb2F1dGhvcl9uYW1lX2xpc3QkaWQpDQogICAgICBjb2F1dGhvcl9uYW1lX2xpc3QgPC0gcmJpbmQoY29hdXRob3JfbmFtZV9saXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19uYW1lcykNCiAgICB9DQogICAgDQogICAgIyBzZWxlY3QgcHJvZiBpbmZvDQogICAgY29hdXRob3JfaW5mbyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAxNCkpDQogICAgY29sdW1ucyA8LSBjKCJpZCIsICJkaXNwbGF5X25hbWUiLCAib3JjaWQiLCAid29ya3NfY291bnQiLA0KICAgICAgICAgICAgICAgICAiY2l0ZWRfYnlfY291bnQiLCAiY291bnRzX2J5X3llYXJfeWVhciIsICJjb3VudHNfYnlfeWVhcl93b3Jrc19jb3VudCIsIA0KICAgICAgICAgICAgICAgICAiY291bnRzX2J5X3llYXJfY2l0ZWRfYnlfY291bnQiLCAiYWZmaWxpYXRpb25fZGlzcGxheV9uYW1lIiwgDQogICAgICAgICAgICAgICAgICJhZmZpbGlhdGlvbl9pZCIsICJhZmZpbGlhdGlvbl9yb3IiLCAiYWZmaWxpYXRpb25fY291bnRyeV9jb2RlIiwNCiAgICAgICAgICAgICAgICAgImFmZmlsaWF0aW9uX3R5cGUiLCAid29ya3NfYXBpX3VybCIpDQogICAgIyBwYWRkaW5nIGluIGNhc2Ugc29tZSBjb2x1bW5zIGFyZSBtaXNzaW5nDQogICAgaWYoIWFsbChjb2x1bW5zICVpbiUgY29sbmFtZXMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCkpKXsNCiAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghY29sdW1ucyAlaW4lIGNvbG5hbWVzKHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QpKQ0KICAgICAgcGFkZGluZyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IGxlbmd0aChuX21pc3NpbmcpLCBucm93PTEpKQ0KICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gY29sdW1uc1t3aGljaCghY29sdW1ucyAlaW4lIGNvbG5hbWVzKHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QpKV0NCiAgICAgIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QgPC0gYmluZF9jb2xzKHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCA8LSBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0W2NvbHVtbnNdDQogICAgfQ0KICAgIA0KICAgIGNvYXV0aG9yX2luZm8gPC0gcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCU+JQ0KICAgICAgc2VsZWN0KGlkLCBkaXNwbGF5X25hbWUsIG9yY2lkLCB3b3Jrc19jb3VudCwNCiAgICAgICAgICAgICBjaXRlZF9ieV9jb3VudCwgY291bnRzX2J5X3llYXJfeWVhciwgY291bnRzX2J5X3llYXJfd29ya3NfY291bnQsIA0KICAgICAgICAgICAgIGNvdW50c19ieV95ZWFyX2NpdGVkX2J5X2NvdW50LCBhZmZpbGlhdGlvbl9kaXNwbGF5X25hbWUsIA0KICAgICAgICAgICAgIGFmZmlsaWF0aW9uX2lkLCBhZmZpbGlhdGlvbl9yb3IsIGFmZmlsaWF0aW9uX2NvdW50cnlfY29kZSwNCiAgICAgICAgICAgICBhZmZpbGlhdGlvbl90eXBlLCB3b3Jrc19hcGlfdXJsKQ0KICAgIA0KICAgICMgYXBwZW5kIHRoZSBuZXcgaW5mbyB0byB0aGUgaW5mbyBkYXRhZnJhbWUNCiAgICBpZiAoIWFsbChpcy5uYShjb2F1dGhvcl9pbmZvKSkpew0KICAgICAgbmV3X2luZm8gPC0gZmlsdGVyKGNvYXV0aG9yX2luZm8sIA0KICAgICAgICAgICAgICAgICAgICAgICAgICEgaWQgJWluJSBjb2F1dGhvcl9pbmZvX2xpc3QkaWQpDQogICAgICANCiAgICAgIGNvYXV0aG9yX2luZm9fbGlzdCA8LSByYmluZChjb2F1dGhvcl9pbmZvX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2luZm8pDQogICAgfQ0KICB9DQogIA0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChiYXRjaGVzKS0xKSkNCn0NCg0KYGBgDQoNCmBgYHtyfQ0KbGlicmFyeShncm91bmRob2cpDQpwYWNrYWdlc190b19sb2FkIDwtIGMoInJlYWRyIiwgImRwbHlyIiwgIm9wZW5hbGV4UiIsDQogICAgICAgICAgICAgICAgICAgICAgImdncGxvdDIiLCAic3RyaW5nciIsICJ0aWR5ciIsDQogICAgICAgICAgICAgICAgICAgICAgImpzb25saXRlIiwgInhtbDIiLCAidGlkeXZlcnNlIiwNCiAgICAgICAgICAgICAgICAgICAgICAiUlBvc3RncmVzIiwgImx1YnJpZGF0ZSIsImRpZ2VzdCIsDQogICAgICAgICAgICAgICAgICAgICAgIkRCSSIsICJST0RCQyIsICJvZGJjIiwgImZvcmVhY2giLA0KICAgICAgICAgICAgICAgICAgICAgICJkb1BhcmFsbGVsIiwgImRvU05PVyIpDQpncm91bmRob2cubGlicmFyeShwYWNrYWdlc190b19sb2FkLCBkYXRlID0gIjIwMjMtMTItMDEiKQ0KDQpgYGANCg0KYGBge3J9DQpwb3J0IDwtIDU0MzINCnVzZXIgPC0gInBvc3RncmVzIg0KcGFzc3dvcmQgPC0gImR1dGNobWVkaWFwcm9mc3NxbCINCmRhdGFiYXNlX25hbWUgPC0gInBvc3RncmVzIg0KDQoNCiMjIEFsdG1ldHJpYyBleHBsb3JlciAoQW5hJ3Mga2V5KQ0KYXBpX3NlY3JldCA8LSAnYzU1ZmMzYTc0MmU3NGFjNWIwZDNhNmYyYmM1MDkwYjcnDQphcGlfa2V5IDwtICdiYWQ3ZDYyM2M3MjA0Zjc1YWQwZDUzYWNkMmZlNWQ4NScNCg0KY29uIDwtIFJQb3N0Z3Jlczo6ZGJDb25uZWN0KFJQb3N0Z3Jlczo6UG9zdGdyZXMoKSwNCiAgICAgICAgICAgICAgICAgZGJuYW1lPSBkYXRhYmFzZV9uYW1lLA0KICAgICAgICAgICAgICAgICBwb3J0ID0gcG9ydCwNCiAgICAgICAgICAgICAgICAgdXNlciA9IHVzZXIsIA0KICAgICAgICAgICAgICAgICBwYXNzd29yZCA9IHBhc3N3b3JkKQ0KYGBgDQoNCg0KYGBge3J9DQojIGdldCBhbGwgdGhlIGNvYXV0aG9yIGluZm8NCmNvYXV0aG9yX2xpc3QgPC0gZGJHZXRRdWVyeShjb25uID0gY29uLCBzdGF0ZW1lbnQgPSBwYXN0ZTAoInNlbGVjdCAqIGZyb20gY29hdXRob3JfaW5mbzsiKSkNCg0KI2dldCB0aGUgdWJpcXVlIE9BIElEcyBvZiBjb2F1dGhvcnMNCmNvYXV0aG9yX29hIDwtIHVuaXF1ZShjb2F1dGhvcl9saXN0JGF1X2lkKQ0KIyBkcm9wIHJlZHVuZGFudCBkYXRhDQpybShjb2F1dGhvcl9saXN0KQ0KZ2MoKQ0KDQoNCmBgYA0KDQpQYXJhbGxlbGl6aW5nIHRoaXMgcHJvY2VzczoNCmBgYHtyfQ0KIyBkZXRlY3QgY29yZXMgYW5kIHNldCB0aGUgcHJlZmVycmVkIG51bWJlciAod2UgaGF2ZSAxNiBhbmQgd2FudCB0byB1c2UgMTApDQpjb3Jlcz1kZXRlY3RDb3JlcygpDQpjbCA8LSBtYWtlQ2x1c3Rlcihjb3Jlc1sxXS02KQ0KcmVnaXN0ZXJEb1BhcmFsbGVsKGNsKQ0KDQojIHNldCB0aGUgcHJlZmVycmVkIGJhdGNoIHNpemUgZm9yIE9BIGNhbGxzDQpwcm9mX2JhdGNoX3NpemUgPC0gMTAwDQojIHZlY3RvciBvZiBpbmRpY2VzIHRvIGxvb3AgdGhyb3VnaA0KYmF0Y2hlcyA8LSBzZXEoZnJvbT0xLCB0bz1sZW5ndGgoY29hdXRob3Jfb2EpLCBieT1wcm9mX2JhdGNoX3NpemUpDQojIHRvIGJlIGFibGUgdG8gc3Vic2V0LCBhbHNvIGFkZCB0aGUgZmluYWwgaW5kZXgrMQ0KYmF0Y2hlcyA8LSBjKGJhdGNoZXMsIGxlbmd0aChjb2F1dGhvcl9vYSkrMSkNCg0KIyBsb2FkIHNvbWUgc3R1ZmYgZm9yIHRoZSBwcm9ncmVzcyBiYXINCg0KI3BhcmFsbGVsaXplIHRoZSBleHRyYWN0aW9uIG9mIHNlbGxlciBuYW1lcyBhbmQgZXh0ZW5kZWQgaW5mbw0Kb3V0cHV0IDwtIGZvcmVhY2goaT0gMjA6MjEsIC5wYWNrYWdlcz1jKCdvcGVuYWxleFInLCAnZHBseXInLCAndGlkeXInLCAnc3RyaW5ncicpLA0KICAgICAgICAgICAgICAgICAgLnZlcmJvc2UgPSBUKSAlZG8lIHsNCiAgIyBnZXQgdGhlIG5hcmNpcyBpZHMgZnJvbSB0aGUgYmF0Y2gNCiAgcHJvZl9iYXRjaCA8LSBjb2F1dGhvcl9vYVtiYXRjaGVzW2ldOihiYXRjaGVzW2krMV0tMSldDQogIGxvb3Bfb3V0cHV0IDwtIGNvYXV0aG9yX29hX2ZldGNoZXMocHJvZl9iYXRjaCkNCiAgcmV0dXJuKGxvb3Bfb3V0cHV0KQ0KICB9DQoNCnN0b3BDbHVzdGVyKGNsKQ0KIyB0aWR5IHVwIHRoZSBvdXRwdXQNCmNvYXV0aG9yX25hbWVzIDwtIGxhcHBseShwdXJycjo6dHJhbnNwb3NlKG91dHB1dCksIGZ1bmN0aW9uKGwpIGRvLmNhbGwocmJpbmQsIGwpKVtbIm5hbWVzIl1dDQpjb2F1dGhvcl9pbmZvIDwtIGxhcHBseShwdXJycjo6dHJhbnNwb3NlKG91dHB1dCksIGZ1bmN0aW9uKGwpIGRvLmNhbGwocmJpbmQsIGwpKVtbImluZm8iXV0NCmBgYA0K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("paralellizing.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
