<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ana Macanovic" />

<meta name="date" content="2024-01-15" />

<title>Untitled</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a>
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="index.html">Code homepage</a>
</li>
<li>
  <a href="OpenAlex_Altmetric_data_download.html">Open Alex and Altmetric data download</a>
</li>
<li>
  <a href="SQL_tutorial.html">SQL database manual</a>
</li>
<li>
  <a href="Prof_gender.html">Professor gender inference</a>
</li>
<li>
  <a href="Grant_parsing.html">Grant parsing</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/amacanovic/dutch_media_profs">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Untitled</h1>
<h4 class="author">Ana Macanovic</h4>
<h4 class="date">2024-01-15</h4>

</div>


<p>Load the packages:</p>
<pre class="r"><code>library(groundhog)
packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;dbplyr&quot;,
                      &quot;stringr&quot;, &quot;lubridate&quot;,
                      &quot;tidyr&quot;, &quot;tidyverse&quot;,
                      &quot;RPostgres&quot;,
                      &quot;DBI&quot;, &quot;RODBC&quot;, &quot;odbc&quot;)
groundhog.library(packages_to_load, date = &quot;2023-12-01&quot;)</code></pre>
<div id="load-helper-data" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Load helper data</h1>
<p>Load the professor profiles:</p>
<pre class="r"><code>load(&quot;raw_data/media_profs_profiles.rda&quot;)
profs &lt;- read_csv(&quot;raw_data/dutch_profs_urls.csv&quot;)

# merge the profs with their ORCIDs
colnames(profs)[c(1,7)] &lt;- c(&quot;id&quot;, &quot;profile_id&quot;)

profs_full &lt;- merge(profs,
                    metadf[, c(1:4, 361)],
                    by = &quot;profile_id&quot;)</code></pre>
<p>Connect to the postgres database:</p>
<pre class="r"><code>dsn_database &lt;- &quot;DutchMediaProfs&quot;
dsn_hostname &lt;- &quot;localhost&quot;
dsn_port &lt;- 5432
dsn_uid &lt;- &quot;postgres&quot;
dsn_pwd &lt;- &quot;dutchmediaprofssql&quot;

con &lt;- RPostgres::dbConnect(RPostgres::Postgres(),
                 dbname= dsn_uid,
                 port = dsn_port,
                 user = dsn_uid, 
                 password = dsn_pwd)


con # Checks connection is working</code></pre>
</div>
<div id="populate-the-database" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Populate the
database</h1>
<div id="identifier-list" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Identifier list</h2>
<p>Write out the identifier list to a table in the SQL database:</p>
<pre class="r"><code>prof_identifier_list &lt;- readRDS(&quot;~/Postdoc/Projects/dutch_media_profs_r/processed_data/prof_oa_identifier_list.RDS&quot;)

prof_oa_mapping &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))

for (i in 1:length(prof_identifier_list)){
  # initiate a dataframe to store this professor&#39;s data
  prof_oa_ids &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))
  # retrieve this professor&#39;s list of identifiers
  prof_identifiers &lt;- prof_identifier_list[[i]]
  # get their Narcis ID and all the retrieved OA IDs
  narcis_id &lt;- prof_identifier_list[[i]][[&quot;narcis_id&quot;]]
  
  pub_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_pubs&quot;]]
  
  orcid_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_orcid&quot;]]
  
  name_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_names&quot;]]
  
  # add any IDs retrieved from the publication list
  if (!all(is.na(pub_ids))){
  
  pub_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = pub_ids,
                              &quot;source&quot; = &quot;publications&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       pub_ids)
  }
  # add any IDs associated with prof&#39;s ORCID
  if (!all(is.na(orcid_ids))){
  orcid_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = orcid_ids,
                              &quot;source&quot; = &quot;orcid&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       orcid_ids)
  }
  # add any IDs from name search + NL country
  if (!all(is.na(name_ids))){
  name_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = name_ids,
                              &quot;source&quot; = &quot;name&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       name_ids)
  }
  
  # if any rows
  if (nrow(prof_oa_ids) &gt; 0){
    
    # deduplicate
    prof_oa_ids$duplicate &lt;- duplicated(prof_oa_ids[c(&quot;profile_id&quot;, &quot;oa_id&quot;)])
    prof_oa_ids &lt;- filter(prof_oa_ids,
                          duplicate == FALSE)
    prof_oa_ids &lt;- prof_oa_ids[, -4]
    
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  } else{
    prof_oa_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                                    &quot;oa_id&quot; = NA,
                                    &quot;source&quot; = NA)
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  }
  #print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
}


dbWriteTable(con, &quot;oa_identifier_table&quot;, prof_oa_mapping, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="gender-data" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Gender data</h2>
<pre class="r"><code>profs_full_gender &lt;- readRDS(&quot;~/Postdoc/Projects/dutch_media_profs_r/processed_data/profs_full_gender.RDS&quot;)
dbWriteTable(con, &quot;gender_table&quot;, profs_full_gender, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="orcids" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> ORCIDs</h2>
<pre class="r"><code>prof_orcid_mapping &lt;- data.frame(matrix(NA, nrow = 0, ncol = 1))

for (i in 1:length(prof_identifier_list)){
  # retrieve this professor&#39;s list of identifiers
  prof_identifiers &lt;- prof_identifier_list[[i]]
  # get their Narcis ID and all the retrieved OA IDs
  narcis_id &lt;- prof_identifier_list[[i]][[&quot;narcis_id&quot;]]
  
  orcid_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_orcid&quot;]]

  
  ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;orcid&quot; = orcid_ids)
  
  prof_orcid_mapping &lt;- rbind(prof_orcid_mapping,
                          ids)
  #print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
}

dbWriteTable(con, &quot;orcid_table&quot;, prof_orcid_mapping, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="create-tables-for-info-in-professor-lists"
class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Create tables for
info in professor lists</h2>
<pre class="r"><code>dbRemoveTable(con, &quot;prof_info&quot;)
dbRemoveTable(con, &quot;affiliation_info&quot;)
dbRemoveTable(con, &quot;grant_info&quot;)
dbRemoveTable(con, &quot;coauthor_info&quot;)
dbRemoveTable(con, &quot;news_mentions&quot;)
dbRemoveTable(con, &quot;wiki_mentions&quot;)
dbRemoveTable(con, &quot;reddit_mentions&quot;)
dbRemoveTable(con, &quot;narcis_pubs&quot;)
dbRemoveTable(con, &quot;oa_pubs&quot;)
dbRemoveTable(con, &quot;oa_concepts&quot;)</code></pre>
</div>
<div id="extract-info-from-professor-lists" class="section level2"
number="2.5">
<h2><span class="header-section-number">2.5</span> Extract info from
professor lists</h2>
<pre class="r"><code># helper elements for mention padding
# mention_cols &lt;- c(&quot;wikipedia&quot;, &quot;news&quot;, &quot;patent&quot;, &quot;blogs&quot;, &quot;googleplus&quot;, 
#                   &quot;facebook&quot;, &quot;reddit&quot;, &quot;f1000&quot;, &quot;policy&quot;, &quot;peer_reviews&quot;,
#                   &quot;video&quot;, &quot;q&amp;a&quot;, &quot;misc&quot;, &quot;weibo&quot;, &quot;pinterest&quot;, &quot;syllabi&quot;,
#                   &quot;linkedin&quot;, &quot;book_reviews&quot;)

# get the list of IDs
narcis_ids &lt;- profs_full$profile_id
# query in batches
# batch size
prof_batch_size &lt;- 500
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(narcis_ids), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(narcis_ids)+1)

# loop through the batches
for(i in 1:(length(batches)-1)){
 # load the batch
  read_string &lt;- paste0(&quot;processed_data/open_alex_prof_data/&quot;, paste(&quot;prof_data_batch&quot;, i, sep = &quot;_&quot;), &quot;.RDS&quot;)
  batch_prof_outcomes &lt;- readRDS(read_string)
  
  # get the narcis ids from the batch
  prof_batch &lt;- narcis_ids[batches[i]:(batches[i+1]-1)]


  for (j in 1:length(prof_batch)){
    prof &lt;- batch_prof_outcomes[[j]]
    prof_id &lt;- names(batch_prof_outcomes[j])
    # if some data in the prof list
    if (length(prof)&gt;1){
      ## get the professor info
      prof_info &lt;- prof[[&quot;prof_info&quot;]]
      # if not empty
      if (!all(is.na(prof_info))){
        # remove columns we do not need
        if(any(c(&quot;x_concepts&quot;,&quot;display_name_alternatives&quot;, &quot;ids&quot;, &quot;affiliation_lineage&quot;) %in% colnames(prof_info))){
          prof_info &lt;- prof_info %&gt;%
            select(!any_of(c(&quot;x_concepts&quot;, &quot;display_name_alternatives&quot;, &quot;ids&quot;, &quot;affiliation_lineage&quot;)))
        }
        # now unnest the data
        prof_info_unnest &lt;- unnest(prof_info, cols = c(counts_by_year), names_sep = &quot;_year_&quot;)
        # append the prof id
        prof_info_unnest &lt;- bind_cols(&quot;profile_id&quot; = prof_id,
                                      prof_info_unnest)
        if ((i == 1) &amp; (j == 1)){
        # and write to the database
        dbWriteTable(con, &quot;prof_info&quot;, prof_info_unnest, row.names=FALSE, append=TRUE)
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;prof_info&quot;)
          # if not all fields there
          if(!all(fields %in% colnames(prof_info_unnest))){
            n_missing &lt;- which(!fields %in% colnames(prof_info_unnest))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(prof_info_unnest))]
            prof_info_unnest &lt;- bind_cols(prof_info_unnest,
                                          padding)
            prof_info_unnest &lt;- prof_info_unnest[fields]
          }
          # only leave these fields in
          prof_info_unnest &lt;-  prof_info_unnest %&gt;%
            select(all_of(fields))
          
          dbAppendTable(con, &quot;prof_info&quot;, prof_info_unnest, row.names=NULL, append=TRUE)
        }
      }
      
      ## get the NARCIS publications
      narcis_pubs &lt;- prof[[&quot;narcis_pubs&quot;]]
      # if not empty
      if (!all(is.na(narcis_pubs)) &amp; class(narcis_pubs) != &quot;character&quot;){
        # if first round, create a table
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;narcis_pubs&quot;, narcis_pubs, row.names=FALSE, append=TRUE)
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;narcis_pubs&quot;)
          # only leave these fields in
          narcis_pubs &lt;-  narcis_pubs %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;narcis_pubs&quot;, narcis_pubs, row.names=NULL, append=TRUE)
        }
      }
      
      ## get the OA publications
      oa_pubs &lt;- prof[[&quot;oa_pubs&quot;]]
      
      # if not empty
      if (!all(is.na(oa_pubs))){
        # first, get the mention data
        mention_data &lt;- oa_pubs %&gt;%
          select(id, profile_id, author_position:last_col(), -author_position)
        
        # if not empty
        if (!all(is.na(mention_data))){
          
          # if there&#39;s wiki data
          if (&#39;wikipedia&#39; %in% colnames(mention_data)){
            wiki_mention_data_unnest &lt;- mention_data%&gt;%
              select(id, profile_id, wikipedia) %&gt;%
              unnest(., cols = &#39;wikipedia&#39;)%&gt;%
              select(!citation_ids)%&gt;%
              unnest(., cols = author, names_sep = &quot;_au_&quot;)
            
            # if first round, create a table
            if ((i == 1) &amp; (j == 1)){
              # write to the database
              dbWriteTable(con, &quot;wiki_mentions&quot;, wiki_mention_data_unnest, row.names=FALSE, append=TRUE)
              # otherwise, append
            }else{
              # check fields in the existing table
              fields &lt;- dbListFields(con, &quot;wiki_mentions&quot;)
              # if not all fields there
              if(!all(fields %in% colnames(wiki_mention_data_unnest))){
                n_missing &lt;- which(!fields %in% colnames(wiki_mention_data_unnest))
                padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
                colnames(padding) &lt;- fields[which(!fields %in% colnames(wiki_mention_data_unnest))]
                wiki_mention_data_unnest &lt;- bind_cols(wiki_mention_data_unnest,
                                              padding)
                wiki_mention_data_unnest &lt;- wiki_mention_data_unnest[fields]
              }
              # only leave these fields in
              wiki_mention_data_unnest &lt;-  wiki_mention_data_unnest %&gt;%
                select(all_of(fields))
              dbAppendTable(con, &quot;wiki_mentions&quot;, wiki_mention_data_unnest, row.names=NULL, append=TRUE)
            }
          }
          # if there&#39;s news data
          if (&#39;news&#39; %in% colnames(mention_data)){
            news_mention_data_unnest &lt;- mention_data%&gt;%
              select(id, profile_id, news) %&gt;%
              unnest(., cols = &#39;news&#39;)%&gt;%
              select(!citation_ids)%&gt;%
              unnest(., cols = author, names_sep = &quot;_au_&quot;)
            
            # if first round, create a table
            if ((i == 1) &amp; (j == 1)){
              # write to the database
              dbWriteTable(con, &quot;news_mentions&quot;, news_mention_data_unnest, row.names=FALSE, append=TRUE) 
              # otherwise, append
            }else{
              # check fields in the existing table
              fields &lt;- dbListFields(con, &quot;news_mentions&quot;)
              # if not all fields there
              if(!all(fields %in% colnames(news_mention_data_unnest))){
                n_missing &lt;- which(!fields %in% colnames(news_mention_data_unnest))
                padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
                colnames(padding) &lt;- fields[which(!fields %in% colnames(news_mention_data_unnest))]
                news_mention_data_unnest &lt;- bind_cols(news_mention_data_unnest,
                                                      padding)
                news_mention_data_unnest &lt;- news_mention_data_unnest[fields]
              }
              
              # only leave these fields in
              news_mention_data_unnest &lt;-  news_mention_data_unnest %&gt;%
                select(all_of(fields))
              dbAppendTable(con, &quot;news_mentions&quot;, news_mention_data_unnest, row.names=NULL, append=TRUE) 
            }
          }
          
          # # if there&#39;s FB data, but this doesn&#39;t work 
          # if (&#39;facebook&#39; %in% colnames(mention_data)){
          #   fb_mention_data_unnest &lt;- mention_data%&gt;%
          #     select(id, profile_id, facebook) %&gt;%
          #     unnest(., cols = &#39;facebook&#39;)%&gt;%
          #     select(!citation_ids)
          # 
          # }
          
          # if there&#39;s reddit data
          if (&#39;reddit&#39; %in% colnames(mention_data)){
            reddit_mention_data_unnest &lt;- mention_data%&gt;%
              select(id, profile_id, reddit) %&gt;%
              unnest(., cols = &#39;reddit&#39;)%&gt;%
              select(!citation_ids)%&gt;%
              unnest(., cols = author, names_sep = &quot;_au_&quot;)
            
            if ((i == 1) &amp; (j == 1)){
              # write to the database
              dbWriteTable(con, &quot;reddit_mentions&quot;, reddit_mention_data_unnest, row.names=FALSE, append=TRUE) 
              # otherwise, append
            }else{
              # check fields in the existing table
              fields &lt;- dbListFields(con, &quot;reddit_mentions&quot;)
              if(!all(fields %in% colnames(reddit_mention_data_unnest))){
                n_missing &lt;- which(!fields %in% colnames(reddit_mention_data_unnest))
                padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
                colnames(padding) &lt;- fields[which(!fields %in% colnames(reddit_mention_data_unnest))]
                reddit_mention_data_unnest &lt;- bind_cols(reddit_mention_data_unnest,
                                                      padding)
                reddit_mention_data_unnest &lt;- reddit_mention_data_unnest[fields]
              }
              # only leave these fields in
              reddit_mention_data_unnest &lt;-  reddit_mention_data_unnest %&gt;%
                select(all_of(fields))
              dbAppendTable(con, &quot;reddit_mentions&quot;, reddit_mention_data_unnest, row.names=NULL, append=TRUE) 
            }
          }
        }
        
        # now, get the publication data
        # select relevant columns
        select_cols &lt;- c(&quot;id&quot;, &quot;profile_id&quot;, &quot;display_name&quot;, &quot;ab&quot;, &quot;publication_year&quot;,
                         &quot;so&quot;, &quot;so_id&quot;, &quot;host_organization&quot;, &quot;issn_l&quot;, 
                         &quot;url&quot;, &quot;pdf_url&quot;, &quot;volume&quot;, &quot;issue&quot;, &quot;first_page&quot;, 
                         &quot;last_page&quot;, &quot; is_ia&quot;, &quot;language&quot;,
                         &quot;cited_by_count&quot;, &quot;counts_by_year&quot;, &quot;cited_by_api_url&quot;,
                         &quot;doi&quot;, &quot;type&quot;, 
                         &quot;is_retracted&quot;, &quot;ia_id&quot;, 
                         &quot;author_position&quot;)
        pub_data &lt;- oa_pubs %&gt;%
          select(any_of(select_cols))
        
        # get the referenced works
        referenced_works &lt;- oa_pubs %&gt;%
          select(id, profile_id, referenced_works)%&gt;%
          unnest(., cols = &quot;referenced_works&quot;)
        
        # get the counts by year
        pub_by_year &lt;- pub_data %&gt;%
          unnest(., cols = &quot;counts_by_year&quot;, names_sep = &quot;_year_&quot;)
        
        # write this out
        # if not empty
        if (!all(is.na(oa_pubs))){
          if ((i == 1) &amp; (j == 1)){
            # write to the database
            dbWriteTable(con, &quot;oa_pubs&quot;, pub_by_year, row.names=FALSE, append=TRUE)
            # otherwise, append
          }else{
            # check fields in the existing table
            fields &lt;- dbListFields(con, &quot;oa_pubs&quot;)
            # if some missing, pad the dataset
            if(!all(fields %in% colnames(pub_by_year))){
              n_missing &lt;- which(!fields %in% colnames(pub_by_year))
              padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
              colnames(padding) &lt;- fields[which(!fields %in% colnames(pub_by_year))]
              pub_by_year &lt;- bind_cols(pub_by_year,
                                                      padding)
              pub_by_year &lt;- pub_by_year[fields]
            }
            # only leave these fields in
            pub_by_year &lt;-  pub_by_year %&gt;%
              select(all_of(fields))
            dbAppendTable(con, &quot;oa_pubs&quot;, pub_by_year, row.names=NULL, append=TRUE)
          }
        }
        
        # unnest the concepts, but also leave only those on levels 0 and 1 and with prob
        # above 0.5
        oa_concepts &lt;- oa_pubs %&gt;%
          select(id, profile_id, concepts)%&gt;%
          unnest(., cols = &quot;concepts&quot;, names_sep = &quot;_conc_&quot;)%&gt;%
          filter(concepts_conc_level %in% c(0,1) &amp; concepts_conc_score &gt;= 0.5)
        
        # write this out
        # if not empty
        if (!all(is.na(oa_concepts))){
          if ((i == 1) &amp; (j == 1)){
            # write to the database
            dbWriteTable(con, &quot;oa_concepts&quot;, oa_concepts, row.names=FALSE, append=TRUE) 
            # otherwise, append
          }else{
            # check fields in the existing table
            fields &lt;- dbListFields(con, &quot;oa_concepts&quot;)
            # if some fields missing, pad the dataset
            if(!all(fields %in% colnames(oa_concepts))){
              n_missing &lt;- which(!fields %in% colnames(oa_concepts))
              padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
              colnames(padding) &lt;- fields[which(!fields %in% colnames(oa_concepts))]
              oa_concepts &lt;- bind_cols(oa_concepts,
                                       padding)
              oa_concepts &lt;- oa_concepts[fields]
            }
            # only leave these fields in
            oa_concepts &lt;-  oa_concepts %&gt;%
              select(all_of(fields))
            dbAppendTable(con, &quot;oa_concepts&quot;, oa_concepts, row.names=NULL, append=TRUE)
          }
        }
      }
      
      ## get the grant info
      grant_info &lt;- prof[[&quot;grant_info&quot;]]
      # and write to the database
      # if not empty
      if (!all(is.na(grant_info))){
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;grant_info&quot;, grant_info, row.names=FALSE, append=TRUE)
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;grant_info&quot;)
          if(!all(fields %in% colnames(grant_info))){
            n_missing &lt;- which(!fields %in% colnames(grant_info))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(grant_info))]
            grant_info &lt;- bind_cols(grant_info,
                                     padding)
            grant_info &lt;- grant_info[fields]
          }
          # only leave these fields in
          grant_info &lt;-  grant_info %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;grant_info&quot;, grant_info, row.names=NULL, append=TRUE)
        }
      
      }
      
      ## get the coauthor info
      coauthor_info &lt;- prof[[&quot;coauthor_info&quot;]]
      # and write to the database
      # if not empty
      if (!all(is.na(coauthor_info))){
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;coauthor_info&quot;, coauthor_info, row.names=FALSE, append=TRUE) 
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;coauthor_info&quot;)
          # if needed, pad the dataset
          if(!all(fields %in% colnames(coauthor_info))){
            n_missing &lt;- which(!fields %in% colnames(coauthor_info))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(coauthor_info))]
            coauthor_info &lt;- bind_cols(coauthor_info,
                                    padding)
            coauthor_info &lt;- coauthor_info[fields]
          }
          # only leave these fields in
          coauthor_info &lt;-  coauthor_info %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;coauthor_info&quot;, coauthor_info, row.names=NULL, append=TRUE) 
        }
      }
      
      ## get the affiliation info
      affiliation_info &lt;- prof[[&quot;affiliation_info&quot;]]
      # if not empty
      if (!all(is.na(affiliation_info))){
        # and write to the database
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;affiliation_info&quot;, affiliation_info, row.names=FALSE, append=TRUE) 
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;affiliation_info&quot;)
          # if needed, pad the dataset
          if(!all(fields %in% colnames(affiliation_info))){
            n_missing &lt;- which(!fields %in% colnames(affiliation_info))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(affiliation_info))]
            affiliation_info &lt;- bind_cols(affiliation_info,
                                       padding)
            affiliation_info &lt;- affiliation_info[fields]
          }
          
          # only leave these fields in
          affiliation_info &lt;-  affiliation_info %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;affiliation_info&quot;, affiliation_info, row.names=NULL, append=TRUE)  
        }
      }
    }
    
    print(paste(&quot;done with&quot;, j, &quot;out of&quot;, length(prof_batch)))
    
  }
}</code></pre>
<pre class="r"><code>oa_colnames_all &lt;- c()
for (j in 1:length(prof_batch)){
  prof &lt;- prof_batch[[j]]
  prof_id &lt;- names(prof_batch[j])
  # if some data in the prof list
  if (length(prof)&gt;1){
    # get the OA publications
    oa_pubs &lt;- prof[[&quot;oa_pubs&quot;]]
    if (!all(is.na(oa_pubs))){
      oa_colnames &lt;- colnames(oa_pubs)
      
      oa_colnames_all &lt;- c(oa_colnames_all,
                           oa_colnames[which(!oa_colnames %in% oa_colnames_all)])
    }
  }
}
    
    # select relevant columns
    cols &lt;- c(&quot;id&quot;, &quot;display_name&quot;, &quot;ab&quot;, &quot;publication_year&quot;,
               &quot;so&quot;, &quot;so_id&quot;, &quot;host_organization&quot;, &quot;issn_l&quot;, 
              &quot;url&quot;, &quot;pdf_url&quot;, &quot;volume&quot;, &quot;issue&quot;, &quot;first_page&quot;, 
               &quot;last_page&quot;, &quot; is_ia&quot;, &quot; language&quot;,
               &quot;cited_by_count&quot;, &quot; counts_by_year&quot;, &quot; cited_by_api_url&quot;,
               &quot;ids&quot;, &quot; doi&quot;, &quot; type&quot;, &quot; referenced_works&quot;, &quot; related_works&quot;,
               &quot;is_retracted&quot;, &quot; concepts&quot;, &quot; ia_id&quot;, &quot; profile_id&quot;, 
               &quot;author_position&quot;)
    # and whatever is 
    
    oa_pubs_2 &lt;- oa_pubs %&gt;%
        select(id, display_name, ab, publication_year,
               so, so_id, host_organization, issn_l,
               url, pdf_url, volume, issue, first_page,
               last_page, is_ia, language,
               cited_by_count, counts_by_year, cited_by_api_url, 
               ids, doi, type, referenced_works, related_works,
               is_retracted, concepts, ia_id, profile_id,
               author_position)
    
    
    # unnest the concepts, but also leave only those on levels 0 and 1 and with prob
    # above 0.5
    oa_pubs_unnested &lt;- unnest(oa_pubs, cols = &quot;concepts&quot;, names_sep = &quot;_conc_&quot;)%&gt;%
      filter(concepts_conc_level %in% c(0,1) &amp; concepts_conc_score &gt;= 0.5)
    
    # append the prof ID
    oa_pubs &lt;- bind_cols(&quot;profile_id&quot; = prof_id,
                         oa_pubs)
    
    
    
    # and write to the database
    dbWriteTable(con, &quot;oa_pubs&quot;, oa_pubs, row.names=FALSE, append=TRUE)
    
    
    
      }

      
  
}</code></pre>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlVudGl0bGVkIg0KYXV0aG9yOiAiQW5hIE1hY2Fub3ZpYyINCmRhdGU6ICIyMDI0LTAxLTE1Ig0Kb3V0cHV0OiBodG1sX2RvY3VtZW50DQotLS0NCg0KYGBge3IgaW5jbHVkZT1GQUxTRX0NCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChldmFsID0gRkFMU0UpDQprbml0cjo6b3B0c19jaHVuayRzZXQod2FybmluZyA9IEZBTFNFKQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KG1lc3NhZ2UgPSBGQUxTRSkNCmBgYA0KDQpMb2FkIHRoZSBwYWNrYWdlczoNCmBgYHtyIG1lc3NhZ2U9ICBGLCB3YXJuaW5nID0gRn0NCmxpYnJhcnkoZ3JvdW5kaG9nKQ0KcGFja2FnZXNfdG9fbG9hZCA8LSBjKCJyZWFkciIsICJkcGx5ciIsICJkYnBseXIiLA0KICAgICAgICAgICAgICAgICAgICAgICJzdHJpbmdyIiwgImx1YnJpZGF0ZSIsDQogICAgICAgICAgICAgICAgICAgICAgInRpZHlyIiwgInRpZHl2ZXJzZSIsDQogICAgICAgICAgICAgICAgICAgICAgIlJQb3N0Z3JlcyIsDQogICAgICAgICAgICAgICAgICAgICAgIkRCSSIsICJST0RCQyIsICJvZGJjIikNCmdyb3VuZGhvZy5saWJyYXJ5KHBhY2thZ2VzX3RvX2xvYWQsIGRhdGUgPSAiMjAyMy0xMi0wMSIpDQoNCmBgYA0KDQojIExvYWQgaGVscGVyIGRhdGENCg0KTG9hZCB0aGUgcHJvZmVzc29yIHByb2ZpbGVzOg0KYGBge3IgbWVzc2FnZSA9IEYsIHdhcm5pbmcgPSBGfQ0KbG9hZCgicmF3X2RhdGEvbWVkaWFfcHJvZnNfcHJvZmlsZXMucmRhIikNCnByb2ZzIDwtIHJlYWRfY3N2KCJyYXdfZGF0YS9kdXRjaF9wcm9mc191cmxzLmNzdiIpDQoNCiMgbWVyZ2UgdGhlIHByb2ZzIHdpdGggdGhlaXIgT1JDSURzDQpjb2xuYW1lcyhwcm9mcylbYygxLDcpXSA8LSBjKCJpZCIsICJwcm9maWxlX2lkIikNCg0KcHJvZnNfZnVsbCA8LSBtZXJnZShwcm9mcywNCiAgICAgICAgICAgICAgICAgICAgbWV0YWRmWywgYygxOjQsIDM2MSldLA0KICAgICAgICAgICAgICAgICAgICBieSA9ICJwcm9maWxlX2lkIikNCmBgYA0KDQpDb25uZWN0IHRvIHRoZSBwb3N0Z3JlcyBkYXRhYmFzZToNCmBgYHtyfQ0KZHNuX2RhdGFiYXNlIDwtICJEdXRjaE1lZGlhUHJvZnMiDQpkc25faG9zdG5hbWUgPC0gImxvY2FsaG9zdCINCmRzbl9wb3J0IDwtIDU0MzINCmRzbl91aWQgPC0gInBvc3RncmVzIg0KZHNuX3B3ZCA8LSAiZHV0Y2htZWRpYXByb2Zzc3FsIg0KDQpjb24gPC0gUlBvc3RncmVzOjpkYkNvbm5lY3QoUlBvc3RncmVzOjpQb3N0Z3JlcygpLA0KICAgICAgICAgICAgICAgICBkYm5hbWU9IGRzbl91aWQsDQogICAgICAgICAgICAgICAgIHBvcnQgPSBkc25fcG9ydCwNCiAgICAgICAgICAgICAgICAgdXNlciA9IGRzbl91aWQsIA0KICAgICAgICAgICAgICAgICBwYXNzd29yZCA9IGRzbl9wd2QpDQoNCg0KY29uICMgQ2hlY2tzIGNvbm5lY3Rpb24gaXMgd29ya2luZw0KYGBgDQojIFBvcHVsYXRlIHRoZSBkYXRhYmFzZQ0KDQojIyBJZGVudGlmaWVyIGxpc3QNCg0KV3JpdGUgb3V0IHRoZSBpZGVudGlmaWVyIGxpc3QgdG8gYSB0YWJsZSBpbiB0aGUgU1FMIGRhdGFiYXNlOg0KYGBge3J9DQpwcm9mX2lkZW50aWZpZXJfbGlzdCA8LSByZWFkUkRTKCJ+L1Bvc3Rkb2MvUHJvamVjdHMvZHV0Y2hfbWVkaWFfcHJvZnNfci9wcm9jZXNzZWRfZGF0YS9wcm9mX29hX2lkZW50aWZpZXJfbGlzdC5SRFMiKQ0KDQpwcm9mX29hX21hcHBpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChwcm9mX2lkZW50aWZpZXJfbGlzdCkpew0KICAjIGluaXRpYXRlIGEgZGF0YWZyYW1lIHRvIHN0b3JlIHRoaXMgcHJvZmVzc29yJ3MgZGF0YQ0KICBwcm9mX29hX2lkcyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAzKSkNCiAgIyByZXRyaWV2ZSB0aGlzIHByb2Zlc3NvcidzIGxpc3Qgb2YgaWRlbnRpZmllcnMNCiAgcHJvZl9pZGVudGlmaWVycyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dDQogICMgZ2V0IHRoZWlyIE5hcmNpcyBJRCBhbmQgYWxsIHRoZSByZXRyaWV2ZWQgT0EgSURzDQogIG5hcmNpc19pZCA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sibmFyY2lzX2lkIl1dDQogIA0KICBwdWJfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfcHVicyJdXQ0KICANCiAgb3JjaWRfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfb3JjaWQiXV0NCiAgDQogIG5hbWVfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfbmFtZXMiXV0NCiAgDQogICMgYWRkIGFueSBJRHMgcmV0cmlldmVkIGZyb20gdGhlIHB1YmxpY2F0aW9uIGxpc3QNCiAgaWYgKCFhbGwoaXMubmEocHViX2lkcykpKXsNCiAgDQogIHB1Yl9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gcHViX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gInB1YmxpY2F0aW9ucyIpDQogIA0KICBwcm9mX29hX2lkcyA8LSByYmluZChwcm9mX29hX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgcHViX2lkcykNCiAgfQ0KICAjIGFkZCBhbnkgSURzIGFzc29jaWF0ZWQgd2l0aCBwcm9mJ3MgT1JDSUQNCiAgaWYgKCFhbGwoaXMubmEob3JjaWRfaWRzKSkpew0KICBvcmNpZF9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gb3JjaWRfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNvdXJjZSIgPSAib3JjaWQiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIG9yY2lkX2lkcykNCiAgfQ0KICAjIGFkZCBhbnkgSURzIGZyb20gbmFtZSBzZWFyY2ggKyBOTCBjb3VudHJ5DQogIGlmICghYWxsKGlzLm5hKG5hbWVfaWRzKSkpew0KICBuYW1lX2lkcyA8LSBjYmluZC5kYXRhLmZyYW1lKCJwcm9maWxlX2lkIiA9IG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYV9pZCIgPSBuYW1lX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gIm5hbWUiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIG5hbWVfaWRzKQ0KICB9DQogIA0KICAjIGlmIGFueSByb3dzDQogIGlmIChucm93KHByb2Zfb2FfaWRzKSA+IDApew0KICAgIA0KICAgICMgZGVkdXBsaWNhdGUNCiAgICBwcm9mX29hX2lkcyRkdXBsaWNhdGUgPC0gZHVwbGljYXRlZChwcm9mX29hX2lkc1tjKCJwcm9maWxlX2lkIiwgIm9hX2lkIildKQ0KICAgIHByb2Zfb2FfaWRzIDwtIGZpbHRlcihwcm9mX29hX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID09IEZBTFNFKQ0KICAgIHByb2Zfb2FfaWRzIDwtIHByb2Zfb2FfaWRzWywgLTRdDQogICAgDQogICAgcHJvZl9vYV9tYXBwaW5nIDwtIHJiaW5kKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9pZHMpDQogIH0gZWxzZXsNCiAgICBwcm9mX29hX2lkcyA8LSBjYmluZC5kYXRhLmZyYW1lKCJwcm9maWxlX2lkIiA9IG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYV9pZCIgPSBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gTkEpDQogICAgcHJvZl9vYV9tYXBwaW5nIDwtIHJiaW5kKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9pZHMpDQogIH0NCiAgI3ByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKG5hcmNpc19pZHMpKSkNCn0NCg0KDQpkYldyaXRlVGFibGUoY29uLCAib2FfaWRlbnRpZmllcl90YWJsZSIsIHByb2Zfb2FfbWFwcGluZywgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQojIyBHZW5kZXIgZGF0YQ0KYGBge3J9DQpwcm9mc19mdWxsX2dlbmRlciA8LSByZWFkUkRTKCJ+L1Bvc3Rkb2MvUHJvamVjdHMvZHV0Y2hfbWVkaWFfcHJvZnNfci9wcm9jZXNzZWRfZGF0YS9wcm9mc19mdWxsX2dlbmRlci5SRFMiKQ0KZGJXcml0ZVRhYmxlKGNvbiwgImdlbmRlcl90YWJsZSIsIHByb2ZzX2Z1bGxfZ2VuZGVyLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KYGBgDQoNCiMjIE9SQ0lEcw0KDQpgYGB7cn0NCnByb2Zfb3JjaWRfbWFwcGluZyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAxKSkNCg0KZm9yIChpIGluIDE6bGVuZ3RoKHByb2ZfaWRlbnRpZmllcl9saXN0KSl7DQogICMgcmV0cmlldmUgdGhpcyBwcm9mZXNzb3IncyBsaXN0IG9mIGlkZW50aWZpZXJzDQogIHByb2ZfaWRlbnRpZmllcnMgPC0gcHJvZl9pZGVudGlmaWVyX2xpc3RbW2ldXQ0KICAjIGdldCB0aGVpciBOYXJjaXMgSUQgYW5kIGFsbCB0aGUgcmV0cmlldmVkIE9BIElEcw0KICBuYXJjaXNfaWQgPC0gcHJvZl9pZGVudGlmaWVyX2xpc3RbW2ldXVtbIm5hcmNpc19pZCJdXQ0KICANCiAgb3JjaWRfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfb3JjaWQiXV0NCg0KICANCiAgaWRzIDwtIGNiaW5kLmRhdGEuZnJhbWUoInByb2ZpbGVfaWQiID0gbmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9yY2lkIiA9IG9yY2lkX2lkcykNCiAgDQogIHByb2Zfb3JjaWRfbWFwcGluZyA8LSByYmluZChwcm9mX29yY2lkX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGlkcykNCiAgI3ByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKG5hcmNpc19pZHMpKSkNCn0NCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9yY2lkX3RhYmxlIiwgcHJvZl9vcmNpZF9tYXBwaW5nLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KYGBgDQoNCiMjIENyZWF0ZSB0YWJsZXMgZm9yIGluZm8gaW4gcHJvZmVzc29yIGxpc3RzDQpgYGB7cn0NCmRiUmVtb3ZlVGFibGUoY29uLCAicHJvZl9pbmZvIikNCmRiUmVtb3ZlVGFibGUoY29uLCAiYWZmaWxpYXRpb25faW5mbyIpDQpkYlJlbW92ZVRhYmxlKGNvbiwgImdyYW50X2luZm8iKQ0KZGJSZW1vdmVUYWJsZShjb24sICJjb2F1dGhvcl9pbmZvIikNCmRiUmVtb3ZlVGFibGUoY29uLCAibmV3c19tZW50aW9ucyIpDQpkYlJlbW92ZVRhYmxlKGNvbiwgIndpa2lfbWVudGlvbnMiKQ0KZGJSZW1vdmVUYWJsZShjb24sICJyZWRkaXRfbWVudGlvbnMiKQ0KZGJSZW1vdmVUYWJsZShjb24sICJuYXJjaXNfcHVicyIpDQpkYlJlbW92ZVRhYmxlKGNvbiwgIm9hX3B1YnMiKQ0KZGJSZW1vdmVUYWJsZShjb24sICJvYV9jb25jZXB0cyIpDQpgYGANCg0KDQojIyBFeHRyYWN0IGluZm8gZnJvbSBwcm9mZXNzb3IgbGlzdHMNCmBgYHtyfQ0KIyBoZWxwZXIgZWxlbWVudHMgZm9yIG1lbnRpb24gcGFkZGluZw0KIyBtZW50aW9uX2NvbHMgPC0gYygid2lraXBlZGlhIiwgIm5ld3MiLCAicGF0ZW50IiwgImJsb2dzIiwgImdvb2dsZXBsdXMiLCANCiMgICAgICAgICAgICAgICAgICAgImZhY2Vib29rIiwgInJlZGRpdCIsICJmMTAwMCIsICJwb2xpY3kiLCAicGVlcl9yZXZpZXdzIiwNCiMgICAgICAgICAgICAgICAgICAgInZpZGVvIiwgInEmYSIsICJtaXNjIiwgIndlaWJvIiwgInBpbnRlcmVzdCIsICJzeWxsYWJpIiwNCiMgICAgICAgICAgICAgICAgICAgImxpbmtlZGluIiwgImJvb2tfcmV2aWV3cyIpDQoNCiMgZ2V0IHRoZSBsaXN0IG9mIElEcw0KbmFyY2lzX2lkcyA8LSBwcm9mc19mdWxsJHByb2ZpbGVfaWQNCiMgcXVlcnkgaW4gYmF0Y2hlcw0KIyBiYXRjaCBzaXplDQpwcm9mX2JhdGNoX3NpemUgPC0gNTAwDQojIHZlY3RvciBvZiBpbmRpY2VzIHRvIGxvb3AgdGhyb3VnaA0KYmF0Y2hlcyA8LSBzZXEoZnJvbT0xLCB0bz1sZW5ndGgobmFyY2lzX2lkcyksIGJ5PXByb2ZfYmF0Y2hfc2l6ZSkNCiMgdG8gYmUgYWJsZSB0byBzdWJzZXQsIGFsc28gYWRkIHRoZSBmaW5hbCBpbmRleCsxDQpiYXRjaGVzIDwtIGMoYmF0Y2hlcywgbGVuZ3RoKG5hcmNpc19pZHMpKzEpDQoNCiMgbG9vcCB0aHJvdWdoIHRoZSBiYXRjaGVzDQpmb3IoaSBpbiAxOihsZW5ndGgoYmF0Y2hlcyktMSkpew0KICMgbG9hZCB0aGUgYmF0Y2gNCiAgcmVhZF9zdHJpbmcgPC0gcGFzdGUwKCJwcm9jZXNzZWRfZGF0YS9vcGVuX2FsZXhfcHJvZl9kYXRhLyIsIHBhc3RlKCJwcm9mX2RhdGFfYmF0Y2giLCBpLCBzZXAgPSAiXyIpLCAiLlJEUyIpDQogIGJhdGNoX3Byb2Zfb3V0Y29tZXMgPC0gcmVhZFJEUyhyZWFkX3N0cmluZykNCiAgDQogICMgZ2V0IHRoZSBuYXJjaXMgaWRzIGZyb20gdGhlIGJhdGNoDQogIHByb2ZfYmF0Y2ggPC0gbmFyY2lzX2lkc1tiYXRjaGVzW2ldOihiYXRjaGVzW2krMV0tMSldDQoNCg0KICBmb3IgKGogaW4gMTpsZW5ndGgocHJvZl9iYXRjaCkpew0KICAgIHByb2YgPC0gYmF0Y2hfcHJvZl9vdXRjb21lc1tbal1dDQogICAgcHJvZl9pZCA8LSBuYW1lcyhiYXRjaF9wcm9mX291dGNvbWVzW2pdKQ0KICAgICMgaWYgc29tZSBkYXRhIGluIHRoZSBwcm9mIGxpc3QNCiAgICBpZiAobGVuZ3RoKHByb2YpPjEpew0KICAgICAgIyMgZ2V0IHRoZSBwcm9mZXNzb3IgaW5mbw0KICAgICAgcHJvZl9pbmZvIDwtIHByb2ZbWyJwcm9mX2luZm8iXV0NCiAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICBpZiAoIWFsbChpcy5uYShwcm9mX2luZm8pKSl7DQogICAgICAgICMgcmVtb3ZlIGNvbHVtbnMgd2UgZG8gbm90IG5lZWQNCiAgICAgICAgaWYoYW55KGMoInhfY29uY2VwdHMiLCJkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzIiwgImlkcyIsICJhZmZpbGlhdGlvbl9saW5lYWdlIikgJWluJSBjb2xuYW1lcyhwcm9mX2luZm8pKSl7DQogICAgICAgICAgcHJvZl9pbmZvIDwtIHByb2ZfaW5mbyAlPiUNCiAgICAgICAgICAgIHNlbGVjdCghYW55X29mKGMoInhfY29uY2VwdHMiLCAiZGlzcGxheV9uYW1lX2FsdGVybmF0aXZlcyIsICJpZHMiLCAiYWZmaWxpYXRpb25fbGluZWFnZSIpKSkNCiAgICAgICAgfQ0KICAgICAgICAjIG5vdyB1bm5lc3QgdGhlIGRhdGENCiAgICAgICAgcHJvZl9pbmZvX3VubmVzdCA8LSB1bm5lc3QocHJvZl9pbmZvLCBjb2xzID0gYyhjb3VudHNfYnlfeWVhciksIG5hbWVzX3NlcCA9ICJfeWVhcl8iKQ0KICAgICAgICAjIGFwcGVuZCB0aGUgcHJvZiBpZA0KICAgICAgICBwcm9mX2luZm9fdW5uZXN0IDwtIGJpbmRfY29scygicHJvZmlsZV9pZCIgPSBwcm9mX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2luZm9fdW5uZXN0KQ0KICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICMgYW5kIHdyaXRlIHRvIHRoZSBkYXRhYmFzZQ0KICAgICAgICBkYldyaXRlVGFibGUoY29uLCAicHJvZl9pbmZvIiwgcHJvZl9pbmZvX3VubmVzdCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCiAgICAgICAgfWVsc2V7DQogICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJwcm9mX2luZm8iKQ0KICAgICAgICAgICMgaWYgbm90IGFsbCBmaWVsZHMgdGhlcmUNCiAgICAgICAgICBpZighYWxsKGZpZWxkcyAlaW4lIGNvbG5hbWVzKHByb2ZfaW5mb191bm5lc3QpKSl7DQogICAgICAgICAgICBuX21pc3NpbmcgPC0gd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHByb2ZfaW5mb191bm5lc3QpKQ0KICAgICAgICAgICAgcGFkZGluZyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IGxlbmd0aChuX21pc3NpbmcpLCBucm93PTEpKQ0KICAgICAgICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gZmllbGRzW3doaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhwcm9mX2luZm9fdW5uZXN0KSldDQogICAgICAgICAgICBwcm9mX2luZm9fdW5uZXN0IDwtIGJpbmRfY29scyhwcm9mX2luZm9fdW5uZXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICAgIHByb2ZfaW5mb191bm5lc3QgPC0gcHJvZl9pbmZvX3VubmVzdFtmaWVsZHNdDQogICAgICAgICAgfQ0KICAgICAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiAgICAgICAgICBwcm9mX2luZm9fdW5uZXN0IDwtICBwcm9mX2luZm9fdW5uZXN0ICU+JQ0KICAgICAgICAgICAgc2VsZWN0KGFsbF9vZihmaWVsZHMpKQ0KICAgICAgICAgIA0KICAgICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAicHJvZl9pbmZvIiwgcHJvZl9pbmZvX3VubmVzdCwgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKQ0KICAgICAgICB9DQogICAgICB9DQogICAgICANCiAgICAgICMjIGdldCB0aGUgTkFSQ0lTIHB1YmxpY2F0aW9ucw0KICAgICAgbmFyY2lzX3B1YnMgPC0gcHJvZltbIm5hcmNpc19wdWJzIl1dDQogICAgICAjIGlmIG5vdCBlbXB0eQ0KICAgICAgaWYgKCFhbGwoaXMubmEobmFyY2lzX3B1YnMpKSAmIGNsYXNzKG5hcmNpc19wdWJzKSAhPSAiY2hhcmFjdGVyIil7DQogICAgICAgICMgaWYgZmlyc3Qgcm91bmQsIGNyZWF0ZSBhIHRhYmxlDQogICAgICAgIGlmICgoaSA9PSAxKSAmIChqID09IDEpKXsNCiAgICAgICAgICAjIHdyaXRlIHRvIHRoZSBkYXRhYmFzZQ0KICAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJuYXJjaXNfcHVicyIsIG5hcmNpc19wdWJzLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KICAgICAgICAgICMgb3RoZXJ3aXNlLCBhcHBlbmQNCiAgICAgICAgfWVsc2V7DQogICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJuYXJjaXNfcHVicyIpDQogICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgIG5hcmNpc19wdWJzIDwtICBuYXJjaXNfcHVicyAlPiUNCiAgICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiAgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgIm5hcmNpc19wdWJzIiwgbmFyY2lzX3B1YnMsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgDQogICAgICAjIyBnZXQgdGhlIE9BIHB1YmxpY2F0aW9ucw0KICAgICAgb2FfcHVicyA8LSBwcm9mW1sib2FfcHVicyJdXQ0KICAgICAgDQogICAgICAjIGlmIG5vdCBlbXB0eQ0KICAgICAgaWYgKCFhbGwoaXMubmEob2FfcHVicykpKXsNCiAgICAgICAgIyBmaXJzdCwgZ2V0IHRoZSBtZW50aW9uIGRhdGENCiAgICAgICAgbWVudGlvbl9kYXRhIDwtIG9hX3B1YnMgJT4lDQogICAgICAgICAgc2VsZWN0KGlkLCBwcm9maWxlX2lkLCBhdXRob3JfcG9zaXRpb246bGFzdF9jb2woKSwgLWF1dGhvcl9wb3NpdGlvbikNCiAgICAgICAgDQogICAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICAgIGlmICghYWxsKGlzLm5hKG1lbnRpb25fZGF0YSkpKXsNCiAgICAgICAgICANCiAgICAgICAgICAjIGlmIHRoZXJlJ3Mgd2lraSBkYXRhDQogICAgICAgICAgaWYgKCd3aWtpcGVkaWEnICVpbiUgY29sbmFtZXMobWVudGlvbl9kYXRhKSl7DQogICAgICAgICAgICB3aWtpX21lbnRpb25fZGF0YV91bm5lc3QgPC0gbWVudGlvbl9kYXRhJT4lDQogICAgICAgICAgICAgIHNlbGVjdChpZCwgcHJvZmlsZV9pZCwgd2lraXBlZGlhKSAlPiUNCiAgICAgICAgICAgICAgdW5uZXN0KC4sIGNvbHMgPSAnd2lraXBlZGlhJyklPiUNCiAgICAgICAgICAgICAgc2VsZWN0KCFjaXRhdGlvbl9pZHMpJT4lDQogICAgICAgICAgICAgIHVubmVzdCguLCBjb2xzID0gYXV0aG9yLCBuYW1lc19zZXAgPSAiX2F1XyIpDQogICAgICAgICAgICANCiAgICAgICAgICAgICMgaWYgZmlyc3Qgcm91bmQsIGNyZWF0ZSBhIHRhYmxlDQogICAgICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJ3aWtpX21lbnRpb25zIiwgd2lraV9tZW50aW9uX2RhdGFfdW5uZXN0LCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KICAgICAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAid2lraV9tZW50aW9ucyIpDQogICAgICAgICAgICAgICMgaWYgbm90IGFsbCBmaWVsZHMgdGhlcmUNCiAgICAgICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyh3aWtpX21lbnRpb25fZGF0YV91bm5lc3QpKSl7DQogICAgICAgICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyh3aWtpX21lbnRpb25fZGF0YV91bm5lc3QpKQ0KICAgICAgICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCkpXQ0KICAgICAgICAgICAgICAgIHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCA8LSBiaW5kX2NvbHMod2lraV9tZW50aW9uX2RhdGFfdW5uZXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICAgICAgICAgICAgd2lraV9tZW50aW9uX2RhdGFfdW5uZXN0IDwtIHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdFtmaWVsZHNdDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgICAgICB3aWtpX21lbnRpb25fZGF0YV91bm5lc3QgPC0gIHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCAlPiUNCiAgICAgICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAid2lraV9tZW50aW9ucyIsIHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCwgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICAjIGlmIHRoZXJlJ3MgbmV3cyBkYXRhDQogICAgICAgICAgaWYgKCduZXdzJyAlaW4lIGNvbG5hbWVzKG1lbnRpb25fZGF0YSkpew0KICAgICAgICAgICAgbmV3c19tZW50aW9uX2RhdGFfdW5uZXN0IDwtIG1lbnRpb25fZGF0YSU+JQ0KICAgICAgICAgICAgICBzZWxlY3QoaWQsIHByb2ZpbGVfaWQsIG5ld3MpICU+JQ0KICAgICAgICAgICAgICB1bm5lc3QoLiwgY29scyA9ICduZXdzJyklPiUNCiAgICAgICAgICAgICAgc2VsZWN0KCFjaXRhdGlvbl9pZHMpJT4lDQogICAgICAgICAgICAgIHVubmVzdCguLCBjb2xzID0gYXV0aG9yLCBuYW1lc19zZXAgPSAiX2F1XyIpDQogICAgICAgICAgICANCiAgICAgICAgICAgICMgaWYgZmlyc3Qgcm91bmQsIGNyZWF0ZSBhIHRhYmxlDQogICAgICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJuZXdzX21lbnRpb25zIiwgbmV3c19tZW50aW9uX2RhdGFfdW5uZXN0LCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKSANCiAgICAgICAgICAgICAgIyBvdGhlcndpc2UsIGFwcGVuZA0KICAgICAgICAgICAgfWVsc2V7DQogICAgICAgICAgICAgICMgY2hlY2sgZmllbGRzIGluIHRoZSBleGlzdGluZyB0YWJsZQ0KICAgICAgICAgICAgICBmaWVsZHMgPC0gZGJMaXN0RmllbGRzKGNvbiwgIm5ld3NfbWVudGlvbnMiKQ0KICAgICAgICAgICAgICAjIGlmIG5vdCBhbGwgZmllbGRzIHRoZXJlDQogICAgICAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXMobmV3c19tZW50aW9uX2RhdGFfdW5uZXN0KSkpew0KICAgICAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMobmV3c19tZW50aW9uX2RhdGFfdW5uZXN0KSkNCiAgICAgICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gZmllbGRzW3doaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhuZXdzX21lbnRpb25fZGF0YV91bm5lc3QpKV0NCiAgICAgICAgICAgICAgICBuZXdzX21lbnRpb25fZGF0YV91bm5lc3QgPC0gYmluZF9jb2xzKG5ld3NfbWVudGlvbl9kYXRhX3VubmVzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICAgICAgICAgICAgbmV3c19tZW50aW9uX2RhdGFfdW5uZXN0IDwtIG5ld3NfbWVudGlvbl9kYXRhX3VubmVzdFtmaWVsZHNdDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiAgICAgICAgICAgICAgbmV3c19tZW50aW9uX2RhdGFfdW5uZXN0IDwtICBuZXdzX21lbnRpb25fZGF0YV91bm5lc3QgJT4lDQogICAgICAgICAgICAgICAgc2VsZWN0KGFsbF9vZihmaWVsZHMpKQ0KICAgICAgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgIm5ld3NfbWVudGlvbnMiLCBuZXdzX21lbnRpb25fZGF0YV91bm5lc3QsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkgDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIA0KICAgICAgICAgICMgIyBpZiB0aGVyZSdzIEZCIGRhdGEsIGJ1dCB0aGlzIGRvZXNuJ3Qgd29yayANCiAgICAgICAgICAjIGlmICgnZmFjZWJvb2snICVpbiUgY29sbmFtZXMobWVudGlvbl9kYXRhKSl7DQogICAgICAgICAgIyAgIGZiX21lbnRpb25fZGF0YV91bm5lc3QgPC0gbWVudGlvbl9kYXRhJT4lDQogICAgICAgICAgIyAgICAgc2VsZWN0KGlkLCBwcm9maWxlX2lkLCBmYWNlYm9vaykgJT4lDQogICAgICAgICAgIyAgICAgdW5uZXN0KC4sIGNvbHMgPSAnZmFjZWJvb2snKSU+JQ0KICAgICAgICAgICMgICAgIHNlbGVjdCghY2l0YXRpb25faWRzKQ0KICAgICAgICAgICMgDQogICAgICAgICAgIyB9DQogICAgICAgICAgDQogICAgICAgICAgIyBpZiB0aGVyZSdzIHJlZGRpdCBkYXRhDQogICAgICAgICAgaWYgKCdyZWRkaXQnICVpbiUgY29sbmFtZXMobWVudGlvbl9kYXRhKSl7DQogICAgICAgICAgICByZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCA8LSBtZW50aW9uX2RhdGElPiUNCiAgICAgICAgICAgICAgc2VsZWN0KGlkLCBwcm9maWxlX2lkLCByZWRkaXQpICU+JQ0KICAgICAgICAgICAgICB1bm5lc3QoLiwgY29scyA9ICdyZWRkaXQnKSU+JQ0KICAgICAgICAgICAgICBzZWxlY3QoIWNpdGF0aW9uX2lkcyklPiUNCiAgICAgICAgICAgICAgdW5uZXN0KC4sIGNvbHMgPSBhdXRob3IsIG5hbWVzX3NlcCA9ICJfYXVfIikNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgaWYgKChpID09IDEpICYgKGogPT0gMSkpew0KICAgICAgICAgICAgICAjIHdyaXRlIHRvIHRoZSBkYXRhYmFzZQ0KICAgICAgICAgICAgICBkYldyaXRlVGFibGUoY29uLCAicmVkZGl0X21lbnRpb25zIiwgcmVkZGl0X21lbnRpb25fZGF0YV91bm5lc3QsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpIA0KICAgICAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAicmVkZGl0X21lbnRpb25zIikNCiAgICAgICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyhyZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCkpKXsNCiAgICAgICAgICAgICAgICBuX21pc3NpbmcgPC0gd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0KSkNCiAgICAgICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gZmllbGRzW3doaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhyZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCkpXQ0KICAgICAgICAgICAgICAgIHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0IDwtIGJpbmRfY29scyhyZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICAgICAgICAgICAgcmVkZGl0X21lbnRpb25fZGF0YV91bm5lc3QgPC0gcmVkZGl0X21lbnRpb25fZGF0YV91bm5lc3RbZmllbGRzXQ0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiAgICAgICAgICAgICAgcmVkZGl0X21lbnRpb25fZGF0YV91bm5lc3QgPC0gIHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0ICU+JQ0KICAgICAgICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiAgICAgICAgICAgICAgZGJBcHBlbmRUYWJsZShjb24sICJyZWRkaXRfbWVudGlvbnMiLCByZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCwgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKSANCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgDQogICAgICAgICMgbm93LCBnZXQgdGhlIHB1YmxpY2F0aW9uIGRhdGENCiAgICAgICAgIyBzZWxlY3QgcmVsZXZhbnQgY29sdW1ucw0KICAgICAgICBzZWxlY3RfY29scyA8LSBjKCJpZCIsICJwcm9maWxlX2lkIiwgImRpc3BsYXlfbmFtZSIsICJhYiIsICJwdWJsaWNhdGlvbl95ZWFyIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAic28iLCAic29faWQiLCAiaG9zdF9vcmdhbml6YXRpb24iLCAiaXNzbl9sIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgInVybCIsICJwZGZfdXJsIiwgInZvbHVtZSIsICJpc3N1ZSIsICJmaXJzdF9wYWdlIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgImxhc3RfcGFnZSIsICIgaXNfaWEiLCAibGFuZ3VhZ2UiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJjaXRlZF9ieV9jb3VudCIsICJjb3VudHNfYnlfeWVhciIsICJjaXRlZF9ieV9hcGlfdXJsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiZG9pIiwgInR5cGUiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAiaXNfcmV0cmFjdGVkIiwgImlhX2lkIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgImF1dGhvcl9wb3NpdGlvbiIpDQogICAgICAgIHB1Yl9kYXRhIDwtIG9hX3B1YnMgJT4lDQogICAgICAgICAgc2VsZWN0KGFueV9vZihzZWxlY3RfY29scykpDQogICAgICAgIA0KICAgICAgICAjIGdldCB0aGUgcmVmZXJlbmNlZCB3b3Jrcw0KICAgICAgICByZWZlcmVuY2VkX3dvcmtzIDwtIG9hX3B1YnMgJT4lDQogICAgICAgICAgc2VsZWN0KGlkLCBwcm9maWxlX2lkLCByZWZlcmVuY2VkX3dvcmtzKSU+JQ0KICAgICAgICAgIHVubmVzdCguLCBjb2xzID0gInJlZmVyZW5jZWRfd29ya3MiKQ0KICAgICAgICANCiAgICAgICAgIyBnZXQgdGhlIGNvdW50cyBieSB5ZWFyDQogICAgICAgIHB1Yl9ieV95ZWFyIDwtIHB1Yl9kYXRhICU+JQ0KICAgICAgICAgIHVubmVzdCguLCBjb2xzID0gImNvdW50c19ieV95ZWFyIiwgbmFtZXNfc2VwID0gIl95ZWFyXyIpDQogICAgICAgIA0KICAgICAgICAjIHdyaXRlIHRoaXMgb3V0DQogICAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICAgIGlmICghYWxsKGlzLm5hKG9hX3B1YnMpKSl7DQogICAgICAgICAgaWYgKChpID09IDEpICYgKGogPT0gMSkpew0KICAgICAgICAgICAgIyB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJvYV9wdWJzIiwgcHViX2J5X3llYXIsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQogICAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgICAgfWVsc2V7DQogICAgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAib2FfcHVicyIpDQogICAgICAgICAgICAjIGlmIHNvbWUgbWlzc2luZywgcGFkIHRoZSBkYXRhc2V0DQogICAgICAgICAgICBpZighYWxsKGZpZWxkcyAlaW4lIGNvbG5hbWVzKHB1Yl9ieV95ZWFyKSkpew0KICAgICAgICAgICAgICBuX21pc3NpbmcgPC0gd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHB1Yl9ieV95ZWFyKSkNCiAgICAgICAgICAgICAgcGFkZGluZyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IGxlbmd0aChuX21pc3NpbmcpLCBucm93PTEpKQ0KICAgICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHB1Yl9ieV95ZWFyKSldDQogICAgICAgICAgICAgIHB1Yl9ieV95ZWFyIDwtIGJpbmRfY29scyhwdWJfYnlfeWVhciwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICAgICAgICAgIHB1Yl9ieV95ZWFyIDwtIHB1Yl9ieV95ZWFyW2ZpZWxkc10NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiAgICAgICAgICAgIHB1Yl9ieV95ZWFyIDwtICBwdWJfYnlfeWVhciAlPiUNCiAgICAgICAgICAgICAgc2VsZWN0KGFsbF9vZihmaWVsZHMpKQ0KICAgICAgICAgICAgZGJBcHBlbmRUYWJsZShjb24sICJvYV9wdWJzIiwgcHViX2J5X3llYXIsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgDQogICAgICAgICMgdW5uZXN0IHRoZSBjb25jZXB0cywgYnV0IGFsc28gbGVhdmUgb25seSB0aG9zZSBvbiBsZXZlbHMgMCBhbmQgMSBhbmQgd2l0aCBwcm9iDQogICAgICAgICMgYWJvdmUgMC41DQogICAgICAgIG9hX2NvbmNlcHRzIDwtIG9hX3B1YnMgJT4lDQogICAgICAgICAgc2VsZWN0KGlkLCBwcm9maWxlX2lkLCBjb25jZXB0cyklPiUNCiAgICAgICAgICB1bm5lc3QoLiwgY29scyA9ICJjb25jZXB0cyIsIG5hbWVzX3NlcCA9ICJfY29uY18iKSU+JQ0KICAgICAgICAgIGZpbHRlcihjb25jZXB0c19jb25jX2xldmVsICVpbiUgYygwLDEpICYgY29uY2VwdHNfY29uY19zY29yZSA+PSAwLjUpDQogICAgICAgIA0KICAgICAgICAjIHdyaXRlIHRoaXMgb3V0DQogICAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICAgIGlmICghYWxsKGlzLm5hKG9hX2NvbmNlcHRzKSkpew0KICAgICAgICAgIGlmICgoaSA9PSAxKSAmIChqID09IDEpKXsNCiAgICAgICAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgICAgICBkYldyaXRlVGFibGUoY29uLCAib2FfY29uY2VwdHMiLCBvYV9jb25jZXB0cywgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkgDQogICAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgICAgfWVsc2V7DQogICAgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAib2FfY29uY2VwdHMiKQ0KICAgICAgICAgICAgIyBpZiBzb21lIGZpZWxkcyBtaXNzaW5nLCBwYWQgdGhlIGRhdGFzZXQNCiAgICAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXMob2FfY29uY2VwdHMpKSl7DQogICAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMob2FfY29uY2VwdHMpKQ0KICAgICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMob2FfY29uY2VwdHMpKV0NCiAgICAgICAgICAgICAgb2FfY29uY2VwdHMgPC0gYmluZF9jb2xzKG9hX2NvbmNlcHRzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICAgICAgb2FfY29uY2VwdHMgPC0gb2FfY29uY2VwdHNbZmllbGRzXQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgICAgb2FfY29uY2VwdHMgPC0gIG9hX2NvbmNlcHRzICU+JQ0KICAgICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgIm9hX2NvbmNlcHRzIiwgb2FfY29uY2VwdHMsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIA0KICAgICAgIyMgZ2V0IHRoZSBncmFudCBpbmZvDQogICAgICBncmFudF9pbmZvIDwtIHByb2ZbWyJncmFudF9pbmZvIl1dDQogICAgICAjIGFuZCB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICBpZiAoIWFsbChpcy5uYShncmFudF9pbmZvKSkpew0KICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICAgIyB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgICBkYldyaXRlVGFibGUoY29uLCAiZ3JhbnRfaW5mbyIsIGdyYW50X2luZm8sIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQogICAgICAgICAgIyBvdGhlcndpc2UsIGFwcGVuZA0KICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgICBmaWVsZHMgPC0gZGJMaXN0RmllbGRzKGNvbiwgImdyYW50X2luZm8iKQ0KICAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXMoZ3JhbnRfaW5mbykpKXsNCiAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMoZ3JhbnRfaW5mbykpDQogICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKGdyYW50X2luZm8pKV0NCiAgICAgICAgICAgIGdyYW50X2luZm8gPC0gYmluZF9jb2xzKGdyYW50X2luZm8sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICAgIGdyYW50X2luZm8gPC0gZ3JhbnRfaW5mb1tmaWVsZHNdDQogICAgICAgICAgfQ0KICAgICAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiAgICAgICAgICBncmFudF9pbmZvIDwtICBncmFudF9pbmZvICU+JQ0KICAgICAgICAgICAgc2VsZWN0KGFsbF9vZihmaWVsZHMpKQ0KICAgICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAiZ3JhbnRfaW5mbyIsIGdyYW50X2luZm8sIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkNCiAgICAgICAgfQ0KICAgICAgDQogICAgICB9DQogICAgICANCiAgICAgICMjIGdldCB0aGUgY29hdXRob3IgaW5mbw0KICAgICAgY29hdXRob3JfaW5mbyA8LSBwcm9mW1siY29hdXRob3JfaW5mbyJdXQ0KICAgICAgIyBhbmQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAjIGlmIG5vdCBlbXB0eQ0KICAgICAgaWYgKCFhbGwoaXMubmEoY29hdXRob3JfaW5mbykpKXsNCiAgICAgICAgaWYgKChpID09IDEpICYgKGogPT0gMSkpew0KICAgICAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgImNvYXV0aG9yX2luZm8iLCBjb2F1dGhvcl9pbmZvLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKSANCiAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgIH1lbHNlew0KICAgICAgICAgICMgY2hlY2sgZmllbGRzIGluIHRoZSBleGlzdGluZyB0YWJsZQ0KICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAiY29hdXRob3JfaW5mbyIpDQogICAgICAgICAgIyBpZiBuZWVkZWQsIHBhZCB0aGUgZGF0YXNldA0KICAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXMoY29hdXRob3JfaW5mbykpKXsNCiAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMoY29hdXRob3JfaW5mbykpDQogICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKGNvYXV0aG9yX2luZm8pKV0NCiAgICAgICAgICAgIGNvYXV0aG9yX2luZm8gPC0gYmluZF9jb2xzKGNvYXV0aG9yX2luZm8sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgICAgICAgY29hdXRob3JfaW5mbyA8LSBjb2F1dGhvcl9pbmZvW2ZpZWxkc10NCiAgICAgICAgICB9DQogICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgIGNvYXV0aG9yX2luZm8gPC0gIGNvYXV0aG9yX2luZm8gJT4lDQogICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgZGJBcHBlbmRUYWJsZShjb24sICJjb2F1dGhvcl9pbmZvIiwgY29hdXRob3JfaW5mbywgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKSANCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgDQogICAgICAjIyBnZXQgdGhlIGFmZmlsaWF0aW9uIGluZm8NCiAgICAgIGFmZmlsaWF0aW9uX2luZm8gPC0gcHJvZltbImFmZmlsaWF0aW9uX2luZm8iXV0NCiAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICBpZiAoIWFsbChpcy5uYShhZmZpbGlhdGlvbl9pbmZvKSkpew0KICAgICAgICAjIGFuZCB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgaWYgKChpID09IDEpICYgKGogPT0gMSkpew0KICAgICAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgImFmZmlsaWF0aW9uX2luZm8iLCBhZmZpbGlhdGlvbl9pbmZvLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKSANCiAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgIH1lbHNlew0KICAgICAgICAgICMgY2hlY2sgZmllbGRzIGluIHRoZSBleGlzdGluZyB0YWJsZQ0KICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAiYWZmaWxpYXRpb25faW5mbyIpDQogICAgICAgICAgIyBpZiBuZWVkZWQsIHBhZCB0aGUgZGF0YXNldA0KICAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXMoYWZmaWxpYXRpb25faW5mbykpKXsNCiAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMoYWZmaWxpYXRpb25faW5mbykpDQogICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKGFmZmlsaWF0aW9uX2luZm8pKV0NCiAgICAgICAgICAgIGFmZmlsaWF0aW9uX2luZm8gPC0gYmluZF9jb2xzKGFmZmlsaWF0aW9uX2luZm8sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgICAgICAgYWZmaWxpYXRpb25faW5mbyA8LSBhZmZpbGlhdGlvbl9pbmZvW2ZpZWxkc10NCiAgICAgICAgICB9DQogICAgICAgICAgDQogICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgIGFmZmlsaWF0aW9uX2luZm8gPC0gIGFmZmlsaWF0aW9uX2luZm8gJT4lDQogICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgZGJBcHBlbmRUYWJsZShjb24sICJhZmZpbGlhdGlvbl9pbmZvIiwgYWZmaWxpYXRpb25faW5mbywgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKSAgDQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9DQogICAgDQogICAgcHJpbnQocGFzdGUoImRvbmUgd2l0aCIsIGosICJvdXQgb2YiLCBsZW5ndGgocHJvZl9iYXRjaCkpKQ0KICAgIA0KICB9DQp9DQpgYGANCg0KDQoNCg0KYGBge3J9DQpvYV9jb2xuYW1lc19hbGwgPC0gYygpDQpmb3IgKGogaW4gMTpsZW5ndGgocHJvZl9iYXRjaCkpew0KICBwcm9mIDwtIHByb2ZfYmF0Y2hbW2pdXQ0KICBwcm9mX2lkIDwtIG5hbWVzKHByb2ZfYmF0Y2hbal0pDQogICMgaWYgc29tZSBkYXRhIGluIHRoZSBwcm9mIGxpc3QNCiAgaWYgKGxlbmd0aChwcm9mKT4xKXsNCiAgICAjIGdldCB0aGUgT0EgcHVibGljYXRpb25zDQogICAgb2FfcHVicyA8LSBwcm9mW1sib2FfcHVicyJdXQ0KICAgIGlmICghYWxsKGlzLm5hKG9hX3B1YnMpKSl7DQogICAgICBvYV9jb2xuYW1lcyA8LSBjb2xuYW1lcyhvYV9wdWJzKQ0KICAgICAgDQogICAgICBvYV9jb2xuYW1lc19hbGwgPC0gYyhvYV9jb2xuYW1lc19hbGwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBvYV9jb2xuYW1lc1t3aGljaCghb2FfY29sbmFtZXMgJWluJSBvYV9jb2xuYW1lc19hbGwpXSkNCiAgICB9DQogIH0NCn0NCiAgICANCiAgICAjIHNlbGVjdCByZWxldmFudCBjb2x1bW5zDQogICAgY29scyA8LSBjKCJpZCIsICJkaXNwbGF5X25hbWUiLCAiYWIiLCAicHVibGljYXRpb25feWVhciIsDQogICAgICAgICAgICAgICAic28iLCAic29faWQiLCAiaG9zdF9vcmdhbml6YXRpb24iLCAiaXNzbl9sIiwgDQogICAgICAgICAgICAgICJ1cmwiLCAicGRmX3VybCIsICJ2b2x1bWUiLCAiaXNzdWUiLCAiZmlyc3RfcGFnZSIsIA0KICAgICAgICAgICAgICAgImxhc3RfcGFnZSIsICIgaXNfaWEiLCAiIGxhbmd1YWdlIiwNCiAgICAgICAgICAgICAgICJjaXRlZF9ieV9jb3VudCIsICIgY291bnRzX2J5X3llYXIiLCAiIGNpdGVkX2J5X2FwaV91cmwiLA0KICAgICAgICAgICAgICAgImlkcyIsICIgZG9pIiwgIiB0eXBlIiwgIiByZWZlcmVuY2VkX3dvcmtzIiwgIiByZWxhdGVkX3dvcmtzIiwNCiAgICAgICAgICAgICAgICJpc19yZXRyYWN0ZWQiLCAiIGNvbmNlcHRzIiwgIiBpYV9pZCIsICIgcHJvZmlsZV9pZCIsIA0KICAgICAgICAgICAgICAgImF1dGhvcl9wb3NpdGlvbiIpDQogICAgIyBhbmQgd2hhdGV2ZXIgaXMgDQogICAgDQogICAgb2FfcHVic18yIDwtIG9hX3B1YnMgJT4lDQogICAgICAgIHNlbGVjdChpZCwgZGlzcGxheV9uYW1lLCBhYiwgcHVibGljYXRpb25feWVhciwNCiAgICAgICAgICAgICAgIHNvLCBzb19pZCwgaG9zdF9vcmdhbml6YXRpb24sIGlzc25fbCwNCiAgICAgICAgICAgICAgIHVybCwgcGRmX3VybCwgdm9sdW1lLCBpc3N1ZSwgZmlyc3RfcGFnZSwNCiAgICAgICAgICAgICAgIGxhc3RfcGFnZSwgaXNfaWEsIGxhbmd1YWdlLA0KICAgICAgICAgICAgICAgY2l0ZWRfYnlfY291bnQsIGNvdW50c19ieV95ZWFyLCBjaXRlZF9ieV9hcGlfdXJsLCANCiAgICAgICAgICAgICAgIGlkcywgZG9pLCB0eXBlLCByZWZlcmVuY2VkX3dvcmtzLCByZWxhdGVkX3dvcmtzLA0KICAgICAgICAgICAgICAgaXNfcmV0cmFjdGVkLCBjb25jZXB0cywgaWFfaWQsIHByb2ZpbGVfaWQsDQogICAgICAgICAgICAgICBhdXRob3JfcG9zaXRpb24pDQogICAgDQogICAgDQogICAgIyB1bm5lc3QgdGhlIGNvbmNlcHRzLCBidXQgYWxzbyBsZWF2ZSBvbmx5IHRob3NlIG9uIGxldmVscyAwIGFuZCAxIGFuZCB3aXRoIHByb2INCiAgICAjIGFib3ZlIDAuNQ0KICAgIG9hX3B1YnNfdW5uZXN0ZWQgPC0gdW5uZXN0KG9hX3B1YnMsIGNvbHMgPSAiY29uY2VwdHMiLCBuYW1lc19zZXAgPSAiX2NvbmNfIiklPiUNCiAgICAgIGZpbHRlcihjb25jZXB0c19jb25jX2xldmVsICVpbiUgYygwLDEpICYgY29uY2VwdHNfY29uY19zY29yZSA+PSAwLjUpDQogICAgDQogICAgIyBhcHBlbmQgdGhlIHByb2YgSUQNCiAgICBvYV9wdWJzIDwtIGJpbmRfY29scygicHJvZmlsZV9pZCIgPSBwcm9mX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgIG9hX3B1YnMpDQogICAgDQogICAgDQogICAgDQogICAgIyBhbmQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3B1YnMiLCBvYV9wdWJzLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KICAgIA0KICAgIA0KICAgIA0KICAgICAgfQ0KDQogICAgICANCiAgDQp9DQpgYGANCg0KDQoNCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("db_Test.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
