<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ana Macanovic" />

<meta name="date" content="2024-04-10" />

<title>Various analyses - April 2024, final dataset</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a>
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="index.html">Code homepage</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="glyphicon glyphicon glyphicon glyphicon-list"></span>
     
    Scripts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="SQL_tutorial.html">Intro: SQL tutorial</a>
    </li>
    <li>
      <a href="OpenAlex_Altmetric_data_download.html">1. Open Alex and Altmetric data download</a>
    </li>
    <li>
      <a href="Gender_inference.html">2. Gender inference</a>
    </li>
    <li>
      <a href="Grant_parsing.html">3. Grant parsing</a>
    </li>
    <li>
      <a href="Lexis_nexis_parser.html">4. Lexis data parser</a>
    </li>
    <li>
      <a href="Mention_url_extraction.html">5. Mention URL extraction</a>
    </li>
    <li>
      <a href="Data_descriptives.html">5. Database description and coverage</a>
    </li>
    <li>
      <a href="Panel_data_compilation.html">6. Panel data compilation</a>
    </li>
    <li>
      <a href="analyses.html">7. Various analyses</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/amacanovic/dutch_media_profs">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Various analyses - April 2024, final
dataset</h1>
<h4 class="author">Ana Macanovic</h4>
<h4 class="date">2024-04-10</h4>

</div>


<p>This is a first draft of our main analyses.</p>
<p>Load the packages:</p>
<pre class="r"><code>library(groundhog)
packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;tidyr&quot;, 
                      &quot;ggplot2&quot;, &quot;gridExtra&quot;, &quot;cowplot&quot;,
                      &quot;tidyverse&quot;, &quot;RPostgres&quot;, &quot;markovchain&quot;
                      , &quot;RPostgres&quot;, &quot;lubridate&quot;, &quot;psych&quot;,
                      &quot;gridExtra&quot;, &quot;DescTools&quot;, &quot;marginaleffects&quot;,
                      &quot;panelr&quot;, &quot;skimr&quot;, &quot;margins&quot;,
                      &quot;lmtest&quot;, &quot;sandwich&quot;, &quot;rstatix&quot;, &quot;ggpubr&quot;,
                      &quot;stargazer&quot;,&quot;plm&quot;, &quot;grid&quot;, &quot;corrplot&quot;)
groundhog.library(packages_to_load, date = &quot;2023-12-01&quot;)
#groundhog.library(c(&quot;ggeffects&quot;, &quot;insight&quot;), date = &quot;2024-04-15&quot;)

install.packages(&quot;insight&quot;)
library(insight)
library(ggeffects)
source(&quot;helper_functions.R&quot;)</code></pre>
<p>Load the panel:</p>
<pre class="r"><code>prof_panel_coa &lt;- read_csv(&quot;panel_datasets/prof_panel_tidy_26_4.csv&quot;)

prof_panel_filter &lt;- filter(prof_panel_coa,
                            year &lt; 2024)

prof_panel_filter$coa_online_all_total &lt;- prof_panel_filter$coa_online_news_total + prof_panel_filter$coa_blogs_total
prof_panel_filter$coa_online_all_total_l &lt;- prof_panel_filter$coa_online_news_total_l + prof_panel_filter$coa_blogs_total_l
prof_panel_filter$coa_online_all &lt;- prof_panel_filter$coa_online_news + prof_panel_filter$coa_blogs
prof_panel_filter$coa_online_all_l &lt;- prof_panel_filter$coa_online_news_l + prof_panel_filter$coa_blogs_l

prof_panel_filter$coa_tot_online_all_total &lt;- prof_panel_filter$coa_tot_online_news_total + prof_panel_filter$coa_tot_blogs_total
prof_panel_filter$coa_tot_online_all_total_l &lt;- prof_panel_filter$coa_tot_online_news_total_l + prof_panel_filter$coa_tot_blogs_total_l
prof_panel_filter$coa_tot_online_all &lt;- prof_panel_filter$coa_tot_online_news + prof_panel_filter$coa_tot_blogs
prof_panel_filter$coa_tot_online_all_l &lt;- prof_panel_filter$coa_tot_online_news + prof_panel_filter$coa_tot_blogs_l</code></pre>
<div id="explore-representation-across-different-data-sources"
class="section level1" number="1">
<h1><span class="header-section-number">1</span> Explore representation
across different data sources</h1>
<pre class="r"><code>sources_check &lt;- prof_panel_filter %&gt;%
  group_by(profile_id)%&gt;%
  filter(year == max(year))</code></pre>
<p>Check two kinds of coauthor variables we have:</p>
<pre class="r"><code>select_vars_cor &lt;- c(&quot;coa_count_pubs_total_oa&quot;,
                     &quot;coa_cited_by_total_oa&quot;,
                     &quot;coa_online_all_total&quot;,
                     &quot;coa_twitter_total&quot;,
                     &quot;coa_tot_count_pubs&quot;,
                     &quot;coa_tot_cited_by&quot;,
                     &quot;coa_tot_online_all_total&quot;,
                     &quot;coa_tot_twitter&quot;)

labels_cor &lt;-c(&quot;Publications - this year&#39;s coauthors&#39; total&quot;,
               &quot;Citations - this year&#39;s coauthors&#39; total&quot;,
               &quot;Online news attention - this year&#39;s coauthor&#39; total&quot;,
               &quot;Twitter attention - this year&#39;s coauthor&#39; total&quot;,
               &quot;Publications - all coauthors&#39; total&quot;,
               &quot;Citations - all coauthors&#39; total&quot;,
               &quot;Online news attention - all coauthor&#39; total&quot;,
               &quot;Twitter attention - all coauthor&#39; total&quot;)

correlation_matrix &lt;- cor(sources_check[,select_vars_cor],use=&quot;pairwise.complete.obs&quot;)


colnames(correlation_matrix) &lt;- labels_cor
rownames(correlation_matrix) &lt;- labels_cor


png(height=10, width=10, 
    unit = &quot;in&quot;, 
    res = 600,
    file=&quot;Plots_april/Supplemental/correlations_coauthor_var_comparison_total.png&quot;)

# Your function to plot image goes here
corrplot(correlation_matrix, 
         method=&quot;number&quot;,
         tl.col = &quot;black&quot;,
         title = &quot;Variable Correlation Matrix - Coauthor variable comparison (Totals)&quot;,
         mar=c(0,0,2,0))
# Then
dev.off()</code></pre>
<p>First, some correlations between different variables, looking at
totals in the final year overall:</p>
<pre class="r"><code>select_vars_cor &lt;- c(&quot;count_pubs_total&quot;,
                     &quot;cited_by_total_all&quot;,
                     &quot;news_all_total&quot;,
                     &quot;alt_online_all_total&quot;,
                     &quot;alt_twitter_total&quot;,
                     &quot;coa_count_pubs_total_oa&quot;,
                     &quot;coa_cited_by_total_oa&quot;,
                     &quot;coa_online_all_total&quot;,
                     &quot;coa_twitter_total&quot;,
                     &quot;years_since_first_pub&quot;)

labels_cor &lt;-c(&quot;Publications&quot;,
               &quot;Citations&quot;,
               &quot;News attention&quot;,
               &quot;Online news attention&quot;,
               &quot;Twitter attention&quot;,
               &quot;Coauthor publications&quot;,
               &quot;Coauthor citations&quot;,
               &quot;Coauthor online news attention&quot;,
               &quot;Coauthor twitter attention&quot;,
               &quot;Years since first publications&quot;)

correlation_matrix &lt;- cor(sources_check[,select_vars_cor],use=&quot;pairwise.complete.obs&quot;)


colnames(correlation_matrix) &lt;- labels_cor
rownames(correlation_matrix) &lt;- labels_cor


png(height=10, width=10, 
    unit = &quot;in&quot;, 
    res = 600,
    file=&quot;Plots_april/Supplemental/correlations_total_overall.png&quot;)

# Your function to plot image goes here
corrplot(correlation_matrix, 
         method=&quot;number&quot;,
         tl.col = &quot;black&quot;,
         title = &quot;Variable Correlation Matrix - Totals, All fields&quot;,
         mar=c(0,0,2,0))
# Then
dev.off()</code></pre>
<p>And per field:</p>
<pre class="r"><code>fields &lt;- unique(sources_check$general_field)
fields &lt;- fields[1:4]

for (field in fields){
  field_data &lt;- filter(sources_check, general_field == field)
  
  correlation_matrix_field &lt;- cor(field_data[,select_vars_cor],use=&quot;pairwise.complete.obs&quot;)
  
  rownames(correlation_matrix_field) &lt;- colnames(correlation_matrix_field)

  
  colnames(correlation_matrix_field) &lt;- labels_cor
  rownames(correlation_matrix_field) &lt;- labels_cor
  
  
  png(height=10, width=10, 
      unit = &quot;in&quot;, 
      res = 600,
      file= paste0(&quot;Plots_april/Supplemental/correlations_total_&quot;, field, &quot;.png&quot;))
  
  # Your function to plot image goes here
  corrplot(correlation_matrix_field, 
           method=&quot;number&quot;,
           tl.col = &quot;black&quot;,
           title = paste(&quot;Variable Correlation Matrix - Totals&quot;, field),
         mar=c(0,0,2,0))
  # Then
  dev.off()

}</code></pre>
<p>Looking at year over year numbers:</p>
<pre class="r"><code>select_vars_cor &lt;- c(&quot;count_pubs&quot;,
                     &quot;cited_by&quot;,
                     &quot;news_all&quot;,
                     &quot;alt_online_all&quot;,
                     &quot;alt_twitter&quot;,
                     &quot;coa_count_pubs&quot;,
                     &quot;coa_cited_by&quot;,
                     &quot;coa_online_all&quot;,
                     &quot;coa_twitter&quot;)

correlation_matrix &lt;- cor(prof_panel_filter[,select_vars_cor],use=&quot;pairwise.complete.obs&quot;)


colnames(correlation_matrix) &lt;- labels_cor[1:9]
rownames(correlation_matrix) &lt;- labels_cor[1:9]


png(height=10, width=10, 
    unit = &quot;in&quot;, 
    res = 600,
    file=&quot;Plots_april/Supplemental/correlations_yearly_overall.png&quot;)

# Your function to plot image goes here
corrplot(correlation_matrix, 
         method=&quot;number&quot;,
         tl.col = &quot;black&quot;,
         title = &quot;Variable Correlation Matrix - Yearly, All fields&quot;,
         mar=c(0,0,2,0))
# Then
dev.off()</code></pre>
<p>And per field:</p>
<pre class="r"><code>for (field in fields){
  field_data &lt;- filter(prof_panel_filter, general_field == field)
  
  correlation_matrix_field &lt;- cor(field_data[,select_vars_cor],use=&quot;pairwise.complete.obs&quot;)
  
  rownames(correlation_matrix_field) &lt;- colnames(correlation_matrix_field)

  
  colnames(correlation_matrix_field) &lt;- labels_cor[1:9]
  rownames(correlation_matrix_field) &lt;- labels_cor[1:9]
  
  
  png(height=10, width=10, 
      unit = &quot;in&quot;, 
      res = 600,
      file= paste0(&quot;Plots_april/Supplemental/correlations_yearly_&quot;, field, &quot;.png&quot;))
  
  # Your function to plot image goes here
  corrplot(correlation_matrix_field, 
           method=&quot;number&quot;,
           tl.col = &quot;black&quot;,
           title = paste(&quot;Variable Correlation Matrix - Yearly,&quot;, field),
         mar=c(0,0,2,0))
  # Then
  dev.off()

}</code></pre>
<div id="news-data" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> News data</h2>
<p>How many professors have at least one mention?</p>
<pre class="r"><code>sources_check$any_news &lt;- ifelse(sources_check$news_all_total &gt; 0, TRUE, FALSE)

table(sources_check$any_news)
prop.table(table(sources_check$any_news))</code></pre>
<p>96% of professors in our data - 6499 of them, has at least one news
mention.</p>
<p>On average, a professor in our dataset has accumulated 68.9 mentions
throughout their career:</p>
<pre class="r"><code>mean(sources_check$news_all_total, na.rm = TRUE)</code></pre>
<p>Or, 2.65 mentions per year:</p>
<pre class="r"><code>mean(prof_panel_filter$news_allall, na.rm = TRUE)</code></pre>
<p>Breakdown by news article type:</p>
<pre class="r"><code>news_type_source &lt;- sources_check %&gt;%
  select(profile_id, general_field, entry_batch_2023, inferred_gender, news_national_total:news_intl_total)
#news_type$news_all_total &lt;- rowSums(news_type[, 5:9])
colnames(news_type_source) &lt;- str_remove(str_remove(str_remove(colnames(news_type_source), &quot;news_&quot;), &quot;_total&quot;), &quot;lexis_&quot;)
colnames(news_type_source)[5:8] &lt;- c(&quot;National news&quot;,
                                     &quot;Regional news&quot;,
                                     &quot;Other news&quot;,
                                     &quot;International news&quot;)

news_type &lt;- news_type_source %&gt;%
  pivot_longer(cols = c(`National news`:`International news`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field, inferred_gender, name)%&gt;%
  summarise(
    profs = n(),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  group_by(general_field)%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m, na.rm = TRUE),3),
         w_prop = round(sum_w/sum(sum_w, na.rm = TRUE), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

news_overall &lt;- news_type_source %&gt;%
  pivot_longer(cols = c(`National news`:`International news`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field, inferred_gender)%&gt;%
  summarise(
    profs = n_distinct(profile_id),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m),3),
         w_prop = round(sum_w/sum(sum_w), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

news_overall$name &lt;- &quot;All news&quot;
news_overall &lt;- news_overall[colnames(news_type)]

news_type &lt;- rbind(news_type,
                   news_overall)

news_overall_overall &lt;- news_type_source %&gt;%
  pivot_longer(cols = c(`National news`:`International news`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(inferred_gender)%&gt;%
  summarise(
    profs = n_distinct(profile_id),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m),3),
         w_prop = round(sum_w/sum(sum_w), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

news_overall_overall$name &lt;- &quot;All news&quot;
news_overall_overall$general_field &lt;- &quot;All fields&quot;
news_overall_overall &lt;- news_overall_overall[colnames(news_type)]

news_type &lt;- rbind(news_type,
                   news_overall_overall)


news_type &lt;- news_type %&gt;%
  arrange(general_field, name)%&gt;%
  select(general_field:sum_w, m_ave, w_ave, m_prop, w_prop)

colnames(news_type) &lt;- c(&quot;Field&quot;,
                         &quot;News type&quot;,
                         &quot;N professors - men&quot;,
                         &quot;N professors - women&quot;,
                         &quot;News mentions - men&quot;,
                         &quot;News mentions - women&quot;,
                         &quot;Avg. news mentions - men&quot;,
                         &quot;Avg. news mentions - women&quot;,
                         &quot;Share mentions per source - men&quot;,
                         &quot;Share mentions per source - women&quot;)

# output to results
write_csv(news_type, &quot;Plots_april/Supplemental/T_news_source.csv&quot;)
knitr::kable(news_type)</code></pre>
</div>
<div id="altmetric-data" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Altmetric data</h2>
<p>How many professors have at least one mention?</p>
<pre class="r"><code>sources_check$any_alt &lt;- ifelse(sources_check$alt_online_all_total &gt; 0, TRUE, FALSE)

table(sources_check$any_alt)
prop.table(table(sources_check$any_alt))</code></pre>
<p>78% of professors in our data - 5301 of them, has at least one news
mention.</p>
<p>On average, a professor in our dataset has accumulated 102.7 online
mentions throughout their career:</p>
<pre class="r"><code>mean(sources_check$alt_online_all_total, na.rm = TRUE)</code></pre>
<p>Or, 8.3 mentions per year:</p>
<pre class="r"><code>mean(prof_panel_filter$alt_online_all, na.rm = TRUE)</code></pre>
<p>Check the averages breakdown:</p>
<pre class="r"><code>online_news_type_source &lt;- sources_check %&gt;%
  select(profile_id, general_field, entry_batch_2023, inferred_gender, alt_news_aggregator_total:alt_science_news_total)
#news_type$news_all_total &lt;- rowSums(news_type[, 5:9])
colnames(online_news_type_source) &lt;- str_remove(str_remove(str_remove(colnames(online_news_type_source), &quot;alt_&quot;), &quot;_total&quot;), &quot;lexis_&quot;)
colnames(online_news_type_source)[5:14] &lt;- c(&quot;News aggregator&quot;,
                                     &quot;Online blog&quot;,
                                     &quot;Science news aggregator&quot;,
                                     &quot;Finance news&quot;,
                                     &quot;General interest - local&quot;,
                                     &quot;General interest&quot;,
                                     &quot;Medical portals&quot;,
                                     &quot;Other news&quot;,
                                     &quot;Popular science news&quot;,
                                     &quot;Science news&quot;)

online_news_type &lt;- online_news_type_source %&gt;%
  pivot_longer(cols = c(`News aggregator`:`Science news`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field, inferred_gender, name)%&gt;%
  summarise(
    profs = n(),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  group_by(general_field)%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m),3),
         w_prop = round(sum_w/sum(sum_w), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

online_news_overall &lt;- online_news_type_source %&gt;%
  pivot_longer(cols = c(`News aggregator`:`Science news`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field, inferred_gender)%&gt;%
  summarise(
    profs = n_distinct(profile_id),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m),3),
         w_prop = round(sum_w/sum(sum_w), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

online_news_overall$name &lt;- &quot;All news&quot;
online_news_overall &lt;- online_news_overall[colnames(online_news_type)]

online_news_type &lt;- rbind(online_news_type,
                   online_news_overall)

online_news_overall_overall &lt;- online_news_type_source %&gt;%
  pivot_longer(cols = c(`News aggregator`:`Science news`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(inferred_gender)%&gt;%
  summarise(
    profs = n_distinct(profile_id),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m),3),
         w_prop = round(sum_w/sum(sum_w), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

online_news_overall_overall$name &lt;- &quot;All news&quot;
online_news_overall_overall$general_field &lt;- &quot;All fields&quot;
online_news_overall_overall &lt;- online_news_overall_overall[colnames(online_news_type)]

online_news_type &lt;- rbind(online_news_type,
                   online_news_overall_overall)

online_news_type &lt;- online_news_type %&gt;%
  arrange(general_field, name)%&gt;%
  select(general_field:sum_w, m_ave, w_ave, m_prop, w_prop)

colnames(online_news_type) &lt;- c(&quot;Field&quot;,
                         &quot;News type&quot;,
                         &quot;N professors - men&quot;,
                         &quot;N professors - women&quot;,
                         &quot;News mentions - men&quot;,
                         &quot;News mentions - women&quot;,
                         &quot;Avg. news mentions - men&quot;,
                         &quot;Avg. news mentions - women&quot;,
                         &quot;Share mentions per source - men&quot;,
                         &quot;Share mentions per source - women&quot;)

# output to results
write_csv(online_news_type, &quot;Plots_april/Supplemental/T_online_news_source.csv&quot;)
knitr::kable(online_news_type)</code></pre>
</div>
<div id="twitter-data" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Twitter data</h2>
<p>How many professors have at least one mention?</p>
<pre class="r"><code>sources_check$any_alt &lt;- ifelse(sources_check$alt_twitter &gt; 0, TRUE, FALSE)

table(sources_check$any_alt)
prop.table(table(sources_check$any_alt))</code></pre>
<p>78% of professors in our data - 5301 of them, has at least one news
mention.</p>
<p>On average, a professor in our dataset has accumulated 102.7 online
mentions throughout their career:</p>
<pre class="r"><code>mean(sources_check$alt_online_all_total, na.rm = TRUE)</code></pre>
<p>Or, 8.3 mentions per year:</p>
<pre class="r"><code>mean(prof_panel_filter$alt_online_all, na.rm = TRUE)</code></pre>
<pre class="r"><code>twitter_type_source &lt;- sources_check %&gt;%
  select(profile_id, general_field, entry_batch_2023, inferred_gender, alt_twitter_total)
#news_type$news_all_total &lt;- rowSums(news_type[, 5:9])
colnames(twitter_type_source) &lt;- str_remove(str_remove(str_remove(colnames(twitter_type_source), &quot;alt_&quot;), &quot;_total&quot;), &quot;lexis_&quot;)
colnames(twitter_type_source)[5] &lt;- c(&quot;Twitter&quot;)

twitter_type &lt;- twitter_type_source %&gt;%
  pivot_longer(cols = c(`Twitter`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field, inferred_gender)%&gt;%
  summarise(
    profs = n(),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  group_by(general_field)%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m),3),
         w_prop = round(sum_w/sum(sum_w), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

twitter_overall &lt;- twitter_type_source %&gt;%
  pivot_longer(cols = c(`Twitter`))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(inferred_gender)%&gt;%
  summarise(
    profs = n_distinct(profile_id),
    sum = sum(value, na.rm = TRUE))%&gt;%
  pivot_wider(names_from = inferred_gender, values_from = c(profs,sum))%&gt;%
  mutate(m_prop = round(sum_m/sum(sum_m),3),
         w_prop = round(sum_w/sum(sum_w), 3),
         m_ave = round(sum_m/profs_m, 3),
         w_ave = round(sum_w/profs_w, 3))

twitter_overall$general_field &lt;- &quot;All fields&quot;
twitter_overall &lt;- twitter_overall[colnames(twitter_type)]

twitter_type &lt;- rbind(twitter_type,
                   twitter_overall)

# output to results
write_csv(twitter_type, &quot;Plots_april/Supplemental/T_twitter.csv&quot;)
knitr::kable(twitter_type)</code></pre>
</div>
</div>
<div id="womens-representation-across-the-board" class="section level1"
number="2">
<h1><span class="header-section-number">2</span> Women’s representation
across the board</h1>
<p>First, get representation per field in our dataset: (?
professors)</p>
<pre class="r"><code>repr_field_2023 &lt;- prof_panel_filter %&gt;%
  group_by(profile_id)%&gt;%
  filter(year == max(year))%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field, inferred_gender)%&gt;%
  summarise(n = n())%&gt;%
  pivot_wider(values_from = n, names_from = inferred_gender)

repr_field_2023$share_women_field &lt;- repr_field_2023$w/(repr_field_2023$m+repr_field_2023$w)</code></pre>
<p>Now get the representation of women among the top 10% and 20% of
researchers in terms of total fame in their field in 2023 (based on
their entry batch):</p>
<pre class="r"><code># first, get the latest year in the panel for each prof
women_field_2023 &lt;- prof_panel_filter %&gt;%
  group_by(profile_id)%&gt;%
  filter(year == max(year))

# and now set the final year as 2023, assuming there was no attention after
# whatever the last year is in the dataset (quite some professors with
# 0 mentions even in this last year, so we want to keep them for correct
# shares)
women_field_2023$year &lt;- 2023

# get their decile based on their total performance within their entry batch
women_field_2023 &lt;- women_field_2023 %&gt;%
  filter(!is.na(general_field))%&gt;%
  select(profile_id, year, inferred_gender, general_field, entry_batch_2023, count_pubs_total,
         cited_by_total_all, alt_online_all_total, news_all_total, alt_twitter_total)%&gt;%
  replace(is.na(.), 0)%&gt;%
  group_by(general_field, entry_batch_2023)%&gt;%
  mutate(
         `Publications` = ntile(-count_pubs_total, 20),
         `Citations` = ntile(-cited_by_total_all, 20),    
         `Online news` = ntile(-alt_online_all_total, 20),
         `News` = ntile(-news_all_total, 20),
         `Twitter` = ntile(-alt_twitter_total, 20))</code></pre>
<div id="women-among-scientists-in-top-n" class="section level3"
number="2.0.1">
<h3><span class="header-section-number">2.0.1</span> % women among
scientists in top n%</h3>
<p>Get shares of women among top n% scientists per attention domain:</p>
<pre class="r"><code># rearrange the dataset to get counts of women and men in each decile
# then leave only top 10 and 20
share_women_field_2023 &lt;- women_field_2023 %&gt;%
  ungroup()%&gt;%
  select(profile_id, year, inferred_gender, general_field, `Publications`:`Twitter`)%&gt;%
  pivot_longer(`Publications`:`Twitter`)%&gt;%
  group_by(general_field, inferred_gender, name, value)%&gt;%
  summarise(n = n())%&gt;%
  pivot_wider(values_from = n, names_from = inferred_gender)%&gt;%
  group_by(general_field, name)%&gt;%
  mutate(m = cumsum(m),
         w = cumsum(w))%&gt;%
  filter(value %in% c(1, 2, 3, 4))
 
share_women_field_2023$share_women &lt;- share_women_field_2023$w/(share_women_field_2023$m+share_women_field_2023$w) </code></pre>
<p>Combine the field representation with the attention
representation:</p>
<pre class="r"><code>repr_field_2023$name &lt;- &quot;overall&quot;
repr_field_2023$value &lt;- 0

repr_field_2023 &lt;- repr_field_2023[c(colnames(share_women_field_2023)[1:5],&quot;share_women_field&quot;)]

share_women_field_2023 &lt;- merge(share_women_field_2023,
                                repr_field_2023[c(&quot;general_field&quot;, &quot;share_women_field&quot;)],
                                by = &quot;general_field&quot;)

share_women_field_2023$share_women_field &lt;- ifelse(share_women_field_2023$name == &quot;News&quot;,
                                                   share_women_field_2023$share_women_field,
                                                   NA)</code></pre>
<p>Plot this out:</p>
<p>Top 10%:</p>
<pre class="r"><code>repr_attn_5 &lt;- share_women_field_2023 %&gt;%
  filter(value == 1 &amp; name %in% c(&quot;News&quot;, &quot;Online news&quot;, &quot;Twitter&quot;))%&gt;%
  ggplot(aes(y=share_women, x=general_field)) + 
  geom_point(aes(shape=name, color=name), position=position_dodge(width=0.2), stat=&quot;identity&quot;, size = 2.5)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_women_field, x=general_field), alpha=0.2, width = 0.4)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
  scale_y_continuous(limits=c(0, 0.5))+
  coord_flip()+
  xlab(&quot;&quot;)+
  ylab(&quot;% Women&quot;)+
  labs(color = &quot;Attention type&quot;,
       shape = &quot;Attention type&quot;)+
  ggtitle(&quot;(a) top 5% of attention domains&quot;)+
  theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))

repr_attn_10 &lt;- share_women_field_2023 %&gt;%
  filter(value == 2 &amp; name %in% c(&quot;News&quot;, &quot;Online news&quot;, &quot;Twitter&quot;))%&gt;%
  ggplot(aes(y=share_women, x=general_field)) + 
  geom_point(aes(shape=name, color=name), position=position_dodge(width=0.2), stat=&quot;identity&quot;, size = 2.5)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_women_field, x=general_field), alpha=0.2, width = 0.4)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
  scale_y_continuous(limits=c(0, 0.5))+
  coord_flip()+
  xlab(&quot;&quot;)+
  ylab(&quot;% Women&quot;)+
  labs(color = &quot;Attention type&quot;,
       shape = &quot;Attention type&quot;)+
  ggtitle(&quot;(b) top 10% of attention domains&quot;)+
  theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))

repr_attn_15 &lt;- share_women_field_2023 %&gt;%
  filter(value == 3 &amp; name %in% c(&quot;News&quot;, &quot;Online news&quot;, &quot;Twitter&quot;))%&gt;%
  ggplot(aes(y=share_women, x=general_field)) + 
    geom_point(aes(shape=name, color=name), position=position_dodge(width=0.2), stat=&quot;identity&quot;, size = 2.5)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_women_field, x=general_field), alpha=0.2, width = 0.4)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
  scale_y_continuous(limits=c(0, 0.5))+
  coord_flip()+
  xlab(&quot;&quot;)+
  ylab(&quot;% Women&quot;)+
  labs(color = &quot;Attention type&quot;,
       shape = &quot;Attention type&quot;)+
  ggtitle(&quot;(c) top 15% of attention domains&quot;)+
  theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))

repr_attn_20 &lt;- share_women_field_2023 %&gt;%
  filter(value == 4 &amp; name %in% c(&quot;News&quot;, &quot;Online news&quot;, &quot;Twitter&quot;))%&gt;%
  ggplot(aes(y=share_women, x=general_field)) + 
    geom_point(aes(shape=name, color=name), position=position_dodge(width=0.2), stat=&quot;identity&quot;, size = 2.5)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_women_field, x=general_field), alpha=0.2, width = 0.4)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
  scale_y_continuous(limits=c(0, 0.5))+
  coord_flip()+
  xlab(&quot;&quot;)+
  ylab(&quot;% Women&quot;)+
  labs(color = &quot;Attention type&quot;,
       shape = &quot;Attention type&quot;)+
  ggtitle(&quot;(d) top 20% of attention domains&quot;)+
  theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))</code></pre>
<p>Plot these two next to each other:</p>
<pre class="r"><code>legend &lt;- get_legend(
  # create some space to the left of the legend
  repr_attn_10
)

combi_plot &lt;- cowplot::plot_grid(
                    repr_attn_10 + theme(legend.position=&quot;none&quot;) + ggtitle(&quot;(a) top 10% of attention domains&quot;),
                    repr_attn_20 + theme(legend.position=&quot;none&quot;,
                                        axis.title.y=element_blank(),
                                        axis.text.y=element_blank())+ggtitle(&quot;(b) top 20% of attention domains&quot;),
                    legend,
                    ncol = 3,
                    rel_widths = c(1, 0.8, 0.22))


ggsave2(
  filename = &quot;Plots_april/Plot_1.png&quot;,
  plot = combi_plot,
  width = 10,
  height = 4,
  units = c(&quot;in&quot;),
  dpi = 300,
  bg = &quot;white&quot;
)

combi_plot</code></pre>
</div>
</div>
<div id="compare-means-and-distributions" class="section level1"
number="3">
<h1><span class="header-section-number">3</span> Compare means and
distributions</h1>
<div id="means-comparison" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Means comparison</h2>
<pre class="r"><code>sources_check &lt;- sources_check%&gt;%
  filter(!is.na(general_field))</code></pre>
<div id="overall" class="section level3" number="3.1.1">
<h3><span class="header-section-number">3.1.1</span> Overall</h3>
<pre class="r"><code>overall_comparisons &lt;- data.frame(matrix(NA, ncol = 6, nrow = 1))
i &lt;- 1
overall_comparisons[i, 1] &lt;- &quot;overall&quot;
overall_comparisons[i, 2] &lt;- round(wilcox.test(count_pubs_total ~ inferred_gender, data=sources_check, paired=FALSE)$p.value, 5)
overall_comparisons[i, 3] &lt;- round(wilcox.test(cited_by_total_all ~ inferred_gender, data=sources_check, paired=FALSE)$p.value, 5)
overall_comparisons[i, 4] &lt;- round(wilcox.test(news_all_total ~ inferred_gender, data=sources_check, paired=FALSE)$p.value, 5)
overall_comparisons[i, 5] &lt;- round(wilcox.test(alt_online_all_total ~ inferred_gender, data=sources_check, paired=FALSE)$p.value, 5)
overall_comparisons[i, 6] &lt;- round(wilcox.test(alt_twitter_total ~ inferred_gender, data=sources_check, paired=FALSE)$p.value, 5)

colnames(overall_comparisons) &lt;-  c(&quot;field&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)


overall_comparisons

mean_values &lt;- sources_check %&gt;%
  group_by(inferred_gender)%&gt;%
  summarise(pubs_total = mean(count_pubs_total, na.rm = TRUE),
            citations_total = mean(cited_by_total_all, na.rm = TRUE),
            news_total = mean(news_all_total, na.rm = TRUE),
            online_news_total = mean(alt_online_all_total, na.rm = TRUE),
            twitter_total =  mean(alt_twitter_total, na.rm = TRUE))%&gt;%
  mutate(across(2:6, \(x) round(x, 1)))

mean_values
overall_comparisons</code></pre>
</div>
<div id="within-fields" class="section level3" number="3.1.2">
<h3><span class="header-section-number">3.1.2</span> Within fields</h3>
<pre class="r"><code>fields &lt;- unique(prof_panel_filter$general_field)
fields &lt;- fields[!is.na(fields)]
field_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(fields)))

for (i in 1:length(fields)){
  field &lt;- fields[i]
  data &lt;- filter(sources_check, 
                 general_field == field)
  field_comparisons[i, 1] &lt;- field
  field_comparisons[i, 2] &lt;- nrow(data)
  field_comparisons[i, 3] &lt;- round(wilcox.test(count_pubs_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 4] &lt;- round(wilcox.test(cited_by_total_all ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 5] &lt;- round(wilcox.test(news_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 6] &lt;- round(wilcox.test(alt_online_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 7] &lt;- round(wilcox.test(alt_twitter_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
}

colnames(field_comparisons) &lt;- c(&quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
field_comparisons</code></pre>
</div>
<div id="within-year-groups" class="section level3" number="3.1.3">
<h3><span class="header-section-number">3.1.3</span> Within year
groups</h3>
<pre class="r"><code>year_groups &lt;- unique(sources_check$entry_batch_2023)
year_groups &lt;- year_groups[! year_groups == &quot;up to NA&quot;]
years &lt;- c(&quot;up to 10&quot;,&quot;up to 20&quot;, &quot;up to 30&quot;, &quot;up to 40&quot;, &quot;up to 50&quot;)
year_groups &lt;- year_groups[order(match(year_groups,years))]
year_groups_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(year_groups)))

for (i in 1:length(year_groups)){
  year_group &lt;- year_groups[i]
  data &lt;- filter(sources_check, 
                 entry_batch_2023 == year_group)
  
  year_groups_comparisons[i, 1] &lt;- year_group
  year_groups_comparisons[i, 2] &lt;- nrow(data)
  year_groups_comparisons[i, 3] &lt;- round(wilcox.test(count_pubs_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 4] &lt;- round(wilcox.test(cited_by_total_all ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 5] &lt;- round(wilcox.test(news_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 6] &lt;- round(wilcox.test(alt_online_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 7] &lt;- round(wilcox.test(alt_twitter_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
}

colnames(year_groups_comparisons) &lt;- c(&quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
year_groups_comparisons</code></pre>
</div>
<div id="within-year-groups-and-fields" class="section level3"
number="3.1.4">
<h3><span class="header-section-number">3.1.4</span> Within year groups
and fields</h3>
<pre class="r"><code>year_groups_field_comparisons &lt;- data.frame(matrix(NA, ncol = 8, nrow = length(year_groups)*length(fields)))
row_index &lt;- 0

for (i in 1:length(year_groups)){
  year_group &lt;- year_groups[i]
  
  for (j in 1:length(fields)){
    field &lt;- fields[j]
    data &lt;- filter(sources_check, 
                   years_since_entry == year_group &amp; general_field == field)
    
    women &lt;- filter(data, inferred_gender == &quot;w&quot;)
    men &lt;- filter(data, inferred_gender == &quot;m&quot;)
    
    if (length(unique(data$inferred_gender)) != 2){
      year_groups_field_comparisons[row_index+j, 1] &lt;- year_group
      year_groups_field_comparisons[row_index+j, 2] &lt;- field
      year_groups_field_comparisons[row_index+j, 3] &lt;- nrow(data)
      year_groups_field_comparisons[row_index+j, 4] &lt;- NA
      year_groups_field_comparisons[row_index+j, 5] &lt;- NA
      year_groups_field_comparisons[row_index+j, 6] &lt;- NA
      year_groups_field_comparisons[row_index+j, 7] &lt;- NA
      year_groups_field_comparisons[row_index+j, 8] &lt;- NA
    }else{
      if (length(which(colSums(data[c(&quot;alt_online_all_total&quot;, &quot;news_all_total&quot;, &quot;alt_twitter_total&quot;, &quot;cited_by_total_all&quot;, &quot;count_pubs_total&quot;)]) == 0)) &gt; 0){
        year_groups_field_comparisons[row_index+j, 1] &lt;- year_group
        year_groups_field_comparisons[row_index+j, 2] &lt;- field
        year_groups_field_comparisons[row_index+j, 3] &lt;- nrow(data)
        year_groups_field_comparisons[row_index+j, 4] &lt;- NA
        year_groups_field_comparisons[row_index+j, 5] &lt;- NA
        year_groups_field_comparisons[row_index+j, 6] &lt;- NA
        year_groups_field_comparisons[row_index+j, 7] &lt;- NA
        year_groups_field_comparisons[row_index+j, 8] &lt;- NA
        
      }else{
        year_groups_field_comparisons[row_index+j, 1] &lt;- year_group
        year_groups_field_comparisons[row_index+j, 2] &lt;- field
        year_groups_field_comparisons[row_index+j, 3] &lt;- nrow(data)
        year_groups_field_comparisons[row_index+j, 4] &lt;- round(wilcox.test(count_pubs_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
        year_groups_field_comparisons[row_index+j, 5] &lt;- round(wilcox.test(cited_by_total_all ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
        year_groups_field_comparisons[row_index+j, 6] &lt;- round(wilcox.test(news_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
        year_groups_field_comparisons[row_index+j, 7] &lt;- round(wilcox.test(alt_online_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
        year_groups_field_comparisons[row_index+j, 8] &lt;- round(wilcox.test(alt_twitter_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
      }
    }
  }
  row_index &lt;- row_index + 4 
}

colnames(year_groups_field_comparisons) &lt;- c(&quot;year_group&quot;, &quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                       &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
year_groups_field_comparisons</code></pre>
</div>
<div id="writing-this-out" class="section level3" number="3.1.5">
<h3><span class="header-section-number">3.1.5</span> Writing this
out</h3>
<pre class="r"><code>write_csv(overall_comparisons, &quot;Plots_april/Supplemental/mean_overall.csv&quot;)
write_csv(field_comparisons, &quot;Plots_april/Supplemental/mean_year.csv&quot;)
write_csv(field_comparisons, &quot;Plots_april/Supplemental/mean_field.csv&quot;)
write_csv(year_groups_field_comparisons, &quot;Plots_april/Supplemental/mean_year_field.csv&quot;)</code></pre>
</div>
</div>
<div id="distributions-comparison" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Distributions
comparison</h2>
<div id="overall-1" class="section level3" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span> Overall</h3>
<pre class="r"><code>overall_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = 1))
i &lt;- 1
women &lt;- filter(sources_check, inferred_gender == &quot;w&quot;)
men &lt;- filter(sources_check, inferred_gender == &quot;m&quot;)

overall_dist_comparisons[i, 1] &lt;- &quot;overall&quot;
overall_dist_comparisons[i, 2] &lt;- nrow(prof_panel_filter)
overall_dist_comparisons[i, 3] &lt;- round(ks.test(women$count_pubs_total, men$count_pubs_total)$p.value, 5)
overall_dist_comparisons[i, 4] &lt;- round(ks.test(women$cited_by_total_all, men$cited_by_total_all)$p.value, 5)
overall_dist_comparisons[i, 5] &lt;- round(ks.test(women$news_all_total, men$news_all_total)$p.value, 5)
overall_dist_comparisons[i, 6] &lt;- round(ks.test(women$alt_online_all_total, men$alt_online_all_total)$p.value, 5)
overall_dist_comparisons[i, 7] &lt;- round(ks.test(women$alt_twitter_total, men$alt_twitter_total)$p.value, 5)

colnames(overall_dist_comparisons) &lt;- c(&quot;overall&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)


overall_dist_comparisons</code></pre>
</div>
<div id="within-fields-1" class="section level3" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span> Within fields</h3>
<pre class="r"><code>fields &lt;- unique(sources_check$general_field)
fields &lt;- fields[!is.na(fields)]
field_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(fields)))

for (i in 1:length(fields)){
  field &lt;- fields[i]
  data &lt;- filter(sources_check, 
                 general_field == field)
  women &lt;- filter(data, inferred_gender == &quot;w&quot;)
  men &lt;- filter(data, inferred_gender == &quot;m&quot;)
  
  field_dist_comparisons[i, 1] &lt;- field
  field_dist_comparisons[i, 2] &lt;- nrow(data)
  field_dist_comparisons[i, 3] &lt;- round(ks.test(women$count_pubs_total, men$count_pubs_total)$p.value, 5)
  field_dist_comparisons[i, 4] &lt;- round(ks.test(women$cited_by_total_all, men$cited_by_total_all)$p.value, 5)
  field_dist_comparisons[i, 5] &lt;- round(ks.test(women$news_all_total, men$news_all_total)$p.value, 5)
  field_dist_comparisons[i, 6] &lt;- round(ks.test(women$alt_online_all_total, men$alt_online_all_total)$p.value, 5)
  field_dist_comparisons[i, 7] &lt;- round(ks.test(women$alt_twitter_total, men$alt_twitter_total)$p.value, 5)
}

colnames(field_dist_comparisons) &lt;- c(&quot;field&quot;,&quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
field_dist_comparisons</code></pre>
</div>
<div id="within-year-groups-1" class="section level3" number="3.2.3">
<h3><span class="header-section-number">3.2.3</span> Within year
groups</h3>
<pre class="r"><code>year_groups &lt;- unique(prof_panel_filter$entry_batch_2023)
year_groups &lt;- year_groups[! year_groups == &quot;up to NA&quot;]
years &lt;- c(&quot;up to 10&quot;,&quot;up to 20&quot;, &quot;up to 30&quot;, &quot;up to 40&quot;, &quot;up to 50&quot;)
year_groups &lt;- year_groups[order(match(year_groups,years))]
year_groups_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(year_groups)))

for (i in 1:length(year_groups)){
  year_group &lt;- year_groups[i]
  data &lt;- filter(sources_check, 
                 years_since_entry == year_group)
  
  women &lt;- filter(data, inferred_gender == &quot;w&quot;)
  men &lt;- filter(data, inferred_gender == &quot;m&quot;)
  
  year_groups_dist_comparisons[i, 1] &lt;- year_group
  year_groups_dist_comparisons[i, 2] &lt;- nrow(data)
  year_groups_dist_comparisons[i, 3] &lt;- round(ks.test(women$count_pubs_total, men$count_pubs_total)$p.value, 5)
  year_groups_dist_comparisons[i, 4] &lt;- round(ks.test(women$cited_by_total_all, men$cited_by_total_all)$p.value, 5)
  year_groups_dist_comparisons[i, 5] &lt;- round(ks.test(women$news_all_total, men$news_all_total)$p.value, 5)
  year_groups_dist_comparisons[i, 6] &lt;- round(ks.test(women$alt_online_all_total, men$alt_online_all_total)$p.value, 5)
  year_groups_dist_comparisons[i, 7] &lt;- round(ks.test(women$alt_twitter_total, men$alt_twitter_total)$p.value, 5)
}

colnames(year_groups_dist_comparisons) &lt;- c(&quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
year_groups_dist_comparisons</code></pre>
</div>
<div id="within-year-groups-and-fields-1" class="section level3"
number="3.2.4">
<h3><span class="header-section-number">3.2.4</span> Within year groups
and fields</h3>
<pre class="r"><code>year_groups_field_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 8, nrow = length(year_groups)*length(fields)))
row_index &lt;- 0

for (i in 1:length(year_groups)){
  year_group &lt;- year_groups[i]
  
  for (j in 1:length(fields)){
    field &lt;- fields[j]
    data &lt;- filter(sources_check, 
                   years_since_entry == year_group &amp; general_field == field)
    
    women &lt;- filter(data, inferred_gender == &quot;w&quot;)
    men &lt;- filter(data, inferred_gender == &quot;m&quot;)
    
    if (length(unique(data$inferred_gender)) != 2){
      year_groups_field_dist_comparisons[row_index+j, 1] &lt;- year_group
      year_groups_field_dist_comparisons[row_index+j, 2] &lt;- field
      year_groups_field_dist_comparisons[row_index+j, 3] &lt;- nrow(data)
      year_groups_field_dist_comparisons[row_index+j, 4] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 5] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 6] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 7] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 8] &lt;- NA
    }else{
      if (length(which(colSums(data[c(&quot;alt_online_all_total&quot;, &quot;news_all_total&quot;, &quot;alt_twitter_total&quot;, &quot;cited_by_total_all&quot;, &quot;count_pubs_total&quot;)]) == 0)) &gt; 0){
        year_groups_field_dist_comparisons[row_index+j, 1] &lt;- year_group
        year_groups_field_dist_comparisons[row_index+j, 2] &lt;- field
        year_groups_field_dist_comparisons[row_index+j, 3] &lt;- nrow(data)
        year_groups_field_dist_comparisons[row_index+j, 4] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 5] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 6] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 7] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 8] &lt;- NA
        
      }else{
        year_groups_field_dist_comparisons[row_index+j, 1] &lt;- year_group
        year_groups_field_dist_comparisons[row_index+j, 2] &lt;- field
        year_groups_field_dist_comparisons[row_index+j, 3] &lt;- nrow(data)
        year_groups_field_dist_comparisons[row_index+j, 4] &lt;- round(ks.test(women$count_pubs_total, men$count_pubs_total)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 5] &lt;- round(ks.test(women$cited_by_total_all, men$cited_by_total_all)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 6] &lt;- round(ks.test(women$news_all_total, men$news_all_total)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 7] &lt;- round(ks.test(women$alt_online_all_total, men$alt_online_all_total)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 8] &lt;- round(ks.test(women$alt_twitter_total, men$alt_twitter_total)$p.value, 5)
      }
    }
  }
  row_index &lt;- row_index + 4 
}

colnames(year_groups_field_dist_comparisons) &lt;- c(&quot;year_group&quot;, &quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                       &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
year_groups_field_dist_comparisons</code></pre>
</div>
<div id="writing-this-out-1" class="section level3" number="3.2.5">
<h3><span class="header-section-number">3.2.5</span> Writing this
out</h3>
<pre class="r"><code>write_csv(overall_dist_comparisons, &quot;Plots_april/Supplemental/dist_overall.csv&quot;)
write_csv(field_dist_comparisons, &quot;Plots_april/Supplemental/dist_year.csv&quot;)
write_csv(field_dist_comparisons, &quot;Plots_april/Supplemental/dist_field.csv&quot;)
write_csv(year_groups_field_dist_comparisons, &quot;Plots_april/Supplemental/dist_year_field.csv&quot;)</code></pre>
</div>
</div>
</div>
<div id="regression-models" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Regression models</h1>
<p>Binary variables for any attention:</p>
<pre class="r"><code>prof_panel_filter$any_news &lt;- as.factor(ifelse(prof_panel_filter$news_all &gt; 0, 1, 0))
prof_panel_filter$any_news_l &lt;- as.factor(ifelse(prof_panel_filter$news_all_l &gt; 0, 1, 0))

prof_panel_filter$any_online_news &lt;- as.factor(ifelse(prof_panel_filter$alt_online_all &gt; 0, 1, 0))
prof_panel_filter$any_online_news_l &lt;- as.factor(ifelse(prof_panel_filter$alt_online_all_l &gt; 0, 1, 0))

prof_panel_filter$any_online_news_gen &lt;- as.factor(ifelse(prof_panel_filter$alt_online_general_all &gt; 0, 1, 0))
prof_panel_filter$any_online_news_gen_l &lt;- as.factor(ifelse(prof_panel_filter$alt_online_general_all_l &gt; 0, 1, 0))

prof_panel_filter$any_online_news_name &lt;- as.factor(ifelse(prof_panel_filter$alt_online_name_all &gt; 0, 1, 0))
prof_panel_filter$any_online_news_name_l &lt;- as.factor(ifelse(prof_panel_filter$alt_online_name_all_l &gt; 0, 1, 0))

prof_panel_filter$any_twitter &lt;- as.factor(ifelse(prof_panel_filter$alt_twitter &gt; 0, 1, 0))
prof_panel_filter$any_twitter_l &lt;- as.factor(ifelse(prof_panel_filter$alt_twitter_l &gt; 0, 1, 0))</code></pre>
<p>Binary variables for belonging to the top 10/20% in the attention for
each source.</p>
<pre class="r"><code>panel_filter_long &lt;- prof_panel_filter %&gt;%
  pivot_longer(c(alt_online_all, alt_online_name_all, news_all, alt_twitter), names_to = &quot;measure&quot;, values_to = &quot;value&quot;)

top_10_attn &lt;- panel_filter_long %&gt;%
  filter(!is.na(general_field) &amp; !is.na(year) &amp; year &gt; 2011)%&gt;%
  group_by(general_field, year, measure)%&gt;%
  filter(quantile(value, 0.90, na.rm = TRUE)&lt;value)%&gt;%
  select(profile_id, general_field, year, measure, value)

top_10_attn$measure &lt;- paste0(top_10_attn$measure, &quot;_top_10&quot;)


top_10_attn &lt;- top_10_attn %&gt;%
  pivot_wider(names_from = &quot;measure&quot;)%&gt;%
  mutate(across(contains(&#39;top_10&#39;),  ~ifelse(is.na(.), 0, 1)))

prof_panel_filter &lt;- merge(prof_panel_filter,
                           top_10_attn[c(&quot;year&quot;, &quot;profile_id&quot;, &quot;general_field&quot;, &quot;alt_online_all_top_10&quot;, &quot;alt_online_name_all_top_10&quot;, &quot;alt_twitter_top_10&quot;, &quot;news_all_top_10&quot;)],
                           by = c(&quot;profile_id&quot;, &quot;year&quot;, &quot;general_field&quot;),
                           all.x = TRUE,
                           all.y = FALSE)

top_20_attn &lt;- panel_filter_long %&gt;%
  filter(!is.na(general_field) &amp; !is.na(year) &amp; year &gt; 2011)%&gt;%
  group_by(general_field, year, measure)%&gt;%
  filter(quantile(value, 0.80, na.rm = TRUE)&lt;value)%&gt;%
  select(profile_id, general_field, year, measure, value)

top_20_attn$measure &lt;- paste0(top_20_attn$measure, &quot;_top_20&quot;)


top_20_attn &lt;- top_20_attn %&gt;%
  pivot_wider(names_from = &quot;measure&quot;)%&gt;%
  mutate(across(contains(&#39;top_20&#39;),  ~ifelse(is.na(.), 0, 1)))

prof_panel_filter &lt;- merge(prof_panel_filter,
                           top_20_attn[c(&quot;year&quot;, &quot;profile_id&quot;, &quot;general_field&quot;, &quot;alt_online_all_top_20&quot;, &quot;alt_online_name_all_top_20&quot;, &quot;alt_twitter_top_20&quot;, &quot;news_all_top_20&quot;)],
                           by = c(&quot;profile_id&quot;, &quot;year&quot;, &quot;general_field&quot;),
                           all.x = TRUE,
                           all.y = FALSE)

prof_panel_filter &lt;- filter(prof_panel_filter, !is.na(general_field))</code></pre>
<p>Split datasets per field:</p>
<pre class="r"><code>stem &lt;- filter(prof_panel_filter, general_field == &quot;STEM&quot;)
soc_sci &lt;- filter(prof_panel_filter, general_field == &quot;Social sciences&quot;)
arts &lt;- filter(prof_panel_filter, general_field == &quot;Arts &amp; Humanities&quot;)
medicine &lt;- filter(prof_panel_filter, general_field == &quot;Medicine&quot;)</code></pre>
<div id="count-models" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Count models</h2>
<div id="news" class="section level3" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> News</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_predictions_news &lt;- data.frame(matrix(ncol = 7, nrow = 0))
all_models_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_comparisons_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- lm(news_all ~ # professor publication variables
                     news_all_l + 
                     cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     alt_online_all_total_l + alt_twitter_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset) 
  
  model_result &lt;- coeftest(news_model, vcov = vcovCL, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(summary(news_model)$r.squared,3)
  model_result$field &lt;- field
  
  all_models_news &lt;- rbind(all_models_news,
                      model_result)
  
  prediction &lt;- predict_response(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;, 
                                 vcov_type = &quot;HC0&quot;,
                                 vcov.args = list(cluster = field_dataset$profile_id))
  prediction$field &lt;- field
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_comparisons_news &lt;- rbind(all_comparisons_news,
                           gender_comparison)
  
  all_predictions_news &lt;- rbind(all_predictions_news,
                           prediction)
  
  
}

all_models_news$stars &lt;- ifelse(all_models_news$`Pr(&gt;|t|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_models_news$`Pr(&gt;|t|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_models_news$`Pr(&gt;|t|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_models_news$`Pr(&gt;|t|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_comparisons_news$stars &lt;- ifelse(all_comparisons_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_comparisons_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_comparisons_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_comparisons_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_comparisons_news$group1 &lt;- str_split_i(all_comparisons_news$inferred_gender, &quot;-&quot;, 1)
all_comparisons_news$group2 &lt;- str_split_i(all_comparisons_news$inferred_gender, &quot;-&quot;, 2)

all_comparisons_news$p_rounded &lt;- round(all_comparisons_news$p.value, 4)</code></pre>
<p>Plot gender differences:</p>
<pre class="r"><code>news_gender_plot &lt;- all_predictions_news %&gt;%
   ggplot(aes(x = fct_rev(field),
              y = predicted,
              ymin = conf.low,
              ymax = conf.high,
              color = x)) +
   geom_pointrange(position = position_dodge(width = 0.5),
                   size = 0.5)+
   ggtitle(&quot;(a) Predicted values of news attention&quot;)+
     stat_pvalue_manual(
    all_comparisons_news,
    y.position = c(4.6, 4.6, 4, 4),
    label.size = 3,
    label = &quot;{stars}&quot;,
    remove.bracket = FALSE,
    bracket.nudge.y = -2,
    x = &quot;field&quot;
    )+
    xlab(&quot;Field&quot;)+
   scale_x_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp; Humanities&quot;,
                             &quot;medicine&quot; = &quot;Medicine&quot;,
                             &quot;soc_sci&quot; = &quot;Social science&quot;,
                             &quot;stem&quot; = &quot;STEM&quot;))+
   ylab(&quot;News attention per year&quot;)+
   labs(color = &quot;Inferred gender&quot;)+
   scale_color_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;), labels = c(&quot;Man&quot;, &quot;Woman&quot;))+
   theme_minimal_hgrid()+
   theme(plot.title = element_text(size = 8),
         axis.text.y = element_text(size = 8),
         axis.title.y = element_text(size = 10),
         axis.text.x = element_text(size = 8) ,
         axis.title.x = element_text(size = 10),
         legend.title=element_text(size=8), 
         legend.text=element_text(size=7))</code></pre>
<pre class="r"><code>knitr::kable(all_models_news)</code></pre>
</div>
<div id="online-news" class="section level3" number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> Online News</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_predictions_online_news &lt;- data.frame(matrix(ncol = 7, nrow = 0))
all_models_online_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_comparisons_online_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- lm(alt_online_all ~ # professor publication variables
                         alt_online_all_l+
                         cited_by_total_all_l + 
                         # gender
                         inferred_gender  +
                         # attention variables
                         news_all_total_l + alt_twitter_total_l +
                         # coauthor publication variables
                         coa_tot_cited_by_total_l +
                         # coauthor publication variables
                         coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset) 
  
  model_result &lt;- coeftest(news_model, vcov = vcovCL, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(summary(news_model)$r.squared,3)
  model_result$field &lt;- field
  
  all_models_online_news &lt;- rbind(all_models_online_news,
                      model_result)
  
  prediction &lt;- predict_response(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;, 
                                 vcov_type = &quot;HC0&quot;,
                                 vcov.args = list(cluster = field_dataset$profile_id))
  prediction$field &lt;- field
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_comparisons_online_news &lt;- rbind(all_comparisons_online_news,
                           gender_comparison)
  
  all_predictions_online_news &lt;- rbind(all_predictions_online_news,
                           prediction)
  
  
}

all_models_online_news$stars &lt;- ifelse(all_models_online_news$`Pr(&gt;|t|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_models_online_news$`Pr(&gt;|t|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_models_online_news$`Pr(&gt;|t|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_models_online_news$`Pr(&gt;|t|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_comparisons_online_news$stars &lt;- ifelse(all_comparisons_online_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_comparisons_online_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_comparisons_online_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_comparisons_online_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_comparisons_online_news$group1 &lt;- str_split_i(all_comparisons_online_news$inferred_gender, &quot;-&quot;, 1)
all_comparisons_online_news$group2 &lt;- str_split_i(all_comparisons_online_news$inferred_gender, &quot;-&quot;, 2)

all_comparisons_online_news$p_rounded &lt;- round(all_comparisons_online_news$p.value, 4)</code></pre>
<p>Plot gender differences:</p>
<pre class="r"><code>online_news_gender_plot &lt;- all_predictions_online_news %&gt;%
   ggplot(aes(x = fct_rev(field),
              y = predicted,
              ymin = conf.low,
              ymax = conf.high,
              color = x)) +
   geom_pointrange(position = position_dodge(width = 0.5),
                   size = 0.5)+
   #ylim(2, 5.5)+
   ggtitle(&quot;(b) Predicted values of online news attention&quot;)+
     stat_pvalue_manual(
    all_comparisons_online_news,
    y.position = c(7, 7, 4, 4),
    label.size = 3,
    label = &quot;{stars}&quot;,
    remove.bracket = FALSE,
    bracket.nudge.y = -2,
    x = &quot;field&quot;
    )+
    xlab(&quot;Field&quot;)+
   scale_x_discrete()+
   scale_x_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp; Humanities&quot;,
                             &quot;medicine&quot; = &quot;Medicine&quot;,
                             &quot;soc_sci&quot; = &quot;Social science&quot;,
                             &quot;stem&quot; = &quot;STEM&quot;))+
   ylab(&quot;Online news attention per year&quot;)+
   labs(color = &quot;Inferred gender&quot;)+
   scale_color_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;), labels = c(&quot;Man&quot;, &quot;Woman&quot;))+
   theme_minimal_hgrid()+
   theme(plot.title = element_text(size = 8),
         axis.text.y = element_text(size = 8),
         axis.title.y = element_text(size = 10),
         axis.text.x = element_text(size = 8) ,
         axis.title.x = element_text(size = 10),
         legend.title=element_text(size=8), 
         legend.text=element_text(size=7))</code></pre>
<pre class="r"><code>knitr::kable(all_models_online_news)</code></pre>
</div>
<div id="twitter" class="section level3" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> Twitter</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_predictions_twitter &lt;- data.frame(matrix(ncol = 7, nrow = 0))
all_models_twitter &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_comparisons_twitter &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- lm(alt_twitter ~ # professor publication variables
                     alt_twitter_l + 
                     count_pubs_total_l + cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     news_all_total_l +
                     alt_online_all_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset) 
  
  model_result &lt;- coeftest(news_model, vcov = vcovCL, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(summary(news_model)$r.squared,3)
  model_result$field &lt;- field
  
  all_models_twitter &lt;- rbind(all_models_twitter,
                      model_result)
  
  prediction &lt;- predict_response(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;, 
                                 vcov_type = &quot;HC0&quot;,
                                 vcov.args = list(cluster = field_dataset$profile_id))
  prediction$field &lt;- field
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_comparisons_twitter &lt;- rbind(all_comparisons_twitter,
                           gender_comparison)
  
  all_predictions_twitter &lt;- rbind(all_predictions_twitter,
                           prediction)
  
  
}

all_models_twitter$stars &lt;- ifelse(all_models_twitter$`Pr(&gt;|t|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_models_twitter$`Pr(&gt;|t|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_models_twitter$`Pr(&gt;|t|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_models_twitter$`Pr(&gt;|t|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_comparisons_twitter$stars &lt;- ifelse(all_comparisons_twitter$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_comparisons_twitter$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_comparisons_twitter$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_comparisons_twitter$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_comparisons_twitter$group1 &lt;- str_split_i(all_comparisons_twitter$inferred_gender, &quot;-&quot;, 1)
all_comparisons_twitter$group2 &lt;- str_split_i(all_comparisons_twitter$inferred_gender, &quot;-&quot;, 2)

all_comparisons_twitter$p_rounded &lt;- round(all_comparisons_twitter$p.value, 4)</code></pre>
<p>Plot gender differences:</p>
<pre class="r"><code>twitter_gender_plot &lt;- all_predictions_twitter %&gt;%
   ggplot(aes(x = fct_rev(field),
              y = predicted,
              ymin = conf.low,
              ymax = conf.high,
              color = x)) +
   geom_pointrange(position = position_dodge(width = 0.5),
                   size = 0.5)+
   #ylim(2, 5.5)+
   ggtitle(&quot;(c) Predicted values of Twitter attention&quot;)+
     stat_pvalue_manual(
    all_comparisons_twitter,
    y.position = c(0, 26, 0, 10),
    label.size = 3,
    label = &quot;{stars}&quot;,
    remove.bracket = FALSE,
    bracket.nudge.y = -2,
    x = &quot;field&quot;
    )+
    xlab(&quot;Field&quot;)+
   scale_x_discrete()+
   scale_x_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp; Humanities&quot;,
                             &quot;medicine&quot; = &quot;Medicine&quot;,
                             &quot;soc_sci&quot; = &quot;Social science&quot;,
                             &quot;stem&quot; = &quot;STEM&quot;))+
   ylab(&quot;News attention per year&quot;)+
   labs(color = &quot;Inferred gender&quot;)+
   scale_color_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;), labels = c(&quot;Man&quot;, &quot;Woman&quot;))+
   theme_minimal_hgrid()+
   theme(plot.title = element_text(size = 8),
         axis.text.y = element_text(size = 8),
         axis.title.y = element_text(size = 10),
         axis.text.x = element_text(size = 8) ,
         axis.title.x = element_text(size = 10),
         legend.title=element_text(size=8), 
         legend.text=element_text(size=7))</code></pre>
<pre class="r"><code>knitr::kable(all_models_twitter)</code></pre>
</div>
<div id="write-out-the-models" class="section level3" number="4.1.4">
<h3><span class="header-section-number">4.1.4</span> Write out the
models</h3>
<pre class="r"><code>write_csv(all_models_news, &quot;Plots_april/reg_mod_ols_news.csv&quot;)
write_csv(all_models_online_news, &quot;Plots_april/reg_mod_ols_online_news.csv&quot;)
write_csv(all_models_twitter, &quot;Plots_april/reg_mod_ols_twitter.csv&quot;)</code></pre>
</div>
<div id="combine-the-plots" class="section level3" number="4.1.5">
<h3><span class="header-section-number">4.1.5</span> Combine the
plots</h3>
<p>Plot it all together:</p>
<pre class="r"><code>legend &lt;- get_legend(
  # create some space to the left of the legend
  news_gender_plot
)

combi_plot &lt;- cowplot::plot_grid(news_gender_plot + theme(legend.position=&quot;none&quot;), 
                    online_news_gender_plot + theme(legend.position=&quot;none&quot;),
                    twitter_gender_plot + theme(legend.position=&quot;none&quot;),
                    legend,
                    ncol = 4,
                    rel_widths = c(1, 1, 1, 0.3))

combi_plot
ggsave2(
  filename = &quot;Plots_april/Plot_2_counts.png&quot;,
  plot = combi_plot,
  width = 11,
  height = 3,
  units = c(&quot;in&quot;),
  dpi = 600,
  bg = &quot;white&quot;
)</code></pre>
</div>
</div>
<div id="count-models---poisson" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Count models -
Poisson</h2>
<div id="news-1" class="section level3" number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> News</h3>
<p>Check how many zeroes do we have:</p>
<pre class="r"><code>100*sum(prof_panel_filter$news == 0)/nrow(prof_panel_filter)</code></pre>
<p>Almost 70%!</p>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_count_predictions_news &lt;- data.frame(matrix(ncol = 7, nrow = 0))
all_count_models_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_count_comparisons_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(news_all ~ # professor publication variables
                     news_all_l + 
                     cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     alt_online_all_total_l + alt_twitter_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;poisson&#39;) 
  
  model_result &lt;- coeftest(news_model, vcov = vcovCL, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  # model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  # model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(summary(news_model)$r.squared,3)
  model_result$field &lt;- field
  
  all_count_models_news &lt;- rbind(all_count_models_news,
                      model_result)
  
  prediction &lt;- predict_response(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;, 
                                 vcov_type = &quot;HC0&quot;,
                                 vcov.args = list(cluster = field_dataset$profile_id))
  prediction$field &lt;- field
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_count_comparisons_news &lt;- rbind(all_count_comparisons_news,
                           gender_comparison)
  
  all_count_predictions_news &lt;- rbind(all_count_predictions_news,
                           prediction)
  
  
}

all_count_models_news$stars &lt;- ifelse(all_count_models_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_count_models_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_count_models_news$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_count_models_news$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_count_comparisons_news$stars &lt;- ifelse(all_count_comparisons_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_count_comparisons_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_count_comparisons_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_count_comparisons_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_count_comparisons_news$group1 &lt;- str_split_i(all_count_comparisons_news$inferred_gender, &quot;-&quot;, 1)
all_count_comparisons_news$group2 &lt;- str_split_i(all_count_comparisons_news$inferred_gender, &quot;-&quot;, 2)

all_count_comparisons_news$p_rounded &lt;- round(all_count_comparisons_news$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_count_models_news)</code></pre>
</div>
<div id="online-news-1" class="section level3" number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> Online News</h3>
<p>Check how many zeroes do we have:</p>
<pre class="r"><code>100*sum(prof_panel_filter$alt_online_all == 0, na.rm = TRUE)/nrow(prof_panel_filter)</code></pre>
<p>Around 27%.</p>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_count_predictions_online_news &lt;- data.frame(matrix(ncol = 7, nrow = 0))
all_count_models_online_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_count_comparisons_online_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(alt_online_all ~ # professor publication variables
                         alt_online_all_l+
                         cited_by_total_all_l + 
                         # gender
                         inferred_gender  +
                         # attention variables
                         news_all_total_l + alt_twitter_total_l +
                         # coauthor publication variables
                         coa_tot_cited_by_total_l +
                         # coauthor publication variables
                         coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;poisson&#39;)  
  
  model_result &lt;- coeftest(news_model, vcov = vcovCL, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  # model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  # model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(summary(news_model)$r.squared,3)
  model_result$field &lt;- field
  
  all_count_models_online_news &lt;- rbind(all_count_models_online_news,
                      model_result)
  
  prediction &lt;- predict_response(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;, 
                                 vcov_type = &quot;HC0&quot;,
                                 vcov.args = list(cluster = field_dataset$profile_id))
  prediction$field &lt;- field
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_count_comparisons_online_news &lt;- rbind(all_count_comparisons_online_news,
                           gender_comparison)
  
  all_count_predictions_online_news &lt;- rbind(all_count_predictions_online_news,
                           prediction)
  
  
}

all_count_models_online_news$stars &lt;- ifelse(all_count_models_online_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_count_models_online_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_count_models_online_news$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_count_models_online_news$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_count_comparisons_online_news$stars &lt;- ifelse(all_count_comparisons_online_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_count_comparisons_online_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_count_comparisons_online_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_count_comparisons_online_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_count_comparisons_online_news$group1 &lt;- str_split_i(all_count_comparisons_online_news$inferred_gender, &quot;-&quot;, 1)
all_count_comparisons_online_news$group2 &lt;- str_split_i(all_count_comparisons_online_news$inferred_gender, &quot;-&quot;, 2)

all_count_comparisons_online_news$p_rounded &lt;- round(all_count_comparisons_online_news$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_count_models_online_news)</code></pre>
</div>
<div id="twitter-1" class="section level3" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> Twitter</h3>
<p>Check how many zeroes do we have:</p>
<pre class="r"><code>100*sum(prof_panel_filter$alt_twitter == 0, na.rm = TRUE)/nrow(prof_panel_filter)</code></pre>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_count_predictions_twitter &lt;- data.frame(matrix(ncol = 7, nrow = 0))
all_count_models_twitter &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_count_comparisons_twitter &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(alt_twitter ~ # professor publication variables
                     alt_twitter_l +  cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     news_all_total_l +
                     alt_online_all_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;poisson&#39;)
  
  model_result &lt;- coeftest(news_model, vcov = vcovCL, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  # model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  # model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(summary(news_model)$r.squared,3)
  model_result$field &lt;- field
  
  all_count_models_twitter &lt;- rbind(all_count_models_twitter,
                      model_result)
  
  prediction &lt;- predict_response(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;, 
                                 vcov_type = &quot;HC0&quot;,
                                 vcov.args = list(cluster = field_dataset$profile_id))
  prediction$field &lt;- field
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_count_comparisons_twitter &lt;- rbind(all_count_comparisons_twitter,
                           gender_comparison)
  
  all_count_predictions_twitter &lt;- rbind(all_count_predictions_twitter,
                           prediction)
  
  
}

all_count_models_twitter$stars &lt;- ifelse(all_count_models_twitter$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_count_models_twitter$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_count_models_twitter$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_count_models_twitter$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_count_comparisons_twitter$stars &lt;- ifelse(all_count_comparisons_twitter$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_count_comparisons_twitter$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_count_comparisons_twitter$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_count_comparisons_twitter$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_count_comparisons_twitter$group1 &lt;- str_split_i(all_count_comparisons_twitter$inferred_gender, &quot;-&quot;, 1)
all_count_comparisons_twitter$group2 &lt;- str_split_i(all_count_comparisons_twitter$inferred_gender, &quot;-&quot;, 2)

all_count_comparisons_twitter$p_rounded &lt;- round(all_count_comparisons_twitter$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_count_models_twitter)</code></pre>
</div>
<div id="write-out-the-models-1" class="section level3" number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> Write out the
models</h3>
<pre class="r"><code>write_csv(all_count_models_news, &quot;Plots_april/reg_mod_poisson_news.csv&quot;)
write_csv(all_count_models_online_news, &quot;Plots_april/reg_mod_poisson_online_news.csv&quot;)
write_csv(all_count_models_twitter, &quot;Plots_april/reg_mod_poisson_twitter.csv&quot;)</code></pre>
</div>
</div>
<div id="binary-models---any-attention" class="section level2"
number="4.3">
<h2><span class="header-section-number">4.3</span> Binary models - any
attention</h2>
<div id="news-2" class="section level3" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> News</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_bin_models_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_bin_comparisons_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(any_news ~ # professor publication variables
                     news_all_l + 
                     cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     alt_online_all_total_l + alt_twitter_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;binomial&#39;) 
  
  model_result &lt;- coeftest(news_model, type = &quot;HC0&quot;, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(PseudoR2(news_model),3)
  model_result$field &lt;- field
  
  all_bin_models_news &lt;- rbind(all_bin_models_news,
                      model_result)
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;HC0&quot;)
  gender_comparison$field &lt;- field
  
  all_bin_comparisons_news &lt;- rbind(all_bin_comparisons_news,
                           gender_comparison)
  
  
}

all_bin_models_news$stars &lt;- ifelse(all_bin_models_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin_models_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin_models_news$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin_models_news$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin_comparisons_news$stars &lt;- ifelse(all_bin_comparisons_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin_comparisons_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin_comparisons_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin_comparisons_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin_comparisons_news$group1 &lt;- str_split_i(all_bin_comparisons_news$inferred_gender, &quot;-&quot;, 1)
all_bin_comparisons_news$group2 &lt;- str_split_i(all_bin_comparisons_news$inferred_gender, &quot;-&quot;, 2)

all_bin_comparisons_news$p_rounded &lt;- round(all_bin_comparisons_news$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_bin_models_news)</code></pre>
</div>
<div id="online-news-2" class="section level3" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> Online News</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_bin_models_online_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_bin_comparisons_online_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(any_online_news ~ # professor publication variables
                         alt_online_all_l+
                         cited_by_total_all_l + 
                         # gender
                         inferred_gender  +
                         # attention variables
                         news_all_total_l + alt_twitter_total_l +
                         # coauthor publication variables
                         coa_tot_cited_by_total_l +
                         # coauthor publication variables
                         coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;binomial&#39;)  
  
  model_result &lt;- coeftest(news_model, type = &quot;HC0&quot;, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(PseudoR2(news_model),3)
  model_result$field &lt;- field
  
  all_bin_models_online_news &lt;- rbind(all_bin_models_online_news,
                      model_result)
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_bin_comparisons_online_news &lt;- rbind(all_bin_comparisons_online_news,
                           gender_comparison)
  
  
}

all_bin_models_online_news$stars &lt;- ifelse(all_bin_models_online_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin_models_online_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin_models_online_news$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin_models_online_news$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin_comparisons_online_news$stars &lt;- ifelse(all_bin_comparisons_online_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin_comparisons_online_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin_comparisons_online_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin_comparisons_online_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin_comparisons_online_news$group1 &lt;- str_split_i(all_bin_comparisons_online_news$inferred_gender, &quot;-&quot;, 1)
all_bin_comparisons_online_news$group2 &lt;- str_split_i(all_bin_comparisons_online_news$inferred_gender, &quot;-&quot;, 2)

all_bin_comparisons_online_news$p_rounded &lt;- round(all_bin_comparisons_online_news$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_bin_models_online_news)</code></pre>
</div>
<div id="twitter-2" class="section level3" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> Twitter</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_bin_predictions_twitter &lt;- data.frame(matrix(ncol = 7, nrow = 0))
all_bin_models_twitter &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_bin_comparisons_twitter &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(any_twitter ~ # professor publication variables
                     alt_twitter_l +  cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     news_all_total_l +
                     alt_online_all_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;binomial&#39;)
  
  model_result &lt;- coeftest(news_model, type = &quot;HC0&quot;, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(PseudoR2(news_model),3)
  model_result$field &lt;- field
  
  all_bin_models_twitter &lt;- rbind(all_bin_models_twitter,
                      model_result)
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_bin_comparisons_twitter &lt;- rbind(all_bin_comparisons_twitter,
                           gender_comparison)
  
  
}

all_bin_models_twitter$stars &lt;- ifelse(all_bin_models_twitter$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin_models_twitter$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin_models_twitter$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin_models_twitter$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin_comparisons_twitter$stars &lt;- ifelse(all_bin_comparisons_twitter$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin_comparisons_twitter$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin_comparisons_twitter$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin_comparisons_twitter$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin_comparisons_twitter$group1 &lt;- str_split_i(all_bin_comparisons_twitter$inferred_gender, &quot;-&quot;, 1)
all_bin_comparisons_twitter$group2 &lt;- str_split_i(all_bin_comparisons_twitter$inferred_gender, &quot;-&quot;, 2)

all_bin_comparisons_twitter$p_rounded &lt;- round(all_bin_comparisons_twitter$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_bin_models_twitter)</code></pre>
</div>
<div id="write-out-the-models-2" class="section level3" number="4.3.4">
<h3><span class="header-section-number">4.3.4</span> Write out the
models</h3>
<pre class="r"><code>write_csv(all_bin_models_news, &quot;Plots_april/reg_mod_bin_news.csv&quot;)
write_csv(all_bin_models_online_news, &quot;Plots_april/reg_mod_bin_online_news.csv&quot;)
write_csv(all_bin_models_twitter, &quot;Plots_april/reg_mod_bin_twitter.csv&quot;)</code></pre>
</div>
</div>
<div id="binary-models---top-10" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> Binary models - top
10</h2>
<div id="news-3" class="section level3" number="4.4.1">
<h3><span class="header-section-number">4.4.1</span> News</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_bin10_models_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_bin10_comparisons_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(news_all_top_10 ~ # professor publication variables
                     news_all_l + 
                     cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     alt_online_all_total_l + alt_twitter_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;binomial&#39;) 
  
  model_result &lt;- coeftest(news_model, type = &quot;HC0&quot;, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(PseudoR2(news_model),3)
  model_result$field &lt;- field
  
  all_bin10_models_news &lt;- rbind(all_bin10_models_news,
                      model_result)
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;HC0&quot;)
  gender_comparison$field &lt;- field
  
  all_bin10_comparisons_news &lt;- rbind(all_bin10_comparisons_news,
                           gender_comparison)
  
  
}

all_bin10_models_news$stars &lt;- ifelse(all_bin10_models_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin10_models_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin10_models_news$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin10_models_news$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin10_comparisons_news$stars &lt;- ifelse(all_bin10_comparisons_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin10_comparisons_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin10_comparisons_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin10_comparisons_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin10_comparisons_news$group1 &lt;- str_split_i(all_bin10_comparisons_news$inferred_gender, &quot;-&quot;, 1)
all_bin10_comparisons_news$group2 &lt;- str_split_i(all_bin10_comparisons_news$inferred_gender, &quot;-&quot;, 2)

all_bin10_comparisons_news$p_rounded &lt;- round(all_bin10_comparisons_news$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_bin10_models_news)</code></pre>
</div>
<div id="online-news-3" class="section level3" number="4.4.2">
<h3><span class="header-section-number">4.4.2</span> Online News</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_bin10_models_online_news &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_bin10_comparisons_online_news &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(alt_online_all_top_10 ~ # professor publication variables
                         alt_online_all_l+
                         cited_by_total_all_l + 
                         # gender
                         inferred_gender  +
                         # attention variables
                         news_all_total_l + alt_twitter_total_l +
                         # coauthor publication variables
                         coa_tot_cited_by_total_l +
                         # coauthor publication variables
                         coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;binomial&#39;)  
  
  model_result &lt;- coeftest(news_model, type = &quot;HC0&quot;, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(PseudoR2(news_model),3)
  model_result$field &lt;- field
  
  all_bin10_models_online_news &lt;- rbind(all_bin10_models_online_news,
                      model_result)
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_bin10_comparisons_online_news &lt;- rbind(all_bin10_comparisons_online_news,
                           gender_comparison)
  
  
}

all_bin10_models_online_news$stars &lt;- ifelse(all_bin10_models_online_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin10_models_online_news$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin10_models_online_news$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin10_models_online_news$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin10_comparisons_online_news$stars &lt;- ifelse(all_bin10_comparisons_online_news$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin10_comparisons_online_news$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin10_comparisons_online_news$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin10_comparisons_online_news$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin10_comparisons_online_news$group1 &lt;- str_split_i(all_bin10_comparisons_online_news$inferred_gender, &quot;-&quot;, 1)
all_bin10_comparisons_online_news$group2 &lt;- str_split_i(all_bin10_comparisons_online_news$inferred_gender, &quot;-&quot;, 2)

all_bin10_comparisons_online_news$p_rounded &lt;- round(all_bin10_comparisons_online_news$p.value, 4)</code></pre>
<pre class="r"><code>knitr::kable(all_bin10_models_online_news)</code></pre>
</div>
<div id="twitter-3" class="section level3" number="4.4.3">
<h3><span class="header-section-number">4.4.3</span> Twitter</h3>
<p>This time period’s news given one’s total citations/publications,
past total attention, controlling for the field and year (Lexis sample
only). Pooled model with clustered SEs:</p>
<pre class="r"><code>fields &lt;- c(&quot;stem&quot;, &quot;soc_sci&quot;, &quot;medicine&quot;, &quot;arts&quot;)

all_bin10_models_twitter &lt;- data.frame(matrix(ncol = 10, nrow = 0))
all_bin10_comparisons_twitter &lt;- data.frame(matrix(ncol = 6, nrow = 0))

for (field in fields){
  
  field_dataset &lt;- get(field)
  
  news_model &lt;- glm(alt_twitter_top_10 ~ # professor publication variables
                     alt_twitter_l +  cited_by_total_all_l + 
                     # gender
                     inferred_gender +
                     # attention variables
                     news_all_total_l +
                     alt_online_all_total_l +
                     # coauthor publication variables
                     coa_tot_cited_by_total_l +
                     # coauthor publication variables
                     coa_online_all_total_l + coa_twitter_total_l+as.factor(year),
                   data = field_dataset, family = &#39;binomial&#39;)
  
  model_result &lt;- coeftest(news_model, type = &quot;HC0&quot;, cluster = ~profile_id)[,] %&gt;% 
    as.data.frame() %&gt;% 
    tibble::rownames_to_column(var = &quot;term&quot;)
  
  model_result[nrow(model_result)+1, 1] &lt;- &quot;R^2&quot;
  model_result[nrow(model_result), 2:ncol(model_result)] &lt;- round(PseudoR2(news_model),3)
  model_result$field &lt;- field
  
  all_bin10_models_twitter &lt;- rbind(all_bin10_models_twitter,
                      model_result)
  
  gender_comparison &lt;- test_predictions(news_model, c(&quot;inferred_gender&quot;), vcov_fun = &quot;vcovCL&quot;)
  gender_comparison$field &lt;- field
  
  all_bin10_comparisons_twitter &lt;- rbind(all_bin10_comparisons_twitter,
                           gender_comparison)
  
  
}

all_bin10_models_twitter$stars &lt;- ifelse(all_bin10_models_twitter$`Pr(&gt;|z|)` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin10_models_twitter$`Pr(&gt;|z|)` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin10_models_twitter$`Pr(&gt;|z|)` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin10_models_twitter$`Pr(&gt;|z|)` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin10_comparisons_twitter$stars &lt;- ifelse(all_bin10_comparisons_twitter$`p.value` &lt;= 0.001, &quot;***&quot;,
                           ifelse(all_bin10_comparisons_twitter$`p.value` &lt;= 0.001, &quot;**&quot;,
                                  ifelse(all_bin10_comparisons_twitter$`p.value` &lt;= 0.05, &quot;*&quot;,
                                         ifelse(all_bin10_comparisons_twitter$`p.value` &lt;= 0.1, &quot;.&quot;, &quot;&quot;))))

all_bin10_comparisons_twitter$group1 &lt;- str_split_i(all_bin10_comparisons_twitter$inferred_gender, &quot;-&quot;, 1)
all_bin10_comparisons_twitter$group2 &lt;- str_split_i(all_bin10_comparisons_twitter$inferred_gender, &quot;-&quot;, 2)

all_bin10_comparisons_twitter$p_rounded &lt;- round(all_bin10_comparisons_twitter$p.value, 4)</code></pre>
</div>
</div>
<div id="write-out-the-models-3" class="section level2" number="4.5">
<h2><span class="header-section-number">4.5</span> Write out the
models</h2>
<pre class="r"><code>write_csv(all_bin10_models_news, &quot;Plots_april/reg_mod_bin10_news.csv&quot;)
write_csv(all_bin10_models_online_news, &quot;Plots_april/reg_mod_bin10_online_news.csv&quot;)
write_csv(all_bin10_models_twitter, &quot;Plots_april/reg_mod_bin10_twitter.csv&quot;)</code></pre>
<pre class="r"><code>knitr::kable(all_bin10_models_twitter)</code></pre>
</div>
</div>
<div id="mobility-per-gender" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Mobility per
gender</h1>
<p>Let us look only at people who have entered the dataset before 2012
and limit the dataset to the period after 2012:</p>
<pre class="r"><code>prof_panel_mobility &lt;- filter(prof_panel_filter, first_pub &lt;= 2012 &amp; year &gt;= 2012)

# split the periods into 2
prof_panel_mobility$period &lt;- ifelse(prof_panel_mobility$year &lt;= 2017, &quot;first&quot;, &quot;second&quot;)</code></pre>
<p>Now, select professors’ attention in these years and add it up per
period:</p>
<p>Get transition matrices per gender: (see the “helper_functions.R”
file for the actual function)</p>
<pre class="r"><code>splits &lt;- 5

gender_matrices &lt;- gen_transition_matrix(prof_panel_mobility, split_by = &quot;gender&quot;, brackets = splits)</code></pre>
<p>Get transition matrices per gender and field:</p>
<pre class="r"><code>gender_field_matrices &lt;- gen_transition_matrix(prof_panel_mobility, split_by = &quot;gender &amp; field&quot;, brackets = splits)</code></pre>
<p>Get plots for: ### Overall transitions:</p>
<pre class="r"><code>loop_list &lt;- c(&quot;pub_transitions&quot;, &quot;cit_transitions&quot;,
          &quot;online_news_transitions&quot;, &quot;news_transitions&quot;, 
          &quot;twitter_transitions&quot;)

titles &lt;- c(&quot;Publications&quot;, &quot;Citations&quot;,
            &quot;Online news attention&quot;, &quot;News attention&quot;,
            &quot;Twitter attention&quot;)


color_list &lt;- c(&quot;#fb923c&quot;, &quot;#fbbf24&quot;, &quot;#34d399&quot;, &quot;#22d3ee&quot;, &quot;#818cf8&quot;)

overall_transition_plots &lt;- list()

for (matrix in loop_list){
  matrix_current &lt;- gender_matrices[[matrix]][[&quot;all&quot;]]
  
  plot_current &lt;- matrix_current %&gt;% 
    as.data.frame() %&gt;%
    rownames_to_column(&quot;p1&quot;) %&gt;%
    pivot_longer(-c(p1), names_to = &quot;p2&quot;, values_to = &quot;prob&quot;)%&gt;%
    ggplot(aes(x=as.integer(p1), y=as.integer(p2), fill=prob)) + 
    geom_tile() +
    scale_fill_gradient2(low = &quot;#f87171&quot;, mid = &quot;white&quot;, high = color_list[which(loop_list == matrix)])+
    scale_x_continuous(breaks=seq(0, splits, 1), expand = c(0, 0))+
    scale_y_continuous(breaks=seq(0, splits, 1), trans = &quot;reverse&quot;, expand = c(0, 0))+
    xlab(&quot;Period 1: 2011-2017&quot;)+
    ylab(&quot;Period 2: 2018-2023&quot;)+
    theme_minimal()+
    ggtitle(titles[which(loop_list == matrix)])+
    guides(fill=guide_legend(title=&quot;Probability&quot;))+
    theme(plot.title = element_text(size = 10),
          axis.text.y = element_text(size = 10),
          axis.title.y = element_text(size = 11),
          axis.text.x = element_text(size = 10) ,
          axis.title.x = element_text(size = 11),
          legend.title=element_text(size=10), 
          legend.text=element_text(size=8))
  
  overall_transition_plots[[matrix]] &lt;- plot_current
  
}</code></pre>
<p>Plot these:</p>
<pre class="r"><code>grid.arrange(grobs = overall_transition_plots, ncol = 2)</code></pre>
<div id="overall-transitions-per-field" class="section level3"
number="5.0.1">
<h3><span class="header-section-number">5.0.1</span> Overall transitions
per field:</h3>
<pre class="r"><code>loop_list &lt;- c(&quot;pub_transitions&quot;, &quot;cit_transitions&quot;,
          &quot;online_news_transitions&quot;, &quot;news_transitions&quot;, 
          &quot;twitter_transitions&quot;)

titles &lt;- c(&quot;Publications&quot;, &quot;Citations&quot;,
            &quot;Online news attention&quot;, &quot;News attention&quot;,
            &quot;Twitter attention&quot;)


color_list &lt;- c(&quot;#fb923c&quot;, &quot;#fbbf24&quot;, &quot;#34d399&quot;, &quot;#22d3ee&quot;, &quot;#818cf8&quot;)

overall_field_transition_plots &lt;- list()

for (matrix in loop_list){
  fields &lt;- c(&quot;STEM&quot;, &quot;Social sciences&quot;, &quot;Medicine&quot;, &quot;Arts &amp; Humanities&quot;)
  
  for (field in fields){
  matrix_current &lt;- gender_field_matrices[[matrix]][[field]][[&quot;all&quot;]]
  
  plot_current &lt;- matrix_current %&gt;% 
    as.data.frame() %&gt;%
    rownames_to_column(&quot;p1&quot;) %&gt;%
    pivot_longer(-c(p1), names_to = &quot;p2&quot;, values_to = &quot;prob&quot;)%&gt;%
    ggplot(aes(x=as.integer(p1), y=as.integer(p2), fill=prob)) + 
    geom_tile() +
    scale_fill_gradient2(low = &quot;#f87171&quot;, mid = &quot;white&quot;, high = color_list[which(loop_list == matrix)])+
    scale_x_continuous(breaks=seq(0, splits, 1), expand = c(0, 0))+
    scale_y_continuous(breaks=seq(0, splits, 1), trans = &quot;reverse&quot;, expand = c(0, 0))+
    xlab(&quot;Period 1: 2011-2017&quot;)+
    ylab(&quot;Period 2: 2018-2023&quot;)+
    theme_minimal()+
    ggtitle(titles[which(loop_list == matrix)])+
    guides(fill=guide_legend(title=&quot;Probability&quot;))+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 9),
        axis.title.y = element_text(size = 10),
        axis.text.x = element_text(size = 9) ,
        axis.title.x = element_text(size = 10),
        legend.title=element_text(size=10), 
        legend.text=element_text(size=8))
  
  overall_field_transition_plots[[field]][[matrix]] &lt;- plot_current
  
  }
  
}</code></pre>
<p>Prepare transition plots per field:</p>
<pre class="r"><code>plot1 &lt;- overall_field_transition_plots[[&#39;STEM&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots[[&#39;STEM&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots[[&#39;STEM&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

# now add the title
title &lt;- ggdraw() + 
  draw_label(
    &quot;(a) STEM&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )
stem &lt;- plot_grid(plot1,
                  plot2,
                  plot3, ncol = 3, nrow = 1)

stem &lt;- plot_grid(
  title, stem,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)

plot1 &lt;- overall_field_transition_plots[[&#39;Social sciences&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots[[&#39;Social sciences&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots[[&#39;Social sciences&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

soc_sci &lt;- plot_grid(plot1,
                     plot2,
                     plot3, ncol = 3, nrow = 1)

title &lt;- ggdraw() + 
  draw_label(
    &quot;(b) Social science&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

soc_sci &lt;- plot_grid(
  title, soc_sci,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)

plot1 &lt;- overall_field_transition_plots[[&#39;Medicine&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots[[&#39;Medicine&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots[[&#39;Medicine&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

medicine &lt;- plot_grid(plot1,
          plot2,
          plot3, ncol = 3, nrow = 1)

title &lt;- ggdraw() + 
  draw_label(
    &quot;(c) Medicine&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

medicine &lt;- plot_grid(
  title, medicine,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)

plot1 &lt;- overall_field_transition_plots[[&#39;Arts &amp; Humanities&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots[[&#39;Arts &amp; Humanities&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots[[&#39;Arts &amp; Humanities&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

arts_hum &lt;- plot_grid(plot1,
          plot2,
          plot3, ncol = 3, nrow = 1)

title &lt;- ggdraw() + 
  draw_label(
    &quot;(d) Arts &amp; Humanities&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

arts_hum &lt;- plot_grid(
  title, arts_hum,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)</code></pre>
<p>Save the plot:</p>
<pre class="r"><code>ggsave(file=&quot;Plots_april/Supplemental/P_overall_transitions_20.png&quot;, 
       grid.arrange(stem, soc_sci,
                    medicine, arts_hum,
                    ncol = 1, nrow = 4),
       width = 10,
       height = 10,
       units = &quot;in&quot;)</code></pre>
</div>
<div id="differences-in-transitions" class="section level3"
number="5.0.2">
<h3><span class="header-section-number">5.0.2</span> Differences in
transitions:</h3>
<pre class="r"><code>loop_list &lt;- c(&quot;online_news_transitions&quot;, &quot;news_transitions&quot;, 
          &quot;twitter_transitions&quot;)

titles &lt;- c(&quot;Online news attention&quot;, &quot;News attention&quot;,
            &quot;Twitter attention&quot;)


color_list &lt;- c(&quot;#fb923c&quot;, &quot;#fbbf24&quot;, &quot;#34d399&quot;, &quot;#22d3ee&quot;, &quot;#818cf8&quot;)
color_list2 &lt;- c(&quot;#fff7ed&quot;, &quot;#fffbeb&quot;, &quot;#ecfdf5&quot;, &quot;#ecfeff&quot;, &quot;#eef2ff&quot;)

overall_diff_plots &lt;- list()

for (matrix in loop_list){
  matrix_current_men &lt;- gender_matrices[[matrix]][[&quot;men&quot;]]
  matrix_current_women &lt;- gender_matrices[[matrix]][[&quot;women&quot;]]
  matrix_diff &lt;- matrix_current_women - matrix_current_men
  plot_current &lt;- matrix_diff %&gt;% 
    as.data.frame() %&gt;%
    rownames_to_column(&quot;p1&quot;) %&gt;%
    pivot_longer(-c(p1), names_to = &quot;p2&quot;, values_to = &quot;prob&quot;)%&gt;%
    ggplot(aes(x=as.integer(p1), y=as.integer(p2), fill=prob)) + 
    geom_tile() +
    scale_fill_gradient2(low = &quot;#f87171&quot;, mid = &quot;white&quot;, high = color_list[which(loop_list == matrix)])+
    scale_x_continuous(breaks=seq(0, splits, 1), expand = c(0, 0))+
    scale_y_continuous(breaks=seq(0, splits, 1), trans = &quot;reverse&quot;, expand = c(0, 0))+
    xlab(&quot;p_1&quot;)+
    ylab(&quot;p_2&quot;)+
    theme_minimal()+
    ggtitle(titles[which(loop_list == matrix)])+
    guides(fill=guide_legend(title=&quot;Diff. (w - m)&quot;))
  
  overall_diff_plots[[matrix]] &lt;- plot_current
  
}</code></pre>
<p>Plot these:</p>
<pre class="r"><code>grid.arrange(grobs = overall_diff_plots, ncol = 3)</code></pre>
<p>Differences per field:</p>
<pre class="r"><code>loop_list &lt;- c(&quot;pub_transitions&quot;, &quot;cit_transitions&quot;,
          &quot;online_news_transitions&quot;, &quot;news_transitions&quot;, 
          &quot;twitter_transitions&quot;)

titles &lt;- c(&quot;Publications&quot;, &quot;Citations&quot;,
            &quot;Online news attention&quot;, &quot;News attention&quot;,
            &quot;Twitter attention&quot;)


color_list &lt;- c(&quot;#fb923c&quot;, &quot;#fbbf24&quot;, &quot;#34d399&quot;, &quot;#22d3ee&quot;, &quot;#818cf8&quot;)

overall_field_transition_plots_diff &lt;- list()

for (matrix in loop_list){
  fields &lt;- c(&quot;STEM&quot;, &quot;Social sciences&quot;, &quot;Medicine&quot;, &quot;Arts &amp; Humanities&quot;)
  
  for (field in fields){
  matrix_current_men &lt;- gender_field_matrices[[matrix]][[field]][[&quot;men&quot;]]
  matrix_current_women &lt;- gender_field_matrices[[matrix]][[field]][[&quot;women&quot;]]
  matrix_diff &lt;- matrix_current_women - matrix_current_men
  
  plot_current &lt;- matrix_diff %&gt;% 
    as.data.frame() %&gt;%
    rownames_to_column(&quot;p1&quot;) %&gt;%
    pivot_longer(-c(p1), names_to = &quot;p2&quot;, values_to = &quot;prob&quot;)%&gt;%
    ggplot(aes(x=as.integer(p1), y=as.integer(p2), fill=prob)) + 
    geom_tile() +
    scale_fill_gradient2(low = &quot;#f87171&quot;, mid = &quot;white&quot;, high = color_list[which(loop_list == matrix)], limits=c(-0.4, 0.4), breaks=seq(round(-0.4, 1),round(0.4,1),by=0.2))+
    scale_x_continuous(breaks=seq(0, splits, 1), expand = c(0, 0))+
    scale_y_continuous(breaks=seq(0, splits, 1), trans = &quot;reverse&quot;, expand = c(0, 0))+
    xlab(&quot;Period 1: 2011-2017&quot;)+
    ylab(&quot;Period 2: 2018-2023&quot;)+
    theme_minimal()+
    ggtitle(titles[which(loop_list == matrix)])+
    guides(fill=guide_legend(title=&quot;Prob. diff. (w-m)&quot;))+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 9),
        axis.title.y = element_text(size = 10),
        axis.text.x = element_text(size = 9) ,
        axis.title.x = element_text(size = 10),
        legend.title=element_text(size=10), 
        legend.text=element_text(size=8))
  
  overall_field_transition_plots_diff[[field]][[matrix]] &lt;- plot_current
  
  }
  
}</code></pre>
<p>Prepare transition difference plots per field:</p>
<pre class="r"><code>plot1 &lt;- overall_field_transition_plots_diff[[&#39;STEM&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots_diff[[&#39;STEM&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots_diff[[&#39;STEM&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

# now add the title
title &lt;- ggdraw() + 
  draw_label(
    &quot;(a) STEM&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )
stem &lt;- plot_grid(plot1,
                  plot2,
                  plot3, ncol = 3, nrow = 1)

stem &lt;- plot_grid(
  title, stem,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)

plot1 &lt;- overall_field_transition_plots_diff[[&#39;Social sciences&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots_diff[[&#39;Social sciences&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots_diff[[&#39;Social sciences&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

soc_sci &lt;- plot_grid(plot1,
                     plot2,
                     plot3, ncol = 3, nrow = 1)

title &lt;- ggdraw() + 
  draw_label(
    &quot;(b) Social science&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

soc_sci &lt;- plot_grid(
  title, soc_sci,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)

plot1 &lt;- overall_field_transition_plots_diff[[&#39;Medicine&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots_diff[[&#39;Medicine&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots_diff[[&#39;Medicine&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

medicine &lt;- plot_grid(plot1,
          plot2,
          plot3, ncol = 3, nrow = 1)

title &lt;- ggdraw() + 
  draw_label(
    &quot;(c) Medicine&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

medicine &lt;- plot_grid(
  title, medicine,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)

plot1 &lt;- overall_field_transition_plots_diff[[&#39;Arts &amp; Humanities&#39;]][4][[&quot;news_transitions&quot;]]+ggtitle(&quot;(i) News attention&quot;)
plot2 &lt;- overall_field_transition_plots_diff[[&#39;Arts &amp; Humanities&#39;]][3][[&quot;online_news_transitions&quot;]]+ggtitle(&quot;(ii) Online attention&quot;)
plot3 &lt;- overall_field_transition_plots_diff[[&#39;Arts &amp; Humanities&#39;]][5][[&quot;twitter_transitions&quot;]]+ggtitle(&quot;(iii) Twitter attention&quot;)

arts_hum &lt;- plot_grid(plot1,
          plot2,
          plot3, ncol = 3, nrow = 1)

title &lt;- ggdraw() + 
  draw_label(
    &quot;(d) Arts &amp; Humanities&quot;,
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

arts_hum &lt;- plot_grid(
  title, arts_hum,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)</code></pre>
<p>Save the plot:</p>
<pre class="r"><code>ggsave(file=&quot;Plots_april/Supplemental/P_transition_diff_20.png&quot;, 
       grid.arrange(stem, soc_sci,
                    medicine, arts_hum,
                    ncol = 1, nrow = 4),
       width = 10,
       height = 10,
       units = &quot;in&quot;)</code></pre>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlZhcmlvdXMgYW5hbHlzZXMgLSBBcHJpbCAyMDI0LCBmaW5hbCBkYXRhc2V0Ig0KYXV0aG9yOiAiQW5hIE1hY2Fub3ZpYyINCmRhdGU6ICIyMDI0LTA0LTEwIg0Kb3V0cHV0OiBodG1sX2RvY3VtZW50DQotLS0NCg0KYGBge3Igc2V0dXAsIGluY2x1ZGU9RkFMU0V9DQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpDQprbml0cjo6b3B0c19jaHVuayRzZXQoZXZhbCA9IEZBTFNFKQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KHdhcm5pbmcgPSBGQUxTRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChtZXNzYWdlID0gRkFMU0UpDQpgYGANCg0KDQpUaGlzIGlzIGEgZmlyc3QgZHJhZnQgb2Ygb3VyIG1haW4gYW5hbHlzZXMuDQoNCkxvYWQgdGhlIHBhY2thZ2VzOg0KYGBge3IgbWVzc2FnZT0gIEYsIHdhcm5pbmcgPSBGLCBldmFsID0gRn0NCmxpYnJhcnkoZ3JvdW5kaG9nKQ0KcGFja2FnZXNfdG9fbG9hZCA8LSBjKCJyZWFkciIsICJkcGx5ciIsICJ0aWR5ciIsIA0KICAgICAgICAgICAgICAgICAgICAgICJnZ3Bsb3QyIiwgImdyaWRFeHRyYSIsICJjb3dwbG90IiwNCiAgICAgICAgICAgICAgICAgICAgICAidGlkeXZlcnNlIiwgIlJQb3N0Z3JlcyIsICJtYXJrb3ZjaGFpbiINCiAgICAgICAgICAgICAgICAgICAgICAsICJSUG9zdGdyZXMiLCAibHVicmlkYXRlIiwgInBzeWNoIiwNCiAgICAgICAgICAgICAgICAgICAgICAiZ3JpZEV4dHJhIiwgIkRlc2NUb29scyIsICJtYXJnaW5hbGVmZmVjdHMiLA0KICAgICAgICAgICAgICAgICAgICAgICJwYW5lbHIiLCAic2tpbXIiLCAibWFyZ2lucyIsDQogICAgICAgICAgICAgICAgICAgICAgImxtdGVzdCIsICJzYW5kd2ljaCIsICJyc3RhdGl4IiwgImdncHViciIsDQogICAgICAgICAgICAgICAgICAgICAgInN0YXJnYXplciIsInBsbSIsICJncmlkIiwgImNvcnJwbG90IikNCmdyb3VuZGhvZy5saWJyYXJ5KHBhY2thZ2VzX3RvX2xvYWQsIGRhdGUgPSAiMjAyMy0xMi0wMSIpDQojZ3JvdW5kaG9nLmxpYnJhcnkoYygiZ2dlZmZlY3RzIiwgImluc2lnaHQiKSwgZGF0ZSA9ICIyMDI0LTA0LTE1IikNCg0KaW5zdGFsbC5wYWNrYWdlcygiaW5zaWdodCIpDQpsaWJyYXJ5KGluc2lnaHQpDQpsaWJyYXJ5KGdnZWZmZWN0cykNCnNvdXJjZSgiaGVscGVyX2Z1bmN0aW9ucy5SIikNCmBgYA0KDQpMb2FkIHRoZSBwYW5lbDoNCmBgYHtyIHdhcm5pbmcgPSBGLCBtZXNzYWdlID0gRn0NCnByb2ZfcGFuZWxfY29hIDwtIHJlYWRfY3N2KCJwYW5lbF9kYXRhc2V0cy9wcm9mX3BhbmVsX3RpZHlfMjZfNC5jc3YiKQ0KDQpwcm9mX3BhbmVsX2ZpbHRlciA8LSBmaWx0ZXIocHJvZl9wYW5lbF9jb2EsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA8IDIwMjQpDQoNCnByb2ZfcGFuZWxfZmlsdGVyJGNvYV9vbmxpbmVfYWxsX3RvdGFsIDwtIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV9vbmxpbmVfbmV3c190b3RhbCArIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV9ibG9nc190b3RhbA0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9hbGxfdG90YWxfbCA8LSBwcm9mX3BhbmVsX2ZpbHRlciRjb2Ffb25saW5lX25ld3NfdG90YWxfbCArIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV9ibG9nc190b3RhbF9sDQpwcm9mX3BhbmVsX2ZpbHRlciRjb2Ffb25saW5lX2FsbCA8LSBwcm9mX3BhbmVsX2ZpbHRlciRjb2Ffb25saW5lX25ld3MgKyBwcm9mX3BhbmVsX2ZpbHRlciRjb2FfYmxvZ3MNCnByb2ZfcGFuZWxfZmlsdGVyJGNvYV9vbmxpbmVfYWxsX2wgPC0gcHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9uZXdzX2wgKyBwcm9mX3BhbmVsX2ZpbHRlciRjb2FfYmxvZ3NfbA0KDQpwcm9mX3BhbmVsX2ZpbHRlciRjb2FfdG90X29ubGluZV9hbGxfdG90YWwgPC0gcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9vbmxpbmVfbmV3c190b3RhbCArIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3RfYmxvZ3NfdG90YWwNCnByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3Rfb25saW5lX2FsbF90b3RhbF9sIDwtIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3Rfb25saW5lX25ld3NfdG90YWxfbCArIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3RfYmxvZ3NfdG90YWxfbA0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9vbmxpbmVfYWxsIDwtIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3Rfb25saW5lX25ld3MgKyBwcm9mX3BhbmVsX2ZpbHRlciRjb2FfdG90X2Jsb2dzDQpwcm9mX3BhbmVsX2ZpbHRlciRjb2FfdG90X29ubGluZV9hbGxfbCA8LSBwcm9mX3BhbmVsX2ZpbHRlciRjb2FfdG90X29ubGluZV9uZXdzICsgcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9ibG9nc19sDQpgYGANCg0KDQojIEV4cGxvcmUgcmVwcmVzZW50YXRpb24gYWNyb3NzIGRpZmZlcmVudCBkYXRhIHNvdXJjZXMNCmBgYHtyfQ0Kc291cmNlc19jaGVjayA8LSBwcm9mX3BhbmVsX2ZpbHRlciAlPiUNCiAgZ3JvdXBfYnkocHJvZmlsZV9pZCklPiUNCiAgZmlsdGVyKHllYXIgPT0gbWF4KHllYXIpKQ0KYGBgDQoNCkNoZWNrIHR3byBraW5kcyBvZiBjb2F1dGhvciB2YXJpYWJsZXMgd2UgaGF2ZToNCmBgYHtyfQ0Kc2VsZWN0X3ZhcnNfY29yIDwtIGMoImNvYV9jb3VudF9wdWJzX3RvdGFsX29hIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfY2l0ZWRfYnlfdG90YWxfb2EiLA0KICAgICAgICAgICAgICAgICAgICAgImNvYV9vbmxpbmVfYWxsX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfdHdpdHRlcl90b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAiY29hX3RvdF9jb3VudF9wdWJzIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfdG90X2NpdGVkX2J5IiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfdG90X29ubGluZV9hbGxfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgImNvYV90b3RfdHdpdHRlciIpDQoNCmxhYmVsc19jb3IgPC1jKCJQdWJsaWNhdGlvbnMgLSB0aGlzIHllYXIncyBjb2F1dGhvcnMnIHRvdGFsIiwNCiAgICAgICAgICAgICAgICJDaXRhdGlvbnMgLSB0aGlzIHllYXIncyBjb2F1dGhvcnMnIHRvdGFsIiwNCiAgICAgICAgICAgICAgICJPbmxpbmUgbmV3cyBhdHRlbnRpb24gLSB0aGlzIHllYXIncyBjb2F1dGhvcicgdG90YWwiLA0KICAgICAgICAgICAgICAgIlR3aXR0ZXIgYXR0ZW50aW9uIC0gdGhpcyB5ZWFyJ3MgY29hdXRob3InIHRvdGFsIiwNCiAgICAgICAgICAgICAgICJQdWJsaWNhdGlvbnMgLSBhbGwgY29hdXRob3JzJyB0b3RhbCIsDQogICAgICAgICAgICAgICAiQ2l0YXRpb25zIC0gYWxsIGNvYXV0aG9ycycgdG90YWwiLA0KICAgICAgICAgICAgICAgIk9ubGluZSBuZXdzIGF0dGVudGlvbiAtIGFsbCBjb2F1dGhvcicgdG90YWwiLA0KICAgICAgICAgICAgICAgIlR3aXR0ZXIgYXR0ZW50aW9uIC0gYWxsIGNvYXV0aG9yJyB0b3RhbCIpDQoNCmNvcnJlbGF0aW9uX21hdHJpeCA8LSBjb3Ioc291cmNlc19jaGVja1ssc2VsZWN0X3ZhcnNfY29yXSx1c2U9InBhaXJ3aXNlLmNvbXBsZXRlLm9icyIpDQoNCg0KY29sbmFtZXMoY29ycmVsYXRpb25fbWF0cml4KSA8LSBsYWJlbHNfY29yDQpyb3duYW1lcyhjb3JyZWxhdGlvbl9tYXRyaXgpIDwtIGxhYmVsc19jb3INCg0KDQpwbmcoaGVpZ2h0PTEwLCB3aWR0aD0xMCwgDQogICAgdW5pdCA9ICJpbiIsIA0KICAgIHJlcyA9IDYwMCwNCiAgICBmaWxlPSJQbG90c19hcHJpbC9TdXBwbGVtZW50YWwvY29ycmVsYXRpb25zX2NvYXV0aG9yX3Zhcl9jb21wYXJpc29uX3RvdGFsLnBuZyIpDQoNCiMgWW91ciBmdW5jdGlvbiB0byBwbG90IGltYWdlIGdvZXMgaGVyZQ0KY29ycnBsb3QoY29ycmVsYXRpb25fbWF0cml4LCANCiAgICAgICAgIG1ldGhvZD0ibnVtYmVyIiwNCiAgICAgICAgIHRsLmNvbCA9ICJibGFjayIsDQogICAgICAgICB0aXRsZSA9ICJWYXJpYWJsZSBDb3JyZWxhdGlvbiBNYXRyaXggLSBDb2F1dGhvciB2YXJpYWJsZSBjb21wYXJpc29uIChUb3RhbHMpIiwNCiAgICAgICAgIG1hcj1jKDAsMCwyLDApKQ0KIyBUaGVuDQpkZXYub2ZmKCkNCmBgYA0KDQoNCkZpcnN0LCBzb21lIGNvcnJlbGF0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB2YXJpYWJsZXMsIGxvb2tpbmcgYXQgdG90YWxzIGluIHRoZSBmaW5hbA0KeWVhciBvdmVyYWxsOg0KYGBge3IgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTEwfQ0Kc2VsZWN0X3ZhcnNfY29yIDwtIGMoImNvdW50X3B1YnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgImNpdGVkX2J5X3RvdGFsX2FsbCIsDQogICAgICAgICAgICAgICAgICAgICAibmV3c19hbGxfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgImFsdF9vbmxpbmVfYWxsX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICJhbHRfdHdpdHRlcl90b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAiY29hX2NvdW50X3B1YnNfdG90YWxfb2EiLA0KICAgICAgICAgICAgICAgICAgICAgImNvYV9jaXRlZF9ieV90b3RhbF9vYSIsDQogICAgICAgICAgICAgICAgICAgICAiY29hX29ubGluZV9hbGxfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgImNvYV90d2l0dGVyX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICJ5ZWFyc19zaW5jZV9maXJzdF9wdWIiKQ0KDQpsYWJlbHNfY29yIDwtYygiUHVibGljYXRpb25zIiwNCiAgICAgICAgICAgICAgICJDaXRhdGlvbnMiLA0KICAgICAgICAgICAgICAgIk5ld3MgYXR0ZW50aW9uIiwNCiAgICAgICAgICAgICAgICJPbmxpbmUgbmV3cyBhdHRlbnRpb24iLA0KICAgICAgICAgICAgICAgIlR3aXR0ZXIgYXR0ZW50aW9uIiwNCiAgICAgICAgICAgICAgICJDb2F1dGhvciBwdWJsaWNhdGlvbnMiLA0KICAgICAgICAgICAgICAgIkNvYXV0aG9yIGNpdGF0aW9ucyIsDQogICAgICAgICAgICAgICAiQ29hdXRob3Igb25saW5lIG5ld3MgYXR0ZW50aW9uIiwNCiAgICAgICAgICAgICAgICJDb2F1dGhvciB0d2l0dGVyIGF0dGVudGlvbiIsDQogICAgICAgICAgICAgICAiWWVhcnMgc2luY2UgZmlyc3QgcHVibGljYXRpb25zIikNCg0KY29ycmVsYXRpb25fbWF0cml4IDwtIGNvcihzb3VyY2VzX2NoZWNrWyxzZWxlY3RfdmFyc19jb3JdLHVzZT0icGFpcndpc2UuY29tcGxldGUub2JzIikNCg0KDQpjb2xuYW1lcyhjb3JyZWxhdGlvbl9tYXRyaXgpIDwtIGxhYmVsc19jb3INCnJvd25hbWVzKGNvcnJlbGF0aW9uX21hdHJpeCkgPC0gbGFiZWxzX2Nvcg0KDQoNCnBuZyhoZWlnaHQ9MTAsIHdpZHRoPTEwLCANCiAgICB1bml0ID0gImluIiwgDQogICAgcmVzID0gNjAwLA0KICAgIGZpbGU9IlBsb3RzX2FwcmlsL1N1cHBsZW1lbnRhbC9jb3JyZWxhdGlvbnNfdG90YWxfb3ZlcmFsbC5wbmciKQ0KDQojIFlvdXIgZnVuY3Rpb24gdG8gcGxvdCBpbWFnZSBnb2VzIGhlcmUNCmNvcnJwbG90KGNvcnJlbGF0aW9uX21hdHJpeCwgDQogICAgICAgICBtZXRob2Q9Im51bWJlciIsDQogICAgICAgICB0bC5jb2wgPSAiYmxhY2siLA0KICAgICAgICAgdGl0bGUgPSAiVmFyaWFibGUgQ29ycmVsYXRpb24gTWF0cml4IC0gVG90YWxzLCBBbGwgZmllbGRzIiwNCiAgICAgICAgIG1hcj1jKDAsMCwyLDApKQ0KIyBUaGVuDQpkZXYub2ZmKCkNCg0KYGBgDQpBbmQgcGVyIGZpZWxkOg0KYGBge3J9DQpmaWVsZHMgPC0gdW5pcXVlKHNvdXJjZXNfY2hlY2skZ2VuZXJhbF9maWVsZCkNCmZpZWxkcyA8LSBmaWVsZHNbMTo0XQ0KDQpmb3IgKGZpZWxkIGluIGZpZWxkcyl7DQogIGZpZWxkX2RhdGEgPC0gZmlsdGVyKHNvdXJjZXNfY2hlY2ssIGdlbmVyYWxfZmllbGQgPT0gZmllbGQpDQogIA0KICBjb3JyZWxhdGlvbl9tYXRyaXhfZmllbGQgPC0gY29yKGZpZWxkX2RhdGFbLHNlbGVjdF92YXJzX2Nvcl0sdXNlPSJwYWlyd2lzZS5jb21wbGV0ZS5vYnMiKQ0KICANCiAgcm93bmFtZXMoY29ycmVsYXRpb25fbWF0cml4X2ZpZWxkKSA8LSBjb2xuYW1lcyhjb3JyZWxhdGlvbl9tYXRyaXhfZmllbGQpDQoNCiAgDQogIGNvbG5hbWVzKGNvcnJlbGF0aW9uX21hdHJpeF9maWVsZCkgPC0gbGFiZWxzX2Nvcg0KICByb3duYW1lcyhjb3JyZWxhdGlvbl9tYXRyaXhfZmllbGQpIDwtIGxhYmVsc19jb3INCiAgDQogIA0KICBwbmcoaGVpZ2h0PTEwLCB3aWR0aD0xMCwgDQogICAgICB1bml0ID0gImluIiwgDQogICAgICByZXMgPSA2MDAsDQogICAgICBmaWxlPSBwYXN0ZTAoIlBsb3RzX2FwcmlsL1N1cHBsZW1lbnRhbC9jb3JyZWxhdGlvbnNfdG90YWxfIiwgZmllbGQsICIucG5nIikpDQogIA0KICAjIFlvdXIgZnVuY3Rpb24gdG8gcGxvdCBpbWFnZSBnb2VzIGhlcmUNCiAgY29ycnBsb3QoY29ycmVsYXRpb25fbWF0cml4X2ZpZWxkLCANCiAgICAgICAgICAgbWV0aG9kPSJudW1iZXIiLA0KICAgICAgICAgICB0bC5jb2wgPSAiYmxhY2siLA0KICAgICAgICAgICB0aXRsZSA9IHBhc3RlKCJWYXJpYWJsZSBDb3JyZWxhdGlvbiBNYXRyaXggLSBUb3RhbHMiLCBmaWVsZCksDQogICAgICAgICBtYXI9YygwLDAsMiwwKSkNCiAgIyBUaGVuDQogIGRldi5vZmYoKQ0KDQp9DQpgYGANCg0KTG9va2luZyBhdCB5ZWFyIG92ZXIgeWVhciBudW1iZXJzOg0KYGBge3J9DQpzZWxlY3RfdmFyc19jb3IgPC0gYygiY291bnRfcHVicyIsDQogICAgICAgICAgICAgICAgICAgICAiY2l0ZWRfYnkiLA0KICAgICAgICAgICAgICAgICAgICAgIm5ld3NfYWxsIiwNCiAgICAgICAgICAgICAgICAgICAgICJhbHRfb25saW5lX2FsbCIsDQogICAgICAgICAgICAgICAgICAgICAiYWx0X3R3aXR0ZXIiLA0KICAgICAgICAgICAgICAgICAgICAgImNvYV9jb3VudF9wdWJzIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfY2l0ZWRfYnkiLA0KICAgICAgICAgICAgICAgICAgICAgImNvYV9vbmxpbmVfYWxsIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfdHdpdHRlciIpDQoNCmNvcnJlbGF0aW9uX21hdHJpeCA8LSBjb3IocHJvZl9wYW5lbF9maWx0ZXJbLHNlbGVjdF92YXJzX2Nvcl0sdXNlPSJwYWlyd2lzZS5jb21wbGV0ZS5vYnMiKQ0KDQoNCmNvbG5hbWVzKGNvcnJlbGF0aW9uX21hdHJpeCkgPC0gbGFiZWxzX2NvclsxOjldDQpyb3duYW1lcyhjb3JyZWxhdGlvbl9tYXRyaXgpIDwtIGxhYmVsc19jb3JbMTo5XQ0KDQoNCnBuZyhoZWlnaHQ9MTAsIHdpZHRoPTEwLCANCiAgICB1bml0ID0gImluIiwgDQogICAgcmVzID0gNjAwLA0KICAgIGZpbGU9IlBsb3RzX2FwcmlsL1N1cHBsZW1lbnRhbC9jb3JyZWxhdGlvbnNfeWVhcmx5X292ZXJhbGwucG5nIikNCg0KIyBZb3VyIGZ1bmN0aW9uIHRvIHBsb3QgaW1hZ2UgZ29lcyBoZXJlDQpjb3JycGxvdChjb3JyZWxhdGlvbl9tYXRyaXgsIA0KICAgICAgICAgbWV0aG9kPSJudW1iZXIiLA0KICAgICAgICAgdGwuY29sID0gImJsYWNrIiwNCiAgICAgICAgIHRpdGxlID0gIlZhcmlhYmxlIENvcnJlbGF0aW9uIE1hdHJpeCAtIFllYXJseSwgQWxsIGZpZWxkcyIsDQogICAgICAgICBtYXI9YygwLDAsMiwwKSkNCiMgVGhlbg0KZGV2Lm9mZigpDQpgYGANCkFuZCBwZXIgZmllbGQ6DQpgYGB7cn0NCmZvciAoZmllbGQgaW4gZmllbGRzKXsNCiAgZmllbGRfZGF0YSA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIGdlbmVyYWxfZmllbGQgPT0gZmllbGQpDQogIA0KICBjb3JyZWxhdGlvbl9tYXRyaXhfZmllbGQgPC0gY29yKGZpZWxkX2RhdGFbLHNlbGVjdF92YXJzX2Nvcl0sdXNlPSJwYWlyd2lzZS5jb21wbGV0ZS5vYnMiKQ0KICANCiAgcm93bmFtZXMoY29ycmVsYXRpb25fbWF0cml4X2ZpZWxkKSA8LSBjb2xuYW1lcyhjb3JyZWxhdGlvbl9tYXRyaXhfZmllbGQpDQoNCiAgDQogIGNvbG5hbWVzKGNvcnJlbGF0aW9uX21hdHJpeF9maWVsZCkgPC0gbGFiZWxzX2NvclsxOjldDQogIHJvd25hbWVzKGNvcnJlbGF0aW9uX21hdHJpeF9maWVsZCkgPC0gbGFiZWxzX2NvclsxOjldDQogIA0KICANCiAgcG5nKGhlaWdodD0xMCwgd2lkdGg9MTAsIA0KICAgICAgdW5pdCA9ICJpbiIsIA0KICAgICAgcmVzID0gNjAwLA0KICAgICAgZmlsZT0gcGFzdGUwKCJQbG90c19hcHJpbC9TdXBwbGVtZW50YWwvY29ycmVsYXRpb25zX3llYXJseV8iLCBmaWVsZCwgIi5wbmciKSkNCiAgDQogICMgWW91ciBmdW5jdGlvbiB0byBwbG90IGltYWdlIGdvZXMgaGVyZQ0KICBjb3JycGxvdChjb3JyZWxhdGlvbl9tYXRyaXhfZmllbGQsIA0KICAgICAgICAgICBtZXRob2Q9Im51bWJlciIsDQogICAgICAgICAgIHRsLmNvbCA9ICJibGFjayIsDQogICAgICAgICAgIHRpdGxlID0gcGFzdGUoIlZhcmlhYmxlIENvcnJlbGF0aW9uIE1hdHJpeCAtIFllYXJseSwiLCBmaWVsZCksDQogICAgICAgICBtYXI9YygwLDAsMiwwKSkNCiAgIyBUaGVuDQogIGRldi5vZmYoKQ0KDQp9DQpgYGANCg0KDQojIyBOZXdzIGRhdGENCg0KSG93IG1hbnkgcHJvZmVzc29ycyBoYXZlIGF0IGxlYXN0IG9uZSBtZW50aW9uPw0KYGBge3J9DQpzb3VyY2VzX2NoZWNrJGFueV9uZXdzIDwtIGlmZWxzZShzb3VyY2VzX2NoZWNrJG5ld3NfYWxsX3RvdGFsID4gMCwgVFJVRSwgRkFMU0UpDQoNCnRhYmxlKHNvdXJjZXNfY2hlY2skYW55X25ld3MpDQpwcm9wLnRhYmxlKHRhYmxlKHNvdXJjZXNfY2hlY2skYW55X25ld3MpKQ0KYGBgDQo5NiUgb2YgcHJvZmVzc29ycyBpbiBvdXIgZGF0YSAtIDY0OTkgb2YgdGhlbSwgaGFzIGF0IGxlYXN0IG9uZSBuZXdzIG1lbnRpb24uDQoNCk9uIGF2ZXJhZ2UsIGEgcHJvZmVzc29yIGluIG91ciBkYXRhc2V0IGhhcyBhY2N1bXVsYXRlZCA2OC45IG1lbnRpb25zIHRocm91Z2hvdXQNCnRoZWlyIGNhcmVlcjoNCmBgYHtyfQ0KbWVhbihzb3VyY2VzX2NoZWNrJG5ld3NfYWxsX3RvdGFsLCBuYS5ybSA9IFRSVUUpDQpgYGANCk9yLCAyLjY1IG1lbnRpb25zIHBlciB5ZWFyOg0KYGBge3J9DQptZWFuKHByb2ZfcGFuZWxfZmlsdGVyJG5ld3NfYWxsYWxsLCBuYS5ybSA9IFRSVUUpDQpgYGANCg0KDQpCcmVha2Rvd24gYnkgbmV3cyBhcnRpY2xlIHR5cGU6DQpgYGB7ciwgZmlnLndpZHRoPTEyLCB3YXJuaW5nID0gRiwgbWVzc2FnZSA9IEZ9DQpuZXdzX3R5cGVfc291cmNlIDwtIHNvdXJjZXNfY2hlY2sgJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCBnZW5lcmFsX2ZpZWxkLCBlbnRyeV9iYXRjaF8yMDIzLCBpbmZlcnJlZF9nZW5kZXIsIG5ld3NfbmF0aW9uYWxfdG90YWw6bmV3c19pbnRsX3RvdGFsKQ0KI25ld3NfdHlwZSRuZXdzX2FsbF90b3RhbCA8LSByb3dTdW1zKG5ld3NfdHlwZVssIDU6OV0pDQpjb2xuYW1lcyhuZXdzX3R5cGVfc291cmNlKSA8LSBzdHJfcmVtb3ZlKHN0cl9yZW1vdmUoc3RyX3JlbW92ZShjb2xuYW1lcyhuZXdzX3R5cGVfc291cmNlKSwgIm5ld3NfIiksICJfdG90YWwiKSwgImxleGlzXyIpDQpjb2xuYW1lcyhuZXdzX3R5cGVfc291cmNlKVs1OjhdIDwtIGMoIk5hdGlvbmFsIG5ld3MiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJSZWdpb25hbCBuZXdzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiT3RoZXIgbmV3cyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkludGVybmF0aW9uYWwgbmV3cyIpDQoNCm5ld3NfdHlwZSA8LSBuZXdzX3R5cGVfc291cmNlICU+JQ0KICBwaXZvdF9sb25nZXIoY29scyA9IGMoYE5hdGlvbmFsIG5ld3NgOmBJbnRlcm5hdGlvbmFsIG5ld3NgKSklPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgaW5mZXJyZWRfZ2VuZGVyLCBuYW1lKSU+JQ0KICBzdW1tYXJpc2UoDQogICAgcHJvZnMgPSBuKCksDQogICAgc3VtID0gc3VtKHZhbHVlLCBuYS5ybSA9IFRSVUUpKSU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gaW5mZXJyZWRfZ2VuZGVyLCB2YWx1ZXNfZnJvbSA9IGMocHJvZnMsc3VtKSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCklPiUNCiAgbXV0YXRlKG1fcHJvcCA9IHJvdW5kKHN1bV9tL3N1bShzdW1fbSwgbmEucm0gPSBUUlVFKSwzKSwNCiAgICAgICAgIHdfcHJvcCA9IHJvdW5kKHN1bV93L3N1bShzdW1fdywgbmEucm0gPSBUUlVFKSwgMyksDQogICAgICAgICBtX2F2ZSA9IHJvdW5kKHN1bV9tL3Byb2ZzX20sIDMpLA0KICAgICAgICAgd19hdmUgPSByb3VuZChzdW1fdy9wcm9mc193LCAzKSkNCg0KbmV3c19vdmVyYWxsIDwtIG5ld3NfdHlwZV9zb3VyY2UgJT4lDQogIHBpdm90X2xvbmdlcihjb2xzID0gYyhgTmF0aW9uYWwgbmV3c2A6YEludGVybmF0aW9uYWwgbmV3c2ApKSU+JQ0KICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBncm91cF9ieShnZW5lcmFsX2ZpZWxkLCBpbmZlcnJlZF9nZW5kZXIpJT4lDQogIHN1bW1hcmlzZSgNCiAgICBwcm9mcyA9IG5fZGlzdGluY3QocHJvZmlsZV9pZCksDQogICAgc3VtID0gc3VtKHZhbHVlLCBuYS5ybSA9IFRSVUUpKSU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gaW5mZXJyZWRfZ2VuZGVyLCB2YWx1ZXNfZnJvbSA9IGMocHJvZnMsc3VtKSklPiUNCiAgbXV0YXRlKG1fcHJvcCA9IHJvdW5kKHN1bV9tL3N1bShzdW1fbSksMyksDQogICAgICAgICB3X3Byb3AgPSByb3VuZChzdW1fdy9zdW0oc3VtX3cpLCAzKSwNCiAgICAgICAgIG1fYXZlID0gcm91bmQoc3VtX20vcHJvZnNfbSwgMyksDQogICAgICAgICB3X2F2ZSA9IHJvdW5kKHN1bV93L3Byb2ZzX3csIDMpKQ0KDQpuZXdzX292ZXJhbGwkbmFtZSA8LSAiQWxsIG5ld3MiDQpuZXdzX292ZXJhbGwgPC0gbmV3c19vdmVyYWxsW2NvbG5hbWVzKG5ld3NfdHlwZSldDQoNCm5ld3NfdHlwZSA8LSByYmluZChuZXdzX3R5cGUsDQogICAgICAgICAgICAgICAgICAgbmV3c19vdmVyYWxsKQ0KDQpuZXdzX292ZXJhbGxfb3ZlcmFsbCA8LSBuZXdzX3R5cGVfc291cmNlICU+JQ0KICBwaXZvdF9sb25nZXIoY29scyA9IGMoYE5hdGlvbmFsIG5ld3NgOmBJbnRlcm5hdGlvbmFsIG5ld3NgKSklPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSklPiUNCiAgZ3JvdXBfYnkoaW5mZXJyZWRfZ2VuZGVyKSU+JQ0KICBzdW1tYXJpc2UoDQogICAgcHJvZnMgPSBuX2Rpc3RpbmN0KHByb2ZpbGVfaWQpLA0KICAgIHN1bSA9IHN1bSh2YWx1ZSwgbmEucm0gPSBUUlVFKSklPiUNCiAgcGl2b3Rfd2lkZXIobmFtZXNfZnJvbSA9IGluZmVycmVkX2dlbmRlciwgdmFsdWVzX2Zyb20gPSBjKHByb2ZzLHN1bSkpJT4lDQogIG11dGF0ZShtX3Byb3AgPSByb3VuZChzdW1fbS9zdW0oc3VtX20pLDMpLA0KICAgICAgICAgd19wcm9wID0gcm91bmQoc3VtX3cvc3VtKHN1bV93KSwgMyksDQogICAgICAgICBtX2F2ZSA9IHJvdW5kKHN1bV9tL3Byb2ZzX20sIDMpLA0KICAgICAgICAgd19hdmUgPSByb3VuZChzdW1fdy9wcm9mc193LCAzKSkNCg0KbmV3c19vdmVyYWxsX292ZXJhbGwkbmFtZSA8LSAiQWxsIG5ld3MiDQpuZXdzX292ZXJhbGxfb3ZlcmFsbCRnZW5lcmFsX2ZpZWxkIDwtICJBbGwgZmllbGRzIg0KbmV3c19vdmVyYWxsX292ZXJhbGwgPC0gbmV3c19vdmVyYWxsX292ZXJhbGxbY29sbmFtZXMobmV3c190eXBlKV0NCg0KbmV3c190eXBlIDwtIHJiaW5kKG5ld3NfdHlwZSwNCiAgICAgICAgICAgICAgICAgICBuZXdzX292ZXJhbGxfb3ZlcmFsbCkNCg0KDQpuZXdzX3R5cGUgPC0gbmV3c190eXBlICU+JQ0KICBhcnJhbmdlKGdlbmVyYWxfZmllbGQsIG5hbWUpJT4lDQogIHNlbGVjdChnZW5lcmFsX2ZpZWxkOnN1bV93LCBtX2F2ZSwgd19hdmUsIG1fcHJvcCwgd19wcm9wKQ0KDQpjb2xuYW1lcyhuZXdzX3R5cGUpIDwtIGMoIkZpZWxkIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiTmV3cyB0eXBlIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiTiBwcm9mZXNzb3JzIC0gbWVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiTiBwcm9mZXNzb3JzIC0gd29tZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJOZXdzIG1lbnRpb25zIC0gbWVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiTmV3cyBtZW50aW9ucyAtIHdvbWVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiQXZnLiBuZXdzIG1lbnRpb25zIC0gbWVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiQXZnLiBuZXdzIG1lbnRpb25zIC0gd29tZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJTaGFyZSBtZW50aW9ucyBwZXIgc291cmNlIC0gbWVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiU2hhcmUgbWVudGlvbnMgcGVyIHNvdXJjZSAtIHdvbWVuIikNCg0KIyBvdXRwdXQgdG8gcmVzdWx0cw0Kd3JpdGVfY3N2KG5ld3NfdHlwZSwgIlBsb3RzX2FwcmlsL1N1cHBsZW1lbnRhbC9UX25ld3Nfc291cmNlLmNzdiIpDQprbml0cjo6a2FibGUobmV3c190eXBlKQ0KYGBgDQoNCiMjIEFsdG1ldHJpYyBkYXRhDQoNCkhvdyBtYW55IHByb2Zlc3NvcnMgaGF2ZSBhdCBsZWFzdCBvbmUgbWVudGlvbj8NCmBgYHtyfQ0Kc291cmNlc19jaGVjayRhbnlfYWx0IDwtIGlmZWxzZShzb3VyY2VzX2NoZWNrJGFsdF9vbmxpbmVfYWxsX3RvdGFsID4gMCwgVFJVRSwgRkFMU0UpDQoNCnRhYmxlKHNvdXJjZXNfY2hlY2skYW55X2FsdCkNCnByb3AudGFibGUodGFibGUoc291cmNlc19jaGVjayRhbnlfYWx0KSkNCmBgYA0KNzglIG9mIHByb2Zlc3NvcnMgaW4gb3VyIGRhdGEgLSA1MzAxIG9mIHRoZW0sIGhhcyBhdCBsZWFzdCBvbmUgbmV3cyBtZW50aW9uLg0KDQpPbiBhdmVyYWdlLCBhIHByb2Zlc3NvciBpbiBvdXIgZGF0YXNldCBoYXMgYWNjdW11bGF0ZWQgMTAyLjcgb25saW5lIG1lbnRpb25zIHRocm91Z2hvdXQNCnRoZWlyIGNhcmVlcjoNCmBgYHtyfQ0KbWVhbihzb3VyY2VzX2NoZWNrJGFsdF9vbmxpbmVfYWxsX3RvdGFsLCBuYS5ybSA9IFRSVUUpDQpgYGANCk9yLCA4LjMgbWVudGlvbnMgcGVyIHllYXI6DQpgYGB7cn0NCm1lYW4ocHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9hbGwsIG5hLnJtID0gVFJVRSkNCmBgYA0KDQpDaGVjayB0aGUgYXZlcmFnZXMgYnJlYWtkb3duOg0KYGBge3IsIGZpZy53aWR0aD0xMiwgd2FybmluZyA9IEYsIG1lc3NhZ2UgPSBGfQ0Kb25saW5lX25ld3NfdHlwZV9zb3VyY2UgPC0gc291cmNlc19jaGVjayAlPiUNCiAgc2VsZWN0KHByb2ZpbGVfaWQsIGdlbmVyYWxfZmllbGQsIGVudHJ5X2JhdGNoXzIwMjMsIGluZmVycmVkX2dlbmRlciwgYWx0X25ld3NfYWdncmVnYXRvcl90b3RhbDphbHRfc2NpZW5jZV9uZXdzX3RvdGFsKQ0KI25ld3NfdHlwZSRuZXdzX2FsbF90b3RhbCA8LSByb3dTdW1zKG5ld3NfdHlwZVssIDU6OV0pDQpjb2xuYW1lcyhvbmxpbmVfbmV3c190eXBlX3NvdXJjZSkgPC0gc3RyX3JlbW92ZShzdHJfcmVtb3ZlKHN0cl9yZW1vdmUoY29sbmFtZXMob25saW5lX25ld3NfdHlwZV9zb3VyY2UpLCAiYWx0XyIpLCAiX3RvdGFsIiksICJsZXhpc18iKQ0KY29sbmFtZXMob25saW5lX25ld3NfdHlwZV9zb3VyY2UpWzU6MTRdIDwtIGMoIk5ld3MgYWdncmVnYXRvciIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIk9ubGluZSBibG9nIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiU2NpZW5jZSBuZXdzIGFnZ3JlZ2F0b3IiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJGaW5hbmNlIG5ld3MiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJHZW5lcmFsIGludGVyZXN0IC0gbG9jYWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJHZW5lcmFsIGludGVyZXN0IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTWVkaWNhbCBwb3J0YWxzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiT3RoZXIgbmV3cyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlBvcHVsYXIgc2NpZW5jZSBuZXdzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiU2NpZW5jZSBuZXdzIikNCg0Kb25saW5lX25ld3NfdHlwZSA8LSBvbmxpbmVfbmV3c190eXBlX3NvdXJjZSAlPiUNCiAgcGl2b3RfbG9uZ2VyKGNvbHMgPSBjKGBOZXdzIGFnZ3JlZ2F0b3JgOmBTY2llbmNlIG5ld3NgKSklPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgaW5mZXJyZWRfZ2VuZGVyLCBuYW1lKSU+JQ0KICBzdW1tYXJpc2UoDQogICAgcHJvZnMgPSBuKCksDQogICAgc3VtID0gc3VtKHZhbHVlLCBuYS5ybSA9IFRSVUUpKSU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gaW5mZXJyZWRfZ2VuZGVyLCB2YWx1ZXNfZnJvbSA9IGMocHJvZnMsc3VtKSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCklPiUNCiAgbXV0YXRlKG1fcHJvcCA9IHJvdW5kKHN1bV9tL3N1bShzdW1fbSksMyksDQogICAgICAgICB3X3Byb3AgPSByb3VuZChzdW1fdy9zdW0oc3VtX3cpLCAzKSwNCiAgICAgICAgIG1fYXZlID0gcm91bmQoc3VtX20vcHJvZnNfbSwgMyksDQogICAgICAgICB3X2F2ZSA9IHJvdW5kKHN1bV93L3Byb2ZzX3csIDMpKQ0KDQpvbmxpbmVfbmV3c19vdmVyYWxsIDwtIG9ubGluZV9uZXdzX3R5cGVfc291cmNlICU+JQ0KICBwaXZvdF9sb25nZXIoY29scyA9IGMoYE5ld3MgYWdncmVnYXRvcmA6YFNjaWVuY2UgbmV3c2ApKSU+JQ0KICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBncm91cF9ieShnZW5lcmFsX2ZpZWxkLCBpbmZlcnJlZF9nZW5kZXIpJT4lDQogIHN1bW1hcmlzZSgNCiAgICBwcm9mcyA9IG5fZGlzdGluY3QocHJvZmlsZV9pZCksDQogICAgc3VtID0gc3VtKHZhbHVlLCBuYS5ybSA9IFRSVUUpKSU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gaW5mZXJyZWRfZ2VuZGVyLCB2YWx1ZXNfZnJvbSA9IGMocHJvZnMsc3VtKSklPiUNCiAgbXV0YXRlKG1fcHJvcCA9IHJvdW5kKHN1bV9tL3N1bShzdW1fbSksMyksDQogICAgICAgICB3X3Byb3AgPSByb3VuZChzdW1fdy9zdW0oc3VtX3cpLCAzKSwNCiAgICAgICAgIG1fYXZlID0gcm91bmQoc3VtX20vcHJvZnNfbSwgMyksDQogICAgICAgICB3X2F2ZSA9IHJvdW5kKHN1bV93L3Byb2ZzX3csIDMpKQ0KDQpvbmxpbmVfbmV3c19vdmVyYWxsJG5hbWUgPC0gIkFsbCBuZXdzIg0Kb25saW5lX25ld3Nfb3ZlcmFsbCA8LSBvbmxpbmVfbmV3c19vdmVyYWxsW2NvbG5hbWVzKG9ubGluZV9uZXdzX3R5cGUpXQ0KDQpvbmxpbmVfbmV3c190eXBlIDwtIHJiaW5kKG9ubGluZV9uZXdzX3R5cGUsDQogICAgICAgICAgICAgICAgICAgb25saW5lX25ld3Nfb3ZlcmFsbCkNCg0Kb25saW5lX25ld3Nfb3ZlcmFsbF9vdmVyYWxsIDwtIG9ubGluZV9uZXdzX3R5cGVfc291cmNlICU+JQ0KICBwaXZvdF9sb25nZXIoY29scyA9IGMoYE5ld3MgYWdncmVnYXRvcmA6YFNjaWVuY2UgbmV3c2ApKSU+JQ0KICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBncm91cF9ieShpbmZlcnJlZF9nZW5kZXIpJT4lDQogIHN1bW1hcmlzZSgNCiAgICBwcm9mcyA9IG5fZGlzdGluY3QocHJvZmlsZV9pZCksDQogICAgc3VtID0gc3VtKHZhbHVlLCBuYS5ybSA9IFRSVUUpKSU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gaW5mZXJyZWRfZ2VuZGVyLCB2YWx1ZXNfZnJvbSA9IGMocHJvZnMsc3VtKSklPiUNCiAgbXV0YXRlKG1fcHJvcCA9IHJvdW5kKHN1bV9tL3N1bShzdW1fbSksMyksDQogICAgICAgICB3X3Byb3AgPSByb3VuZChzdW1fdy9zdW0oc3VtX3cpLCAzKSwNCiAgICAgICAgIG1fYXZlID0gcm91bmQoc3VtX20vcHJvZnNfbSwgMyksDQogICAgICAgICB3X2F2ZSA9IHJvdW5kKHN1bV93L3Byb2ZzX3csIDMpKQ0KDQpvbmxpbmVfbmV3c19vdmVyYWxsX292ZXJhbGwkbmFtZSA8LSAiQWxsIG5ld3MiDQpvbmxpbmVfbmV3c19vdmVyYWxsX292ZXJhbGwkZ2VuZXJhbF9maWVsZCA8LSAiQWxsIGZpZWxkcyINCm9ubGluZV9uZXdzX292ZXJhbGxfb3ZlcmFsbCA8LSBvbmxpbmVfbmV3c19vdmVyYWxsX292ZXJhbGxbY29sbmFtZXMob25saW5lX25ld3NfdHlwZSldDQoNCm9ubGluZV9uZXdzX3R5cGUgPC0gcmJpbmQob25saW5lX25ld3NfdHlwZSwNCiAgICAgICAgICAgICAgICAgICBvbmxpbmVfbmV3c19vdmVyYWxsX292ZXJhbGwpDQoNCm9ubGluZV9uZXdzX3R5cGUgPC0gb25saW5lX25ld3NfdHlwZSAlPiUNCiAgYXJyYW5nZShnZW5lcmFsX2ZpZWxkLCBuYW1lKSU+JQ0KICBzZWxlY3QoZ2VuZXJhbF9maWVsZDpzdW1fdywgbV9hdmUsIHdfYXZlLCBtX3Byb3AsIHdfcHJvcCkNCg0KY29sbmFtZXMob25saW5lX25ld3NfdHlwZSkgPC0gYygiRmllbGQiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJOZXdzIHR5cGUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJOIHByb2Zlc3NvcnMgLSBtZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJOIHByb2Zlc3NvcnMgLSB3b21lbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIk5ld3MgbWVudGlvbnMgLSBtZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJOZXdzIG1lbnRpb25zIC0gd29tZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJBdmcuIG5ld3MgbWVudGlvbnMgLSBtZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJBdmcuIG5ld3MgbWVudGlvbnMgLSB3b21lbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIlNoYXJlIG1lbnRpb25zIHBlciBzb3VyY2UgLSBtZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJTaGFyZSBtZW50aW9ucyBwZXIgc291cmNlIC0gd29tZW4iKQ0KDQojIG91dHB1dCB0byByZXN1bHRzDQp3cml0ZV9jc3Yob25saW5lX25ld3NfdHlwZSwgIlBsb3RzX2FwcmlsL1N1cHBsZW1lbnRhbC9UX29ubGluZV9uZXdzX3NvdXJjZS5jc3YiKQ0Ka25pdHI6OmthYmxlKG9ubGluZV9uZXdzX3R5cGUpDQpgYGANCg0KIyMgVHdpdHRlciBkYXRhDQoNCkhvdyBtYW55IHByb2Zlc3NvcnMgaGF2ZSBhdCBsZWFzdCBvbmUgbWVudGlvbj8NCmBgYHtyfQ0Kc291cmNlc19jaGVjayRhbnlfYWx0IDwtIGlmZWxzZShzb3VyY2VzX2NoZWNrJGFsdF90d2l0dGVyID4gMCwgVFJVRSwgRkFMU0UpDQoNCnRhYmxlKHNvdXJjZXNfY2hlY2skYW55X2FsdCkNCnByb3AudGFibGUodGFibGUoc291cmNlc19jaGVjayRhbnlfYWx0KSkNCmBgYA0KNzglIG9mIHByb2Zlc3NvcnMgaW4gb3VyIGRhdGEgLSA1MzAxIG9mIHRoZW0sIGhhcyBhdCBsZWFzdCBvbmUgbmV3cyBtZW50aW9uLg0KDQpPbiBhdmVyYWdlLCBhIHByb2Zlc3NvciBpbiBvdXIgZGF0YXNldCBoYXMgYWNjdW11bGF0ZWQgMTAyLjcgb25saW5lIG1lbnRpb25zIHRocm91Z2hvdXQNCnRoZWlyIGNhcmVlcjoNCmBgYHtyfQ0KbWVhbihzb3VyY2VzX2NoZWNrJGFsdF9vbmxpbmVfYWxsX3RvdGFsLCBuYS5ybSA9IFRSVUUpDQpgYGANCk9yLCA4LjMgbWVudGlvbnMgcGVyIHllYXI6DQpgYGB7cn0NCm1lYW4ocHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9hbGwsIG5hLnJtID0gVFJVRSkNCmBgYA0KDQpgYGB7ciwgZmlnLndpZHRoPTEyLCB3YXJuaW5nID0gRiwgbWVzc2FnZSA9IEZ9DQp0d2l0dGVyX3R5cGVfc291cmNlIDwtIHNvdXJjZXNfY2hlY2sgJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCBnZW5lcmFsX2ZpZWxkLCBlbnRyeV9iYXRjaF8yMDIzLCBpbmZlcnJlZF9nZW5kZXIsIGFsdF90d2l0dGVyX3RvdGFsKQ0KI25ld3NfdHlwZSRuZXdzX2FsbF90b3RhbCA8LSByb3dTdW1zKG5ld3NfdHlwZVssIDU6OV0pDQpjb2xuYW1lcyh0d2l0dGVyX3R5cGVfc291cmNlKSA8LSBzdHJfcmVtb3ZlKHN0cl9yZW1vdmUoc3RyX3JlbW92ZShjb2xuYW1lcyh0d2l0dGVyX3R5cGVfc291cmNlKSwgImFsdF8iKSwgIl90b3RhbCIpLCAibGV4aXNfIikNCmNvbG5hbWVzKHR3aXR0ZXJfdHlwZV9zb3VyY2UpWzVdIDwtIGMoIlR3aXR0ZXIiKQ0KDQp0d2l0dGVyX3R5cGUgPC0gdHdpdHRlcl90eXBlX3NvdXJjZSAlPiUNCiAgcGl2b3RfbG9uZ2VyKGNvbHMgPSBjKGBUd2l0dGVyYCkpJT4lDQogIGZpbHRlcighaXMubmEoZ2VuZXJhbF9maWVsZCkpJT4lDQogIGdyb3VwX2J5KGdlbmVyYWxfZmllbGQsIGluZmVycmVkX2dlbmRlciklPiUNCiAgc3VtbWFyaXNlKA0KICAgIHByb2ZzID0gbigpLA0KICAgIHN1bSA9IHN1bSh2YWx1ZSwgbmEucm0gPSBUUlVFKSklPiUNCiAgcGl2b3Rfd2lkZXIobmFtZXNfZnJvbSA9IGluZmVycmVkX2dlbmRlciwgdmFsdWVzX2Zyb20gPSBjKHByb2ZzLHN1bSkpJT4lDQogIGdyb3VwX2J5KGdlbmVyYWxfZmllbGQpJT4lDQogIG11dGF0ZShtX3Byb3AgPSByb3VuZChzdW1fbS9zdW0oc3VtX20pLDMpLA0KICAgICAgICAgd19wcm9wID0gcm91bmQoc3VtX3cvc3VtKHN1bV93KSwgMyksDQogICAgICAgICBtX2F2ZSA9IHJvdW5kKHN1bV9tL3Byb2ZzX20sIDMpLA0KICAgICAgICAgd19hdmUgPSByb3VuZChzdW1fdy9wcm9mc193LCAzKSkNCg0KdHdpdHRlcl9vdmVyYWxsIDwtIHR3aXR0ZXJfdHlwZV9zb3VyY2UgJT4lDQogIHBpdm90X2xvbmdlcihjb2xzID0gYyhgVHdpdHRlcmApKSU+JQ0KICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBncm91cF9ieShpbmZlcnJlZF9nZW5kZXIpJT4lDQogIHN1bW1hcmlzZSgNCiAgICBwcm9mcyA9IG5fZGlzdGluY3QocHJvZmlsZV9pZCksDQogICAgc3VtID0gc3VtKHZhbHVlLCBuYS5ybSA9IFRSVUUpKSU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gaW5mZXJyZWRfZ2VuZGVyLCB2YWx1ZXNfZnJvbSA9IGMocHJvZnMsc3VtKSklPiUNCiAgbXV0YXRlKG1fcHJvcCA9IHJvdW5kKHN1bV9tL3N1bShzdW1fbSksMyksDQogICAgICAgICB3X3Byb3AgPSByb3VuZChzdW1fdy9zdW0oc3VtX3cpLCAzKSwNCiAgICAgICAgIG1fYXZlID0gcm91bmQoc3VtX20vcHJvZnNfbSwgMyksDQogICAgICAgICB3X2F2ZSA9IHJvdW5kKHN1bV93L3Byb2ZzX3csIDMpKQ0KDQp0d2l0dGVyX292ZXJhbGwkZ2VuZXJhbF9maWVsZCA8LSAiQWxsIGZpZWxkcyINCnR3aXR0ZXJfb3ZlcmFsbCA8LSB0d2l0dGVyX292ZXJhbGxbY29sbmFtZXModHdpdHRlcl90eXBlKV0NCg0KdHdpdHRlcl90eXBlIDwtIHJiaW5kKHR3aXR0ZXJfdHlwZSwNCiAgICAgICAgICAgICAgICAgICB0d2l0dGVyX292ZXJhbGwpDQoNCiMgb3V0cHV0IHRvIHJlc3VsdHMNCndyaXRlX2Nzdih0d2l0dGVyX3R5cGUsICJQbG90c19hcHJpbC9TdXBwbGVtZW50YWwvVF90d2l0dGVyLmNzdiIpDQprbml0cjo6a2FibGUodHdpdHRlcl90eXBlKQ0KYGBgDQoNCg0KIyBXb21lbidzIHJlcHJlc2VudGF0aW9uIGFjcm9zcyB0aGUgYm9hcmQNCg0KRmlyc3QsIGdldCByZXByZXNlbnRhdGlvbiBwZXIgZmllbGQgaW4gb3VyIGRhdGFzZXQ6DQooPyBwcm9mZXNzb3JzKQ0KYGBge3J9DQpyZXByX2ZpZWxkXzIwMjMgPC0gcHJvZl9wYW5lbF9maWx0ZXIgJT4lDQogIGdyb3VwX2J5KHByb2ZpbGVfaWQpJT4lDQogIGZpbHRlcih5ZWFyID09IG1heCh5ZWFyKSklPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgaW5mZXJyZWRfZ2VuZGVyKSU+JQ0KICBzdW1tYXJpc2UobiA9IG4oKSklPiUNCiAgcGl2b3Rfd2lkZXIodmFsdWVzX2Zyb20gPSBuLCBuYW1lc19mcm9tID0gaW5mZXJyZWRfZ2VuZGVyKQ0KDQpyZXByX2ZpZWxkXzIwMjMkc2hhcmVfd29tZW5fZmllbGQgPC0gcmVwcl9maWVsZF8yMDIzJHcvKHJlcHJfZmllbGRfMjAyMyRtK3JlcHJfZmllbGRfMjAyMyR3KQ0KDQpgYGANCg0KTm93IGdldCB0aGUgcmVwcmVzZW50YXRpb24gb2Ygd29tZW4gYW1vbmcgdGhlIHRvcCAxMCUgYW5kIDIwJSBvZiByZXNlYXJjaGVycyBpbiB0ZXJtcw0Kb2YgdG90YWwgZmFtZSBpbiB0aGVpciBmaWVsZCBpbiAyMDIzIChiYXNlZCBvbiB0aGVpciBlbnRyeSBiYXRjaCk6DQpgYGB7cn0NCiMgZmlyc3QsIGdldCB0aGUgbGF0ZXN0IHllYXIgaW4gdGhlIHBhbmVsIGZvciBlYWNoIHByb2YNCndvbWVuX2ZpZWxkXzIwMjMgPC0gcHJvZl9wYW5lbF9maWx0ZXIgJT4lDQogIGdyb3VwX2J5KHByb2ZpbGVfaWQpJT4lDQogIGZpbHRlcih5ZWFyID09IG1heCh5ZWFyKSkNCg0KIyBhbmQgbm93IHNldCB0aGUgZmluYWwgeWVhciBhcyAyMDIzLCBhc3N1bWluZyB0aGVyZSB3YXMgbm8gYXR0ZW50aW9uIGFmdGVyDQojIHdoYXRldmVyIHRoZSBsYXN0IHllYXIgaXMgaW4gdGhlIGRhdGFzZXQgKHF1aXRlIHNvbWUgcHJvZmVzc29ycyB3aXRoDQojIDAgbWVudGlvbnMgZXZlbiBpbiB0aGlzIGxhc3QgeWVhciwgc28gd2Ugd2FudCB0byBrZWVwIHRoZW0gZm9yIGNvcnJlY3QNCiMgc2hhcmVzKQ0Kd29tZW5fZmllbGRfMjAyMyR5ZWFyIDwtIDIwMjMNCg0KIyBnZXQgdGhlaXIgZGVjaWxlIGJhc2VkIG9uIHRoZWlyIHRvdGFsIHBlcmZvcm1hbmNlIHdpdGhpbiB0aGVpciBlbnRyeSBiYXRjaA0Kd29tZW5fZmllbGRfMjAyMyA8LSB3b21lbl9maWVsZF8yMDIzICU+JQ0KICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZCwgeWVhciwgaW5mZXJyZWRfZ2VuZGVyLCBnZW5lcmFsX2ZpZWxkLCBlbnRyeV9iYXRjaF8yMDIzLCBjb3VudF9wdWJzX3RvdGFsLA0KICAgICAgICAgY2l0ZWRfYnlfdG90YWxfYWxsLCBhbHRfb25saW5lX2FsbF90b3RhbCwgbmV3c19hbGxfdG90YWwsIGFsdF90d2l0dGVyX3RvdGFsKSU+JQ0KICByZXBsYWNlKGlzLm5hKC4pLCAwKSU+JQ0KICBncm91cF9ieShnZW5lcmFsX2ZpZWxkLCBlbnRyeV9iYXRjaF8yMDIzKSU+JQ0KICBtdXRhdGUoDQogICAgICAgICBgUHVibGljYXRpb25zYCA9IG50aWxlKC1jb3VudF9wdWJzX3RvdGFsLCAyMCksDQogICAgICAgICBgQ2l0YXRpb25zYCA9IG50aWxlKC1jaXRlZF9ieV90b3RhbF9hbGwsIDIwKSwgICAgDQogICAgICAgICBgT25saW5lIG5ld3NgID0gbnRpbGUoLWFsdF9vbmxpbmVfYWxsX3RvdGFsLCAyMCksDQogICAgICAgICBgTmV3c2AgPSBudGlsZSgtbmV3c19hbGxfdG90YWwsIDIwKSwNCiAgICAgICAgIGBUd2l0dGVyYCA9IG50aWxlKC1hbHRfdHdpdHRlcl90b3RhbCwgMjApKQ0KYGBgDQoNCiMjIyAlIHdvbWVuIGFtb25nIHNjaWVudGlzdHMgaW4gdG9wIG4lDQpHZXQgc2hhcmVzIG9mIHdvbWVuIGFtb25nIHRvcCBuJSBzY2llbnRpc3RzIHBlciBhdHRlbnRpb24gZG9tYWluOg0KYGBge3J9DQojIHJlYXJyYW5nZSB0aGUgZGF0YXNldCB0byBnZXQgY291bnRzIG9mIHdvbWVuIGFuZCBtZW4gaW4gZWFjaCBkZWNpbGUNCiMgdGhlbiBsZWF2ZSBvbmx5IHRvcCAxMCBhbmQgMjANCnNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMgPC0gd29tZW5fZmllbGRfMjAyMyAlPiUNCiAgdW5ncm91cCgpJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCB5ZWFyLCBpbmZlcnJlZF9nZW5kZXIsIGdlbmVyYWxfZmllbGQsIGBQdWJsaWNhdGlvbnNgOmBUd2l0dGVyYCklPiUNCiAgcGl2b3RfbG9uZ2VyKGBQdWJsaWNhdGlvbnNgOmBUd2l0dGVyYCklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgaW5mZXJyZWRfZ2VuZGVyLCBuYW1lLCB2YWx1ZSklPiUNCiAgc3VtbWFyaXNlKG4gPSBuKCkpJT4lDQogIHBpdm90X3dpZGVyKHZhbHVlc19mcm9tID0gbiwgbmFtZXNfZnJvbSA9IGluZmVycmVkX2dlbmRlciklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgbmFtZSklPiUNCiAgbXV0YXRlKG0gPSBjdW1zdW0obSksDQogICAgICAgICB3ID0gY3Vtc3VtKHcpKSU+JQ0KICBmaWx0ZXIodmFsdWUgJWluJSBjKDEsIDIsIDMsIDQpKQ0KIA0Kc2hhcmVfd29tZW5fZmllbGRfMjAyMyRzaGFyZV93b21lbiA8LSBzaGFyZV93b21lbl9maWVsZF8yMDIzJHcvKHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMkbStzaGFyZV93b21lbl9maWVsZF8yMDIzJHcpIA0KYGBgDQpDb21iaW5lIHRoZSBmaWVsZCByZXByZXNlbnRhdGlvbiB3aXRoIHRoZSBhdHRlbnRpb24gcmVwcmVzZW50YXRpb246DQpgYGB7cn0NCnJlcHJfZmllbGRfMjAyMyRuYW1lIDwtICJvdmVyYWxsIg0KcmVwcl9maWVsZF8yMDIzJHZhbHVlIDwtIDANCg0KcmVwcl9maWVsZF8yMDIzIDwtIHJlcHJfZmllbGRfMjAyM1tjKGNvbG5hbWVzKHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMpWzE6NV0sInNoYXJlX3dvbWVuX2ZpZWxkIildDQoNCnNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMgPC0gbWVyZ2Uoc2hhcmVfd29tZW5fZmllbGRfMjAyMywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwcl9maWVsZF8yMDIzW2MoImdlbmVyYWxfZmllbGQiLCAic2hhcmVfd29tZW5fZmllbGQiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gImdlbmVyYWxfZmllbGQiKQ0KDQpzaGFyZV93b21lbl9maWVsZF8yMDIzJHNoYXJlX3dvbWVuX2ZpZWxkIDwtIGlmZWxzZShzaGFyZV93b21lbl9maWVsZF8yMDIzJG5hbWUgPT0gIk5ld3MiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVfd29tZW5fZmllbGRfMjAyMyRzaGFyZV93b21lbl9maWVsZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5BKQ0KYGBgDQoNClBsb3QgdGhpcyBvdXQ6DQoNClRvcCAxMCU6DQpgYGB7ciB3YXJuaW5nID0gRn0NCnJlcHJfYXR0bl81IDwtIHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMgJT4lDQogIGZpbHRlcih2YWx1ZSA9PSAxICYgbmFtZSAlaW4lIGMoIk5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlciIpKSU+JQ0KICBnZ3Bsb3QoYWVzKHk9c2hhcmVfd29tZW4sIHg9Z2VuZXJhbF9maWVsZCkpICsgDQogIGdlb21fcG9pbnQoYWVzKHNoYXBlPW5hbWUsIGNvbG9yPW5hbWUpLCBwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSh3aWR0aD0wLjIpLCBzdGF0PSJpZGVudGl0eSIsIHNpemUgPSAyLjUpKw0KICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIGFlcyh5PXNoYXJlX3dvbWVuX2ZpZWxkLCB4PWdlbmVyYWxfZmllbGQpLCBhbHBoYT0wLjIsIHdpZHRoID0gMC40KSsNCiAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZT1UUlVFLCB0aXRsZSA9ICJNZWFzdXJlIikpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzPWMoMCwgMC41KSkrDQogIGNvb3JkX2ZsaXAoKSsNCiAgeGxhYigiIikrDQogIHlsYWIoIiUgV29tZW4iKSsNCiAgbGFicyhjb2xvciA9ICJBdHRlbnRpb24gdHlwZSIsDQogICAgICAgc2hhcGUgPSAiQXR0ZW50aW9uIHR5cGUiKSsNCiAgZ2d0aXRsZSgiKGEpIHRvcCA1JSBvZiBhdHRlbnRpb24gZG9tYWlucyIpKw0KICB0aGVtZV9taW5pbWFsX3ZncmlkKCkrDQogIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgIGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCkgLA0KICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTExKSwgDQogICAgICAgIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTEwKSkNCg0KcmVwcl9hdHRuXzEwIDwtIHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMgJT4lDQogIGZpbHRlcih2YWx1ZSA9PSAyICYgbmFtZSAlaW4lIGMoIk5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlciIpKSU+JQ0KICBnZ3Bsb3QoYWVzKHk9c2hhcmVfd29tZW4sIHg9Z2VuZXJhbF9maWVsZCkpICsgDQogIGdlb21fcG9pbnQoYWVzKHNoYXBlPW5hbWUsIGNvbG9yPW5hbWUpLCBwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSh3aWR0aD0wLjIpLCBzdGF0PSJpZGVudGl0eSIsIHNpemUgPSAyLjUpKw0KICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIGFlcyh5PXNoYXJlX3dvbWVuX2ZpZWxkLCB4PWdlbmVyYWxfZmllbGQpLCBhbHBoYT0wLjIsIHdpZHRoID0gMC40KSsNCiAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZT1UUlVFLCB0aXRsZSA9ICJNZWFzdXJlIikpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzPWMoMCwgMC41KSkrDQogIGNvb3JkX2ZsaXAoKSsNCiAgeGxhYigiIikrDQogIHlsYWIoIiUgV29tZW4iKSsNCiAgbGFicyhjb2xvciA9ICJBdHRlbnRpb24gdHlwZSIsDQogICAgICAgc2hhcGUgPSAiQXR0ZW50aW9uIHR5cGUiKSsNCiAgZ2d0aXRsZSgiKGIpIHRvcCAxMCUgb2YgYXR0ZW50aW9uIGRvbWFpbnMiKSsNCiAgdGhlbWVfbWluaW1hbF92Z3JpZCgpKw0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApICwNCiAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgIGxlZ2VuZC50aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xMSksIA0KICAgICAgICBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT0xMCkpDQoNCnJlcHJfYXR0bl8xNSA8LSBzaGFyZV93b21lbl9maWVsZF8yMDIzICU+JQ0KICBmaWx0ZXIodmFsdWUgPT0gMyAmIG5hbWUgJWluJSBjKCJOZXdzIiwgIk9ubGluZSBuZXdzIiwgIlR3aXR0ZXIiKSklPiUNCiAgZ2dwbG90KGFlcyh5PXNoYXJlX3dvbWVuLCB4PWdlbmVyYWxfZmllbGQpKSArIA0KICAgIGdlb21fcG9pbnQoYWVzKHNoYXBlPW5hbWUsIGNvbG9yPW5hbWUpLCBwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSh3aWR0aD0wLjIpLCBzdGF0PSJpZGVudGl0eSIsIHNpemUgPSAyLjUpKw0KICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIGFlcyh5PXNoYXJlX3dvbWVuX2ZpZWxkLCB4PWdlbmVyYWxfZmllbGQpLCBhbHBoYT0wLjIsIHdpZHRoID0gMC40KSsNCiAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZT1UUlVFLCB0aXRsZSA9ICJNZWFzdXJlIikpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzPWMoMCwgMC41KSkrDQogIGNvb3JkX2ZsaXAoKSsNCiAgeGxhYigiIikrDQogIHlsYWIoIiUgV29tZW4iKSsNCiAgbGFicyhjb2xvciA9ICJBdHRlbnRpb24gdHlwZSIsDQogICAgICAgc2hhcGUgPSAiQXR0ZW50aW9uIHR5cGUiKSsNCiAgZ2d0aXRsZSgiKGMpIHRvcCAxNSUgb2YgYXR0ZW50aW9uIGRvbWFpbnMiKSsNCiAgdGhlbWVfbWluaW1hbF92Z3JpZCgpKw0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApICwNCiAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgIGxlZ2VuZC50aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xMSksIA0KICAgICAgICBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT0xMCkpDQoNCnJlcHJfYXR0bl8yMCA8LSBzaGFyZV93b21lbl9maWVsZF8yMDIzICU+JQ0KICBmaWx0ZXIodmFsdWUgPT0gNCAmIG5hbWUgJWluJSBjKCJOZXdzIiwgIk9ubGluZSBuZXdzIiwgIlR3aXR0ZXIiKSklPiUNCiAgZ2dwbG90KGFlcyh5PXNoYXJlX3dvbWVuLCB4PWdlbmVyYWxfZmllbGQpKSArIA0KICAgIGdlb21fcG9pbnQoYWVzKHNoYXBlPW5hbWUsIGNvbG9yPW5hbWUpLCBwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSh3aWR0aD0wLjIpLCBzdGF0PSJpZGVudGl0eSIsIHNpemUgPSAyLjUpKw0KICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIGFlcyh5PXNoYXJlX3dvbWVuX2ZpZWxkLCB4PWdlbmVyYWxfZmllbGQpLCBhbHBoYT0wLjIsIHdpZHRoID0gMC40KSsNCiAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZT1UUlVFLCB0aXRsZSA9ICJNZWFzdXJlIikpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzPWMoMCwgMC41KSkrDQogIGNvb3JkX2ZsaXAoKSsNCiAgeGxhYigiIikrDQogIHlsYWIoIiUgV29tZW4iKSsNCiAgbGFicyhjb2xvciA9ICJBdHRlbnRpb24gdHlwZSIsDQogICAgICAgc2hhcGUgPSAiQXR0ZW50aW9uIHR5cGUiKSsNCiAgZ2d0aXRsZSgiKGQpIHRvcCAyMCUgb2YgYXR0ZW50aW9uIGRvbWFpbnMiKSsNCiAgdGhlbWVfbWluaW1hbF92Z3JpZCgpKw0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApICwNCiAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgIGxlZ2VuZC50aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xMSksIA0KICAgICAgICBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT0xMCkpDQpgYGANCg0KDQpQbG90IHRoZXNlIHR3byBuZXh0IHRvIGVhY2ggb3RoZXI6DQpgYGB7ciBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9NCwgd2FybmluZyA9IEZ9DQpsZWdlbmQgPC0gZ2V0X2xlZ2VuZCgNCiAgIyBjcmVhdGUgc29tZSBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgbGVnZW5kDQogIHJlcHJfYXR0bl8xMA0KKQ0KDQpjb21iaV9wbG90IDwtIGNvd3Bsb3Q6OnBsb3RfZ3JpZCgNCiAgICAgICAgICAgICAgICAgICAgcmVwcl9hdHRuXzEwICsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIikgKyBnZ3RpdGxlKCIoYSkgdG9wIDEwJSBvZiBhdHRlbnRpb24gZG9tYWlucyIpLA0KICAgICAgICAgICAgICAgICAgICByZXByX2F0dG5fMjAgKyB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUueT1lbGVtZW50X2JsYW5rKCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50ZXh0Lnk9ZWxlbWVudF9ibGFuaygpKStnZ3RpdGxlKCIoYikgdG9wIDIwJSBvZiBhdHRlbnRpb24gZG9tYWlucyIpLA0KICAgICAgICAgICAgICAgICAgICBsZWdlbmQsDQogICAgICAgICAgICAgICAgICAgIG5jb2wgPSAzLA0KICAgICAgICAgICAgICAgICAgICByZWxfd2lkdGhzID0gYygxLCAwLjgsIDAuMjIpKQ0KDQoNCmdnc2F2ZTIoDQogIGZpbGVuYW1lID0gIlBsb3RzX2FwcmlsL1Bsb3RfMS5wbmciLA0KICBwbG90ID0gY29tYmlfcGxvdCwNCiAgd2lkdGggPSAxMCwNCiAgaGVpZ2h0ID0gNCwNCiAgdW5pdHMgPSBjKCJpbiIpLA0KICBkcGkgPSAzMDAsDQogIGJnID0gIndoaXRlIg0KKQ0KDQpjb21iaV9wbG90DQpgYGANCg0KDQojIENvbXBhcmUgbWVhbnMgYW5kIGRpc3RyaWJ1dGlvbnMNCiMjIE1lYW5zIGNvbXBhcmlzb24NCg0KYGBge3J9DQpzb3VyY2VzX2NoZWNrIDwtIHNvdXJjZXNfY2hlY2slPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSkNCmBgYA0KDQojIyMgT3ZlcmFsbA0KYGBge3J9DQpvdmVyYWxsX2NvbXBhcmlzb25zIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNiwgbnJvdyA9IDEpKQ0KaSA8LSAxDQpvdmVyYWxsX2NvbXBhcmlzb25zW2ksIDFdIDwtICJvdmVyYWxsIg0Kb3ZlcmFsbF9jb21wYXJpc29uc1tpLCAyXSA8LSByb3VuZCh3aWxjb3gudGVzdChjb3VudF9wdWJzX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPXNvdXJjZXNfY2hlY2ssIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCm92ZXJhbGxfY29tcGFyaXNvbnNbaSwgM10gPC0gcm91bmQod2lsY294LnRlc3QoY2l0ZWRfYnlfdG90YWxfYWxsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPXNvdXJjZXNfY2hlY2ssIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCm92ZXJhbGxfY29tcGFyaXNvbnNbaSwgNF0gPC0gcm91bmQod2lsY294LnRlc3QobmV3c19hbGxfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9c291cmNlc19jaGVjaywgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0Kb3ZlcmFsbF9jb21wYXJpc29uc1tpLCA1XSA8LSByb3VuZCh3aWxjb3gudGVzdChhbHRfb25saW5lX2FsbF90b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1zb3VyY2VzX2NoZWNrLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQpvdmVyYWxsX2NvbXBhcmlzb25zW2ksIDZdIDwtIHJvdW5kKHdpbGNveC50ZXN0KGFsdF90d2l0dGVyX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPXNvdXJjZXNfY2hlY2ssIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCg0KY29sbmFtZXMob3ZlcmFsbF9jb21wYXJpc29ucykgPC0gIGMoImZpZWxkIiwgInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuZXdzX3RvdGFsIiwgIm9ubGluZV9uZXdzX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiKQ0KDQoNCm92ZXJhbGxfY29tcGFyaXNvbnMNCg0KbWVhbl92YWx1ZXMgPC0gc291cmNlc19jaGVjayAlPiUNCiAgZ3JvdXBfYnkoaW5mZXJyZWRfZ2VuZGVyKSU+JQ0KICBzdW1tYXJpc2UocHVic190b3RhbCA9IG1lYW4oY291bnRfcHVic190b3RhbCwgbmEucm0gPSBUUlVFKSwNCiAgICAgICAgICAgIGNpdGF0aW9uc190b3RhbCA9IG1lYW4oY2l0ZWRfYnlfdG90YWxfYWxsLCBuYS5ybSA9IFRSVUUpLA0KICAgICAgICAgICAgbmV3c190b3RhbCA9IG1lYW4obmV3c19hbGxfdG90YWwsIG5hLnJtID0gVFJVRSksDQogICAgICAgICAgICBvbmxpbmVfbmV3c190b3RhbCA9IG1lYW4oYWx0X29ubGluZV9hbGxfdG90YWwsIG5hLnJtID0gVFJVRSksDQogICAgICAgICAgICB0d2l0dGVyX3RvdGFsID0gIG1lYW4oYWx0X3R3aXR0ZXJfdG90YWwsIG5hLnJtID0gVFJVRSkpJT4lDQogIG11dGF0ZShhY3Jvc3MoMjo2LCBcKHgpIHJvdW5kKHgsIDEpKSkNCg0KbWVhbl92YWx1ZXMNCm92ZXJhbGxfY29tcGFyaXNvbnMNCmBgYA0KDQoNCiMjIyBXaXRoaW4gZmllbGRzDQoNCmBgYHtyfQ0KZmllbGRzIDwtIHVuaXF1ZShwcm9mX3BhbmVsX2ZpbHRlciRnZW5lcmFsX2ZpZWxkKQ0KZmllbGRzIDwtIGZpZWxkc1shaXMubmEoZmllbGRzKV0NCmZpZWxkX2NvbXBhcmlzb25zIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNywgbnJvdyA9IGxlbmd0aChmaWVsZHMpKSkNCg0KZm9yIChpIGluIDE6bGVuZ3RoKGZpZWxkcykpew0KICBmaWVsZCA8LSBmaWVsZHNbaV0NCiAgZGF0YSA8LSBmaWx0ZXIoc291cmNlc19jaGVjaywgDQogICAgICAgICAgICAgICAgIGdlbmVyYWxfZmllbGQgPT0gZmllbGQpDQogIGZpZWxkX2NvbXBhcmlzb25zW2ksIDFdIDwtIGZpZWxkDQogIGZpZWxkX2NvbXBhcmlzb25zW2ksIDJdIDwtIG5yb3coZGF0YSkNCiAgZmllbGRfY29tcGFyaXNvbnNbaSwgM10gPC0gcm91bmQod2lsY294LnRlc3QoY291bnRfcHVic190b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQogIGZpZWxkX2NvbXBhcmlzb25zW2ksIDRdIDwtIHJvdW5kKHdpbGNveC50ZXN0KGNpdGVkX2J5X3RvdGFsX2FsbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQogIGZpZWxkX2NvbXBhcmlzb25zW2ksIDVdIDwtIHJvdW5kKHdpbGNveC50ZXN0KG5ld3NfYWxsX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgZmllbGRfY29tcGFyaXNvbnNbaSwgNl0gPC0gcm91bmQod2lsY294LnRlc3QoYWx0X29ubGluZV9hbGxfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9jb21wYXJpc29uc1tpLCA3XSA8LSByb3VuZCh3aWxjb3gudGVzdChhbHRfdHdpdHRlcl90b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQp9DQoNCmNvbG5hbWVzKGZpZWxkX2NvbXBhcmlzb25zKSA8LSBjKCJmaWVsZCIsICJwcm9mcyIsICJwdWJzX3RvdGFsIiwgImNpdGF0aW9uc190b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmV3c190b3RhbCIsICJvbmxpbmVfbmV3c190b3RhbCIsICJ0d2l0dGVyX3RvdGFsIikNCmZpZWxkX2NvbXBhcmlzb25zDQpgYGANCg0KIyMjIFdpdGhpbiB5ZWFyIGdyb3Vwcw0KYGBge3J9DQp5ZWFyX2dyb3VwcyA8LSB1bmlxdWUoc291cmNlc19jaGVjayRlbnRyeV9iYXRjaF8yMDIzKQ0KeWVhcl9ncm91cHMgPC0geWVhcl9ncm91cHNbISB5ZWFyX2dyb3VwcyA9PSAidXAgdG8gTkEiXQ0KeWVhcnMgPC0gYygidXAgdG8gMTAiLCJ1cCB0byAyMCIsICJ1cCB0byAzMCIsICJ1cCB0byA0MCIsICJ1cCB0byA1MCIpDQp5ZWFyX2dyb3VwcyA8LSB5ZWFyX2dyb3Vwc1tvcmRlcihtYXRjaCh5ZWFyX2dyb3Vwcyx5ZWFycykpXQ0KeWVhcl9ncm91cHNfY29tcGFyaXNvbnMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSA3LCBucm93ID0gbGVuZ3RoKHllYXJfZ3JvdXBzKSkpDQoNCmZvciAoaSBpbiAxOmxlbmd0aCh5ZWFyX2dyb3Vwcykpew0KICB5ZWFyX2dyb3VwIDwtIHllYXJfZ3JvdXBzW2ldDQogIGRhdGEgPC0gZmlsdGVyKHNvdXJjZXNfY2hlY2ssIA0KICAgICAgICAgICAgICAgICBlbnRyeV9iYXRjaF8yMDIzID09IHllYXJfZ3JvdXApDQogIA0KICB5ZWFyX2dyb3Vwc19jb21wYXJpc29uc1tpLCAxXSA8LSB5ZWFyX2dyb3VwDQogIHllYXJfZ3JvdXBzX2NvbXBhcmlzb25zW2ksIDJdIDwtIG5yb3coZGF0YSkNCiAgeWVhcl9ncm91cHNfY29tcGFyaXNvbnNbaSwgM10gPC0gcm91bmQod2lsY294LnRlc3QoY291bnRfcHVic190b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2NvbXBhcmlzb25zW2ksIDRdIDwtIHJvdW5kKHdpbGNveC50ZXN0KGNpdGVkX2J5X3RvdGFsX2FsbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2NvbXBhcmlzb25zW2ksIDVdIDwtIHJvdW5kKHdpbGNveC50ZXN0KG5ld3NfYWxsX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgeWVhcl9ncm91cHNfY29tcGFyaXNvbnNbaSwgNl0gPC0gcm91bmQod2lsY294LnRlc3QoYWx0X29ubGluZV9hbGxfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICB5ZWFyX2dyb3Vwc19jb21wYXJpc29uc1tpLCA3XSA8LSByb3VuZCh3aWxjb3gudGVzdChhbHRfdHdpdHRlcl90b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQp9DQoNCmNvbG5hbWVzKHllYXJfZ3JvdXBzX2NvbXBhcmlzb25zKSA8LSBjKCJmaWVsZCIsICJwcm9mcyIsICJwdWJzX3RvdGFsIiwgImNpdGF0aW9uc190b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmV3c190b3RhbCIsICJvbmxpbmVfbmV3c190b3RhbCIsICJ0d2l0dGVyX3RvdGFsIikNCnllYXJfZ3JvdXBzX2NvbXBhcmlzb25zDQpgYGANCg0KDQojIyMgV2l0aGluIHllYXIgZ3JvdXBzIGFuZCBmaWVsZHMNCmBgYHtyIHdhcm5pbmcgPSBGfQ0KeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSA4LCBucm93ID0gbGVuZ3RoKHllYXJfZ3JvdXBzKSpsZW5ndGgoZmllbGRzKSkpDQpyb3dfaW5kZXggPC0gMA0KDQpmb3IgKGkgaW4gMTpsZW5ndGgoeWVhcl9ncm91cHMpKXsNCiAgeWVhcl9ncm91cCA8LSB5ZWFyX2dyb3Vwc1tpXQ0KICANCiAgZm9yIChqIGluIDE6bGVuZ3RoKGZpZWxkcykpew0KICAgIGZpZWxkIDwtIGZpZWxkc1tqXQ0KICAgIGRhdGEgPC0gZmlsdGVyKHNvdXJjZXNfY2hlY2ssIA0KICAgICAgICAgICAgICAgICAgIHllYXJzX3NpbmNlX2VudHJ5ID09IHllYXJfZ3JvdXAgJiBnZW5lcmFsX2ZpZWxkID09IGZpZWxkKQ0KICAgIA0KICAgIHdvbWVuIDwtIGZpbHRlcihkYXRhLCBpbmZlcnJlZF9nZW5kZXIgPT0gInciKQ0KICAgIG1lbiA8LSBmaWx0ZXIoZGF0YSwgaW5mZXJyZWRfZ2VuZGVyID09ICJtIikNCiAgICANCiAgICBpZiAobGVuZ3RoKHVuaXF1ZShkYXRhJGluZmVycmVkX2dlbmRlcikpICE9IDIpew0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDFdIDwtIHllYXJfZ3JvdXANCiAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAyXSA8LSBmaWVsZA0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDNdIDwtIG5yb3coZGF0YSkNCiAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA0XSA8LSBOQQ0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDVdIDwtIE5BDQogICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNl0gPC0gTkENCiAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA3XSA8LSBOQQ0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDhdIDwtIE5BDQogICAgfWVsc2V7DQogICAgICBpZiAobGVuZ3RoKHdoaWNoKGNvbFN1bXMoZGF0YVtjKCJhbHRfb25saW5lX2FsbF90b3RhbCIsICJuZXdzX2FsbF90b3RhbCIsICJhbHRfdHdpdHRlcl90b3RhbCIsICJjaXRlZF9ieV90b3RhbF9hbGwiLCAiY291bnRfcHVic190b3RhbCIpXSkgPT0gMCkpID4gMCl7DQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAxXSA8LSB5ZWFyX2dyb3VwDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAyXSA8LSBmaWVsZA0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgM10gPC0gbnJvdyhkYXRhKQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNF0gPC0gTkENCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDVdIDwtIE5BDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA2XSA8LSBOQQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgN10gPC0gTkENCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDhdIDwtIE5BDQogICAgICAgIA0KICAgICAgfWVsc2V7DQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAxXSA8LSB5ZWFyX2dyb3VwDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAyXSA8LSBmaWVsZA0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgM10gPC0gbnJvdyhkYXRhKQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNF0gPC0gcm91bmQod2lsY294LnRlc3QoY291bnRfcHVic190b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA1XSA8LSByb3VuZCh3aWxjb3gudGVzdChjaXRlZF9ieV90b3RhbF9hbGwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNl0gPC0gcm91bmQod2lsY294LnRlc3QobmV3c19hbGxfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgN10gPC0gcm91bmQod2lsY294LnRlc3QoYWx0X29ubGluZV9hbGxfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgOF0gPC0gcm91bmQod2lsY294LnRlc3QoYWx0X3R3aXR0ZXJfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICAgICAgfQ0KICAgIH0NCiAgfQ0KICByb3dfaW5kZXggPC0gcm93X2luZGV4ICsgNCANCn0NCg0KY29sbmFtZXMoeWVhcl9ncm91cHNfZmllbGRfY29tcGFyaXNvbnMpIDwtIGMoInllYXJfZ3JvdXAiLCAiZmllbGQiLCAicHJvZnMiLCAicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5ld3NfdG90YWwiLCAib25saW5lX25ld3NfdG90YWwiLCAidHdpdHRlcl90b3RhbCIpDQp5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29ucw0KYGBgDQoNCiMjIyBXcml0aW5nIHRoaXMgb3V0DQpgYGB7cn0NCndyaXRlX2NzdihvdmVyYWxsX2NvbXBhcmlzb25zLCAiUGxvdHNfYXByaWwvU3VwcGxlbWVudGFsL21lYW5fb3ZlcmFsbC5jc3YiKQ0Kd3JpdGVfY3N2KGZpZWxkX2NvbXBhcmlzb25zLCAiUGxvdHNfYXByaWwvU3VwcGxlbWVudGFsL21lYW5feWVhci5jc3YiKQ0Kd3JpdGVfY3N2KGZpZWxkX2NvbXBhcmlzb25zLCAiUGxvdHNfYXByaWwvU3VwcGxlbWVudGFsL21lYW5fZmllbGQuY3N2IikNCndyaXRlX2Nzdih5ZWFyX2dyb3Vwc19maWVsZF9jb21wYXJpc29ucywgIlBsb3RzX2FwcmlsL1N1cHBsZW1lbnRhbC9tZWFuX3llYXJfZmllbGQuY3N2IikNCmBgYA0KDQoNCiMjIERpc3RyaWJ1dGlvbnMgY29tcGFyaXNvbg0KDQojIyMgT3ZlcmFsbA0KYGBge3J9DQpvdmVyYWxsX2Rpc3RfY29tcGFyaXNvbnMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSA3LCBucm93ID0gMSkpDQppIDwtIDENCndvbWVuIDwtIGZpbHRlcihzb3VyY2VzX2NoZWNrLCBpbmZlcnJlZF9nZW5kZXIgPT0gInciKQ0KbWVuIDwtIGZpbHRlcihzb3VyY2VzX2NoZWNrLCBpbmZlcnJlZF9nZW5kZXIgPT0gIm0iKQ0KDQpvdmVyYWxsX2Rpc3RfY29tcGFyaXNvbnNbaSwgMV0gPC0gIm92ZXJhbGwiDQpvdmVyYWxsX2Rpc3RfY29tcGFyaXNvbnNbaSwgMl0gPC0gbnJvdyhwcm9mX3BhbmVsX2ZpbHRlcikNCm92ZXJhbGxfZGlzdF9jb21wYXJpc29uc1tpLCAzXSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJGNvdW50X3B1YnNfdG90YWwsIG1lbiRjb3VudF9wdWJzX3RvdGFsKSRwLnZhbHVlLCA1KQ0Kb3ZlcmFsbF9kaXN0X2NvbXBhcmlzb25zW2ksIDRdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kY2l0ZWRfYnlfdG90YWxfYWxsLCBtZW4kY2l0ZWRfYnlfdG90YWxfYWxsKSRwLnZhbHVlLCA1KQ0Kb3ZlcmFsbF9kaXN0X2NvbXBhcmlzb25zW2ksIDVdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kbmV3c19hbGxfdG90YWwsIG1lbiRuZXdzX2FsbF90b3RhbCkkcC52YWx1ZSwgNSkNCm92ZXJhbGxfZGlzdF9jb21wYXJpc29uc1tpLCA2XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJGFsdF9vbmxpbmVfYWxsX3RvdGFsLCBtZW4kYWx0X29ubGluZV9hbGxfdG90YWwpJHAudmFsdWUsIDUpDQpvdmVyYWxsX2Rpc3RfY29tcGFyaXNvbnNbaSwgN10gPC0gcm91bmQoa3MudGVzdCh3b21lbiRhbHRfdHdpdHRlcl90b3RhbCwgbWVuJGFsdF90d2l0dGVyX3RvdGFsKSRwLnZhbHVlLCA1KQ0KDQpjb2xuYW1lcyhvdmVyYWxsX2Rpc3RfY29tcGFyaXNvbnMpIDwtIGMoIm92ZXJhbGwiLCAicHJvZnMiLCAicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5ld3NfdG90YWwiLCAib25saW5lX25ld3NfdG90YWwiLCAidHdpdHRlcl90b3RhbCIpDQoNCg0Kb3ZlcmFsbF9kaXN0X2NvbXBhcmlzb25zDQpgYGANCg0KDQojIyMgV2l0aGluIGZpZWxkcw0KDQpgYGB7cn0NCmZpZWxkcyA8LSB1bmlxdWUoc291cmNlc19jaGVjayRnZW5lcmFsX2ZpZWxkKQ0KZmllbGRzIDwtIGZpZWxkc1shaXMubmEoZmllbGRzKV0NCmZpZWxkX2Rpc3RfY29tcGFyaXNvbnMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSA3LCBucm93ID0gbGVuZ3RoKGZpZWxkcykpKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgoZmllbGRzKSl7DQogIGZpZWxkIDwtIGZpZWxkc1tpXQ0KICBkYXRhIDwtIGZpbHRlcihzb3VyY2VzX2NoZWNrLCANCiAgICAgICAgICAgICAgICAgZ2VuZXJhbF9maWVsZCA9PSBmaWVsZCkNCiAgd29tZW4gPC0gZmlsdGVyKGRhdGEsIGluZmVycmVkX2dlbmRlciA9PSAidyIpDQogIG1lbiA8LSBmaWx0ZXIoZGF0YSwgaW5mZXJyZWRfZ2VuZGVyID09ICJtIikNCiAgDQogIGZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbaSwgMV0gPC0gZmllbGQNCiAgZmllbGRfZGlzdF9jb21wYXJpc29uc1tpLCAyXSA8LSBucm93KGRhdGEpDQogIGZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbaSwgM10gPC0gcm91bmQoa3MudGVzdCh3b21lbiRjb3VudF9wdWJzX3RvdGFsLCBtZW4kY291bnRfcHVic190b3RhbCkkcC52YWx1ZSwgNSkNCiAgZmllbGRfZGlzdF9jb21wYXJpc29uc1tpLCA0XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJGNpdGVkX2J5X3RvdGFsX2FsbCwgbWVuJGNpdGVkX2J5X3RvdGFsX2FsbCkkcC52YWx1ZSwgNSkNCiAgZmllbGRfZGlzdF9jb21wYXJpc29uc1tpLCA1XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJG5ld3NfYWxsX3RvdGFsLCBtZW4kbmV3c19hbGxfdG90YWwpJHAudmFsdWUsIDUpDQogIGZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbaSwgNl0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRhbHRfb25saW5lX2FsbF90b3RhbCwgbWVuJGFsdF9vbmxpbmVfYWxsX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9kaXN0X2NvbXBhcmlzb25zW2ksIDddIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kYWx0X3R3aXR0ZXJfdG90YWwsIG1lbiRhbHRfdHdpdHRlcl90b3RhbCkkcC52YWx1ZSwgNSkNCn0NCg0KY29sbmFtZXMoZmllbGRfZGlzdF9jb21wYXJpc29ucykgPC0gYygiZmllbGQiLCJwcm9mcyIsICJwdWJzX3RvdGFsIiwgImNpdGF0aW9uc190b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmV3c190b3RhbCIsICJvbmxpbmVfbmV3c190b3RhbCIsICJ0d2l0dGVyX3RvdGFsIikNCmZpZWxkX2Rpc3RfY29tcGFyaXNvbnMNCmBgYA0KDQojIyMgV2l0aGluIHllYXIgZ3JvdXBzDQpgYGB7cn0NCnllYXJfZ3JvdXBzIDwtIHVuaXF1ZShwcm9mX3BhbmVsX2ZpbHRlciRlbnRyeV9iYXRjaF8yMDIzKQ0KeWVhcl9ncm91cHMgPC0geWVhcl9ncm91cHNbISB5ZWFyX2dyb3VwcyA9PSAidXAgdG8gTkEiXQ0KeWVhcnMgPC0gYygidXAgdG8gMTAiLCJ1cCB0byAyMCIsICJ1cCB0byAzMCIsICJ1cCB0byA0MCIsICJ1cCB0byA1MCIpDQp5ZWFyX2dyb3VwcyA8LSB5ZWFyX2dyb3Vwc1tvcmRlcihtYXRjaCh5ZWFyX2dyb3Vwcyx5ZWFycykpXQ0KeWVhcl9ncm91cHNfZGlzdF9jb21wYXJpc29ucyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IDcsIG5yb3cgPSBsZW5ndGgoeWVhcl9ncm91cHMpKSkNCg0KZm9yIChpIGluIDE6bGVuZ3RoKHllYXJfZ3JvdXBzKSl7DQogIHllYXJfZ3JvdXAgPC0geWVhcl9ncm91cHNbaV0NCiAgZGF0YSA8LSBmaWx0ZXIoc291cmNlc19jaGVjaywgDQogICAgICAgICAgICAgICAgIHllYXJzX3NpbmNlX2VudHJ5ID09IHllYXJfZ3JvdXApDQogIA0KICB3b21lbiA8LSBmaWx0ZXIoZGF0YSwgaW5mZXJyZWRfZ2VuZGVyID09ICJ3IikNCiAgbWVuIDwtIGZpbHRlcihkYXRhLCBpbmZlcnJlZF9nZW5kZXIgPT0gIm0iKQ0KICANCiAgeWVhcl9ncm91cHNfZGlzdF9jb21wYXJpc29uc1tpLCAxXSA8LSB5ZWFyX2dyb3VwDQogIHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnNbaSwgMl0gPC0gbnJvdyhkYXRhKQ0KICB5ZWFyX2dyb3Vwc19kaXN0X2NvbXBhcmlzb25zW2ksIDNdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kY291bnRfcHVic190b3RhbCwgbWVuJGNvdW50X3B1YnNfdG90YWwpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnNbaSwgNF0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRjaXRlZF9ieV90b3RhbF9hbGwsIG1lbiRjaXRlZF9ieV90b3RhbF9hbGwpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnNbaSwgNV0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRuZXdzX2FsbF90b3RhbCwgbWVuJG5ld3NfYWxsX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICB5ZWFyX2dyb3Vwc19kaXN0X2NvbXBhcmlzb25zW2ksIDZdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kYWx0X29ubGluZV9hbGxfdG90YWwsIG1lbiRhbHRfb25saW5lX2FsbF90b3RhbCkkcC52YWx1ZSwgNSkNCiAgeWVhcl9ncm91cHNfZGlzdF9jb21wYXJpc29uc1tpLCA3XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJGFsdF90d2l0dGVyX3RvdGFsLCBtZW4kYWx0X3R3aXR0ZXJfdG90YWwpJHAudmFsdWUsIDUpDQp9DQoNCmNvbG5hbWVzKHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnMpIDwtIGMoImZpZWxkIiwgInByb2ZzIiwgInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuZXdzX3RvdGFsIiwgIm9ubGluZV9uZXdzX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiKQ0KeWVhcl9ncm91cHNfZGlzdF9jb21wYXJpc29ucw0KYGBgDQojIyMgV2l0aGluIHllYXIgZ3JvdXBzIGFuZCBmaWVsZHMNCmBgYHtyIHdhcm5pbmcgPSBGfQ0KeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29ucyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IDgsIG5yb3cgPSBsZW5ndGgoeWVhcl9ncm91cHMpKmxlbmd0aChmaWVsZHMpKSkNCnJvd19pbmRleCA8LSAwDQoNCmZvciAoaSBpbiAxOmxlbmd0aCh5ZWFyX2dyb3Vwcykpew0KICB5ZWFyX2dyb3VwIDwtIHllYXJfZ3JvdXBzW2ldDQogIA0KICBmb3IgKGogaW4gMTpsZW5ndGgoZmllbGRzKSl7DQogICAgZmllbGQgPC0gZmllbGRzW2pdDQogICAgZGF0YSA8LSBmaWx0ZXIoc291cmNlc19jaGVjaywgDQogICAgICAgICAgICAgICAgICAgeWVhcnNfc2luY2VfZW50cnkgPT0geWVhcl9ncm91cCAmIGdlbmVyYWxfZmllbGQgPT0gZmllbGQpDQogICAgDQogICAgd29tZW4gPC0gZmlsdGVyKGRhdGEsIGluZmVycmVkX2dlbmRlciA9PSAidyIpDQogICAgbWVuIDwtIGZpbHRlcihkYXRhLCBpbmZlcnJlZF9nZW5kZXIgPT0gIm0iKQ0KICAgIA0KICAgIGlmIChsZW5ndGgodW5pcXVlKGRhdGEkaW5mZXJyZWRfZ2VuZGVyKSkgIT0gMil7DQogICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAxXSA8LSB5ZWFyX2dyb3VwDQogICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAyXSA8LSBmaWVsZA0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgM10gPC0gbnJvdyhkYXRhKQ0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNF0gPC0gTkENCiAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDVdIDwtIE5BDQogICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA2XSA8LSBOQQ0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgN10gPC0gTkENCiAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDhdIDwtIE5BDQogICAgfWVsc2V7DQogICAgICBpZiAobGVuZ3RoKHdoaWNoKGNvbFN1bXMoZGF0YVtjKCJhbHRfb25saW5lX2FsbF90b3RhbCIsICJuZXdzX2FsbF90b3RhbCIsICJhbHRfdHdpdHRlcl90b3RhbCIsICJjaXRlZF9ieV90b3RhbF9hbGwiLCAiY291bnRfcHVic190b3RhbCIpXSkgPT0gMCkpID4gMCl7DQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDFdIDwtIHllYXJfZ3JvdXANCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgMl0gPC0gZmllbGQNCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgM10gPC0gbnJvdyhkYXRhKQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA0XSA8LSBOQQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA1XSA8LSBOQQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA2XSA8LSBOQQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA3XSA8LSBOQQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA4XSA8LSBOQQ0KICAgICAgICANCiAgICAgIH1lbHNlew0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAxXSA8LSB5ZWFyX2dyb3VwDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDJdIDwtIGZpZWxkDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDNdIDwtIG5yb3coZGF0YSkNCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNF0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRjb3VudF9wdWJzX3RvdGFsLCBtZW4kY291bnRfcHVic190b3RhbCkkcC52YWx1ZSwgNSkNCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNV0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRjaXRlZF9ieV90b3RhbF9hbGwsIG1lbiRjaXRlZF9ieV90b3RhbF9hbGwpJHAudmFsdWUsIDUpDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDZdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kbmV3c19hbGxfdG90YWwsIG1lbiRuZXdzX2FsbF90b3RhbCkkcC52YWx1ZSwgNSkNCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgN10gPC0gcm91bmQoa3MudGVzdCh3b21lbiRhbHRfb25saW5lX2FsbF90b3RhbCwgbWVuJGFsdF9vbmxpbmVfYWxsX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA4XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJGFsdF90d2l0dGVyX3RvdGFsLCBtZW4kYWx0X3R3aXR0ZXJfdG90YWwpJHAudmFsdWUsIDUpDQogICAgICB9DQogICAgfQ0KICB9DQogIHJvd19pbmRleCA8LSByb3dfaW5kZXggKyA0IA0KfQ0KDQpjb2xuYW1lcyh5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zKSA8LSBjKCJ5ZWFyX2dyb3VwIiwgImZpZWxkIiwgInByb2ZzIiwgInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuZXdzX3RvdGFsIiwgIm9ubGluZV9uZXdzX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiKQ0KeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29ucw0KYGBgDQoNCg0KIyMjIFdyaXRpbmcgdGhpcyBvdXQNCmBgYHtyfQ0Kd3JpdGVfY3N2KG92ZXJhbGxfZGlzdF9jb21wYXJpc29ucywgIlBsb3RzX2FwcmlsL1N1cHBsZW1lbnRhbC9kaXN0X292ZXJhbGwuY3N2IikNCndyaXRlX2NzdihmaWVsZF9kaXN0X2NvbXBhcmlzb25zLCAiUGxvdHNfYXByaWwvU3VwcGxlbWVudGFsL2Rpc3RfeWVhci5jc3YiKQ0Kd3JpdGVfY3N2KGZpZWxkX2Rpc3RfY29tcGFyaXNvbnMsICJQbG90c19hcHJpbC9TdXBwbGVtZW50YWwvZGlzdF9maWVsZC5jc3YiKQ0Kd3JpdGVfY3N2KHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnMsICJQbG90c19hcHJpbC9TdXBwbGVtZW50YWwvZGlzdF95ZWFyX2ZpZWxkLmNzdiIpDQpgYGANCg0KDQoNCiMgUmVncmVzc2lvbiBtb2RlbHMNCg0KQmluYXJ5IHZhcmlhYmxlcyBmb3IgYW55IGF0dGVudGlvbjoNCmBgYHtyfQ0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X25ld3MgPC0gYXMuZmFjdG9yKGlmZWxzZShwcm9mX3BhbmVsX2ZpbHRlciRuZXdzX2FsbCA+IDAsIDEsIDApKQ0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X25ld3NfbCA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJG5ld3NfYWxsX2wgPiAwLCAxLCAwKSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X29ubGluZV9uZXdzIDwtIGFzLmZhY3RvcihpZmVsc2UocHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9hbGwgPiAwLCAxLCAwKSkNCnByb2ZfcGFuZWxfZmlsdGVyJGFueV9vbmxpbmVfbmV3c19sIDwtIGFzLmZhY3RvcihpZmVsc2UocHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9hbGxfbCA+IDAsIDEsIDApKQ0KDQpwcm9mX3BhbmVsX2ZpbHRlciRhbnlfb25saW5lX25ld3NfZ2VuIDwtIGFzLmZhY3RvcihpZmVsc2UocHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9nZW5lcmFsX2FsbCA+IDAsIDEsIDApKQ0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X29ubGluZV9uZXdzX2dlbl9sIDwtIGFzLmZhY3RvcihpZmVsc2UocHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9nZW5lcmFsX2FsbF9sID4gMCwgMSwgMCkpDQoNCnByb2ZfcGFuZWxfZmlsdGVyJGFueV9vbmxpbmVfbmV3c19uYW1lIDwtIGFzLmZhY3RvcihpZmVsc2UocHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9uYW1lX2FsbCA+IDAsIDEsIDApKQ0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X29ubGluZV9uZXdzX25hbWVfbCA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfbmFtZV9hbGxfbCA+IDAsIDEsIDApKQ0KDQpwcm9mX3BhbmVsX2ZpbHRlciRhbnlfdHdpdHRlciA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF90d2l0dGVyID4gMCwgMSwgMCkpDQpwcm9mX3BhbmVsX2ZpbHRlciRhbnlfdHdpdHRlcl9sIDwtIGFzLmZhY3RvcihpZmVsc2UocHJvZl9wYW5lbF9maWx0ZXIkYWx0X3R3aXR0ZXJfbCA+IDAsIDEsIDApKQ0KYGBgDQoNCkJpbmFyeSB2YXJpYWJsZXMgZm9yIGJlbG9uZ2luZyB0byB0aGUgdG9wIDEwLzIwJSBpbiB0aGUgYXR0ZW50aW9uIGZvciBlYWNoIHNvdXJjZS4NCmBgYHtyfQ0KcGFuZWxfZmlsdGVyX2xvbmcgPC0gcHJvZl9wYW5lbF9maWx0ZXIgJT4lDQogIHBpdm90X2xvbmdlcihjKGFsdF9vbmxpbmVfYWxsLCBhbHRfb25saW5lX25hbWVfYWxsLCBuZXdzX2FsbCwgYWx0X3R3aXR0ZXIpLCBuYW1lc190byA9ICJtZWFzdXJlIiwgdmFsdWVzX3RvID0gInZhbHVlIikNCg0KdG9wXzEwX2F0dG4gPC0gcGFuZWxfZmlsdGVyX2xvbmcgJT4lDQogIGZpbHRlcighaXMubmEoZ2VuZXJhbF9maWVsZCkgJiAhaXMubmEoeWVhcikgJiB5ZWFyID4gMjAxMSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgeWVhciwgbWVhc3VyZSklPiUNCiAgZmlsdGVyKHF1YW50aWxlKHZhbHVlLCAwLjkwLCBuYS5ybSA9IFRSVUUpPHZhbHVlKSU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZCwgZ2VuZXJhbF9maWVsZCwgeWVhciwgbWVhc3VyZSwgdmFsdWUpDQoNCnRvcF8xMF9hdHRuJG1lYXN1cmUgPC0gcGFzdGUwKHRvcF8xMF9hdHRuJG1lYXN1cmUsICJfdG9wXzEwIikNCg0KDQp0b3BfMTBfYXR0biA8LSB0b3BfMTBfYXR0biAlPiUNCiAgcGl2b3Rfd2lkZXIobmFtZXNfZnJvbSA9ICJtZWFzdXJlIiklPiUNCiAgbXV0YXRlKGFjcm9zcyhjb250YWlucygndG9wXzEwJyksICB+aWZlbHNlKGlzLm5hKC4pLCAwLCAxKSkpDQoNCnByb2ZfcGFuZWxfZmlsdGVyIDwtIG1lcmdlKHByb2ZfcGFuZWxfZmlsdGVyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wXzEwX2F0dG5bYygieWVhciIsICJwcm9maWxlX2lkIiwgImdlbmVyYWxfZmllbGQiLCAiYWx0X29ubGluZV9hbGxfdG9wXzEwIiwgImFsdF9vbmxpbmVfbmFtZV9hbGxfdG9wXzEwIiwgImFsdF90d2l0dGVyX3RvcF8xMCIsICJuZXdzX2FsbF90b3BfMTAiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IGMoInByb2ZpbGVfaWQiLCAieWVhciIsICJnZW5lcmFsX2ZpZWxkIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueSA9IEZBTFNFKQ0KDQp0b3BfMjBfYXR0biA8LSBwYW5lbF9maWx0ZXJfbG9uZyAlPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSAmICFpcy5uYSh5ZWFyKSAmIHllYXIgPiAyMDExKSU+JQ0KICBncm91cF9ieShnZW5lcmFsX2ZpZWxkLCB5ZWFyLCBtZWFzdXJlKSU+JQ0KICBmaWx0ZXIocXVhbnRpbGUodmFsdWUsIDAuODAsIG5hLnJtID0gVFJVRSk8dmFsdWUpJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCBnZW5lcmFsX2ZpZWxkLCB5ZWFyLCBtZWFzdXJlLCB2YWx1ZSkNCg0KdG9wXzIwX2F0dG4kbWVhc3VyZSA8LSBwYXN0ZTAodG9wXzIwX2F0dG4kbWVhc3VyZSwgIl90b3BfMjAiKQ0KDQoNCnRvcF8yMF9hdHRuIDwtIHRvcF8yMF9hdHRuICU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gIm1lYXN1cmUiKSU+JQ0KICBtdXRhdGUoYWNyb3NzKGNvbnRhaW5zKCd0b3BfMjAnKSwgIH5pZmVsc2UoaXMubmEoLiksIDAsIDEpKSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIgPC0gbWVyZ2UocHJvZl9wYW5lbF9maWx0ZXIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BfMjBfYXR0bltjKCJ5ZWFyIiwgInByb2ZpbGVfaWQiLCAiZ2VuZXJhbF9maWVsZCIsICJhbHRfb25saW5lX2FsbF90b3BfMjAiLCAiYWx0X29ubGluZV9uYW1lX2FsbF90b3BfMjAiLCAiYWx0X3R3aXR0ZXJfdG9wXzIwIiwgIm5ld3NfYWxsX3RvcF8yMCIpXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gYygicHJvZmlsZV9pZCIsICJ5ZWFyIiwgImdlbmVyYWxfZmllbGQiKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbC54ID0gVFJVRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbC55ID0gRkFMU0UpDQoNCnByb2ZfcGFuZWxfZmlsdGVyIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgIWlzLm5hKGdlbmVyYWxfZmllbGQpKQ0KYGBgDQoNClNwbGl0IGRhdGFzZXRzIHBlciBmaWVsZDoNCmBgYHtyfQ0Kc3RlbSA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIGdlbmVyYWxfZmllbGQgPT0gIlNURU0iKQ0Kc29jX3NjaSA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIGdlbmVyYWxfZmllbGQgPT0gIlNvY2lhbCBzY2llbmNlcyIpDQphcnRzIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgZ2VuZXJhbF9maWVsZCA9PSAiQXJ0cyAmIEh1bWFuaXRpZXMiKQ0KbWVkaWNpbmUgPC0gZmlsdGVyKHByb2ZfcGFuZWxfZmlsdGVyLCBnZW5lcmFsX2ZpZWxkID09ICJNZWRpY2luZSIpDQpgYGANCg0KDQojIyBDb3VudCBtb2RlbHMNCg0KIyMjIE5ld3MNClRoaXMgdGltZSBwZXJpb2QncyBuZXdzIGdpdmVuIG9uZSdzIHRvdGFsIGNpdGF0aW9ucy9wdWJsaWNhdGlvbnMsIHBhc3QgdG90YWwgDQphdHRlbnRpb24sIGNvbnRyb2xsaW5nIGZvciB0aGUgZmllbGQgYW5kIHllYXIgKExleGlzIHNhbXBsZSBvbmx5KS4gUG9vbGVkIG1vZGVsDQp3aXRoIGNsdXN0ZXJlZCBTRXM6DQpgYGB7ciB3YXJuaW5nID0gRn0NCmZpZWxkcyA8LSBjKCJzdGVtIiwgInNvY19zY2kiLCAibWVkaWNpbmUiLCAiYXJ0cyIpDQoNCmFsbF9wcmVkaWN0aW9uc19uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSA3LCBucm93ID0gMCkpDQphbGxfbW9kZWxzX25ld3MgPC0gZGF0YS5mcmFtZShtYXRyaXgobmNvbCA9IDEwLCBucm93ID0gMCkpDQphbGxfY29tcGFyaXNvbnNfbmV3cyA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNiwgbnJvdyA9IDApKQ0KDQpmb3IgKGZpZWxkIGluIGZpZWxkcyl7DQogIA0KICBmaWVsZF9kYXRhc2V0IDwtIGdldChmaWVsZCkNCiAgDQogIG5ld3NfbW9kZWwgPC0gbG0obmV3c19hbGwgfiAjIHByb2Zlc3NvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIG5ld3NfYWxsX2wgKyANCiAgICAgICAgICAgICAgICAgICAgIGNpdGVkX2J5X3RvdGFsX2FsbF9sICsgDQogICAgICAgICAgICAgICAgICAgICAjIGdlbmRlcg0KICAgICAgICAgICAgICAgICAgICAgaW5mZXJyZWRfZ2VuZGVyICsNCiAgICAgICAgICAgICAgICAgICAgICMgYXR0ZW50aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgYWx0X29ubGluZV9hbGxfdG90YWxfbCArIGFsdF90d2l0dGVyX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGNvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgY29hX29ubGluZV9hbGxfdG90YWxfbCArIGNvYV90d2l0dGVyX3RvdGFsX2wrYXMuZmFjdG9yKHllYXIpLA0KICAgICAgICAgICAgICAgICAgIGRhdGEgPSBmaWVsZF9kYXRhc2V0KSANCiAgDQogIG1vZGVsX3Jlc3VsdCA8LSBjb2VmdGVzdChuZXdzX21vZGVsLCB2Y292ID0gdmNvdkNMLCBjbHVzdGVyID0gfnByb2ZpbGVfaWQpWyxdICU+JSANCiAgICBhcy5kYXRhLmZyYW1lKCkgJT4lIA0KICAgIHRpYmJsZTo6cm93bmFtZXNfdG9fY29sdW1uKHZhciA9ICJ0ZXJtIikNCiAgDQogIG1vZGVsX3Jlc3VsdFtucm93KG1vZGVsX3Jlc3VsdCkrMSwgMV0gPC0gIlJeMiINCiAgbW9kZWxfcmVzdWx0W25yb3cobW9kZWxfcmVzdWx0KSwgMjpuY29sKG1vZGVsX3Jlc3VsdCldIDwtIHJvdW5kKHN1bW1hcnkobmV3c19tb2RlbCkkci5zcXVhcmVkLDMpDQogIG1vZGVsX3Jlc3VsdCRmaWVsZCA8LSBmaWVsZA0KICANCiAgYWxsX21vZGVsc19uZXdzIDwtIHJiaW5kKGFsbF9tb2RlbHNfbmV3cywNCiAgICAgICAgICAgICAgICAgICAgICBtb2RlbF9yZXN1bHQpDQogIA0KICBwcmVkaWN0aW9uIDwtIHByZWRpY3RfcmVzcG9uc2UobmV3c19tb2RlbCwgYygiaW5mZXJyZWRfZ2VuZGVyIiksIHZjb3ZfZnVuID0gInZjb3ZDTCIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmNvdl90eXBlID0gIkhDMCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Y292LmFyZ3MgPSBsaXN0KGNsdXN0ZXIgPSBmaWVsZF9kYXRhc2V0JHByb2ZpbGVfaWQpKQ0KICBwcmVkaWN0aW9uJGZpZWxkIDwtIGZpZWxkDQogIA0KICBnZW5kZXJfY29tcGFyaXNvbiA8LSB0ZXN0X3ByZWRpY3Rpb25zKG5ld3NfbW9kZWwsIGMoImluZmVycmVkX2dlbmRlciIpLCB2Y292X2Z1biA9ICJ2Y292Q0wiKQ0KICBnZW5kZXJfY29tcGFyaXNvbiRmaWVsZCA8LSBmaWVsZA0KICANCiAgYWxsX2NvbXBhcmlzb25zX25ld3MgPC0gcmJpbmQoYWxsX2NvbXBhcmlzb25zX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJfY29tcGFyaXNvbikNCiAgDQogIGFsbF9wcmVkaWN0aW9uc19uZXdzIDwtIHJiaW5kKGFsbF9wcmVkaWN0aW9uc19uZXdzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZGljdGlvbikNCiAgDQogIA0KfQ0KDQphbGxfbW9kZWxzX25ld3Mkc3RhcnMgPC0gaWZlbHNlKGFsbF9tb2RlbHNfbmV3cyRgUHIoPnx0fClgIDw9IDAuMDAxLCAiKioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfbW9kZWxzX25ld3MkYFByKD58dHwpYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX21vZGVsc19uZXdzJGBQcig+fHR8KWAgPD0gMC4wNSwgIioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX21vZGVsc19uZXdzJGBQcig+fHR8KWAgPD0gMC4xLCAiLiIsICIiKSkpKQ0KDQphbGxfY29tcGFyaXNvbnNfbmV3cyRzdGFycyA8LSBpZmVsc2UoYWxsX2NvbXBhcmlzb25zX25ld3MkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY29tcGFyaXNvbnNfbmV3cyRgcC52YWx1ZWAgPD0gMC4wMDEsICIqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjA1LCAiKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY29tcGFyaXNvbnNfbmV3cyRgcC52YWx1ZWAgPD0gMC4xLCAiLiIsICIiKSkpKQ0KDQphbGxfY29tcGFyaXNvbnNfbmV3cyRncm91cDEgPC0gc3RyX3NwbGl0X2koYWxsX2NvbXBhcmlzb25zX25ld3MkaW5mZXJyZWRfZ2VuZGVyLCAiLSIsIDEpDQphbGxfY29tcGFyaXNvbnNfbmV3cyRncm91cDIgPC0gc3RyX3NwbGl0X2koYWxsX2NvbXBhcmlzb25zX25ld3MkaW5mZXJyZWRfZ2VuZGVyLCAiLSIsIDIpDQoNCmFsbF9jb21wYXJpc29uc19uZXdzJHBfcm91bmRlZCA8LSByb3VuZChhbGxfY29tcGFyaXNvbnNfbmV3cyRwLnZhbHVlLCA0KQ0KYGBgDQoNClBsb3QgZ2VuZGVyIGRpZmZlcmVuY2VzOg0KYGBge3IgZmlnLmhlaWdodD0zLCBmaWdoLndpZHRoID0gNH0NCm5ld3NfZ2VuZGVyX3Bsb3QgPC0gYWxsX3ByZWRpY3Rpb25zX25ld3MgJT4lDQogICBnZ3Bsb3QoYWVzKHggPSBmY3RfcmV2KGZpZWxkKSwNCiAgICAgICAgICAgICAgeSA9IHByZWRpY3RlZCwNCiAgICAgICAgICAgICAgeW1pbiA9IGNvbmYubG93LA0KICAgICAgICAgICAgICB5bWF4ID0gY29uZi5oaWdoLA0KICAgICAgICAgICAgICBjb2xvciA9IHgpKSArDQogICBnZW9tX3BvaW50cmFuZ2UocG9zaXRpb24gPSBwb3NpdGlvbl9kb2RnZSh3aWR0aCA9IDAuNSksDQogICAgICAgICAgICAgICAgICAgc2l6ZSA9IDAuNSkrDQogICBnZ3RpdGxlKCIoYSkgUHJlZGljdGVkIHZhbHVlcyBvZiBuZXdzIGF0dGVudGlvbiIpKw0KICAgICBzdGF0X3B2YWx1ZV9tYW51YWwoDQogICAgYWxsX2NvbXBhcmlzb25zX25ld3MsDQogICAgeS5wb3NpdGlvbiA9IGMoNC42LCA0LjYsIDQsIDQpLA0KICAgIGxhYmVsLnNpemUgPSAzLA0KICAgIGxhYmVsID0gIntzdGFyc30iLA0KICAgIHJlbW92ZS5icmFja2V0ID0gRkFMU0UsDQogICAgYnJhY2tldC5udWRnZS55ID0gLTIsDQogICAgeCA9ICJmaWVsZCINCiAgICApKw0KICAgIHhsYWIoIkZpZWxkIikrDQogICBzY2FsZV94X2Rpc2NyZXRlKGxhYmVscz1jKCJhcnRzIiA9ICJBcnRzICYgSHVtYW5pdGllcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZWRpY2luZSIgPSAiTWVkaWNpbmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic29jX3NjaSIgPSAiU29jaWFsIHNjaWVuY2UiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RlbSIgPSAiU1RFTSIpKSsNCiAgIHlsYWIoIk5ld3MgYXR0ZW50aW9uIHBlciB5ZWFyIikrDQogICBsYWJzKGNvbG9yID0gIkluZmVycmVkIGdlbmRlciIpKw0KICAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IGMoIiMzNGQzOTkiLCAiI2ZiYmYyNCIpLCBsYWJlbHMgPSBjKCJNYW4iLCAiV29tYW4iKSkrDQogICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSwNCiAgICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSwNCiAgICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpICwNCiAgICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTgpLCANCiAgICAgICAgIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTcpKQ0KYGBgDQoNCmBgYHtyfQ0Ka25pdHI6OmthYmxlKGFsbF9tb2RlbHNfbmV3cykNCmBgYA0KDQoNCiMjIyBPbmxpbmUgTmV3cw0KVGhpcyB0aW1lIHBlcmlvZCdzIG5ld3MgZ2l2ZW4gb25lJ3MgdG90YWwgY2l0YXRpb25zL3B1YmxpY2F0aW9ucywgcGFzdCB0b3RhbCANCmF0dGVudGlvbiwgY29udHJvbGxpbmcgZm9yIHRoZSBmaWVsZCBhbmQgeWVhciAoTGV4aXMgc2FtcGxlIG9ubHkpLiBQb29sZWQgbW9kZWwNCndpdGggY2x1c3RlcmVkIFNFczoNCmBgYHtyfQ0KZmllbGRzIDwtIGMoInN0ZW0iLCAic29jX3NjaSIsICJtZWRpY2luZSIsICJhcnRzIikNCg0KYWxsX3ByZWRpY3Rpb25zX29ubGluZV9uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSA3LCBucm93ID0gMCkpDQphbGxfbW9kZWxzX29ubGluZV9uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSAxMCwgbnJvdyA9IDApKQ0KYWxsX2NvbXBhcmlzb25zX29ubGluZV9uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSA2LCBucm93ID0gMCkpDQoNCmZvciAoZmllbGQgaW4gZmllbGRzKXsNCiAgDQogIGZpZWxkX2RhdGFzZXQgPC0gZ2V0KGZpZWxkKQ0KICANCiAgbmV3c19tb2RlbCA8LSBsbShhbHRfb25saW5lX2FsbCB+ICMgcHJvZmVzc29yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgICAgIGFsdF9vbmxpbmVfYWxsX2wrDQogICAgICAgICAgICAgICAgICAgICAgICAgY2l0ZWRfYnlfdG90YWxfYWxsX2wgKyANCiAgICAgICAgICAgICAgICAgICAgICAgICAjIGdlbmRlcg0KICAgICAgICAgICAgICAgICAgICAgICAgIGluZmVycmVkX2dlbmRlciAgKw0KICAgICAgICAgICAgICAgICAgICAgICAgICMgYXR0ZW50aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3NfYWxsX3RvdGFsX2wgKyBhbHRfdHdpdHRlcl90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgICAgIGNvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb2Ffb25saW5lX2FsbF90b3RhbF9sICsgY29hX3R3aXR0ZXJfdG90YWxfbCthcy5mYWN0b3IoeWVhciksDQogICAgICAgICAgICAgICAgICAgZGF0YSA9IGZpZWxkX2RhdGFzZXQpIA0KICANCiAgbW9kZWxfcmVzdWx0IDwtIGNvZWZ0ZXN0KG5ld3NfbW9kZWwsIHZjb3YgPSB2Y292Q0wsIGNsdXN0ZXIgPSB+cHJvZmlsZV9pZClbLF0gJT4lIA0KICAgIGFzLmRhdGEuZnJhbWUoKSAlPiUgDQogICAgdGliYmxlOjpyb3duYW1lc190b19jb2x1bW4odmFyID0gInRlcm0iKQ0KICANCiAgbW9kZWxfcmVzdWx0W25yb3cobW9kZWxfcmVzdWx0KSsxLCAxXSA8LSAiUl4yIg0KICBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoc3VtbWFyeShuZXdzX21vZGVsKSRyLnNxdWFyZWQsMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfbW9kZWxzX29ubGluZV9uZXdzIDwtIHJiaW5kKGFsbF9tb2RlbHNfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgbW9kZWxfcmVzdWx0KQ0KICANCiAgcHJlZGljdGlvbiA8LSBwcmVkaWN0X3Jlc3BvbnNlKG5ld3NfbW9kZWwsIGMoImluZmVycmVkX2dlbmRlciIpLCB2Y292X2Z1biA9ICJ2Y292Q0wiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZjb3ZfdHlwZSA9ICJIQzAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmNvdi5hcmdzID0gbGlzdChjbHVzdGVyID0gZmllbGRfZGF0YXNldCRwcm9maWxlX2lkKSkNCiAgcHJlZGljdGlvbiRmaWVsZCA8LSBmaWVsZA0KICANCiAgZ2VuZGVyX2NvbXBhcmlzb24gPC0gdGVzdF9wcmVkaWN0aW9ucyhuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIikNCiAgZ2VuZGVyX2NvbXBhcmlzb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyA8LSByYmluZChhbGxfY29tcGFyaXNvbnNfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJfY29tcGFyaXNvbikNCiAgDQogIGFsbF9wcmVkaWN0aW9uc19vbmxpbmVfbmV3cyA8LSByYmluZChhbGxfcHJlZGljdGlvbnNfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9uKQ0KICANCiAgDQp9DQoNCmFsbF9tb2RlbHNfb25saW5lX25ld3Mkc3RhcnMgPC0gaWZlbHNlKGFsbF9tb2RlbHNfb25saW5lX25ld3MkYFByKD58dHwpYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx0fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfbW9kZWxzX29ubGluZV9uZXdzJGBQcig+fHR8KWAgPD0gMC4wNSwgIioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx0fClgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2NvbXBhcmlzb25zX29ubGluZV9uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRgcC52YWx1ZWAgPD0gMC4xLCAiLiIsICIiKSkpKQ0KDQphbGxfY29tcGFyaXNvbnNfb25saW5lX25ld3MkZ3JvdXAxIDwtIHN0cl9zcGxpdF9pKGFsbF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRncm91cDIgPC0gc3RyX3NwbGl0X2koYWxsX2NvbXBhcmlzb25zX29ubGluZV9uZXdzJGluZmVycmVkX2dlbmRlciwgIi0iLCAyKQ0KDQphbGxfY29tcGFyaXNvbnNfb25saW5lX25ld3MkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRwLnZhbHVlLCA0KQ0KYGBgDQoNClBsb3QgZ2VuZGVyIGRpZmZlcmVuY2VzOg0KYGBge3IgZmlnLmhlaWdodD0zLCBmaWdoLndpZHRoID0gNH0NCm9ubGluZV9uZXdzX2dlbmRlcl9wbG90IDwtIGFsbF9wcmVkaWN0aW9uc19vbmxpbmVfbmV3cyAlPiUNCiAgIGdncGxvdChhZXMoeCA9IGZjdF9yZXYoZmllbGQpLA0KICAgICAgICAgICAgICB5ID0gcHJlZGljdGVkLA0KICAgICAgICAgICAgICB5bWluID0gY29uZi5sb3csDQogICAgICAgICAgICAgIHltYXggPSBjb25mLmhpZ2gsDQogICAgICAgICAgICAgIGNvbG9yID0geCkpICsNCiAgIGdlb21fcG9pbnRyYW5nZShwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC41KSwNCiAgICAgICAgICAgICAgICAgICBzaXplID0gMC41KSsNCiAgICN5bGltKDIsIDUuNSkrDQogICBnZ3RpdGxlKCIoYikgUHJlZGljdGVkIHZhbHVlcyBvZiBvbmxpbmUgbmV3cyBhdHRlbnRpb24iKSsNCiAgICAgc3RhdF9wdmFsdWVfbWFudWFsKA0KICAgIGFsbF9jb21wYXJpc29uc19vbmxpbmVfbmV3cywNCiAgICB5LnBvc2l0aW9uID0gYyg3LCA3LCA0LCA0KSwNCiAgICBsYWJlbC5zaXplID0gMywNCiAgICBsYWJlbCA9ICJ7c3RhcnN9IiwNCiAgICByZW1vdmUuYnJhY2tldCA9IEZBTFNFLA0KICAgIGJyYWNrZXQubnVkZ2UueSA9IC0yLA0KICAgIHggPSAiZmllbGQiDQogICAgKSsNCiAgICB4bGFiKCJGaWVsZCIpKw0KICAgc2NhbGVfeF9kaXNjcmV0ZSgpKw0KICAgc2NhbGVfeF9kaXNjcmV0ZShsYWJlbHM9YygiYXJ0cyIgPSAiQXJ0cyAmIEh1bWFuaXRpZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVkaWNpbmUiID0gIk1lZGljaW5lIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNvY19zY2kiID0gIlNvY2lhbCBzY2llbmNlIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0ZW0iID0gIlNURU0iKSkrDQogICB5bGFiKCJPbmxpbmUgbmV3cyBhdHRlbnRpb24gcGVyIHllYXIiKSsNCiAgIGxhYnMoY29sb3IgPSAiSW5mZXJyZWQgZ2VuZGVyIikrDQogICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gYygiIzM0ZDM5OSIsICIjZmJiZjI0IiksIGxhYmVscyA9IGMoIk1hbiIsICJXb21hbiIpKSsNCiAgIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpLA0KICAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDgpLA0KICAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gOCkgLA0KICAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF90ZXh0KHNpemU9OCksIA0KICAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9NykpDQpgYGANCg0KYGBge3J9DQprbml0cjo6a2FibGUoYWxsX21vZGVsc19vbmxpbmVfbmV3cykNCmBgYA0KDQoNCiMjIyBUd2l0dGVyDQpUaGlzIHRpbWUgcGVyaW9kJ3MgbmV3cyBnaXZlbiBvbmUncyB0b3RhbCBjaXRhdGlvbnMvcHVibGljYXRpb25zLCBwYXN0IHRvdGFsIA0KYXR0ZW50aW9uLCBjb250cm9sbGluZyBmb3IgdGhlIGZpZWxkIGFuZCB5ZWFyIChMZXhpcyBzYW1wbGUgb25seSkuIFBvb2xlZCBtb2RlbA0Kd2l0aCBjbHVzdGVyZWQgU0VzOg0KYGBge3J9DQpmaWVsZHMgPC0gYygic3RlbSIsICJzb2Nfc2NpIiwgIm1lZGljaW5lIiwgImFydHMiKQ0KDQphbGxfcHJlZGljdGlvbnNfdHdpdHRlciA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNywgbnJvdyA9IDApKQ0KYWxsX21vZGVsc190d2l0dGVyIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSAxMCwgbnJvdyA9IDApKQ0KYWxsX2NvbXBhcmlzb25zX3R3aXR0ZXIgPC0gZGF0YS5mcmFtZShtYXRyaXgobmNvbCA9IDYsIG5yb3cgPSAwKSkNCg0KZm9yIChmaWVsZCBpbiBmaWVsZHMpew0KICANCiAgZmllbGRfZGF0YXNldCA8LSBnZXQoZmllbGQpDQogIA0KICBuZXdzX21vZGVsIDwtIGxtKGFsdF90d2l0dGVyIH4gIyBwcm9mZXNzb3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBhbHRfdHdpdHRlcl9sICsgDQogICAgICAgICAgICAgICAgICAgICBjb3VudF9wdWJzX3RvdGFsX2wgKyBjaXRlZF9ieV90b3RhbF9hbGxfbCArIA0KICAgICAgICAgICAgICAgICAgICAgIyBnZW5kZXINCiAgICAgICAgICAgICAgICAgICAgIGluZmVycmVkX2dlbmRlciArDQogICAgICAgICAgICAgICAgICAgICAjIGF0dGVudGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIG5ld3NfYWxsX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgYWx0X29ubGluZV9hbGxfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgICMgY29hdXRob3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBjb2Ffb25saW5lX2FsbF90b3RhbF9sICsgY29hX3R3aXR0ZXJfdG90YWxfbCthcy5mYWN0b3IoeWVhciksDQogICAgICAgICAgICAgICAgICAgZGF0YSA9IGZpZWxkX2RhdGFzZXQpIA0KICANCiAgbW9kZWxfcmVzdWx0IDwtIGNvZWZ0ZXN0KG5ld3NfbW9kZWwsIHZjb3YgPSB2Y292Q0wsIGNsdXN0ZXIgPSB+cHJvZmlsZV9pZClbLF0gJT4lIA0KICAgIGFzLmRhdGEuZnJhbWUoKSAlPiUgDQogICAgdGliYmxlOjpyb3duYW1lc190b19jb2x1bW4odmFyID0gInRlcm0iKQ0KICANCiAgbW9kZWxfcmVzdWx0W25yb3cobW9kZWxfcmVzdWx0KSsxLCAxXSA8LSAiUl4yIg0KICBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoc3VtbWFyeShuZXdzX21vZGVsKSRyLnNxdWFyZWQsMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfbW9kZWxzX3R3aXR0ZXIgPC0gcmJpbmQoYWxsX21vZGVsc190d2l0dGVyLA0KICAgICAgICAgICAgICAgICAgICAgIG1vZGVsX3Jlc3VsdCkNCiAgDQogIHByZWRpY3Rpb24gPC0gcHJlZGljdF9yZXNwb25zZShuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Y292X3R5cGUgPSAiSEMwIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZjb3YuYXJncyA9IGxpc3QoY2x1c3RlciA9IGZpZWxkX2RhdGFzZXQkcHJvZmlsZV9pZCkpDQogIHByZWRpY3Rpb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGdlbmRlcl9jb21wYXJpc29uIDwtIHRlc3RfcHJlZGljdGlvbnMobmV3c19tb2RlbCwgYygiaW5mZXJyZWRfZ2VuZGVyIiksIHZjb3ZfZnVuID0gInZjb3ZDTCIpDQogIGdlbmRlcl9jb21wYXJpc29uJGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfY29tcGFyaXNvbnNfdHdpdHRlciA8LSByYmluZChhbGxfY29tcGFyaXNvbnNfdHdpdHRlciwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlcl9jb21wYXJpc29uKQ0KICANCiAgYWxsX3ByZWRpY3Rpb25zX3R3aXR0ZXIgPC0gcmJpbmQoYWxsX3ByZWRpY3Rpb25zX3R3aXR0ZXIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9uKQ0KICANCiAgDQp9DQoNCmFsbF9tb2RlbHNfdHdpdHRlciRzdGFycyA8LSBpZmVsc2UoYWxsX21vZGVsc190d2l0dGVyJGBQcig+fHR8KWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9tb2RlbHNfdHdpdHRlciRgUHIoPnx0fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfbW9kZWxzX3R3aXR0ZXIkYFByKD58dHwpYCA8PSAwLjA1LCAiKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfbW9kZWxzX3R3aXR0ZXIkYFByKD58dHwpYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9jb21wYXJpc29uc190d2l0dGVyJHN0YXJzIDwtIGlmZWxzZShhbGxfY29tcGFyaXNvbnNfdHdpdHRlciRgcC52YWx1ZWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2NvbXBhcmlzb25zX3R3aXR0ZXIkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9jb21wYXJpc29uc190d2l0dGVyJGdyb3VwMSA8LSBzdHJfc3BsaXRfaShhbGxfY29tcGFyaXNvbnNfdHdpdHRlciRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9jb21wYXJpc29uc190d2l0dGVyJGdyb3VwMiA8LSBzdHJfc3BsaXRfaShhbGxfY29tcGFyaXNvbnNfdHdpdHRlciRpbmZlcnJlZF9nZW5kZXIsICItIiwgMikNCg0KYWxsX2NvbXBhcmlzb25zX3R3aXR0ZXIkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9jb21wYXJpc29uc190d2l0dGVyJHAudmFsdWUsIDQpDQpgYGANCg0KUGxvdCBnZW5kZXIgZGlmZmVyZW5jZXM6DQpgYGB7ciBmaWcuaGVpZ2h0PTMsIGZpZ2gud2lkdGggPSA0fQ0KdHdpdHRlcl9nZW5kZXJfcGxvdCA8LSBhbGxfcHJlZGljdGlvbnNfdHdpdHRlciAlPiUNCiAgIGdncGxvdChhZXMoeCA9IGZjdF9yZXYoZmllbGQpLA0KICAgICAgICAgICAgICB5ID0gcHJlZGljdGVkLA0KICAgICAgICAgICAgICB5bWluID0gY29uZi5sb3csDQogICAgICAgICAgICAgIHltYXggPSBjb25mLmhpZ2gsDQogICAgICAgICAgICAgIGNvbG9yID0geCkpICsNCiAgIGdlb21fcG9pbnRyYW5nZShwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC41KSwNCiAgICAgICAgICAgICAgICAgICBzaXplID0gMC41KSsNCiAgICN5bGltKDIsIDUuNSkrDQogICBnZ3RpdGxlKCIoYykgUHJlZGljdGVkIHZhbHVlcyBvZiBUd2l0dGVyIGF0dGVudGlvbiIpKw0KICAgICBzdGF0X3B2YWx1ZV9tYW51YWwoDQogICAgYWxsX2NvbXBhcmlzb25zX3R3aXR0ZXIsDQogICAgeS5wb3NpdGlvbiA9IGMoMCwgMjYsIDAsIDEwKSwNCiAgICBsYWJlbC5zaXplID0gMywNCiAgICBsYWJlbCA9ICJ7c3RhcnN9IiwNCiAgICByZW1vdmUuYnJhY2tldCA9IEZBTFNFLA0KICAgIGJyYWNrZXQubnVkZ2UueSA9IC0yLA0KICAgIHggPSAiZmllbGQiDQogICAgKSsNCiAgICB4bGFiKCJGaWVsZCIpKw0KICAgc2NhbGVfeF9kaXNjcmV0ZSgpKw0KICAgc2NhbGVfeF9kaXNjcmV0ZShsYWJlbHM9YygiYXJ0cyIgPSAiQXJ0cyAmIEh1bWFuaXRpZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVkaWNpbmUiID0gIk1lZGljaW5lIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNvY19zY2kiID0gIlNvY2lhbCBzY2llbmNlIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0ZW0iID0gIlNURU0iKSkrDQogICB5bGFiKCJOZXdzIGF0dGVudGlvbiBwZXIgeWVhciIpKw0KICAgbGFicyhjb2xvciA9ICJJbmZlcnJlZCBnZW5kZXIiKSsNCiAgIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCIjMzRkMzk5IiwgIiNmYmJmMjQiKSwgbGFiZWxzID0gYygiTWFuIiwgIldvbWFuIikpKw0KICAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gOCksDQogICAgICAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfdGV4dChzaXplID0gOCksDQogICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgIGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KHNpemUgPSA4KSAsDQogICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgIGxlZ2VuZC50aXRsZT1lbGVtZW50X3RleHQoc2l6ZT04KSwgDQogICAgICAgICBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT03KSkNCmBgYA0KDQpgYGB7cn0NCmtuaXRyOjprYWJsZShhbGxfbW9kZWxzX3R3aXR0ZXIpDQpgYGANCg0KDQojIyMgV3JpdGUgb3V0IHRoZSBtb2RlbHMNCmBgYHtyfQ0Kd3JpdGVfY3N2KGFsbF9tb2RlbHNfbmV3cywgIlBsb3RzX2FwcmlsL3JlZ19tb2Rfb2xzX25ld3MuY3N2IikNCndyaXRlX2NzdihhbGxfbW9kZWxzX29ubGluZV9uZXdzLCAiUGxvdHNfYXByaWwvcmVnX21vZF9vbHNfb25saW5lX25ld3MuY3N2IikNCndyaXRlX2NzdihhbGxfbW9kZWxzX3R3aXR0ZXIsICJQbG90c19hcHJpbC9yZWdfbW9kX29sc190d2l0dGVyLmNzdiIpDQpgYGANCg0KDQojIyMgQ29tYmluZSB0aGUgcGxvdHMNCg0KUGxvdCBpdCBhbGwgdG9nZXRoZXI6DQpgYGB7ciBmaWcud2lkdGg9MTEsIGZpZy5oZWlnaHQ9M30NCmxlZ2VuZCA8LSBnZXRfbGVnZW5kKA0KICAjIGNyZWF0ZSBzb21lIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBsZWdlbmQNCiAgbmV3c19nZW5kZXJfcGxvdA0KKQ0KDQpjb21iaV9wbG90IDwtIGNvd3Bsb3Q6OnBsb3RfZ3JpZChuZXdzX2dlbmRlcl9wbG90ICsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIiksIA0KICAgICAgICAgICAgICAgICAgICBvbmxpbmVfbmV3c19nZW5kZXJfcGxvdCArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIpLA0KICAgICAgICAgICAgICAgICAgICB0d2l0dGVyX2dlbmRlcl9wbG90ICsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIiksDQogICAgICAgICAgICAgICAgICAgIGxlZ2VuZCwNCiAgICAgICAgICAgICAgICAgICAgbmNvbCA9IDQsDQogICAgICAgICAgICAgICAgICAgIHJlbF93aWR0aHMgPSBjKDEsIDEsIDEsIDAuMykpDQoNCmNvbWJpX3Bsb3QNCmdnc2F2ZTIoDQogIGZpbGVuYW1lID0gIlBsb3RzX2FwcmlsL1Bsb3RfMl9jb3VudHMucG5nIiwNCiAgcGxvdCA9IGNvbWJpX3Bsb3QsDQogIHdpZHRoID0gMTEsDQogIGhlaWdodCA9IDMsDQogIHVuaXRzID0gYygiaW4iKSwNCiAgZHBpID0gNjAwLA0KICBiZyA9ICJ3aGl0ZSINCikNCmBgYA0KDQoNCg0KDQoNCiMjIENvdW50IG1vZGVscyAtIFBvaXNzb24NCg0KIyMjIE5ld3MNCg0KQ2hlY2sgaG93IG1hbnkgemVyb2VzIGRvIHdlIGhhdmU6DQpgYGB7cn0NCjEwMCpzdW0ocHJvZl9wYW5lbF9maWx0ZXIkbmV3cyA9PSAwKS9ucm93KHByb2ZfcGFuZWxfZmlsdGVyKQ0KYGBgDQpBbG1vc3QgNzAlIQ0KDQpUaGlzIHRpbWUgcGVyaW9kJ3MgbmV3cyBnaXZlbiBvbmUncyB0b3RhbCBjaXRhdGlvbnMvcHVibGljYXRpb25zLCBwYXN0IHRvdGFsIA0KYXR0ZW50aW9uLCBjb250cm9sbGluZyBmb3IgdGhlIGZpZWxkIGFuZCB5ZWFyIChMZXhpcyBzYW1wbGUgb25seSkuIFBvb2xlZCBtb2RlbA0Kd2l0aCBjbHVzdGVyZWQgU0VzOg0KYGBge3J9DQpmaWVsZHMgPC0gYygic3RlbSIsICJzb2Nfc2NpIiwgIm1lZGljaW5lIiwgImFydHMiKQ0KDQphbGxfY291bnRfcHJlZGljdGlvbnNfbmV3cyA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNywgbnJvdyA9IDApKQ0KYWxsX2NvdW50X21vZGVsc19uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSAxMCwgbnJvdyA9IDApKQ0KYWxsX2NvdW50X2NvbXBhcmlzb25zX25ld3MgPC0gZGF0YS5mcmFtZShtYXRyaXgobmNvbCA9IDYsIG5yb3cgPSAwKSkNCg0KZm9yIChmaWVsZCBpbiBmaWVsZHMpew0KICANCiAgZmllbGRfZGF0YXNldCA8LSBnZXQoZmllbGQpDQogIA0KICBuZXdzX21vZGVsIDwtIGdsbShuZXdzX2FsbCB+ICMgcHJvZmVzc29yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgbmV3c19hbGxfbCArIA0KICAgICAgICAgICAgICAgICAgICAgY2l0ZWRfYnlfdG90YWxfYWxsX2wgKyANCiAgICAgICAgICAgICAgICAgICAgICMgZ2VuZGVyDQogICAgICAgICAgICAgICAgICAgICBpbmZlcnJlZF9nZW5kZXIgKw0KICAgICAgICAgICAgICAgICAgICAgIyBhdHRlbnRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBhbHRfb25saW5lX2FsbF90b3RhbF9sICsgYWx0X3R3aXR0ZXJfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgICMgY29hdXRob3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBjb2Ffb25saW5lX2FsbF90b3RhbF9sICsgY29hX3R3aXR0ZXJfdG90YWxfbCthcy5mYWN0b3IoeWVhciksDQogICAgICAgICAgICAgICAgICAgZGF0YSA9IGZpZWxkX2RhdGFzZXQsIGZhbWlseSA9ICdwb2lzc29uJykgDQogIA0KICBtb2RlbF9yZXN1bHQgPC0gY29lZnRlc3QobmV3c19tb2RlbCwgdmNvdiA9IHZjb3ZDTCwgY2x1c3RlciA9IH5wcm9maWxlX2lkKVssXSAlPiUgDQogICAgYXMuZGF0YS5mcmFtZSgpICU+JSANCiAgICB0aWJibGU6OnJvd25hbWVzX3RvX2NvbHVtbih2YXIgPSAidGVybSIpDQogIA0KICAjIG1vZGVsX3Jlc3VsdFtucm93KG1vZGVsX3Jlc3VsdCkrMSwgMV0gPC0gIlJeMiINCiAgIyBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoc3VtbWFyeShuZXdzX21vZGVsKSRyLnNxdWFyZWQsMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfY291bnRfbW9kZWxzX25ld3MgPC0gcmJpbmQoYWxsX2NvdW50X21vZGVsc19uZXdzLA0KICAgICAgICAgICAgICAgICAgICAgIG1vZGVsX3Jlc3VsdCkNCiAgDQogIHByZWRpY3Rpb24gPC0gcHJlZGljdF9yZXNwb25zZShuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Y292X3R5cGUgPSAiSEMwIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZjb3YuYXJncyA9IGxpc3QoY2x1c3RlciA9IGZpZWxkX2RhdGFzZXQkcHJvZmlsZV9pZCkpDQogIHByZWRpY3Rpb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGdlbmRlcl9jb21wYXJpc29uIDwtIHRlc3RfcHJlZGljdGlvbnMobmV3c19tb2RlbCwgYygiaW5mZXJyZWRfZ2VuZGVyIiksIHZjb3ZfZnVuID0gInZjb3ZDTCIpDQogIGdlbmRlcl9jb21wYXJpc29uJGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfY291bnRfY29tcGFyaXNvbnNfbmV3cyA8LSByYmluZChhbGxfY291bnRfY29tcGFyaXNvbnNfbmV3cywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlcl9jb21wYXJpc29uKQ0KICANCiAgYWxsX2NvdW50X3ByZWRpY3Rpb25zX25ld3MgPC0gcmJpbmQoYWxsX2NvdW50X3ByZWRpY3Rpb25zX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9uKQ0KICANCiAgDQp9DQoNCmFsbF9jb3VudF9tb2RlbHNfbmV3cyRzdGFycyA8LSBpZmVsc2UoYWxsX2NvdW50X21vZGVsc19uZXdzJGBQcig+fHp8KWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb3VudF9tb2RlbHNfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY291bnRfbW9kZWxzX25ld3MkYFByKD58enwpYCA8PSAwLjA1LCAiKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY291bnRfbW9kZWxzX25ld3MkYFByKD58enwpYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9jb3VudF9jb21wYXJpc29uc19uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfY291bnRfY29tcGFyaXNvbnNfbmV3cyRgcC52YWx1ZWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb3VudF9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2NvdW50X2NvbXBhcmlzb25zX25ld3MkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb3VudF9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9jb3VudF9jb21wYXJpc29uc19uZXdzJGdyb3VwMSA8LSBzdHJfc3BsaXRfaShhbGxfY291bnRfY29tcGFyaXNvbnNfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9jb3VudF9jb21wYXJpc29uc19uZXdzJGdyb3VwMiA8LSBzdHJfc3BsaXRfaShhbGxfY291bnRfY29tcGFyaXNvbnNfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMikNCg0KYWxsX2NvdW50X2NvbXBhcmlzb25zX25ld3MkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9jb3VudF9jb21wYXJpc29uc19uZXdzJHAudmFsdWUsIDQpDQpgYGANCg0KYGBge3J9DQprbml0cjo6a2FibGUoYWxsX2NvdW50X21vZGVsc19uZXdzKQ0KYGBgDQoNCiMjIyBPbmxpbmUgTmV3cw0KDQpDaGVjayBob3cgbWFueSB6ZXJvZXMgZG8gd2UgaGF2ZToNCmBgYHtyfQ0KMTAwKnN1bShwcm9mX3BhbmVsX2ZpbHRlciRhbHRfb25saW5lX2FsbCA9PSAwLCBuYS5ybSA9IFRSVUUpL25yb3cocHJvZl9wYW5lbF9maWx0ZXIpDQpgYGANCkFyb3VuZCAyNyUuDQoNClRoaXMgdGltZSBwZXJpb2QncyBuZXdzIGdpdmVuIG9uZSdzIHRvdGFsIGNpdGF0aW9ucy9wdWJsaWNhdGlvbnMsIHBhc3QgdG90YWwgDQphdHRlbnRpb24sIGNvbnRyb2xsaW5nIGZvciB0aGUgZmllbGQgYW5kIHllYXIgKExleGlzIHNhbXBsZSBvbmx5KS4gUG9vbGVkIG1vZGVsDQp3aXRoIGNsdXN0ZXJlZCBTRXM6DQpgYGB7cn0NCmZpZWxkcyA8LSBjKCJzdGVtIiwgInNvY19zY2kiLCAibWVkaWNpbmUiLCAiYXJ0cyIpDQoNCmFsbF9jb3VudF9wcmVkaWN0aW9uc19vbmxpbmVfbmV3cyA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNywgbnJvdyA9IDApKQ0KYWxsX2NvdW50X21vZGVsc19vbmxpbmVfbmV3cyA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gMTAsIG5yb3cgPSAwKSkNCmFsbF9jb3VudF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNiwgbnJvdyA9IDApKQ0KDQpmb3IgKGZpZWxkIGluIGZpZWxkcyl7DQogIA0KICBmaWVsZF9kYXRhc2V0IDwtIGdldChmaWVsZCkNCiAgDQogIG5ld3NfbW9kZWwgPC0gZ2xtKGFsdF9vbmxpbmVfYWxsIH4gIyBwcm9mZXNzb3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICAgICAgYWx0X29ubGluZV9hbGxfbCsNCiAgICAgICAgICAgICAgICAgICAgICAgICBjaXRlZF9ieV90b3RhbF9hbGxfbCArIA0KICAgICAgICAgICAgICAgICAgICAgICAgICMgZ2VuZGVyDQogICAgICAgICAgICAgICAgICAgICAgICAgaW5mZXJyZWRfZ2VuZGVyICArDQogICAgICAgICAgICAgICAgICAgICAgICAgIyBhdHRlbnRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICAgICAgbmV3c19hbGxfdG90YWxfbCArIGFsdF90d2l0dGVyX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgICAgICMgY29hdXRob3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICAgICAgY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgICAgIGNvYV9vbmxpbmVfYWxsX3RvdGFsX2wgKyBjb2FfdHdpdHRlcl90b3RhbF9sK2FzLmZhY3Rvcih5ZWFyKSwNCiAgICAgICAgICAgICAgICAgICBkYXRhID0gZmllbGRfZGF0YXNldCwgZmFtaWx5ID0gJ3BvaXNzb24nKSAgDQogIA0KICBtb2RlbF9yZXN1bHQgPC0gY29lZnRlc3QobmV3c19tb2RlbCwgdmNvdiA9IHZjb3ZDTCwgY2x1c3RlciA9IH5wcm9maWxlX2lkKVssXSAlPiUgDQogICAgYXMuZGF0YS5mcmFtZSgpICU+JSANCiAgICB0aWJibGU6OnJvd25hbWVzX3RvX2NvbHVtbih2YXIgPSAidGVybSIpDQogIA0KICAjIG1vZGVsX3Jlc3VsdFtucm93KG1vZGVsX3Jlc3VsdCkrMSwgMV0gPC0gIlJeMiINCiAgIyBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoc3VtbWFyeShuZXdzX21vZGVsKSRyLnNxdWFyZWQsMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfY291bnRfbW9kZWxzX29ubGluZV9uZXdzIDwtIHJiaW5kKGFsbF9jb3VudF9tb2RlbHNfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgbW9kZWxfcmVzdWx0KQ0KICANCiAgcHJlZGljdGlvbiA8LSBwcmVkaWN0X3Jlc3BvbnNlKG5ld3NfbW9kZWwsIGMoImluZmVycmVkX2dlbmRlciIpLCB2Y292X2Z1biA9ICJ2Y292Q0wiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZjb3ZfdHlwZSA9ICJIQzAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmNvdi5hcmdzID0gbGlzdChjbHVzdGVyID0gZmllbGRfZGF0YXNldCRwcm9maWxlX2lkKSkNCiAgcHJlZGljdGlvbiRmaWVsZCA8LSBmaWVsZA0KICANCiAgZ2VuZGVyX2NvbXBhcmlzb24gPC0gdGVzdF9wcmVkaWN0aW9ucyhuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIikNCiAgZ2VuZGVyX2NvbXBhcmlzb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9jb3VudF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyA8LSByYmluZChhbGxfY291bnRfY29tcGFyaXNvbnNfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJfY29tcGFyaXNvbikNCiAgDQogIGFsbF9jb3VudF9wcmVkaWN0aW9uc19vbmxpbmVfbmV3cyA8LSByYmluZChhbGxfY291bnRfcHJlZGljdGlvbnNfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9uKQ0KICANCiAgDQp9DQoNCmFsbF9jb3VudF9tb2RlbHNfb25saW5lX25ld3Mkc3RhcnMgPC0gaWZlbHNlKGFsbF9jb3VudF9tb2RlbHNfb25saW5lX25ld3MkYFByKD58enwpYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2NvdW50X21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY291bnRfbW9kZWxzX29ubGluZV9uZXdzJGBQcig+fHp8KWAgPD0gMC4wNSwgIioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2NvdW50X21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx6fClgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2NvdW50X2NvbXBhcmlzb25zX29ubGluZV9uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfY291bnRfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY291bnRfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY291bnRfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb3VudF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRgcC52YWx1ZWAgPD0gMC4xLCAiLiIsICIiKSkpKQ0KDQphbGxfY291bnRfY29tcGFyaXNvbnNfb25saW5lX25ld3MkZ3JvdXAxIDwtIHN0cl9zcGxpdF9pKGFsbF9jb3VudF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9jb3VudF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRncm91cDIgPC0gc3RyX3NwbGl0X2koYWxsX2NvdW50X2NvbXBhcmlzb25zX29ubGluZV9uZXdzJGluZmVycmVkX2dlbmRlciwgIi0iLCAyKQ0KDQphbGxfY291bnRfY29tcGFyaXNvbnNfb25saW5lX25ld3MkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9jb3VudF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRwLnZhbHVlLCA0KQ0KYGBgDQoNCmBgYHtyfQ0Ka25pdHI6OmthYmxlKGFsbF9jb3VudF9tb2RlbHNfb25saW5lX25ld3MpDQpgYGANCg0KDQojIyMgVHdpdHRlcg0KDQpDaGVjayBob3cgbWFueSB6ZXJvZXMgZG8gd2UgaGF2ZToNCmBgYHtyfQ0KMTAwKnN1bShwcm9mX3BhbmVsX2ZpbHRlciRhbHRfdHdpdHRlciA9PSAwLCBuYS5ybSA9IFRSVUUpL25yb3cocHJvZl9wYW5lbF9maWx0ZXIpDQpgYGANCg0KVGhpcyB0aW1lIHBlcmlvZCdzIG5ld3MgZ2l2ZW4gb25lJ3MgdG90YWwgY2l0YXRpb25zL3B1YmxpY2F0aW9ucywgcGFzdCB0b3RhbCANCmF0dGVudGlvbiwgY29udHJvbGxpbmcgZm9yIHRoZSBmaWVsZCBhbmQgeWVhciAoTGV4aXMgc2FtcGxlIG9ubHkpLiBQb29sZWQgbW9kZWwNCndpdGggY2x1c3RlcmVkIFNFczoNCmBgYHtyfQ0KZmllbGRzIDwtIGMoInN0ZW0iLCAic29jX3NjaSIsICJtZWRpY2luZSIsICJhcnRzIikNCg0KYWxsX2NvdW50X3ByZWRpY3Rpb25zX3R3aXR0ZXIgPC0gZGF0YS5mcmFtZShtYXRyaXgobmNvbCA9IDcsIG5yb3cgPSAwKSkNCmFsbF9jb3VudF9tb2RlbHNfdHdpdHRlciA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gMTAsIG5yb3cgPSAwKSkNCmFsbF9jb3VudF9jb21wYXJpc29uc190d2l0dGVyIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSA2LCBucm93ID0gMCkpDQoNCmZvciAoZmllbGQgaW4gZmllbGRzKXsNCiAgDQogIGZpZWxkX2RhdGFzZXQgPC0gZ2V0KGZpZWxkKQ0KICANCiAgbmV3c19tb2RlbCA8LSBnbG0oYWx0X3R3aXR0ZXIgfiAjIHByb2Zlc3NvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGFsdF90d2l0dGVyX2wgKyAgY2l0ZWRfYnlfdG90YWxfYWxsX2wgKyANCiAgICAgICAgICAgICAgICAgICAgICMgZ2VuZGVyDQogICAgICAgICAgICAgICAgICAgICBpbmZlcnJlZF9nZW5kZXIgKw0KICAgICAgICAgICAgICAgICAgICAgIyBhdHRlbnRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBuZXdzX2FsbF90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgIGFsdF9vbmxpbmVfYWxsX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGNvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgY29hX29ubGluZV9hbGxfdG90YWxfbCArIGNvYV90d2l0dGVyX3RvdGFsX2wrYXMuZmFjdG9yKHllYXIpLA0KICAgICAgICAgICAgICAgICAgIGRhdGEgPSBmaWVsZF9kYXRhc2V0LCBmYW1pbHkgPSAncG9pc3NvbicpDQogIA0KICBtb2RlbF9yZXN1bHQgPC0gY29lZnRlc3QobmV3c19tb2RlbCwgdmNvdiA9IHZjb3ZDTCwgY2x1c3RlciA9IH5wcm9maWxlX2lkKVssXSAlPiUgDQogICAgYXMuZGF0YS5mcmFtZSgpICU+JSANCiAgICB0aWJibGU6OnJvd25hbWVzX3RvX2NvbHVtbih2YXIgPSAidGVybSIpDQogIA0KICAjIG1vZGVsX3Jlc3VsdFtucm93KG1vZGVsX3Jlc3VsdCkrMSwgMV0gPC0gIlJeMiINCiAgIyBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoc3VtbWFyeShuZXdzX21vZGVsKSRyLnNxdWFyZWQsMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfY291bnRfbW9kZWxzX3R3aXR0ZXIgPC0gcmJpbmQoYWxsX2NvdW50X21vZGVsc190d2l0dGVyLA0KICAgICAgICAgICAgICAgICAgICAgIG1vZGVsX3Jlc3VsdCkNCiAgDQogIHByZWRpY3Rpb24gPC0gcHJlZGljdF9yZXNwb25zZShuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Y292X3R5cGUgPSAiSEMwIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZjb3YuYXJncyA9IGxpc3QoY2x1c3RlciA9IGZpZWxkX2RhdGFzZXQkcHJvZmlsZV9pZCkpDQogIHByZWRpY3Rpb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGdlbmRlcl9jb21wYXJpc29uIDwtIHRlc3RfcHJlZGljdGlvbnMobmV3c19tb2RlbCwgYygiaW5mZXJyZWRfZ2VuZGVyIiksIHZjb3ZfZnVuID0gInZjb3ZDTCIpDQogIGdlbmRlcl9jb21wYXJpc29uJGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfY291bnRfY29tcGFyaXNvbnNfdHdpdHRlciA8LSByYmluZChhbGxfY291bnRfY29tcGFyaXNvbnNfdHdpdHRlciwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlcl9jb21wYXJpc29uKQ0KICANCiAgYWxsX2NvdW50X3ByZWRpY3Rpb25zX3R3aXR0ZXIgPC0gcmJpbmQoYWxsX2NvdW50X3ByZWRpY3Rpb25zX3R3aXR0ZXIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9uKQ0KICANCiAgDQp9DQoNCmFsbF9jb3VudF9tb2RlbHNfdHdpdHRlciRzdGFycyA8LSBpZmVsc2UoYWxsX2NvdW50X21vZGVsc190d2l0dGVyJGBQcig+fHp8KWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb3VudF9tb2RlbHNfdHdpdHRlciRgUHIoPnx6fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY291bnRfbW9kZWxzX3R3aXR0ZXIkYFByKD58enwpYCA8PSAwLjA1LCAiKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfY291bnRfbW9kZWxzX3R3aXR0ZXIkYFByKD58enwpYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9jb3VudF9jb21wYXJpc29uc190d2l0dGVyJHN0YXJzIDwtIGlmZWxzZShhbGxfY291bnRfY29tcGFyaXNvbnNfdHdpdHRlciRgcC52YWx1ZWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb3VudF9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2NvdW50X2NvbXBhcmlzb25zX3R3aXR0ZXIkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9jb3VudF9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9jb3VudF9jb21wYXJpc29uc190d2l0dGVyJGdyb3VwMSA8LSBzdHJfc3BsaXRfaShhbGxfY291bnRfY29tcGFyaXNvbnNfdHdpdHRlciRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9jb3VudF9jb21wYXJpc29uc190d2l0dGVyJGdyb3VwMiA8LSBzdHJfc3BsaXRfaShhbGxfY291bnRfY29tcGFyaXNvbnNfdHdpdHRlciRpbmZlcnJlZF9nZW5kZXIsICItIiwgMikNCg0KYWxsX2NvdW50X2NvbXBhcmlzb25zX3R3aXR0ZXIkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9jb3VudF9jb21wYXJpc29uc190d2l0dGVyJHAudmFsdWUsIDQpDQoNCg0KYGBgDQoNCmBgYHtyfQ0Ka25pdHI6OmthYmxlKGFsbF9jb3VudF9tb2RlbHNfdHdpdHRlcikNCmBgYA0KDQoNCiMjIyBXcml0ZSBvdXQgdGhlIG1vZGVscw0KYGBge3J9DQp3cml0ZV9jc3YoYWxsX2NvdW50X21vZGVsc19uZXdzLCAiUGxvdHNfYXByaWwvcmVnX21vZF9wb2lzc29uX25ld3MuY3N2IikNCndyaXRlX2NzdihhbGxfY291bnRfbW9kZWxzX29ubGluZV9uZXdzLCAiUGxvdHNfYXByaWwvcmVnX21vZF9wb2lzc29uX29ubGluZV9uZXdzLmNzdiIpDQp3cml0ZV9jc3YoYWxsX2NvdW50X21vZGVsc190d2l0dGVyLCAiUGxvdHNfYXByaWwvcmVnX21vZF9wb2lzc29uX3R3aXR0ZXIuY3N2IikNCmBgYA0KDQoNCiMjIEJpbmFyeSBtb2RlbHMgLSBhbnkgYXR0ZW50aW9uDQoNCiMjIyBOZXdzDQpUaGlzIHRpbWUgcGVyaW9kJ3MgbmV3cyBnaXZlbiBvbmUncyB0b3RhbCBjaXRhdGlvbnMvcHVibGljYXRpb25zLCBwYXN0IHRvdGFsIA0KYXR0ZW50aW9uLCBjb250cm9sbGluZyBmb3IgdGhlIGZpZWxkIGFuZCB5ZWFyIChMZXhpcyBzYW1wbGUgb25seSkuIFBvb2xlZCBtb2RlbA0Kd2l0aCBjbHVzdGVyZWQgU0VzOg0KYGBge3J9DQpmaWVsZHMgPC0gYygic3RlbSIsICJzb2Nfc2NpIiwgIm1lZGljaW5lIiwgImFydHMiKQ0KDQphbGxfYmluX21vZGVsc19uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSAxMCwgbnJvdyA9IDApKQ0KYWxsX2Jpbl9jb21wYXJpc29uc19uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSA2LCBucm93ID0gMCkpDQoNCmZvciAoZmllbGQgaW4gZmllbGRzKXsNCiAgDQogIGZpZWxkX2RhdGFzZXQgPC0gZ2V0KGZpZWxkKQ0KICANCiAgbmV3c19tb2RlbCA8LSBnbG0oYW55X25ld3MgfiAjIHByb2Zlc3NvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIG5ld3NfYWxsX2wgKyANCiAgICAgICAgICAgICAgICAgICAgIGNpdGVkX2J5X3RvdGFsX2FsbF9sICsgDQogICAgICAgICAgICAgICAgICAgICAjIGdlbmRlcg0KICAgICAgICAgICAgICAgICAgICAgaW5mZXJyZWRfZ2VuZGVyICsNCiAgICAgICAgICAgICAgICAgICAgICMgYXR0ZW50aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgYWx0X29ubGluZV9hbGxfdG90YWxfbCArIGFsdF90d2l0dGVyX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGNvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgY29hX29ubGluZV9hbGxfdG90YWxfbCArIGNvYV90d2l0dGVyX3RvdGFsX2wrYXMuZmFjdG9yKHllYXIpLA0KICAgICAgICAgICAgICAgICAgIGRhdGEgPSBmaWVsZF9kYXRhc2V0LCBmYW1pbHkgPSAnYmlub21pYWwnKSANCiAgDQogIG1vZGVsX3Jlc3VsdCA8LSBjb2VmdGVzdChuZXdzX21vZGVsLCB0eXBlID0gIkhDMCIsIGNsdXN0ZXIgPSB+cHJvZmlsZV9pZClbLF0gJT4lIA0KICAgIGFzLmRhdGEuZnJhbWUoKSAlPiUgDQogICAgdGliYmxlOjpyb3duYW1lc190b19jb2x1bW4odmFyID0gInRlcm0iKQ0KICANCiAgbW9kZWxfcmVzdWx0W25yb3cobW9kZWxfcmVzdWx0KSsxLCAxXSA8LSAiUl4yIg0KICBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoUHNldWRvUjIobmV3c19tb2RlbCksMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfYmluX21vZGVsc19uZXdzIDwtIHJiaW5kKGFsbF9iaW5fbW9kZWxzX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgbW9kZWxfcmVzdWx0KQ0KICANCiAgZ2VuZGVyX2NvbXBhcmlzb24gPC0gdGVzdF9wcmVkaWN0aW9ucyhuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAiSEMwIikNCiAgZ2VuZGVyX2NvbXBhcmlzb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9iaW5fY29tcGFyaXNvbnNfbmV3cyA8LSByYmluZChhbGxfYmluX2NvbXBhcmlzb25zX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJfY29tcGFyaXNvbikNCiAgDQogIA0KfQ0KDQphbGxfYmluX21vZGVsc19uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfYmluX21vZGVsc19uZXdzJGBQcig+fHp8KWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW5fbW9kZWxzX25ld3MkYFByKD58enwpYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2Jpbl9tb2RlbHNfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW5fbW9kZWxzX25ld3MkYFByKD58enwpYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9iaW5fY29tcGFyaXNvbnNfbmV3cyRzdGFycyA8LSBpZmVsc2UoYWxsX2Jpbl9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2Jpbl9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2Jpbl9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjA1LCAiKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluX2NvbXBhcmlzb25zX25ld3MkYHAudmFsdWVgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2Jpbl9jb21wYXJpc29uc19uZXdzJGdyb3VwMSA8LSBzdHJfc3BsaXRfaShhbGxfYmluX2NvbXBhcmlzb25zX25ld3MkaW5mZXJyZWRfZ2VuZGVyLCAiLSIsIDEpDQphbGxfYmluX2NvbXBhcmlzb25zX25ld3MkZ3JvdXAyIDwtIHN0cl9zcGxpdF9pKGFsbF9iaW5fY29tcGFyaXNvbnNfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMikNCg0KYWxsX2Jpbl9jb21wYXJpc29uc19uZXdzJHBfcm91bmRlZCA8LSByb3VuZChhbGxfYmluX2NvbXBhcmlzb25zX25ld3MkcC52YWx1ZSwgNCkNCg0KYGBgDQoNCmBgYHtyfQ0Ka25pdHI6OmthYmxlKGFsbF9iaW5fbW9kZWxzX25ld3MpDQpgYGANCg0KIyMjIE9ubGluZSBOZXdzDQpUaGlzIHRpbWUgcGVyaW9kJ3MgbmV3cyBnaXZlbiBvbmUncyB0b3RhbCBjaXRhdGlvbnMvcHVibGljYXRpb25zLCBwYXN0IHRvdGFsIA0KYXR0ZW50aW9uLCBjb250cm9sbGluZyBmb3IgdGhlIGZpZWxkIGFuZCB5ZWFyIChMZXhpcyBzYW1wbGUgb25seSkuIFBvb2xlZCBtb2RlbA0Kd2l0aCBjbHVzdGVyZWQgU0VzOg0KYGBge3J9DQpmaWVsZHMgPC0gYygic3RlbSIsICJzb2Nfc2NpIiwgIm1lZGljaW5lIiwgImFydHMiKQ0KDQphbGxfYmluX21vZGVsc19vbmxpbmVfbmV3cyA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gMTAsIG5yb3cgPSAwKSkNCmFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MgPC0gZGF0YS5mcmFtZShtYXRyaXgobmNvbCA9IDYsIG5yb3cgPSAwKSkNCg0KZm9yIChmaWVsZCBpbiBmaWVsZHMpew0KICANCiAgZmllbGRfZGF0YXNldCA8LSBnZXQoZmllbGQpDQogIA0KICBuZXdzX21vZGVsIDwtIGdsbShhbnlfb25saW5lX25ld3MgfiAjIHByb2Zlc3NvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgICAgICBhbHRfb25saW5lX2FsbF9sKw0KICAgICAgICAgICAgICAgICAgICAgICAgIGNpdGVkX2J5X3RvdGFsX2FsbF9sICsgDQogICAgICAgICAgICAgICAgICAgICAgICAgIyBnZW5kZXINCiAgICAgICAgICAgICAgICAgICAgICAgICBpbmZlcnJlZF9nZW5kZXIgICsNCiAgICAgICAgICAgICAgICAgICAgICAgICAjIGF0dGVudGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgICAgICBuZXdzX2FsbF90b3RhbF9sICsgYWx0X3R3aXR0ZXJfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb2FfdG90X2NpdGVkX2J5X3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgICAgICMgY29hdXRob3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICAgICAgY29hX29ubGluZV9hbGxfdG90YWxfbCArIGNvYV90d2l0dGVyX3RvdGFsX2wrYXMuZmFjdG9yKHllYXIpLA0KICAgICAgICAgICAgICAgICAgIGRhdGEgPSBmaWVsZF9kYXRhc2V0LCBmYW1pbHkgPSAnYmlub21pYWwnKSAgDQogIA0KICBtb2RlbF9yZXN1bHQgPC0gY29lZnRlc3QobmV3c19tb2RlbCwgdHlwZSA9ICJIQzAiLCBjbHVzdGVyID0gfnByb2ZpbGVfaWQpWyxdICU+JSANCiAgICBhcy5kYXRhLmZyYW1lKCkgJT4lIA0KICAgIHRpYmJsZTo6cm93bmFtZXNfdG9fY29sdW1uKHZhciA9ICJ0ZXJtIikNCiAgDQogIG1vZGVsX3Jlc3VsdFtucm93KG1vZGVsX3Jlc3VsdCkrMSwgMV0gPC0gIlJeMiINCiAgbW9kZWxfcmVzdWx0W25yb3cobW9kZWxfcmVzdWx0KSwgMjpuY29sKG1vZGVsX3Jlc3VsdCldIDwtIHJvdW5kKFBzZXVkb1IyKG5ld3NfbW9kZWwpLDMpDQogIG1vZGVsX3Jlc3VsdCRmaWVsZCA8LSBmaWVsZA0KICANCiAgYWxsX2Jpbl9tb2RlbHNfb25saW5lX25ld3MgPC0gcmJpbmQoYWxsX2Jpbl9tb2RlbHNfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgbW9kZWxfcmVzdWx0KQ0KICANCiAgZ2VuZGVyX2NvbXBhcmlzb24gPC0gdGVzdF9wcmVkaWN0aW9ucyhuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIikNCiAgZ2VuZGVyX2NvbXBhcmlzb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MgPC0gcmJpbmQoYWxsX2Jpbl9jb21wYXJpc29uc19vbmxpbmVfbmV3cywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlcl9jb21wYXJpc29uKQ0KICANCiAgDQp9DQoNCmFsbF9iaW5fbW9kZWxzX29ubGluZV9uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfYmluX21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDAxLCAiKioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluX21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluX21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW5fbW9kZWxzX29ubGluZV9uZXdzJGBQcig+fHp8KWAgPD0gMC4xLCAiLiIsICIiKSkpKQ0KDQphbGxfYmluX2NvbXBhcmlzb25zX29ubGluZV9uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfYmluX2NvbXBhcmlzb25zX29ubGluZV9uZXdzJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2Jpbl9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRgcC52YWx1ZWAgPD0gMC4wMDEsICIqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2Jpbl9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRncm91cDEgPC0gc3RyX3NwbGl0X2koYWxsX2Jpbl9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MkZ3JvdXAyIDwtIHN0cl9zcGxpdF9pKGFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MkaW5mZXJyZWRfZ2VuZGVyLCAiLSIsIDIpDQoNCmFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9iaW5fY29tcGFyaXNvbnNfb25saW5lX25ld3MkcC52YWx1ZSwgNCkNCg0KYGBgDQoNCmBgYHtyfQ0Ka25pdHI6OmthYmxlKGFsbF9iaW5fbW9kZWxzX29ubGluZV9uZXdzKQ0KYGBgDQoNCg0KIyMjIFR3aXR0ZXINClRoaXMgdGltZSBwZXJpb2QncyBuZXdzIGdpdmVuIG9uZSdzIHRvdGFsIGNpdGF0aW9ucy9wdWJsaWNhdGlvbnMsIHBhc3QgdG90YWwgDQphdHRlbnRpb24sIGNvbnRyb2xsaW5nIGZvciB0aGUgZmllbGQgYW5kIHllYXIgKExleGlzIHNhbXBsZSBvbmx5KS4gUG9vbGVkIG1vZGVsDQp3aXRoIGNsdXN0ZXJlZCBTRXM6DQpgYGB7cn0NCmZpZWxkcyA8LSBjKCJzdGVtIiwgInNvY19zY2kiLCAibWVkaWNpbmUiLCAiYXJ0cyIpDQoNCmFsbF9iaW5fcHJlZGljdGlvbnNfdHdpdHRlciA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNywgbnJvdyA9IDApKQ0KYWxsX2Jpbl9tb2RlbHNfdHdpdHRlciA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gMTAsIG5yb3cgPSAwKSkNCmFsbF9iaW5fY29tcGFyaXNvbnNfdHdpdHRlciA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNiwgbnJvdyA9IDApKQ0KDQpmb3IgKGZpZWxkIGluIGZpZWxkcyl7DQogIA0KICBmaWVsZF9kYXRhc2V0IDwtIGdldChmaWVsZCkNCiAgDQogIG5ld3NfbW9kZWwgPC0gZ2xtKGFueV90d2l0dGVyIH4gIyBwcm9mZXNzb3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBhbHRfdHdpdHRlcl9sICsgIGNpdGVkX2J5X3RvdGFsX2FsbF9sICsgDQogICAgICAgICAgICAgICAgICAgICAjIGdlbmRlcg0KICAgICAgICAgICAgICAgICAgICAgaW5mZXJyZWRfZ2VuZGVyICsNCiAgICAgICAgICAgICAgICAgICAgICMgYXR0ZW50aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgbmV3c19hbGxfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICBhbHRfb25saW5lX2FsbF90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgICMgY29hdXRob3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBjb2FfdG90X2NpdGVkX2J5X3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGNvYV9vbmxpbmVfYWxsX3RvdGFsX2wgKyBjb2FfdHdpdHRlcl90b3RhbF9sK2FzLmZhY3Rvcih5ZWFyKSwNCiAgICAgICAgICAgICAgICAgICBkYXRhID0gZmllbGRfZGF0YXNldCwgZmFtaWx5ID0gJ2Jpbm9taWFsJykNCiAgDQogIG1vZGVsX3Jlc3VsdCA8LSBjb2VmdGVzdChuZXdzX21vZGVsLCB0eXBlID0gIkhDMCIsIGNsdXN0ZXIgPSB+cHJvZmlsZV9pZClbLF0gJT4lIA0KICAgIGFzLmRhdGEuZnJhbWUoKSAlPiUgDQogICAgdGliYmxlOjpyb3duYW1lc190b19jb2x1bW4odmFyID0gInRlcm0iKQ0KICANCiAgbW9kZWxfcmVzdWx0W25yb3cobW9kZWxfcmVzdWx0KSsxLCAxXSA8LSAiUl4yIg0KICBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoUHNldWRvUjIobmV3c19tb2RlbCksMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfYmluX21vZGVsc190d2l0dGVyIDwtIHJiaW5kKGFsbF9iaW5fbW9kZWxzX3R3aXR0ZXIsDQogICAgICAgICAgICAgICAgICAgICAgbW9kZWxfcmVzdWx0KQ0KICANCiAgZ2VuZGVyX2NvbXBhcmlzb24gPC0gdGVzdF9wcmVkaWN0aW9ucyhuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIikNCiAgZ2VuZGVyX2NvbXBhcmlzb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9iaW5fY29tcGFyaXNvbnNfdHdpdHRlciA8LSByYmluZChhbGxfYmluX2NvbXBhcmlzb25zX3R3aXR0ZXIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJfY29tcGFyaXNvbikNCiAgDQogIA0KfQ0KDQphbGxfYmluX21vZGVsc190d2l0dGVyJHN0YXJzIDwtIGlmZWxzZShhbGxfYmluX21vZGVsc190d2l0dGVyJGBQcig+fHp8KWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW5fbW9kZWxzX3R3aXR0ZXIkYFByKD58enwpYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2Jpbl9tb2RlbHNfdHdpdHRlciRgUHIoPnx6fClgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW5fbW9kZWxzX3R3aXR0ZXIkYFByKD58enwpYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9iaW5fY29tcGFyaXNvbnNfdHdpdHRlciRzdGFycyA8LSBpZmVsc2UoYWxsX2Jpbl9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2Jpbl9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2Jpbl9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjA1LCAiKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluX2NvbXBhcmlzb25zX3R3aXR0ZXIkYHAudmFsdWVgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2Jpbl9jb21wYXJpc29uc190d2l0dGVyJGdyb3VwMSA8LSBzdHJfc3BsaXRfaShhbGxfYmluX2NvbXBhcmlzb25zX3R3aXR0ZXIkaW5mZXJyZWRfZ2VuZGVyLCAiLSIsIDEpDQphbGxfYmluX2NvbXBhcmlzb25zX3R3aXR0ZXIkZ3JvdXAyIDwtIHN0cl9zcGxpdF9pKGFsbF9iaW5fY29tcGFyaXNvbnNfdHdpdHRlciRpbmZlcnJlZF9nZW5kZXIsICItIiwgMikNCg0KYWxsX2Jpbl9jb21wYXJpc29uc190d2l0dGVyJHBfcm91bmRlZCA8LSByb3VuZChhbGxfYmluX2NvbXBhcmlzb25zX3R3aXR0ZXIkcC52YWx1ZSwgNCkNCmBgYA0KDQpgYGB7cn0NCmtuaXRyOjprYWJsZShhbGxfYmluX21vZGVsc190d2l0dGVyKQ0KYGBgDQoNCg0KIyMjIFdyaXRlIG91dCB0aGUgbW9kZWxzDQpgYGB7cn0NCndyaXRlX2NzdihhbGxfYmluX21vZGVsc19uZXdzLCAiUGxvdHNfYXByaWwvcmVnX21vZF9iaW5fbmV3cy5jc3YiKQ0Kd3JpdGVfY3N2KGFsbF9iaW5fbW9kZWxzX29ubGluZV9uZXdzLCAiUGxvdHNfYXByaWwvcmVnX21vZF9iaW5fb25saW5lX25ld3MuY3N2IikNCndyaXRlX2NzdihhbGxfYmluX21vZGVsc190d2l0dGVyLCAiUGxvdHNfYXByaWwvcmVnX21vZF9iaW5fdHdpdHRlci5jc3YiKQ0KYGBgDQoNCg0KIyMgQmluYXJ5IG1vZGVscyAtIHRvcCAxMA0KDQojIyMgTmV3cw0KVGhpcyB0aW1lIHBlcmlvZCdzIG5ld3MgZ2l2ZW4gb25lJ3MgdG90YWwgY2l0YXRpb25zL3B1YmxpY2F0aW9ucywgcGFzdCB0b3RhbCANCmF0dGVudGlvbiwgY29udHJvbGxpbmcgZm9yIHRoZSBmaWVsZCBhbmQgeWVhciAoTGV4aXMgc2FtcGxlIG9ubHkpLiBQb29sZWQgbW9kZWwNCndpdGggY2x1c3RlcmVkIFNFczoNCmBgYHtyfQ0KZmllbGRzIDwtIGMoInN0ZW0iLCAic29jX3NjaSIsICJtZWRpY2luZSIsICJhcnRzIikNCg0KYWxsX2JpbjEwX21vZGVsc19uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSAxMCwgbnJvdyA9IDApKQ0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX25ld3MgPC0gZGF0YS5mcmFtZShtYXRyaXgobmNvbCA9IDYsIG5yb3cgPSAwKSkNCg0KZm9yIChmaWVsZCBpbiBmaWVsZHMpew0KICANCiAgZmllbGRfZGF0YXNldCA8LSBnZXQoZmllbGQpDQogIA0KICBuZXdzX21vZGVsIDwtIGdsbShuZXdzX2FsbF90b3BfMTAgfiAjIHByb2Zlc3NvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIG5ld3NfYWxsX2wgKyANCiAgICAgICAgICAgICAgICAgICAgIGNpdGVkX2J5X3RvdGFsX2FsbF9sICsgDQogICAgICAgICAgICAgICAgICAgICAjIGdlbmRlcg0KICAgICAgICAgICAgICAgICAgICAgaW5mZXJyZWRfZ2VuZGVyICsNCiAgICAgICAgICAgICAgICAgICAgICMgYXR0ZW50aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgYWx0X29ubGluZV9hbGxfdG90YWxfbCArIGFsdF90d2l0dGVyX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGNvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgY29hX29ubGluZV9hbGxfdG90YWxfbCArIGNvYV90d2l0dGVyX3RvdGFsX2wrYXMuZmFjdG9yKHllYXIpLA0KICAgICAgICAgICAgICAgICAgIGRhdGEgPSBmaWVsZF9kYXRhc2V0LCBmYW1pbHkgPSAnYmlub21pYWwnKSANCiAgDQogIG1vZGVsX3Jlc3VsdCA8LSBjb2VmdGVzdChuZXdzX21vZGVsLCB0eXBlID0gIkhDMCIsIGNsdXN0ZXIgPSB+cHJvZmlsZV9pZClbLF0gJT4lIA0KICAgIGFzLmRhdGEuZnJhbWUoKSAlPiUgDQogICAgdGliYmxlOjpyb3duYW1lc190b19jb2x1bW4odmFyID0gInRlcm0iKQ0KICANCiAgbW9kZWxfcmVzdWx0W25yb3cobW9kZWxfcmVzdWx0KSsxLCAxXSA8LSAiUl4yIg0KICBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpLCAyOm5jb2wobW9kZWxfcmVzdWx0KV0gPC0gcm91bmQoUHNldWRvUjIobmV3c19tb2RlbCksMykNCiAgbW9kZWxfcmVzdWx0JGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfYmluMTBfbW9kZWxzX25ld3MgPC0gcmJpbmQoYWxsX2JpbjEwX21vZGVsc19uZXdzLA0KICAgICAgICAgICAgICAgICAgICAgIG1vZGVsX3Jlc3VsdCkNCiAgDQogIGdlbmRlcl9jb21wYXJpc29uIDwtIHRlc3RfcHJlZGljdGlvbnMobmV3c19tb2RlbCwgYygiaW5mZXJyZWRfZ2VuZGVyIiksIHZjb3ZfZnVuID0gIkhDMCIpDQogIGdlbmRlcl9jb21wYXJpc29uJGZpZWxkIDwtIGZpZWxkDQogIA0KICBhbGxfYmluMTBfY29tcGFyaXNvbnNfbmV3cyA8LSByYmluZChhbGxfYmluMTBfY29tcGFyaXNvbnNfbmV3cywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlcl9jb21wYXJpc29uKQ0KICANCiAgDQp9DQoNCmFsbF9iaW4xMF9tb2RlbHNfbmV3cyRzdGFycyA8LSBpZmVsc2UoYWxsX2JpbjEwX21vZGVsc19uZXdzJGBQcig+fHp8KWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW4xMF9tb2RlbHNfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluMTBfbW9kZWxzX25ld3MkYFByKD58enwpYCA8PSAwLjA1LCAiKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluMTBfbW9kZWxzX25ld3MkYFByKD58enwpYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9iaW4xMF9jb21wYXJpc29uc19uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfYmluMTBfY29tcGFyaXNvbnNfbmV3cyRgcC52YWx1ZWAgPD0gMC4wMDEsICIqKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW4xMF9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2JpbjEwX2NvbXBhcmlzb25zX25ld3MkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW4xMF9jb21wYXJpc29uc19uZXdzJGBwLnZhbHVlYCA8PSAwLjEsICIuIiwgIiIpKSkpDQoNCmFsbF9iaW4xMF9jb21wYXJpc29uc19uZXdzJGdyb3VwMSA8LSBzdHJfc3BsaXRfaShhbGxfYmluMTBfY29tcGFyaXNvbnNfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9iaW4xMF9jb21wYXJpc29uc19uZXdzJGdyb3VwMiA8LSBzdHJfc3BsaXRfaShhbGxfYmluMTBfY29tcGFyaXNvbnNfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMikNCg0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX25ld3MkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9iaW4xMF9jb21wYXJpc29uc19uZXdzJHAudmFsdWUsIDQpDQoNCmBgYA0KDQpgYGB7cn0NCmtuaXRyOjprYWJsZShhbGxfYmluMTBfbW9kZWxzX25ld3MpDQpgYGANCg0KIyMjIE9ubGluZSBOZXdzDQpUaGlzIHRpbWUgcGVyaW9kJ3MgbmV3cyBnaXZlbiBvbmUncyB0b3RhbCBjaXRhdGlvbnMvcHVibGljYXRpb25zLCBwYXN0IHRvdGFsIA0KYXR0ZW50aW9uLCBjb250cm9sbGluZyBmb3IgdGhlIGZpZWxkIGFuZCB5ZWFyIChMZXhpcyBzYW1wbGUgb25seSkuIFBvb2xlZCBtb2RlbA0Kd2l0aCBjbHVzdGVyZWQgU0VzOg0KYGBge3J9DQpmaWVsZHMgPC0gYygic3RlbSIsICJzb2Nfc2NpIiwgIm1lZGljaW5lIiwgImFydHMiKQ0KDQphbGxfYmluMTBfbW9kZWxzX29ubGluZV9uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSAxMCwgbnJvdyA9IDApKQ0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX29ubGluZV9uZXdzIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSA2LCBucm93ID0gMCkpDQoNCmZvciAoZmllbGQgaW4gZmllbGRzKXsNCiAgDQogIGZpZWxkX2RhdGFzZXQgPC0gZ2V0KGZpZWxkKQ0KICANCiAgbmV3c19tb2RlbCA8LSBnbG0oYWx0X29ubGluZV9hbGxfdG9wXzEwIH4gIyBwcm9mZXNzb3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICAgICAgYWx0X29ubGluZV9hbGxfbCsNCiAgICAgICAgICAgICAgICAgICAgICAgICBjaXRlZF9ieV90b3RhbF9hbGxfbCArIA0KICAgICAgICAgICAgICAgICAgICAgICAgICMgZ2VuZGVyDQogICAgICAgICAgICAgICAgICAgICAgICAgaW5mZXJyZWRfZ2VuZGVyICArDQogICAgICAgICAgICAgICAgICAgICAgICAgIyBhdHRlbnRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICAgICAgbmV3c19hbGxfdG90YWxfbCArIGFsdF90d2l0dGVyX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgICAgICMgY29hdXRob3IgcHVibGljYXRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICAgICAgY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgICAgIGNvYV9vbmxpbmVfYWxsX3RvdGFsX2wgKyBjb2FfdHdpdHRlcl90b3RhbF9sK2FzLmZhY3Rvcih5ZWFyKSwNCiAgICAgICAgICAgICAgICAgICBkYXRhID0gZmllbGRfZGF0YXNldCwgZmFtaWx5ID0gJ2Jpbm9taWFsJykgIA0KICANCiAgbW9kZWxfcmVzdWx0IDwtIGNvZWZ0ZXN0KG5ld3NfbW9kZWwsIHR5cGUgPSAiSEMwIiwgY2x1c3RlciA9IH5wcm9maWxlX2lkKVssXSAlPiUgDQogICAgYXMuZGF0YS5mcmFtZSgpICU+JSANCiAgICB0aWJibGU6OnJvd25hbWVzX3RvX2NvbHVtbih2YXIgPSAidGVybSIpDQogIA0KICBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpKzEsIDFdIDwtICJSXjIiDQogIG1vZGVsX3Jlc3VsdFtucm93KG1vZGVsX3Jlc3VsdCksIDI6bmNvbChtb2RlbF9yZXN1bHQpXSA8LSByb3VuZChQc2V1ZG9SMihuZXdzX21vZGVsKSwzKQ0KICBtb2RlbF9yZXN1bHQkZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9iaW4xMF9tb2RlbHNfb25saW5lX25ld3MgPC0gcmJpbmQoYWxsX2JpbjEwX21vZGVsc19vbmxpbmVfbmV3cywNCiAgICAgICAgICAgICAgICAgICAgICBtb2RlbF9yZXN1bHQpDQogIA0KICBnZW5kZXJfY29tcGFyaXNvbiA8LSB0ZXN0X3ByZWRpY3Rpb25zKG5ld3NfbW9kZWwsIGMoImluZmVycmVkX2dlbmRlciIpLCB2Y292X2Z1biA9ICJ2Y292Q0wiKQ0KICBnZW5kZXJfY29tcGFyaXNvbiRmaWVsZCA8LSBmaWVsZA0KICANCiAgYWxsX2JpbjEwX2NvbXBhcmlzb25zX29ubGluZV9uZXdzIDwtIHJiaW5kKGFsbF9iaW4xMF9jb21wYXJpc29uc19vbmxpbmVfbmV3cywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlcl9jb21wYXJpc29uKQ0KICANCiAgDQp9DQoNCmFsbF9iaW4xMF9tb2RlbHNfb25saW5lX25ld3Mkc3RhcnMgPC0gaWZlbHNlKGFsbF9iaW4xMF9tb2RlbHNfb25saW5lX25ld3MkYFByKD58enwpYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2JpbjEwX21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx6fClgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluMTBfbW9kZWxzX29ubGluZV9uZXdzJGBQcig+fHp8KWAgPD0gMC4wNSwgIioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2JpbjEwX21vZGVsc19vbmxpbmVfbmV3cyRgUHIoPnx6fClgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX29ubGluZV9uZXdzJHN0YXJzIDwtIGlmZWxzZShhbGxfYmluMTBfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluMTBfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluMTBfY29tcGFyaXNvbnNfb25saW5lX25ld3MkYHAudmFsdWVgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW4xMF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRgcC52YWx1ZWAgPD0gMC4xLCAiLiIsICIiKSkpKQ0KDQphbGxfYmluMTBfY29tcGFyaXNvbnNfb25saW5lX25ld3MkZ3JvdXAxIDwtIHN0cl9zcGxpdF9pKGFsbF9iaW4xMF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRpbmZlcnJlZF9nZW5kZXIsICItIiwgMSkNCmFsbF9iaW4xMF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRncm91cDIgPC0gc3RyX3NwbGl0X2koYWxsX2JpbjEwX2NvbXBhcmlzb25zX29ubGluZV9uZXdzJGluZmVycmVkX2dlbmRlciwgIi0iLCAyKQ0KDQphbGxfYmluMTBfY29tcGFyaXNvbnNfb25saW5lX25ld3MkcF9yb3VuZGVkIDwtIHJvdW5kKGFsbF9iaW4xMF9jb21wYXJpc29uc19vbmxpbmVfbmV3cyRwLnZhbHVlLCA0KQ0KDQpgYGANCg0KYGBge3J9DQprbml0cjo6a2FibGUoYWxsX2JpbjEwX21vZGVsc19vbmxpbmVfbmV3cykNCmBgYA0KDQojIyMgVHdpdHRlcg0KVGhpcyB0aW1lIHBlcmlvZCdzIG5ld3MgZ2l2ZW4gb25lJ3MgdG90YWwgY2l0YXRpb25zL3B1YmxpY2F0aW9ucywgcGFzdCB0b3RhbCANCmF0dGVudGlvbiwgY29udHJvbGxpbmcgZm9yIHRoZSBmaWVsZCBhbmQgeWVhciAoTGV4aXMgc2FtcGxlIG9ubHkpLiBQb29sZWQgbW9kZWwNCndpdGggY2x1c3RlcmVkIFNFczoNCmBgYHtyfQ0KZmllbGRzIDwtIGMoInN0ZW0iLCAic29jX3NjaSIsICJtZWRpY2luZSIsICJhcnRzIikNCg0KYWxsX2JpbjEwX21vZGVsc190d2l0dGVyIDwtIGRhdGEuZnJhbWUobWF0cml4KG5jb2wgPSAxMCwgbnJvdyA9IDApKQ0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX3R3aXR0ZXIgPC0gZGF0YS5mcmFtZShtYXRyaXgobmNvbCA9IDYsIG5yb3cgPSAwKSkNCg0KZm9yIChmaWVsZCBpbiBmaWVsZHMpew0KICANCiAgZmllbGRfZGF0YXNldCA8LSBnZXQoZmllbGQpDQogIA0KICBuZXdzX21vZGVsIDwtIGdsbShhbHRfdHdpdHRlcl90b3BfMTAgfiAjIHByb2Zlc3NvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGFsdF90d2l0dGVyX2wgKyAgY2l0ZWRfYnlfdG90YWxfYWxsX2wgKyANCiAgICAgICAgICAgICAgICAgICAgICMgZ2VuZGVyDQogICAgICAgICAgICAgICAgICAgICBpbmZlcnJlZF9nZW5kZXIgKw0KICAgICAgICAgICAgICAgICAgICAgIyBhdHRlbnRpb24gdmFyaWFibGVzDQogICAgICAgICAgICAgICAgICAgICBuZXdzX2FsbF90b3RhbF9sICsNCiAgICAgICAgICAgICAgICAgICAgIGFsdF9vbmxpbmVfYWxsX3RvdGFsX2wgKw0KICAgICAgICAgICAgICAgICAgICAgIyBjb2F1dGhvciBwdWJsaWNhdGlvbiB2YXJpYWJsZXMNCiAgICAgICAgICAgICAgICAgICAgIGNvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArDQogICAgICAgICAgICAgICAgICAgICAjIGNvYXV0aG9yIHB1YmxpY2F0aW9uIHZhcmlhYmxlcw0KICAgICAgICAgICAgICAgICAgICAgY29hX29ubGluZV9hbGxfdG90YWxfbCArIGNvYV90d2l0dGVyX3RvdGFsX2wrYXMuZmFjdG9yKHllYXIpLA0KICAgICAgICAgICAgICAgICAgIGRhdGEgPSBmaWVsZF9kYXRhc2V0LCBmYW1pbHkgPSAnYmlub21pYWwnKQ0KICANCiAgbW9kZWxfcmVzdWx0IDwtIGNvZWZ0ZXN0KG5ld3NfbW9kZWwsIHR5cGUgPSAiSEMwIiwgY2x1c3RlciA9IH5wcm9maWxlX2lkKVssXSAlPiUgDQogICAgYXMuZGF0YS5mcmFtZSgpICU+JSANCiAgICB0aWJibGU6OnJvd25hbWVzX3RvX2NvbHVtbih2YXIgPSAidGVybSIpDQogIA0KICBtb2RlbF9yZXN1bHRbbnJvdyhtb2RlbF9yZXN1bHQpKzEsIDFdIDwtICJSXjIiDQogIG1vZGVsX3Jlc3VsdFtucm93KG1vZGVsX3Jlc3VsdCksIDI6bmNvbChtb2RlbF9yZXN1bHQpXSA8LSByb3VuZChQc2V1ZG9SMihuZXdzX21vZGVsKSwzKQ0KICBtb2RlbF9yZXN1bHQkZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9iaW4xMF9tb2RlbHNfdHdpdHRlciA8LSByYmluZChhbGxfYmluMTBfbW9kZWxzX3R3aXR0ZXIsDQogICAgICAgICAgICAgICAgICAgICAgbW9kZWxfcmVzdWx0KQ0KICANCiAgZ2VuZGVyX2NvbXBhcmlzb24gPC0gdGVzdF9wcmVkaWN0aW9ucyhuZXdzX21vZGVsLCBjKCJpbmZlcnJlZF9nZW5kZXIiKSwgdmNvdl9mdW4gPSAidmNvdkNMIikNCiAgZ2VuZGVyX2NvbXBhcmlzb24kZmllbGQgPC0gZmllbGQNCiAgDQogIGFsbF9iaW4xMF9jb21wYXJpc29uc190d2l0dGVyIDwtIHJiaW5kKGFsbF9iaW4xMF9jb21wYXJpc29uc190d2l0dGVyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZGVyX2NvbXBhcmlzb24pDQogIA0KICANCn0NCg0KYWxsX2JpbjEwX21vZGVsc190d2l0dGVyJHN0YXJzIDwtIGlmZWxzZShhbGxfYmluMTBfbW9kZWxzX3R3aXR0ZXIkYFByKD58enwpYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2JpbjEwX21vZGVsc190d2l0dGVyJGBQcig+fHp8KWAgPD0gMC4wMDEsICIqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW4xMF9tb2RlbHNfdHdpdHRlciRgUHIoPnx6fClgIDw9IDAuMDUsICIqIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGFsbF9iaW4xMF9tb2RlbHNfdHdpdHRlciRgUHIoPnx6fClgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX3R3aXR0ZXIkc3RhcnMgPC0gaWZlbHNlKGFsbF9iaW4xMF9jb21wYXJpc29uc190d2l0dGVyJGBwLnZhbHVlYCA8PSAwLjAwMSwgIioqKiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2JpbjEwX2NvbXBhcmlzb25zX3R3aXR0ZXIkYHAudmFsdWVgIDw9IDAuMDAxLCAiKioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShhbGxfYmluMTBfY29tcGFyaXNvbnNfdHdpdHRlciRgcC52YWx1ZWAgPD0gMC4wNSwgIioiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoYWxsX2JpbjEwX2NvbXBhcmlzb25zX3R3aXR0ZXIkYHAudmFsdWVgIDw9IDAuMSwgIi4iLCAiIikpKSkNCg0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX3R3aXR0ZXIkZ3JvdXAxIDwtIHN0cl9zcGxpdF9pKGFsbF9iaW4xMF9jb21wYXJpc29uc190d2l0dGVyJGluZmVycmVkX2dlbmRlciwgIi0iLCAxKQ0KYWxsX2JpbjEwX2NvbXBhcmlzb25zX3R3aXR0ZXIkZ3JvdXAyIDwtIHN0cl9zcGxpdF9pKGFsbF9iaW4xMF9jb21wYXJpc29uc190d2l0dGVyJGluZmVycmVkX2dlbmRlciwgIi0iLCAyKQ0KDQphbGxfYmluMTBfY29tcGFyaXNvbnNfdHdpdHRlciRwX3JvdW5kZWQgPC0gcm91bmQoYWxsX2JpbjEwX2NvbXBhcmlzb25zX3R3aXR0ZXIkcC52YWx1ZSwgNCkNCmBgYA0KIyMgV3JpdGUgb3V0IHRoZSBtb2RlbHMNCmBgYHtyfQ0Kd3JpdGVfY3N2KGFsbF9iaW4xMF9tb2RlbHNfbmV3cywgIlBsb3RzX2FwcmlsL3JlZ19tb2RfYmluMTBfbmV3cy5jc3YiKQ0Kd3JpdGVfY3N2KGFsbF9iaW4xMF9tb2RlbHNfb25saW5lX25ld3MsICJQbG90c19hcHJpbC9yZWdfbW9kX2JpbjEwX29ubGluZV9uZXdzLmNzdiIpDQp3cml0ZV9jc3YoYWxsX2JpbjEwX21vZGVsc190d2l0dGVyLCAiUGxvdHNfYXByaWwvcmVnX21vZF9iaW4xMF90d2l0dGVyLmNzdiIpDQpgYGANCg0KYGBge3J9DQprbml0cjo6a2FibGUoYWxsX2JpbjEwX21vZGVsc190d2l0dGVyKQ0KYGBgDQoNCiMgTW9iaWxpdHkgcGVyIGdlbmRlcg0KDQpMZXQgdXMgbG9vayBvbmx5IGF0IHBlb3BsZSB3aG8gaGF2ZSBlbnRlcmVkIHRoZSBkYXRhc2V0IGJlZm9yZSAyMDEyIGFuZCBsaW1pdCB0aGUgDQpkYXRhc2V0IHRvIHRoZSBwZXJpb2QgYWZ0ZXIgMjAxMjoNCmBgYHtyfQ0KcHJvZl9wYW5lbF9tb2JpbGl0eSA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIGZpcnN0X3B1YiA8PSAyMDEyICYgeWVhciA+PSAyMDEyKQ0KDQojIHNwbGl0IHRoZSBwZXJpb2RzIGludG8gMg0KcHJvZl9wYW5lbF9tb2JpbGl0eSRwZXJpb2QgPC0gaWZlbHNlKHByb2ZfcGFuZWxfbW9iaWxpdHkkeWVhciA8PSAyMDE3LCAiZmlyc3QiLCAic2Vjb25kIikNCmBgYA0KDQpOb3csIHNlbGVjdCBwcm9mZXNzb3JzJyBhdHRlbnRpb24gaW4gdGhlc2UgeWVhcnMgYW5kIGFkZCBpdCB1cCBwZXIgcGVyaW9kOg0KDQpHZXQgdHJhbnNpdGlvbiBtYXRyaWNlcyBwZXIgZ2VuZGVyOg0KKHNlZSB0aGUgImhlbHBlcl9mdW5jdGlvbnMuUiIgZmlsZSBmb3IgdGhlIGFjdHVhbCBmdW5jdGlvbikNCmBgYHtyIG1lc3NhZ2U9Rn0NCnNwbGl0cyA8LSA1DQoNCmdlbmRlcl9tYXRyaWNlcyA8LSBnZW5fdHJhbnNpdGlvbl9tYXRyaXgocHJvZl9wYW5lbF9tb2JpbGl0eSwgc3BsaXRfYnkgPSAiZ2VuZGVyIiwgYnJhY2tldHMgPSBzcGxpdHMpDQpgYGANCg0KR2V0IHRyYW5zaXRpb24gbWF0cmljZXMgcGVyIGdlbmRlciBhbmQgZmllbGQ6DQpgYGB7ciBtZXNzYWdlPUZ9DQpnZW5kZXJfZmllbGRfbWF0cmljZXMgPC0gZ2VuX3RyYW5zaXRpb25fbWF0cml4KHByb2ZfcGFuZWxfbW9iaWxpdHksIHNwbGl0X2J5ID0gImdlbmRlciAmIGZpZWxkIiwgYnJhY2tldHMgPSBzcGxpdHMpDQpgYGANCg0KR2V0IHBsb3RzIGZvcjoNCiMjIyBPdmVyYWxsIHRyYW5zaXRpb25zOg0KYGBge3J9DQpsb29wX2xpc3QgPC0gYygicHViX3RyYW5zaXRpb25zIiwgImNpdF90cmFuc2l0aW9ucyIsDQogICAgICAgICAgIm9ubGluZV9uZXdzX3RyYW5zaXRpb25zIiwgIm5ld3NfdHJhbnNpdGlvbnMiLCANCiAgICAgICAgICAidHdpdHRlcl90cmFuc2l0aW9ucyIpDQoNCnRpdGxlcyA8LSBjKCJQdWJsaWNhdGlvbnMiLCAiQ2l0YXRpb25zIiwNCiAgICAgICAgICAgICJPbmxpbmUgbmV3cyBhdHRlbnRpb24iLCAiTmV3cyBhdHRlbnRpb24iLA0KICAgICAgICAgICAgIlR3aXR0ZXIgYXR0ZW50aW9uIikNCg0KDQpjb2xvcl9saXN0IDwtIGMoIiNmYjkyM2MiLCAiI2ZiYmYyNCIsICIjMzRkMzk5IiwgIiMyMmQzZWUiLCAiIzgxOGNmOCIpDQoNCm92ZXJhbGxfdHJhbnNpdGlvbl9wbG90cyA8LSBsaXN0KCkNCg0KZm9yIChtYXRyaXggaW4gbG9vcF9saXN0KXsNCiAgbWF0cml4X2N1cnJlbnQgPC0gZ2VuZGVyX21hdHJpY2VzW1ttYXRyaXhdXVtbImFsbCJdXQ0KICANCiAgcGxvdF9jdXJyZW50IDwtIG1hdHJpeF9jdXJyZW50ICU+JSANCiAgICBhcy5kYXRhLmZyYW1lKCkgJT4lDQogICAgcm93bmFtZXNfdG9fY29sdW1uKCJwMSIpICU+JQ0KICAgIHBpdm90X2xvbmdlcigtYyhwMSksIG5hbWVzX3RvID0gInAyIiwgdmFsdWVzX3RvID0gInByb2IiKSU+JQ0KICAgIGdncGxvdChhZXMoeD1hcy5pbnRlZ2VyKHAxKSwgeT1hcy5pbnRlZ2VyKHAyKSwgZmlsbD1wcm9iKSkgKyANCiAgICBnZW9tX3RpbGUoKSArDQogICAgc2NhbGVfZmlsbF9ncmFkaWVudDIobG93ID0gIiNmODcxNzEiLCBtaWQgPSAid2hpdGUiLCBoaWdoID0gY29sb3JfbGlzdFt3aGljaChsb29wX2xpc3QgPT0gbWF0cml4KV0pKw0KICAgIHNjYWxlX3hfY29udGludW91cyhicmVha3M9c2VxKDAsIHNwbGl0cywgMSksIGV4cGFuZCA9IGMoMCwgMCkpKw0KICAgIHNjYWxlX3lfY29udGludW91cyhicmVha3M9c2VxKDAsIHNwbGl0cywgMSksIHRyYW5zID0gInJldmVyc2UiLCBleHBhbmQgPSBjKDAsIDApKSsNCiAgICB4bGFiKCJQZXJpb2QgMTogMjAxMS0yMDE3IikrDQogICAgeWxhYigiUGVyaW9kIDI6IDIwMTgtMjAyMyIpKw0KICAgIHRoZW1lX21pbmltYWwoKSsNCiAgICBnZ3RpdGxlKHRpdGxlc1t3aGljaChsb29wX2xpc3QgPT0gbWF0cml4KV0pKw0KICAgIGd1aWRlcyhmaWxsPWd1aWRlX2xlZ2VuZCh0aXRsZT0iUHJvYmFiaWxpdHkiKSkrDQogICAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSAsDQogICAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTEwKSwgDQogICAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9OCkpDQogIA0KICBvdmVyYWxsX3RyYW5zaXRpb25fcGxvdHNbW21hdHJpeF1dIDwtIHBsb3RfY3VycmVudA0KICANCn0NCmBgYA0KUGxvdCB0aGVzZToNCmBgYHtyIGZpZy53aWR0aD04LCBmaWcuaGVpZ2h0PTd9DQpncmlkLmFycmFuZ2UoZ3JvYnMgPSBvdmVyYWxsX3RyYW5zaXRpb25fcGxvdHMsIG5jb2wgPSAyKQ0KYGBgDQoNCiMjIyBPdmVyYWxsIHRyYW5zaXRpb25zIHBlciBmaWVsZDoNCmBgYHtyfQ0KbG9vcF9saXN0IDwtIGMoInB1Yl90cmFuc2l0aW9ucyIsICJjaXRfdHJhbnNpdGlvbnMiLA0KICAgICAgICAgICJvbmxpbmVfbmV3c190cmFuc2l0aW9ucyIsICJuZXdzX3RyYW5zaXRpb25zIiwgDQogICAgICAgICAgInR3aXR0ZXJfdHJhbnNpdGlvbnMiKQ0KDQp0aXRsZXMgPC0gYygiUHVibGljYXRpb25zIiwgIkNpdGF0aW9ucyIsDQogICAgICAgICAgICAiT25saW5lIG5ld3MgYXR0ZW50aW9uIiwgIk5ld3MgYXR0ZW50aW9uIiwNCiAgICAgICAgICAgICJUd2l0dGVyIGF0dGVudGlvbiIpDQoNCg0KY29sb3JfbGlzdCA8LSBjKCIjZmI5MjNjIiwgIiNmYmJmMjQiLCAiIzM0ZDM5OSIsICIjMjJkM2VlIiwgIiM4MThjZjgiKQ0KDQpvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHMgPC0gbGlzdCgpDQoNCmZvciAobWF0cml4IGluIGxvb3BfbGlzdCl7DQogIGZpZWxkcyA8LSBjKCJTVEVNIiwgIlNvY2lhbCBzY2llbmNlcyIsICJNZWRpY2luZSIsICJBcnRzICYgSHVtYW5pdGllcyIpDQogIA0KICBmb3IgKGZpZWxkIGluIGZpZWxkcyl7DQogIG1hdHJpeF9jdXJyZW50IDwtIGdlbmRlcl9maWVsZF9tYXRyaWNlc1tbbWF0cml4XV1bW2ZpZWxkXV1bWyJhbGwiXV0NCiAgDQogIHBsb3RfY3VycmVudCA8LSBtYXRyaXhfY3VycmVudCAlPiUgDQogICAgYXMuZGF0YS5mcmFtZSgpICU+JQ0KICAgIHJvd25hbWVzX3RvX2NvbHVtbigicDEiKSAlPiUNCiAgICBwaXZvdF9sb25nZXIoLWMocDEpLCBuYW1lc190byA9ICJwMiIsIHZhbHVlc190byA9ICJwcm9iIiklPiUNCiAgICBnZ3Bsb3QoYWVzKHg9YXMuaW50ZWdlcihwMSksIHk9YXMuaW50ZWdlcihwMiksIGZpbGw9cHJvYikpICsgDQogICAgZ2VvbV90aWxlKCkgKw0KICAgIHNjYWxlX2ZpbGxfZ3JhZGllbnQyKGxvdyA9ICIjZjg3MTcxIiwgbWlkID0gIndoaXRlIiwgaGlnaCA9IGNvbG9yX2xpc3Rbd2hpY2gobG9vcF9saXN0ID09IG1hdHJpeCldKSsNCiAgICBzY2FsZV94X2NvbnRpbnVvdXMoYnJlYWtzPXNlcSgwLCBzcGxpdHMsIDEpLCBleHBhbmQgPSBjKDAsIDApKSsNCiAgICBzY2FsZV95X2NvbnRpbnVvdXMoYnJlYWtzPXNlcSgwLCBzcGxpdHMsIDEpLCB0cmFucyA9ICJyZXZlcnNlIiwgZXhwYW5kID0gYygwLCAwKSkrDQogICAgeGxhYigiUGVyaW9kIDE6IDIwMTEtMjAxNyIpKw0KICAgIHlsYWIoIlBlcmlvZCAyOiAyMDE4LTIwMjMiKSsNCiAgICB0aGVtZV9taW5pbWFsKCkrDQogICAgZ2d0aXRsZSh0aXRsZXNbd2hpY2gobG9vcF9saXN0ID09IG1hdHJpeCldKSsNCiAgICBndWlkZXMoZmlsbD1ndWlkZV9sZWdlbmQodGl0bGU9IlByb2JhYmlsaXR5IikpKw0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSA5KSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KHNpemUgPSA5KSAsDQogICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF90ZXh0KHNpemU9MTApLCANCiAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9OCkpDQogIA0KICBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNbW2ZpZWxkXV1bW21hdHJpeF1dIDwtIHBsb3RfY3VycmVudA0KICANCiAgfQ0KICANCn0NCmBgYA0KDQpQcmVwYXJlIHRyYW5zaXRpb24gcGxvdHMgcGVyIGZpZWxkOg0KYGBge3IgZmlnLndpZHRoPTEyLCBmaWcuaGVpZ2h0PTEyfQ0KcGxvdDEgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzW1snU1RFTSddXVs0XVtbIm5ld3NfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGkpIE5ld3MgYXR0ZW50aW9uIikNCnBsb3QyIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c1tbJ1NURU0nXV1bM11bWyJvbmxpbmVfbmV3c190cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaWkpIE9ubGluZSBhdHRlbnRpb24iKQ0KcGxvdDMgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzW1snU1RFTSddXVs1XVtbInR3aXR0ZXJfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGlpaSkgVHdpdHRlciBhdHRlbnRpb24iKQ0KDQojIG5vdyBhZGQgdGhlIHRpdGxlDQp0aXRsZSA8LSBnZ2RyYXcoKSArIA0KICBkcmF3X2xhYmVsKA0KICAgICIoYSkgU1RFTSIsDQogICAgeCA9IDAsDQogICAgaGp1c3QgPSAwDQogICkgKw0KICB0aGVtZSgNCiAgICAjIGFkZCBtYXJnaW4gb24gdGhlIGxlZnQgb2YgdGhlIGRyYXdpbmcgY2FudmFzLA0KICAgICMgc28gdGl0bGUgaXMgYWxpZ25lZCB3aXRoIGxlZnQgZWRnZSBvZiBmaXJzdCBwbG90DQogICAgcGxvdC5tYXJnaW4gPSBtYXJnaW4oMCwgMCwgMCwgNykNCiAgKQ0Kc3RlbSA8LSBwbG90X2dyaWQocGxvdDEsDQogICAgICAgICAgICAgICAgICBwbG90MiwNCiAgICAgICAgICAgICAgICAgIHBsb3QzLCBuY29sID0gMywgbnJvdyA9IDEpDQoNCnN0ZW0gPC0gcGxvdF9ncmlkKA0KICB0aXRsZSwgc3RlbSwNCiAgbmNvbCA9IDEsDQogICMgcmVsX2hlaWdodHMgdmFsdWVzIGNvbnRyb2wgdmVydGljYWwgdGl0bGUgbWFyZ2lucw0KICByZWxfaGVpZ2h0cyA9IGMoMC4xLCAxKQ0KKQ0KDQpwbG90MSA8LSBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNbWydTb2NpYWwgc2NpZW5jZXMnXV1bNF1bWyJuZXdzX3RyYW5zaXRpb25zIl1dK2dndGl0bGUoIihpKSBOZXdzIGF0dGVudGlvbiIpDQpwbG90MiA8LSBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNbWydTb2NpYWwgc2NpZW5jZXMnXV1bM11bWyJvbmxpbmVfbmV3c190cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaWkpIE9ubGluZSBhdHRlbnRpb24iKQ0KcGxvdDMgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzW1snU29jaWFsIHNjaWVuY2VzJ11dWzVdW1sidHdpdHRlcl90cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaWlpKSBUd2l0dGVyIGF0dGVudGlvbiIpDQoNCnNvY19zY2kgPC0gcGxvdF9ncmlkKHBsb3QxLA0KICAgICAgICAgICAgICAgICAgICAgcGxvdDIsDQogICAgICAgICAgICAgICAgICAgICBwbG90MywgbmNvbCA9IDMsIG5yb3cgPSAxKQ0KDQp0aXRsZSA8LSBnZ2RyYXcoKSArIA0KICBkcmF3X2xhYmVsKA0KICAgICIoYikgU29jaWFsIHNjaWVuY2UiLA0KICAgIHggPSAwLA0KICAgIGhqdXN0ID0gMA0KICApICsNCiAgdGhlbWUoDQogICAgIyBhZGQgbWFyZ2luIG9uIHRoZSBsZWZ0IG9mIHRoZSBkcmF3aW5nIGNhbnZhcywNCiAgICAjIHNvIHRpdGxlIGlzIGFsaWduZWQgd2l0aCBsZWZ0IGVkZ2Ugb2YgZmlyc3QgcGxvdA0KICAgIHBsb3QubWFyZ2luID0gbWFyZ2luKDAsIDAsIDAsIDcpDQogICkNCg0Kc29jX3NjaSA8LSBwbG90X2dyaWQoDQogIHRpdGxlLCBzb2Nfc2NpLA0KICBuY29sID0gMSwNCiAgIyByZWxfaGVpZ2h0cyB2YWx1ZXMgY29udHJvbCB2ZXJ0aWNhbCB0aXRsZSBtYXJnaW5zDQogIHJlbF9oZWlnaHRzID0gYygwLjEsIDEpDQopDQoNCnBsb3QxIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c1tbJ01lZGljaW5lJ11dWzRdW1sibmV3c190cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaSkgTmV3cyBhdHRlbnRpb24iKQ0KcGxvdDIgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzW1snTWVkaWNpbmUnXV1bM11bWyJvbmxpbmVfbmV3c190cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaWkpIE9ubGluZSBhdHRlbnRpb24iKQ0KcGxvdDMgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzW1snTWVkaWNpbmUnXV1bNV1bWyJ0d2l0dGVyX3RyYW5zaXRpb25zIl1dK2dndGl0bGUoIihpaWkpIFR3aXR0ZXIgYXR0ZW50aW9uIikNCg0KbWVkaWNpbmUgPC0gcGxvdF9ncmlkKHBsb3QxLA0KICAgICAgICAgIHBsb3QyLA0KICAgICAgICAgIHBsb3QzLCBuY29sID0gMywgbnJvdyA9IDEpDQoNCnRpdGxlIDwtIGdnZHJhdygpICsgDQogIGRyYXdfbGFiZWwoDQogICAgIihjKSBNZWRpY2luZSIsDQogICAgeCA9IDAsDQogICAgaGp1c3QgPSAwDQogICkgKw0KICB0aGVtZSgNCiAgICAjIGFkZCBtYXJnaW4gb24gdGhlIGxlZnQgb2YgdGhlIGRyYXdpbmcgY2FudmFzLA0KICAgICMgc28gdGl0bGUgaXMgYWxpZ25lZCB3aXRoIGxlZnQgZWRnZSBvZiBmaXJzdCBwbG90DQogICAgcGxvdC5tYXJnaW4gPSBtYXJnaW4oMCwgMCwgMCwgNykNCiAgKQ0KDQptZWRpY2luZSA8LSBwbG90X2dyaWQoDQogIHRpdGxlLCBtZWRpY2luZSwNCiAgbmNvbCA9IDEsDQogICMgcmVsX2hlaWdodHMgdmFsdWVzIGNvbnRyb2wgdmVydGljYWwgdGl0bGUgbWFyZ2lucw0KICByZWxfaGVpZ2h0cyA9IGMoMC4xLCAxKQ0KKQ0KDQpwbG90MSA8LSBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNbWydBcnRzICYgSHVtYW5pdGllcyddXVs0XVtbIm5ld3NfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGkpIE5ld3MgYXR0ZW50aW9uIikNCnBsb3QyIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c1tbJ0FydHMgJiBIdW1hbml0aWVzJ11dWzNdW1sib25saW5lX25ld3NfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGlpKSBPbmxpbmUgYXR0ZW50aW9uIikNCnBsb3QzIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c1tbJ0FydHMgJiBIdW1hbml0aWVzJ11dWzVdW1sidHdpdHRlcl90cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaWlpKSBUd2l0dGVyIGF0dGVudGlvbiIpDQoNCmFydHNfaHVtIDwtIHBsb3RfZ3JpZChwbG90MSwNCiAgICAgICAgICBwbG90MiwNCiAgICAgICAgICBwbG90MywgbmNvbCA9IDMsIG5yb3cgPSAxKQ0KDQp0aXRsZSA8LSBnZ2RyYXcoKSArIA0KICBkcmF3X2xhYmVsKA0KICAgICIoZCkgQXJ0cyAmIEh1bWFuaXRpZXMiLA0KICAgIHggPSAwLA0KICAgIGhqdXN0ID0gMA0KICApICsNCiAgdGhlbWUoDQogICAgIyBhZGQgbWFyZ2luIG9uIHRoZSBsZWZ0IG9mIHRoZSBkcmF3aW5nIGNhbnZhcywNCiAgICAjIHNvIHRpdGxlIGlzIGFsaWduZWQgd2l0aCBsZWZ0IGVkZ2Ugb2YgZmlyc3QgcGxvdA0KICAgIHBsb3QubWFyZ2luID0gbWFyZ2luKDAsIDAsIDAsIDcpDQogICkNCg0KYXJ0c19odW0gPC0gcGxvdF9ncmlkKA0KICB0aXRsZSwgYXJ0c19odW0sDQogIG5jb2wgPSAxLA0KICAjIHJlbF9oZWlnaHRzIHZhbHVlcyBjb250cm9sIHZlcnRpY2FsIHRpdGxlIG1hcmdpbnMNCiAgcmVsX2hlaWdodHMgPSBjKDAuMSwgMSkNCikNCg0KYGBgDQoNClNhdmUgdGhlIHBsb3Q6DQpgYGB7ciBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9MTB9DQpnZ3NhdmUoZmlsZT0iUGxvdHNfYXByaWwvU3VwcGxlbWVudGFsL1Bfb3ZlcmFsbF90cmFuc2l0aW9uc18yMC5wbmciLCANCiAgICAgICBncmlkLmFycmFuZ2Uoc3RlbSwgc29jX3NjaSwNCiAgICAgICAgICAgICAgICAgICAgbWVkaWNpbmUsIGFydHNfaHVtLA0KICAgICAgICAgICAgICAgICAgICBuY29sID0gMSwgbnJvdyA9IDQpLA0KICAgICAgIHdpZHRoID0gMTAsDQogICAgICAgaGVpZ2h0ID0gMTAsDQogICAgICAgdW5pdHMgPSAiaW4iKQ0KYGBgDQoNCiMjIyBEaWZmZXJlbmNlcyBpbiB0cmFuc2l0aW9uczoNCmBgYHtyfQ0KbG9vcF9saXN0IDwtIGMoIm9ubGluZV9uZXdzX3RyYW5zaXRpb25zIiwgIm5ld3NfdHJhbnNpdGlvbnMiLCANCiAgICAgICAgICAidHdpdHRlcl90cmFuc2l0aW9ucyIpDQoNCnRpdGxlcyA8LSBjKCJPbmxpbmUgbmV3cyBhdHRlbnRpb24iLCAiTmV3cyBhdHRlbnRpb24iLA0KICAgICAgICAgICAgIlR3aXR0ZXIgYXR0ZW50aW9uIikNCg0KDQpjb2xvcl9saXN0IDwtIGMoIiNmYjkyM2MiLCAiI2ZiYmYyNCIsICIjMzRkMzk5IiwgIiMyMmQzZWUiLCAiIzgxOGNmOCIpDQpjb2xvcl9saXN0MiA8LSBjKCIjZmZmN2VkIiwgIiNmZmZiZWIiLCAiI2VjZmRmNSIsICIjZWNmZWZmIiwgIiNlZWYyZmYiKQ0KDQpvdmVyYWxsX2RpZmZfcGxvdHMgPC0gbGlzdCgpDQoNCmZvciAobWF0cml4IGluIGxvb3BfbGlzdCl7DQogIG1hdHJpeF9jdXJyZW50X21lbiA8LSBnZW5kZXJfbWF0cmljZXNbW21hdHJpeF1dW1sibWVuIl1dDQogIG1hdHJpeF9jdXJyZW50X3dvbWVuIDwtIGdlbmRlcl9tYXRyaWNlc1tbbWF0cml4XV1bWyJ3b21lbiJdXQ0KICBtYXRyaXhfZGlmZiA8LSBtYXRyaXhfY3VycmVudF93b21lbiAtIG1hdHJpeF9jdXJyZW50X21lbg0KICBwbG90X2N1cnJlbnQgPC0gbWF0cml4X2RpZmYgJT4lIA0KICAgIGFzLmRhdGEuZnJhbWUoKSAlPiUNCiAgICByb3duYW1lc190b19jb2x1bW4oInAxIikgJT4lDQogICAgcGl2b3RfbG9uZ2VyKC1jKHAxKSwgbmFtZXNfdG8gPSAicDIiLCB2YWx1ZXNfdG8gPSAicHJvYiIpJT4lDQogICAgZ2dwbG90KGFlcyh4PWFzLmludGVnZXIocDEpLCB5PWFzLmludGVnZXIocDIpLCBmaWxsPXByb2IpKSArIA0KICAgIGdlb21fdGlsZSgpICsNCiAgICBzY2FsZV9maWxsX2dyYWRpZW50Mihsb3cgPSAiI2Y4NzE3MSIsIG1pZCA9ICJ3aGl0ZSIsIGhpZ2ggPSBjb2xvcl9saXN0W3doaWNoKGxvb3BfbGlzdCA9PSBtYXRyaXgpXSkrDQogICAgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcz1zZXEoMCwgc3BsaXRzLCAxKSwgZXhwYW5kID0gYygwLCAwKSkrDQogICAgc2NhbGVfeV9jb250aW51b3VzKGJyZWFrcz1zZXEoMCwgc3BsaXRzLCAxKSwgdHJhbnMgPSAicmV2ZXJzZSIsIGV4cGFuZCA9IGMoMCwgMCkpKw0KICAgIHhsYWIoInBfMSIpKw0KICAgIHlsYWIoInBfMiIpKw0KICAgIHRoZW1lX21pbmltYWwoKSsNCiAgICBnZ3RpdGxlKHRpdGxlc1t3aGljaChsb29wX2xpc3QgPT0gbWF0cml4KV0pKw0KICAgIGd1aWRlcyhmaWxsPWd1aWRlX2xlZ2VuZCh0aXRsZT0iRGlmZi4gKHcgLSBtKSIpKQ0KICANCiAgb3ZlcmFsbF9kaWZmX3Bsb3RzW1ttYXRyaXhdXSA8LSBwbG90X2N1cnJlbnQNCiAgDQp9DQpgYGANCg0KUGxvdCB0aGVzZToNCmBgYHtyIGZpZy53aWR0aD0xMiwgZmlnLmhlaWdodD0zfQ0KZ3JpZC5hcnJhbmdlKGdyb2JzID0gb3ZlcmFsbF9kaWZmX3Bsb3RzLCBuY29sID0gMykNCmBgYA0KDQpEaWZmZXJlbmNlcyBwZXIgZmllbGQ6DQpgYGB7cn0NCmxvb3BfbGlzdCA8LSBjKCJwdWJfdHJhbnNpdGlvbnMiLCAiY2l0X3RyYW5zaXRpb25zIiwNCiAgICAgICAgICAib25saW5lX25ld3NfdHJhbnNpdGlvbnMiLCAibmV3c190cmFuc2l0aW9ucyIsIA0KICAgICAgICAgICJ0d2l0dGVyX3RyYW5zaXRpb25zIikNCg0KdGl0bGVzIDwtIGMoIlB1YmxpY2F0aW9ucyIsICJDaXRhdGlvbnMiLA0KICAgICAgICAgICAgIk9ubGluZSBuZXdzIGF0dGVudGlvbiIsICJOZXdzIGF0dGVudGlvbiIsDQogICAgICAgICAgICAiVHdpdHRlciBhdHRlbnRpb24iKQ0KDQoNCmNvbG9yX2xpc3QgPC0gYygiI2ZiOTIzYyIsICIjZmJiZjI0IiwgIiMzNGQzOTkiLCAiIzIyZDNlZSIsICIjODE4Y2Y4IikNCg0Kb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzX2RpZmYgPC0gbGlzdCgpDQoNCmZvciAobWF0cml4IGluIGxvb3BfbGlzdCl7DQogIGZpZWxkcyA8LSBjKCJTVEVNIiwgIlNvY2lhbCBzY2llbmNlcyIsICJNZWRpY2luZSIsICJBcnRzICYgSHVtYW5pdGllcyIpDQogIA0KICBmb3IgKGZpZWxkIGluIGZpZWxkcyl7DQogIG1hdHJpeF9jdXJyZW50X21lbiA8LSBnZW5kZXJfZmllbGRfbWF0cmljZXNbW21hdHJpeF1dW1tmaWVsZF1dW1sibWVuIl1dDQogIG1hdHJpeF9jdXJyZW50X3dvbWVuIDwtIGdlbmRlcl9maWVsZF9tYXRyaWNlc1tbbWF0cml4XV1bW2ZpZWxkXV1bWyJ3b21lbiJdXQ0KICBtYXRyaXhfZGlmZiA8LSBtYXRyaXhfY3VycmVudF93b21lbiAtIG1hdHJpeF9jdXJyZW50X21lbg0KICANCiAgcGxvdF9jdXJyZW50IDwtIG1hdHJpeF9kaWZmICU+JSANCiAgICBhcy5kYXRhLmZyYW1lKCkgJT4lDQogICAgcm93bmFtZXNfdG9fY29sdW1uKCJwMSIpICU+JQ0KICAgIHBpdm90X2xvbmdlcigtYyhwMSksIG5hbWVzX3RvID0gInAyIiwgdmFsdWVzX3RvID0gInByb2IiKSU+JQ0KICAgIGdncGxvdChhZXMoeD1hcy5pbnRlZ2VyKHAxKSwgeT1hcy5pbnRlZ2VyKHAyKSwgZmlsbD1wcm9iKSkgKyANCiAgICBnZW9tX3RpbGUoKSArDQogICAgc2NhbGVfZmlsbF9ncmFkaWVudDIobG93ID0gIiNmODcxNzEiLCBtaWQgPSAid2hpdGUiLCBoaWdoID0gY29sb3JfbGlzdFt3aGljaChsb29wX2xpc3QgPT0gbWF0cml4KV0sIGxpbWl0cz1jKC0wLjQsIDAuNCksIGJyZWFrcz1zZXEocm91bmQoLTAuNCwgMSkscm91bmQoMC40LDEpLGJ5PTAuMikpKw0KICAgIHNjYWxlX3hfY29udGludW91cyhicmVha3M9c2VxKDAsIHNwbGl0cywgMSksIGV4cGFuZCA9IGMoMCwgMCkpKw0KICAgIHNjYWxlX3lfY29udGludW91cyhicmVha3M9c2VxKDAsIHNwbGl0cywgMSksIHRyYW5zID0gInJldmVyc2UiLCBleHBhbmQgPSBjKDAsIDApKSsNCiAgICB4bGFiKCJQZXJpb2QgMTogMjAxMS0yMDE3IikrDQogICAgeWxhYigiUGVyaW9kIDI6IDIwMTgtMjAyMyIpKw0KICAgIHRoZW1lX21pbmltYWwoKSsNCiAgICBnZ3RpdGxlKHRpdGxlc1t3aGljaChsb29wX2xpc3QgPT0gbWF0cml4KV0pKw0KICAgIGd1aWRlcyhmaWxsPWd1aWRlX2xlZ2VuZCh0aXRsZT0iUHJvYi4gZGlmZi4gKHctbSkiKSkrDQogIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDkpLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDkpICwNCiAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGxlZ2VuZC50aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xMCksIA0KICAgICAgICBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT04KSkNCiAgDQogIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c19kaWZmW1tmaWVsZF1dW1ttYXRyaXhdXSA8LSBwbG90X2N1cnJlbnQNCiAgDQogIH0NCiAgDQp9DQpgYGANCg0KUHJlcGFyZSB0cmFuc2l0aW9uIGRpZmZlcmVuY2UgcGxvdHMgcGVyIGZpZWxkOg0KYGBge3IgZmlnLndpZHRoPTEyLCBmaWcuaGVpZ2h0PTEyfQ0KcGxvdDEgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzX2RpZmZbWydTVEVNJ11dWzRdW1sibmV3c190cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaSkgTmV3cyBhdHRlbnRpb24iKQ0KcGxvdDIgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzX2RpZmZbWydTVEVNJ11dWzNdW1sib25saW5lX25ld3NfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGlpKSBPbmxpbmUgYXR0ZW50aW9uIikNCnBsb3QzIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c19kaWZmW1snU1RFTSddXVs1XVtbInR3aXR0ZXJfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGlpaSkgVHdpdHRlciBhdHRlbnRpb24iKQ0KDQojIG5vdyBhZGQgdGhlIHRpdGxlDQp0aXRsZSA8LSBnZ2RyYXcoKSArIA0KICBkcmF3X2xhYmVsKA0KICAgICIoYSkgU1RFTSIsDQogICAgeCA9IDAsDQogICAgaGp1c3QgPSAwDQogICkgKw0KICB0aGVtZSgNCiAgICAjIGFkZCBtYXJnaW4gb24gdGhlIGxlZnQgb2YgdGhlIGRyYXdpbmcgY2FudmFzLA0KICAgICMgc28gdGl0bGUgaXMgYWxpZ25lZCB3aXRoIGxlZnQgZWRnZSBvZiBmaXJzdCBwbG90DQogICAgcGxvdC5tYXJnaW4gPSBtYXJnaW4oMCwgMCwgMCwgNykNCiAgKQ0Kc3RlbSA8LSBwbG90X2dyaWQocGxvdDEsDQogICAgICAgICAgICAgICAgICBwbG90MiwNCiAgICAgICAgICAgICAgICAgIHBsb3QzLCBuY29sID0gMywgbnJvdyA9IDEpDQoNCnN0ZW0gPC0gcGxvdF9ncmlkKA0KICB0aXRsZSwgc3RlbSwNCiAgbmNvbCA9IDEsDQogICMgcmVsX2hlaWdodHMgdmFsdWVzIGNvbnRyb2wgdmVydGljYWwgdGl0bGUgbWFyZ2lucw0KICByZWxfaGVpZ2h0cyA9IGMoMC4xLCAxKQ0KKQ0KDQpwbG90MSA8LSBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNfZGlmZltbJ1NvY2lhbCBzY2llbmNlcyddXVs0XVtbIm5ld3NfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGkpIE5ld3MgYXR0ZW50aW9uIikNCnBsb3QyIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c19kaWZmW1snU29jaWFsIHNjaWVuY2VzJ11dWzNdW1sib25saW5lX25ld3NfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGlpKSBPbmxpbmUgYXR0ZW50aW9uIikNCnBsb3QzIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c19kaWZmW1snU29jaWFsIHNjaWVuY2VzJ11dWzVdW1sidHdpdHRlcl90cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaWlpKSBUd2l0dGVyIGF0dGVudGlvbiIpDQoNCnNvY19zY2kgPC0gcGxvdF9ncmlkKHBsb3QxLA0KICAgICAgICAgICAgICAgICAgICAgcGxvdDIsDQogICAgICAgICAgICAgICAgICAgICBwbG90MywgbmNvbCA9IDMsIG5yb3cgPSAxKQ0KDQp0aXRsZSA8LSBnZ2RyYXcoKSArIA0KICBkcmF3X2xhYmVsKA0KICAgICIoYikgU29jaWFsIHNjaWVuY2UiLA0KICAgIHggPSAwLA0KICAgIGhqdXN0ID0gMA0KICApICsNCiAgdGhlbWUoDQogICAgIyBhZGQgbWFyZ2luIG9uIHRoZSBsZWZ0IG9mIHRoZSBkcmF3aW5nIGNhbnZhcywNCiAgICAjIHNvIHRpdGxlIGlzIGFsaWduZWQgd2l0aCBsZWZ0IGVkZ2Ugb2YgZmlyc3QgcGxvdA0KICAgIHBsb3QubWFyZ2luID0gbWFyZ2luKDAsIDAsIDAsIDcpDQogICkNCg0Kc29jX3NjaSA8LSBwbG90X2dyaWQoDQogIHRpdGxlLCBzb2Nfc2NpLA0KICBuY29sID0gMSwNCiAgIyByZWxfaGVpZ2h0cyB2YWx1ZXMgY29udHJvbCB2ZXJ0aWNhbCB0aXRsZSBtYXJnaW5zDQogIHJlbF9oZWlnaHRzID0gYygwLjEsIDEpDQopDQoNCnBsb3QxIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c19kaWZmW1snTWVkaWNpbmUnXV1bNF1bWyJuZXdzX3RyYW5zaXRpb25zIl1dK2dndGl0bGUoIihpKSBOZXdzIGF0dGVudGlvbiIpDQpwbG90MiA8LSBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNfZGlmZltbJ01lZGljaW5lJ11dWzNdW1sib25saW5lX25ld3NfdHJhbnNpdGlvbnMiXV0rZ2d0aXRsZSgiKGlpKSBPbmxpbmUgYXR0ZW50aW9uIikNCnBsb3QzIDwtIG92ZXJhbGxfZmllbGRfdHJhbnNpdGlvbl9wbG90c19kaWZmW1snTWVkaWNpbmUnXV1bNV1bWyJ0d2l0dGVyX3RyYW5zaXRpb25zIl1dK2dndGl0bGUoIihpaWkpIFR3aXR0ZXIgYXR0ZW50aW9uIikNCg0KbWVkaWNpbmUgPC0gcGxvdF9ncmlkKHBsb3QxLA0KICAgICAgICAgIHBsb3QyLA0KICAgICAgICAgIHBsb3QzLCBuY29sID0gMywgbnJvdyA9IDEpDQoNCnRpdGxlIDwtIGdnZHJhdygpICsgDQogIGRyYXdfbGFiZWwoDQogICAgIihjKSBNZWRpY2luZSIsDQogICAgeCA9IDAsDQogICAgaGp1c3QgPSAwDQogICkgKw0KICB0aGVtZSgNCiAgICAjIGFkZCBtYXJnaW4gb24gdGhlIGxlZnQgb2YgdGhlIGRyYXdpbmcgY2FudmFzLA0KICAgICMgc28gdGl0bGUgaXMgYWxpZ25lZCB3aXRoIGxlZnQgZWRnZSBvZiBmaXJzdCBwbG90DQogICAgcGxvdC5tYXJnaW4gPSBtYXJnaW4oMCwgMCwgMCwgNykNCiAgKQ0KDQptZWRpY2luZSA8LSBwbG90X2dyaWQoDQogIHRpdGxlLCBtZWRpY2luZSwNCiAgbmNvbCA9IDEsDQogICMgcmVsX2hlaWdodHMgdmFsdWVzIGNvbnRyb2wgdmVydGljYWwgdGl0bGUgbWFyZ2lucw0KICByZWxfaGVpZ2h0cyA9IGMoMC4xLCAxKQ0KKQ0KDQpwbG90MSA8LSBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNfZGlmZltbJ0FydHMgJiBIdW1hbml0aWVzJ11dWzRdW1sibmV3c190cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaSkgTmV3cyBhdHRlbnRpb24iKQ0KcGxvdDIgPC0gb3ZlcmFsbF9maWVsZF90cmFuc2l0aW9uX3Bsb3RzX2RpZmZbWydBcnRzICYgSHVtYW5pdGllcyddXVszXVtbIm9ubGluZV9uZXdzX3RyYW5zaXRpb25zIl1dK2dndGl0bGUoIihpaSkgT25saW5lIGF0dGVudGlvbiIpDQpwbG90MyA8LSBvdmVyYWxsX2ZpZWxkX3RyYW5zaXRpb25fcGxvdHNfZGlmZltbJ0FydHMgJiBIdW1hbml0aWVzJ11dWzVdW1sidHdpdHRlcl90cmFuc2l0aW9ucyJdXStnZ3RpdGxlKCIoaWlpKSBUd2l0dGVyIGF0dGVudGlvbiIpDQoNCmFydHNfaHVtIDwtIHBsb3RfZ3JpZChwbG90MSwNCiAgICAgICAgICBwbG90MiwNCiAgICAgICAgICBwbG90MywgbmNvbCA9IDMsIG5yb3cgPSAxKQ0KDQp0aXRsZSA8LSBnZ2RyYXcoKSArIA0KICBkcmF3X2xhYmVsKA0KICAgICIoZCkgQXJ0cyAmIEh1bWFuaXRpZXMiLA0KICAgIHggPSAwLA0KICAgIGhqdXN0ID0gMA0KICApICsNCiAgdGhlbWUoDQogICAgIyBhZGQgbWFyZ2luIG9uIHRoZSBsZWZ0IG9mIHRoZSBkcmF3aW5nIGNhbnZhcywNCiAgICAjIHNvIHRpdGxlIGlzIGFsaWduZWQgd2l0aCBsZWZ0IGVkZ2Ugb2YgZmlyc3QgcGxvdA0KICAgIHBsb3QubWFyZ2luID0gbWFyZ2luKDAsIDAsIDAsIDcpDQogICkNCg0KYXJ0c19odW0gPC0gcGxvdF9ncmlkKA0KICB0aXRsZSwgYXJ0c19odW0sDQogIG5jb2wgPSAxLA0KICAjIHJlbF9oZWlnaHRzIHZhbHVlcyBjb250cm9sIHZlcnRpY2FsIHRpdGxlIG1hcmdpbnMNCiAgcmVsX2hlaWdodHMgPSBjKDAuMSwgMSkNCikNCg0KYGBgDQoNClNhdmUgdGhlIHBsb3Q6DQpgYGB7ciBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9MTB9DQpnZ3NhdmUoZmlsZT0iUGxvdHNfYXByaWwvU3VwcGxlbWVudGFsL1BfdHJhbnNpdGlvbl9kaWZmXzIwLnBuZyIsIA0KICAgICAgIGdyaWQuYXJyYW5nZShzdGVtLCBzb2Nfc2NpLA0KICAgICAgICAgICAgICAgICAgICBtZWRpY2luZSwgYXJ0c19odW0sDQogICAgICAgICAgICAgICAgICAgIG5jb2wgPSAxLCBucm93ID0gNCksDQogICAgICAgd2lkdGggPSAxMCwNCiAgICAgICBoZWlnaHQgPSAxMCwNCiAgICAgICB1bml0cyA9ICJpbiIpDQpgYGANCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("April_analyses.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
