<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ana Macanovic" />

<meta name="date" content="2024-01-06" />

<title>OpenAlex_Altmetric_data_download</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a>
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="index.html">Code homepage</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="glyphicon glyphicon glyphicon glyphicon-list"></span>
     
    Scripts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="SQL_tutorial.html">Intro: SQL tutorial</a>
    </li>
    <li>
      <a href="OpenAlex_Altmetric_data_download.html">1. Open Alex and Altmetric data download</a>
    </li>
    <li>
      <a href="Gender_inference.html">2. Gender inference</a>
    </li>
    <li>
      <a href="Grant_parsing.html">3. Grant parsing</a>
    </li>
    <li>
      <a href="Lexis_nexis_parser.html">4. Lexis data parser</a>
    </li>
    <li>
      <a href="Mention_url_extraction.html">5. Mention URL extraction</a>
    </li>
    <li>
      <a href="Data_descriptives.html">5. Database description and coverage</a>
    </li>
    <li>
      <a href="Panel_data_compilation.html">6. Panel data compilation</a>
    </li>
    <li>
      <a href="analyses.html">7. Various analyses</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/amacanovic/dutch_media_profs">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">OpenAlex_Altmetric_data_download</h1>
<h4 class="author">Ana Macanovic</h4>
<h4 class="date">2024-01-06</h4>

</div>


<p>This script uses OpenAlex and Altmetric databases to download data on
professors in our sample.</p>
<p>Load the necessary packages:</p>
<pre class="r"><code>library(groundhog)
packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;openalexR&quot;,
                      &quot;ggplot2&quot;, &quot;stringr&quot;, &quot;tidyr&quot;,
                      &quot;jsonlite&quot;, &quot;xml2&quot;, &quot;tidyverse&quot;,
                      &quot;RPostgres&quot;, &quot;lubridate&quot;,&quot;digest&quot;,
                      &quot;DBI&quot;, &quot;RODBC&quot;, &quot;odbc&quot;)
groundhog.library(packages_to_load, date = &quot;2023-12-01&quot;)

# we&#39;ve also added our email to the &quot;polite pool&quot; of OpenAlex by
# adding a line in the .Rprofile

# load the helper function file
source(&quot;helper_functions.R&quot;)</code></pre>
<p>Connect to our database:</p>
<pre class="r"><code>port &lt;- 
user &lt;- &quot;&quot;
password &lt;- &quot;&quot;
database_name &lt;- &quot;&quot;

con &lt;- RPostgres::dbConnect(RPostgres::Postgres(),
                 dbname= database_name,
                 port = port,
                 user = user, 
                 password = password)

con # Checks connection is working</code></pre>
<div id="tidy-up-professor-data-from-narcis" class="section level1"
number="1">
<h1><span class="header-section-number">1</span> Tidy up professor data
from NARCIS</h1>
<p>Load the professor profiles:</p>
<pre class="r"><code>load(&quot;raw_data/media_profs_profiles.rda&quot;)
profs &lt;- read_csv(&quot;raw_data/dutch_profs_urls.csv&quot;)

# merge the profs with their ORCIDs
colnames(profs)[c(1,7)] &lt;- c(&quot;id&quot;, &quot;profile_id&quot;)

profs_full &lt;- merge(profs,
                    metadf[, c(1:4, 361)],
                    by = &quot;profile_id&quot;)

# Write this out into our DB
#dbWriteTable(con, &quot;narcis_prof_info&quot;, profs_full, row.names=FALSE, append=TRUE)</code></pre>
<p>Check for professors with duplicate names:</p>
<pre class="r"><code>profs_full_dupl &lt;- profs_full
profs_full_dupl$dupl &lt;- duplicated(profs_full_dupl$full)
dupl_names &lt;- filter(profs_full_dupl, dupl == TRUE)$full


profs_duplicates &lt;- filter(profs_full_dupl, full %in% dupl_names)</code></pre>
</div>
<div id="tidy-up-the-publication-data-from-narcis"
class="section level1" number="2">
<h1><span class="header-section-number">2</span> Tidy up the publication
data from NARCIS</h1>
<p>Load the publication data:</p>
<pre class="r"><code># fetch the papers
load(&quot;~/Postdoc/Projects/dutch_media_profs_r/raw_data/media_profs_pubs.rda&quot;)
# match the publication data to authorships
load(&quot;~/Postdoc/Projects/dutch_media_profs_r/raw_data/media_profs_pub_to_profile_ids.rda&quot;)
colnames(pub_to_profile_id)[1] &lt;- &quot;narcis_url&quot;

prof_pubs_full &lt;- merge(pubs_metadf[, c(1:23)],
                        pub_to_profile_id,
                        by = &quot;narcis_url&quot;)
# strip the last / from the profile ids here
prof_pubs_full$profile_id &lt;- str_sub(prof_pubs_full$profile_id, end = -2)

# tidy up some misbehaving DOIs
prof_pubs_full$n_words &lt;- str_count(prof_pubs_full$DOI, &quot; &quot;)

# let&#39;s manually fix them since there are so few problematic ones
pubs_doi_words &lt;- filter(prof_pubs_full, n_words &gt; 0)
# these are just the DOIs where we have manually removed the spaces or redundant text
pubs_doi_words$DOI &lt;- c(&quot;10.1016/j.jhydrol.2011.03.047&quot;, &quot;10.1111/j.1365-3091.2012.01365.x&quot;,   
                         &quot;10.1120/jacmp.v17i4.6117&quot;, &quot;10.22203/ecm.v032a11&quot;,  
                         &quot;10.22203/ecm.v032a11&quot;, &quot;10.1167/iovs.16-20799&quot;,  
                         &quot;10.1136/bmjsem-2018-000427&quot;, &quot;10.1111/hae.12353&quot;,
                         &quot;10.1128/iai.64.10.4220-4225.1996&quot;, &quot;10.1039/b302097e&quot;,       
                         &quot;10.1039/b302097e&quot;, &quot;10.1016/s0016-5085(19)38052-7&quot;,
                         &quot;10.1039/b209378b&quot;, &quot;10.3850/978-981-07-2615-7-290&quot;,      
                         &quot;10.3850/978-981-07-2615-7 289&quot;, &quot;10.1016/s0040-6090(96)09248-6&quot;,    
                         &quot;10.1061(asce)mt.1943-5533.0002169&quot;, &quot;10.1371/journal.pone.0059600&quot;,     
                         &quot;10.1371/journal.pone.0059600&quot;, &quot;10.1371/journal.pone.0059600&quot;,     
                         &quot;10.1109/isbi.2016.7493532&quot;, &quot;10.1109/isbi.2016.7493532&quot;,         
                         &quot;10.1109/isbi.2016.7493532&quot;, &quot;10.1109/isbi.2016.7493532&quot;,         
                         &quot;10.1109/isbi.2016.7493532&quot;, &quot;10.1080/03797720120082651&quot;,         
                         &quot;10.3850/978-981-11-2724-3_0641-cd&quot;, &quot;10.3850/978-981-11-2724-3_0641-cd&quot;, 
                         &quot;10.3850/978-981-11-2724-3_0596-cd&quot;, &quot;10.1136/bmjopen-2017-016077&quot;,       
                         &quot;10.1103/physrevlett.115.159901&quot;, &quot;10.1515/lingvan-2016-0048&quot;,         
                         &quot;10.1108/jfrc-07-2018-0103&quot;, &quot;10.1097/01.brs.0000206381.15224.0&quot;,
                         &quot;10.1080/21507740.2016.1251990&quot;, &quot;10.1021/ie0492449 s0888-5885(04)09244-9&quot;,  
                         &quot;10.1021/ie0492449 s0888-5885(04)09244-9&quot;, &quot;10.2478/v10304-012-0011-y&quot;,   
                         &quot;10.1007/s10853-011-5682-6&quot;, &quot;10.1021/ja0455650s0002-7863(04)05565-9&quot;,   
                         &quot;10.1021/jo0401220-s0022-3263(04)00122-7&quot;,&quot;10.1007/s10103-008-0626-3&quot;,  
                         &quot;10.1371/journal.pone.0216743&quot;, &quot;10.1177/0021886316672724&quot;,         
                         &quot;10.5194/se-10-517-2019&quot;, &quot;10.18690/978-961-286-061-5.3&quot;,      
                         &quot;10.18690/978-961-286-061-5.3&quot;, &quot;10.3850/978-981-11-2724-3_0441-cd&quot;, 
                         &quot;10.3850/978-981-11-2725-0-is3-5-cd&quot;, &quot;10.3390/atmos12121633&quot;,  
                         &quot;10.3850/978-981-14-8593-0-4139-cd&quot;, &quot;10.3850/978-981-11-2724-3_0248-cd&quot;) 
# fix the pub list
# filter out the problematic dois
prof_pubs_full_fix &lt;- filter(prof_pubs_full, (is.na(n_words)|n_words == 0))
# and then put them back
prof_pubs_full &lt;- rbind(prof_pubs_full_fix,
                        pubs_doi_words)


# drop large files from the memory as we don&#39;t need them anymore
rm(pubs_metadf)
rm(metadf)
rm(pub_to_profile_id)
gc()

# Write this out into our DB
#dbWriteTable(con, &quot;narcis_pub_info&quot;, prof_pubs_full, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="oa-data" class="section level1" number="3">
<h1><span class="header-section-number">3</span> OA data</h1>
<div id="seek-professor-identifiers-in-openalex" class="section level2"
number="3.1">
<h2><span class="header-section-number">3.1</span> Seek professor
identifiers in OpenAlex</h2>
<p>Define the function that helps us seek identifiers from: 1.
Professor’s Narcis publication list (based on DOI) 2. Professor’s ORCID
as in Narcis 3. Professor’s name + NL as the country of their last known
institution</p>
<p>This diagram describes how we do it: <img
src="images/professor_identifier_retriever_diagram.png"
alt="Figure 1" /></p>
<p>Loop through professors and find their identifiers:</p>
<pre class="r"><code>narcis_ids &lt;- profs_full$profile_id
prof_identifier_list &lt;- list()

for (i in 1:length(narcis_ids)){
  narcis_id &lt;- narcis_ids[i]
  
  prof_ids &lt;- NA
  
  try(prof_ids &lt;- professor_identifier_retriever(narcis_id,
                                                 pub_data = prof_pubs_full,
                                                 prof_data = profs_full)
  )
  
  prof_identifier_list[[i]] &lt;- prof_ids
  names(prof_identifier_list)[[i]] &lt;- narcis_id
  
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
  
}</code></pre>
<p>We fail to find any OA ids for some professors. Find their OA IDs
manually:</p>
<pre class="r"><code># manually get the correct search terms for the missing professors:
missing_ids &lt;- c(&quot;https://www.narcis.nl/person/RecordID/PRS1236634&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1236869&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1236960&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1237850&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238045&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238542&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238880&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238898&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1239122&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1239606&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1239841&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1240194&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241218&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241266&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241562&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241837&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1242035&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1242243&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1243109&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1247112&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1251650&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1253801&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1255909&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1263017&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1265503&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1273858&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1276448&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1281844&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1281845&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1281875&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1283984&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1286354&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1288340&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1288550&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1289299&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1291051&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1291919&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1291938&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1295469&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1295569&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1296313&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1297223&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1297929&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1300768&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1303552&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1304651&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1313781&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1314178&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1316068&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1317806&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1319241&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1319812&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1320174&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1321103&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1324160&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1325120&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1329166&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1331360&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1331452&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1333614&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1333801&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1334043&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1335654&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1335659&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1336365&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1336549&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1340887&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1340978&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1341557&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1342181&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1342195&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1342275&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1347897&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1348241&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1348353&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1349732&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1350328&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1350937&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351306&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351308&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351364&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351481&quot;)

missing_search_terms &lt;- c(&quot;W.H.M. Reehuis&quot;,
                          &quot;Philip H. J. G. van Huizen&quot;,
                          &quot;J.C.E. van Kollenburg&quot;,
                          &quot;A.I.M. van Mierlo&quot;,
                          &quot;Jean-Bernard Martens&quot;,
                          &quot;R.P.J.L. Tjittes&quot;,
                          &quot;J.W. Duyvendak&quot;,
                          &quot;Jean-Pierre Wils&quot;,
                          &quot;W.G. Huijgen&quot;,
                          &quot;Jan A. Bruijn&quot;,
                          &quot;Anne-Marie Korte&quot;,
                          &quot;G.W.J.M. Kampschöer&quot;,
                          NA,
                          NA,
                          &quot;m.h. corbey&quot;,
                          &quot;A.M. Lubotsky&quot;,
                          &quot;https://openalex.org/A5041930157&quot;,
                          &quot;E.F. Steennis&quot;,
                          &quot;Venugopal Venkataraman&quot;,
                          &quot;hoefte rosemarijn&quot;,
                          &quot;B.P.M. van Ravels&quot;,
                          &quot;korsten f.w.a.&quot;,
                          &quot;Alberdina Houtman&quot;,
                          &quot;Marco P Nieuwe Weme&quot;,
                          &quot;Jan-Diederik van Wees&quot;,
                          NA,
                          &quot;C.D.J. Bulten&quot;,
                          &quot;A.M.B. DeWaegenaere&quot;,
                          &quot;Willem‐Jan van den Heuvel&quot;,
                          &quot;E.C.C. Punselie&quot;,
                          NA,
                          NA,
                          &quot;G. van Rijssen&quot;,
                          NA,
                          &quot;M.A. Verbrugh&quot;,
                          &quot;Huibert Diederik van Romburgh&quot;,
                          NA,
                          &quot;Katarzyna J. Cwiertka&quot;,
                          &quot;J.W. Foppen&quot;,
                          &quot;Peter van Gool&quot;,
                          &quot;H.J.M. Havekes&quot;,
                          NA,
                          &quot;i.a.m. saloul&quot;,
                          &quot;e.j.j. beulen&quot;,
                          &quot;Olexander Yarovyi&quot;,
                          &quot;R.P. Botha&quot;,
                          &quot;A. M. Baryshev&quot;,
                          &quot;sylvia burg-vermeulen&quot;,
                          &quot;J.S.L.A.W.B. Roes&quot;,
                          &quot;Jan Hein Furnée&quot;,
                          &quot;Annette Freyberg‐Inan&quot;,
                          &quot;Gert Jan van der Sman&quot;,
                          NA,
                          &quot;C. Goukens-Mertens&quot;,
                          NA,
                          &quot;G.R.B.E. Römer&quot;,
                          &quot;p.h.l.m. kuypers&quot;,
                          &quot;Genserik Reniers&quot;,
                          &quot;Stephan Wensveen&quot;,
                          &quot;Onno Kranenburg&quot;,
                          &quot;Schwartz-Landsman&quot;,
                          &quot;G.J.C. Rensen&quot;,
                          &quot;K.W.H. Broekhuizen&quot;,
                          &quot;S.H.M.A. Dumoulin&quot;,
                          &quot;S. Jong Kon Chin&quot;,
                          &quot;S.P.J. van Alphen&quot;,
                          &quot;Chun‐Keung Hoi&quot;,
                          &quot;Sergey Nejentsev&quot;,
                          &quot;ludovico alcorta&quot;,
                          &quot;p.a.m.g. de kock&quot;,
                          &quot;haersolte-van hof jacomijn&quot;,
                          &quot;Eugenia Houvenaghel&quot;,
                          &quot;m.a. van willigen&quot;,
                          &quot;arthur ten cate&quot;,
                          &quot;Peter Koudijs&quot;,
                          &quot;Fulvio Reggiori&quot;,
                          NA,
                          NA,
                          &quot;Antonis Papapantoleon&quot;,
                          &quot;a.c. boerstra&quot;,
                          &quot;Leonie Heres&quot;,
                          &quot;Thomas P. Moliterno&quot;)

length(which(is.na(missing_search_terms)))</code></pre>
<p>We cannot find a reliable OA ID for 12 professors in our dataset.</p>
<p>Loop through the identifier list to fill the IDs in:</p>
<pre class="r"><code>for (i in 1:length(missing_ids)){
  narcis_id &lt;- missing_ids[i]
  
  search_term &lt;- missing_search_terms[i]
  
  prof_list_item &lt;- prof_identifier_list[[narcis_id]]
  
  if (!is.na(search_term)){
    
    if(search_term == &quot;https://openalex.org/A5041930157&quot;){
      prof_oa_ids &lt;- oa_fetch(
        entity = &quot;author&quot;, &#39;A5041930157&#39;)
    }else{
      prof_oa_ids &lt;- oa_fetch(&quot;author&quot;,
                              search = search_term)
    }
    
    if (nrow(prof_oa_ids)&gt;0){
      oa_ids_names &lt;- prof_oa_ids$ids
      # if a list, only retain the OA IDs:
      if(class(oa_ids_names) == &quot;list&quot;){
        oa_ids_names &lt;- c()
        for (j in 1:nrow(prof_oa_ids)){
          id &lt;- prof_oa_ids$ids[[j]][&#39;openalex&#39;]
          oa_ids_names &lt;- c(oa_ids_names, id)
        }
        oa_ids_names &lt;- unname(oa_ids_names)
      }
      
      prof_list_item[&quot;oa_ids_names&quot;] &lt;- list(oa_ids_names)
    }
  }
  
  prof_identifier_list[[narcis_id]] &lt;- prof_list_item
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(missing_ids)))
  
}</code></pre>
<p>Extract professor IDs and sources for each professor:</p>
<pre class="r"><code>prof_oa_mapping &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))

for (i in 1:length(prof_identifier_list)){
  # initiate a dataframe to store this professor&#39;s data
  prof_oa_ids &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))
  # retrieve this professor&#39;s list of identifiers
  prof_identifiers &lt;- prof_identifier_list[[i]]
  # get their Narcis ID and all the retrieved OA IDs
  narcis_id &lt;- prof_identifier_list[[i]][[&quot;narcis_id&quot;]]
  
  pub_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_pubs&quot;]]
  
  orcid_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_orcid&quot;]]
  
  name_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_names&quot;]]
  
  # add any IDs retrieved from the publication list
  if (!all(is.na(pub_ids))){
  
  pub_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = pub_ids,
                              &quot;source&quot; = &quot;publications&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       pub_ids)
  }
  # add any IDs associated with prof&#39;s ORCID
  if (!all(is.na(orcid_ids))){
  orcid_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = orcid_ids,
                              &quot;source&quot; = &quot;orcid&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       orcid_ids)
  }
  # add any IDs from name search + NL country
  if (!all(is.na(name_ids))){
  name_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = name_ids,
                              &quot;source&quot; = &quot;name&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       name_ids)
  }
  
  # if any rows
  if (nrow(prof_oa_ids) &gt; 0){
    
    # deduplicate
    prof_oa_ids$duplicate &lt;- duplicated(prof_oa_ids[c(&quot;profile_id&quot;, &quot;oa_id&quot;)])
    prof_oa_ids &lt;- filter(prof_oa_ids,
                          duplicate == FALSE)
    prof_oa_ids &lt;- prof_oa_ids[, -4]
    
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  } else{
    prof_oa_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                                    &quot;oa_id&quot; = NA,
                                    &quot;source&quot; = NA)
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  }
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
}</code></pre>
<p>For professors where we have publication and ORCID-based OA IDs, we
will only use those (which is 5452 professors)</p>
<pre class="r"><code>prof_oa_mapping_pub_orcid &lt;- filter(prof_oa_mapping,
                                    source != &quot;name&quot;)

length(unique(prof_oa_mapping_pub_orcid$profile_id))</code></pre>
<p>And now, for the remaining professors, get their name-based IDs (1366
professors), but watch out for any oddities (e.g., an extreme number of
IDs):</p>
<pre class="r"><code>prof_oa_mapping_name &lt;- filter(prof_oa_mapping,
                               source == &quot;name&quot; &amp; ! profile_id %in% prof_oa_mapping_pub_orcid$profile_id)

length(unique(prof_oa_mapping_name$profile_id))

# check manually for odd numbers of IDs
oa_id_check &lt;- prof_oa_mapping_name %&gt;% 
  count(profile_id, source, sort = TRUE)

# here are professor IDs with more than 10 different IDs where we see inconsistent name-based results
problematic_ids &lt;- c(&quot;https://www.narcis.nl/person/RecordID/PRS1336203&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1336222&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1334028&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1303190&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1330673&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1334007&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1325766&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1340156&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1350809&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1332288&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1340901&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1336178&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1340719&quot;,
                     &quot;https://www.narcis.nl/person/RecordID/PRS1242634&quot;, 
                     &quot;https://www.narcis.nl/person/RecordID/PRS1332700&quot;)

# filter them out
prof_oa_mapping_name &lt;- filter(prof_oa_mapping_name,
                               ! profile_id %in% problematic_ids)</code></pre>
<p>Combine the reliable results together. In total, we miss OA IDs for
27 professors (0.4% of all observations):</p>
<pre class="r"><code>prof_oa_mapping_fix &lt;- rbind(prof_oa_mapping_pub_orcid,
                             prof_oa_mapping_name)

length(unique(prof_oa_mapping_fix$profile_id))
(nrow(profs_full)-length(unique(prof_oa_mapping_fix$profile_id)))/nrow(profs_full)*100</code></pre>
<p>And do not query professors who have names that appear more than once
in the dataset, and whose OA IDs we only query via name:</p>
<pre class="r"><code># which profs from the duplicate list have OA IDs pulled from their names only?
profs_duplicates_oa &lt;- filter(prof_oa_mapping_fix,
                              profile_id %in% profs_duplicates$profile_id)

# drop  the profs for whom we have name-based IDs only
profs_duplicates_drop &lt;- profs_duplicates_oa %&gt;%  group_by(profile_id) %&gt;% filter(any(source == &#39;name&#39;))


prof_oa_mapping_fix &lt;- filter(prof_oa_mapping_fix, 
                              ! profile_id %in% profs_duplicates_drop$profile_id)</code></pre>
<p>What do we miss? We miss IDs for 31 professor.</p>
<pre class="r"><code>length(unique(prof_oa_mapping_fix$profile_id))
(nrow(profs_full)-length(unique(prof_oa_mapping_fix$profile_id)))
(nrow(profs_full)-length(unique(prof_oa_mapping_fix$profile_id)))/nrow(profs_full)*100</code></pre>
<p>Write the data out:</p>
<pre class="r"><code>dbWriteTable(con, &quot;oa_id_mapping&quot;, prof_oa_mapping_fix, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="orcids" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> ORCIDs</h2>
<p>Now, find professor’s ORCIDs based on our NARCIS data (always has the
preference) and, where not available, on the ORCIDs extracted based on
their OA IDs:</p>
<pre class="r"><code>oa_id_list &lt;- unique(prof_oa_mapping_fix$oa_id)
# now fetch the professor info from OA based on their ID, to seek their ORCIDs
prof_info_all &lt;- oa_fetch(
  entity = &quot;authors&quot;, 
  openalex_id = oa_id_list)

# only leave the IDs that have ORCIDs
prof_info_orcids_1 &lt;- filter(prof_info_all, !is.na(orcid))%&gt;%
  select(id, orcid)
# tidy up the colnames
colnames(prof_info_orcids_1) &lt;- c(&quot;oa_id&quot;, &quot;ORCID&quot;)
# and match to Narcis IDs
prof_info_orcids_1 &lt;- merge(prof_oa_mapping_fix[1:2],
                            prof_info_orcids_1,
                            by = &quot;oa_id&quot;)

# now, get the ORCIDs we already have from Narcis
prof_info_orcids_2 &lt;- filter(profs_full, !is.na(ORCID))%&gt;%
  select(profile_id, ORCID)

prof_info_orcids_2 &lt;- merge(prof_oa_mapping_fix[1:2],
                            prof_info_orcids_2,
                            by = &quot;profile_id&quot;,
                            all.y = TRUE)

# only select professors for whom we don&#39;t have an ORCID in our Narcis data,
# as Narcis data is always our first choice
prof_info_orcids_1 &lt;- filter(prof_info_orcids_1, ! profile_id %in% prof_info_orcids_2$profile_id)

# combine the two sources
prof_info_orcids_2 &lt;- prof_info_orcids_2[colnames(prof_info_orcids_1)]

prof_info_orcids_combi &lt;- rbind(prof_info_orcids_1,
                                prof_info_orcids_2)

# and keep only one row with ORCID&#39;s per Narcis ID
prof_info_orcids_combi &lt;- prof_info_orcids_combi %&gt;%
  distinct(., profile_id, ORCID, .keep_all = TRUE)%&gt;%
  select(profile_id, ORCID)
  
# so we have ORCIDs for 5478 professors, or some 80% of our dataset
nrow(prof_info_orcids_combi)
nrow(prof_info_orcids_combi)/nrow(profs_full)*100

dbWriteTable(con, &quot;orcid_mapping&quot;, prof_info_orcids_combi, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="extract-publications-based-on-oa-ids" class="section level2"
number="3.3">
<h2><span class="header-section-number">3.3</span> Extract publications
based on OA IDs</h2>
<p>Define the data querying function, which pulls data from OA as shown
in the Diagram below: <img
src="images/professor_info_retriever_diagram.png" alt="Figure 2" /></p>
<p>Pull the professor data:</p>
<pre class="r"><code># get the list of IDs
narcis_ids &lt;- profs_full$profile_id

# 2435 is the next one
# loop through the batches
for(i in 1:length(narcis_ids)){
  narcis_id &lt;- narcis_ids[i]
  
  professor_pub_info_retriever(prof_oa_ids = prof_oa_mapping_fix,
                               narcis_id = narcis_id,
                               pub_data = prof_pubs_full,
                               prof_data = profs_full)
  # print some info out
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
}</code></pre>
<p>Write out the unique publication list:</p>
<pre class="r"><code>oa_prof_pubs &lt;- dbReadTable(con, &quot;oa_prof_pubs&quot;)

oa_prof_pubs_unique &lt;- distinct(oa_prof_pubs, id, .keep_all = TRUE)

oa_prof_pubs_unique &lt;- oa_prof_pubs_unique %&gt;%
  select(-counts_by_year_year, -counts_by_year_cited_by_count)%&gt;%
  select(-c(au_id:institution_lineage)) %&gt;%
  select(-c(oa_id:profile_id))

dbWriteTable(con, &quot;oa_prof_pubs_unique&quot;, oa_prof_pubs_unique)</code></pre>
</div>
</div>
<div id="professor-altmetric-data" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Professor Altmetric
data</h1>
<div id="professor-attention-data-doi-based-excluding-twitter"
class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Professor attention
data (DOI based, excluding Twitter)</h2>
<p>Get the altmetric attention for our professors, per DOI:</p>
<pre class="r"><code># api key for the Details API
altmetric_details_api_key &lt;- &#39;&#39;

# get the list of publications to extract
oa_pubs &lt;- dbGetQuery(con, &quot;select * from oa_prof_pubs;&quot;)

# get a unique list of publications to fetch mentions for
doi_list &lt;- filter(oa_pubs, !is.na(doi))%&gt;%
  distinct(doi, .keep_all = TRUE)

# loop through the dois
for(i in 1:nrow(doi_list)){
  doi &lt;- doi_list[i,]
 
  altmetric_mention_retriever(api_key = altmetric_details_api_key,
                              doi = doi,
                              include_twitter = FALSE)
  
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, nrow(doi_list)))
}</code></pre>
</div>
<div id="retrieve-twitter-mentions-per-orcid" class="section level2"
number="4.2">
<h2><span class="header-section-number">4.2</span> Retrieve Twitter
mentions (per ORCID)</h2>
<p>Using professor ORCIDs, pull the attention Twitter data from the
Altmetric Explorer API:</p>
<pre class="r"><code># retrieve the ORCID table
prof_orcids &lt;- dbGetQuery(conn = con, statement = &quot;select * from orcid_mapping;&quot;)

# get the Altmetric Explorer API api keys (fill in own)
api_secret &lt;- &#39;&#39;
api_key &lt;- &#39;&#39;</code></pre>
<p>We pull all attention for robustness checks against the Altmetric
Details Page info we get by searching attention via DOI.</p>
<p>Loop through the ORCIDs and get prof’ attention (including
twitter).</p>
<pre class="r"><code>prof_attention_list &lt;- data.frame(matrix(NA, nrow = 0, ncol = 4))
colnames(prof_attention_list) &lt;- c(&quot;mention_type&quot;, &quot;year&quot;, &quot;yearly_count&quot;, &quot;profile_id&quot;)


for (i in 1:nrow(prof_orcids)){
  # not sure this is correct!
  orcid &lt;- prof_orcids$ORCID[i]
  prof_attention &lt;- NA
  # query the info
  try(prof_attention &lt;- altmetric_api_orcid_caller(orcid = orcid,
                                                       api_secret = api_secret,
                                                       api_key = api_key,
                                                       endpoint = &quot;attention&quot;))
  
  # if any data, unnest twice to unravel the info
  if (!all(is.na(prof_attention))){
    prof_attention &lt;- prof_attention %&gt;% distinct(id, .keep_all = TRUE)
    prof_attention &lt;- unnest(prof_attention, cols = c(&quot;meta&quot;))
    prof_attention &lt;- unnest(prof_attention, cols = c(&quot;dates&quot;))
    # now, extract the year and group mentions by year
    prof_attention$year &lt;- year(ymd(prof_attention$date))
    prof_attention_year &lt;- prof_attention %&gt;%
      group_by(id, year)%&gt;%
      summarise(yearly_count = sum(count))
    # tidy up the column names
    colnames(prof_attention_year)[1] &lt;- c(&quot;mention_type&quot;)
    # add in the coauthor OA ID
    prof_attention_year$profile_id &lt;- prof_orcids$profile_id[i]
    
    if (nrow(prof_attention_year)&gt;0){
      # filter out the duplicates
      prof_attention_year &lt;- filter(prof_attention_year, 
                                        ! profile_id %in% prof_attention_list$profile_id)
      
      prof_attention_list &lt;- rbind(prof_attention_list,
                                       prof_attention_year)
    }
  }
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, nrow(prof_orcids)))
}

dbWriteTable(con, &quot;altmetric_prof_attention&quot;, prof_attention_list, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="retrieve-twitter-mentions-per-publication"
class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Retrieve Twitter
mentions (per publication)</h2>
<p>Get twitter data that was initially not pulled using Altmetric and
write it to our database as well.</p>
<p>Connect to the postgres database and pull the publications table:</p>
<pre class="r"><code># pull all the publication data
query &lt;- paste0(&quot;select * from oa_prof_pubs;&quot;)
all_oa_pubs &lt;- dbGetQuery(conn = con, statement = query)</code></pre>
<p>Now fetch the twitter mentions for each publication. Since there is a
limit for Tweet IDs that can be pulled from Altmetric, we retrieve
tweets per paper, and not the author, to avoid double API calls, and
will match these with authors later on:</p>
<pre class="r"><code># get a unique list of OA IDs to pull the data for and ensure they have a DOI
relevant_oa_pubs &lt;- filter(all_oa_pubs, !is.na(doi))%&gt;%
  distinct(., id, .keep_all = TRUE)

# remove redundant items from memory
rm(all_oa_pubs)
gc()

# batch size
batch_size &lt;- 1000
# vector of indices to loop through
batches &lt;- seq(from=1, to=nrow(relevant_oa_pubs), by=batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(relevant_oa_pubs)+1)

# per batch
for (i in 1:length(batches)){
  # get the list
  batch_pubs &lt;- relevant_oa_pubs[batches[i]:(batches[i+1]-1),]
  
  tweet_info_full &lt;- NA
  
  # try getting the tweet info
  try(tweet_info_full &lt;- altmetric_twitter_retriever(publication_list = batch_pubs,
                                                api_key = altmetric_api_key),
      silent = TRUE)
  
  # and write to the database
  # if not empty
  if (!all(is.na(tweet_info_full))){
    # if there is no table yet, write it as a new table
    if (! dbExistsTable(con, &quot;altmetric_pub_att_twitter&quot;)){
      # write to the database
      dbWriteTable(con, &quot;altmetric_pub_att_twitter&quot;, tweet_info_full, row.names=FALSE, append=TRUE) 
      # otherwise, append
    }else{
      # check fields in the existing table
      fields &lt;- dbListFields(con, &quot;altmetric_pub_att_twitter&quot;)
      # if needed, pad the dataset
      if(!all(fields %in% colnames(tweet_info_full))){
        n_missing &lt;- which(!fields %in% colnames(tweet_info_full))
        padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
        colnames(padding) &lt;- fields[which(!fields %in% colnames(tweet_info_full))]
        tweet_info_full &lt;- bind_cols(tweet_info_full,
                                   padding)
        tweet_info_full &lt;- tweet_info_full[fields]
      }
      # only leave these fields in
      tweet_info_full &lt;-  tweet_info_full %&gt;%
        select(all_of(fields))
      dbAppendTable(con, &quot;altmetric_pub_att_twitter&quot;, tweet_info_full, row.names=NULL, append=TRUE) 
    }
  }
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(batches), sep = &quot; &quot;))
}</code></pre>
</div>
</div>
<div id="gender-data" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Gender data</h1>
<p>See script “Prof_gender.Rmd”.</p>
<pre class="r"><code>profs_full_gender &lt;- readRDS(&quot;~/Postdoc/Projects/dutch_media_profs_r/processed_data/profs_full_gender.RDS&quot;)
dbWriteTable(con, &quot;gender_table&quot;, profs_full_gender, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="grants-nwo-and-erc" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Grants NWO and ERC</h1>
<p>First, get the data scraped from the NWO using the python script
[pulling-nwo-grant-data.ipynb] and parsed using the [Grant_parsing.Rmd]
script. Then, also load the NWO grant info from NARCIS:</p>
<pre class="r"><code># data scraped from the NWO website
nwo_grants &lt;- readRDS(&quot;~/Postdoc/Projects/dutch_media_profs_r/processed_data/nwo_grants_intermediate.RDS&quot;)

# data from NARCIS
load(&quot;~/Postdoc/Projects/dutch_media_profs_r/raw_data/media_profs_profiles.rda&quot;)
# get the columns of interest
nwo_grants_narcis &lt;- metadf[c(&quot;Grants/prizes&quot;, &quot;narcis_url&quot;)]
# split the textual info
nwo_grants_narcis_list &lt;- nwo_grants_narcis %&gt;% 
  separate_wider_delim(cols = `Grants/prizes`, 
                       delim = &quot;;&quot;,
                       names = c(&quot;grant_1&quot;, &quot;grant_2&quot;, &quot;grant_3&quot;, &quot;grant_4&quot;),
                       too_few = &quot;align_start&quot;)

# convert to a long dataframe
nwo_grants_narcis_long &lt;- gather(nwo_grants_narcis_list,
                                 number,
                                 grant_string,
                                 grant_1:grant_4)%&gt;%
  filter(!is.na(grant_string))

# extract the grant names and years
nwo_grants_narcis_long$grant_string_2 &lt;- ifelse(str_detect(nwo_grants_narcis_long$grant_string, &quot;Spinoza&quot;) == FALSE,
                                                str_split_i(nwo_grants_narcis_long$grant_string, &quot;-&quot;, 2),
                                                str_split_i(nwo_grants_narcis_long$grant_string, &quot; - &quot;, 2))

nwo_grants_narcis_long$grant_string_2 &lt;- str_remove(nwo_grants_narcis_long$grant_string_2, &quot;Award&quot;)
nwo_grants_narcis_long$grant_string_2 &lt;- str_squish(nwo_grants_narcis_long$grant_string_2)

nwo_grants_narcis_long$grant &lt;- str_split_i(nwo_grants_narcis_long$grant_string_2, &quot; &quot;, 1)
nwo_grants_narcis_long$year &lt;- str_split_i(nwo_grants_narcis_long$grant_string_2, &quot; &quot;, 2)
nwo_grants_narcis_long$year &lt;- str_split_i(nwo_grants_narcis_long$year, &quot;/&quot;, 1)


# get the final dataframe
nwo_grants_narcis &lt;- nwo_grants_narcis_long[c(&quot;narcis_url&quot;, &quot;grant&quot;, &quot;year&quot;)]
nwo_grants_narcis$grant &lt;- tolower(nwo_grants_narcis$grant)
colnames(nwo_grants_narcis)[1] &lt;- &quot;profile_id&quot;</code></pre>
<p>Check if our NARCIS data missed out on any scraped info:</p>
<pre class="r"><code># first, get them into the same format
nwo_grants_narcis &lt;- nwo_grants_narcis[c(colnames(nwo_grants))]
nwo_grants_narcis$year &lt;- as.numeric(nwo_grants_narcis$year)
nwo_grants_narcis$person_grant &lt;- paste(nwo_grants_narcis$profile_id, nwo_grants_narcis$grant, sep = &quot;_&quot;)
nwo_grants$person_grant &lt;- paste(nwo_grants$profile_id, nwo_grants$grant, sep = &quot;_&quot;)

# get some grants we scraped, but were not in the NARCIS data, most from 2022
nwo_grants_check &lt;- filter(nwo_grants,
                           !person_grant %in% nwo_grants_narcis$person_grant)

# add them to the NARCIS data
nwo_grants_narcis &lt;- rbind(nwo_grants_narcis,
                           nwo_grants_check)

nwo_grants_narcis &lt;- nwo_grants_narcis[c(&quot;grant&quot;, &quot;year&quot;, &quot;profile_id&quot;)]</code></pre>
<p>Write into a database:</p>
<pre class="r"><code>dbWriteTable(con, &quot;narcis_nwo_grant_info&quot;, nwo_grants_narcis, row.names=FALSE, append=TRUE) </code></pre>
<p>This misses ERC grants. Now also get the ERC grants by downloading
the csv. file listing all Dutch grants from <a
href="https://erc.easme-web.eu?mode=7&amp;countries=NL">here</a>:</p>
<pre class="r"><code>erc_data &lt;- read_delim(&quot;processed_data/erc_data.csv&quot;, 
    delim = &quot;;&quot;, escape_double = FALSE, trim_ws = TRUE)</code></pre>
<p>See if we can merge ERC grants with professor names in our data:</p>
<pre class="r"><code>erc_data$PI &lt;- tolower(erc_data$PI)

profs$PI &lt;- tolower(paste(profs$last, profs$first))

erc_data_merge &lt;- merge(erc_data,
                        profs[c(&quot;profile_id&quot;, &quot;PI&quot;)],
                        by = &quot;PI&quot;)

# extract the year
erc_data_merge$year &lt;- parse_number(erc_data_merge$`Call ID`)
erc_data_merge$year &lt;- str_remove(erc_data_merge$year, &quot;-&quot;)

# tidy up the colnames
colnames(erc_data_merge) &lt;- tolower(str_replace_all(colnames(erc_data_merge), &quot; &quot;, &quot;_&quot;))

# tidy up the city column
erc_data_merge$city &lt;- str_to_title(erc_data_merge$city)</code></pre>
<p>Write into a database:</p>
<pre class="r"><code>dbWriteTable(con, &quot;erc_grant_info&quot;, erc_data_merge, row.names=FALSE, append=TRUE) </code></pre>
</div>
<div id="coauthor-data" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Coauthor data</h1>
<div id="oa-coauthor-publication-data" class="section level2"
number="7.1">
<h2><span class="header-section-number">7.1</span> OA coauthor
publication data</h2>
<p>We also need, for each professor, the more detailed data about their
co-authors.</p>
<p>For each professor, we will query their coauthors’ data. We output
the following: 1. A full list of author’s OA data 2. A full list of
author’s names 3. A full list of author’s yearly attention from
Altmetric</p>
</div>
<div id="coauthor-oa-data" class="section level2" number="7.2">
<h2><span class="header-section-number">7.2</span> Coauthor OA data</h2>
<p>First, get all the coauthor yearly OA stastistics and a full list of
names:</p>
<pre class="r"><code># get all the coauthor info
coauthor_list &lt;- dbGetQuery(conn = con, statement = paste0(&quot;select * from oa_coauthor_info;&quot;))

#get the unique OA IDs of coauthors
coauthor_oa &lt;- coauthor_list%&gt;% 
  distinct(au_id)

coauthor_oa &lt;- coauthor_oa$au_id
# drop redundant data
rm(coauthor_list)
gc()

# coauthor affiliation etc list
coauthor_info_list &lt;- data.frame(matrix(NA, nrow = 0, ncol = 14))
# keep a list of co-author names with inferred genders that we can complement further and further
# as we loop through the data
coauthor_name_list &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))

prof_batch_size &lt;- 1000
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(coauthor_oa), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(coauthor_oa)+1)


# query additional prof info
for(i in 1:(length(batches)-1)){
  # get the narcis ids from the batch
  prof_batch &lt;- coauthor_oa[batches[i]:(batches[i+1]-1)]
  prof_coauthor_info_oa &lt;- NA
  
  try(prof_coauthor_info_oa &lt;- oa_fetch(
    entity = &quot;authors&quot;, 
    openalex_id = prof_batch))
  
  if (!all(is.na(prof_coauthor_info_oa))){
    
    # unnest the data 
    prof_coauthor_info_oa_unnest &lt;- unnest(prof_coauthor_info_oa, cols = c(counts_by_year), names_sep = &quot;_&quot;)%&gt;%
      select(-x_concepts)
    
    # get their names
    # first, get all the name alternatives as well
    coauthor_name_variations &lt;- prof_coauthor_info_oa %&gt;%
      select(id, display_name, display_name_alternatives)%&gt;%
      unnest(., cols = c(display_name_alternatives))
    # wide to long, with all variations
    coauthor_name_variations &lt;- gather(coauthor_name_variations,
                                       type, 
                                       full_name, 
                                       display_name:display_name_alternatives, 
                                       factor_key=FALSE)
    
    # now, identify which ones are actualy names, and not just initials
    # get the first word, and detect if longer than 1 character and/or does not contain any full stops
    coauthor_name_variations$first &lt;- word(coauthor_name_variations$full_name, 1)
    coauthor_name_variations$valid_name &lt;- ifelse(str_detect(coauthor_name_variations$first, &quot;\\.&quot;),
                                                  &quot;FALSE&quot;,
                                                  &quot;TRUE&quot;)
    # get the name variation lengths
    coauthor_name_variations$length_first &lt;-  nchar(coauthor_name_variations$first) 
    coauthor_names &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))
    # leave only the ones where we seem to have a shortest name longer than 2 characters
    coauthor_names &lt;- filter(coauthor_name_variations, valid_name == TRUE)%&gt;%
      group_by(id)%&gt;%
      slice(which.max(length_first))%&gt;%
      filter(., length_first &gt; 2)%&gt;%
      select(-valid_name, -length_first, -type)
    
    # append the new names to the names dataframe
    if (!all(is.na(coauthor_names))){
      new_names &lt;- filter(coauthor_names, 
                          ! id %in% coauthor_name_list$id)
      coauthor_name_list &lt;- rbind(coauthor_name_list,
                                  new_names)
    }
    
    # select prof info
    coauthor_info &lt;- data.frame(matrix(NA, nrow = 0, ncol = 14))
    columns &lt;- c(&quot;id&quot;, &quot;display_name&quot;, &quot;orcid&quot;, &quot;works_count&quot;,
                 &quot;cited_by_count&quot;, &quot;counts_by_year_year&quot;, &quot;counts_by_year_works_count&quot;, 
                 &quot;counts_by_year_cited_by_count&quot;, &quot;affiliation_display_name&quot;, 
                 &quot;affiliation_id&quot;, &quot;affiliation_ror&quot;, &quot;affiliation_country_code&quot;,
                 &quot;affiliation_type&quot;, &quot;works_api_url&quot;)
    # padding in case some columns are missing
    if(!all(columns %in% colnames(prof_coauthor_info_oa_unnest))){
      n_missing &lt;- which(!columns %in% colnames(prof_coauthor_info_oa_unnest))
      padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
      colnames(padding) &lt;- columns[which(!columns %in% colnames(prof_coauthor_info_oa_unnest))]
      prof_coauthor_info_oa_unnest &lt;- bind_cols(prof_coauthor_info_oa_unnest,
                                                padding)
      prof_coauthor_info_oa_unnest &lt;- prof_coauthor_info_oa_unnest[columns]
    }
    
    coauthor_info &lt;- prof_coauthor_info_oa_unnest%&gt;%
      select(id, display_name, orcid, works_count,
             cited_by_count, counts_by_year_year, counts_by_year_works_count, 
             counts_by_year_cited_by_count, affiliation_display_name, 
             affiliation_id, affiliation_ror, affiliation_country_code,
             affiliation_type, works_api_url)
    
    # append the new info to the info dataframe
    if (!all(is.na(coauthor_info))){
      new_info &lt;- filter(coauthor_info, 
                         ! id %in% coauthor_info_list$id)
      
      coauthor_info_list &lt;- rbind(coauthor_info_list,
                                  new_info)
    }
  }
  
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(batches)))
}

dbWriteTable(con, &quot;oa_coauthor_info_full&quot;, coauthor_info_list, row.names=FALSE, append=TRUE)

dbWriteTable(con, &quot;oa_coauthor_name_list&quot;, coauthor_name_list, row.names=FALSE, append=TRUE)</code></pre>
<p>We have 1 371 810 unique coauthors we fetched the data for, and 177
823 unique first names.</p>
<p>Write out unique combinations of papers, coauthors, and
professors:</p>
<pre class="r"><code>oa_coauthor_matching &lt;- coauthor_info_list %&gt;% distinct(id, oa_id, profile_id, .keep_all = TRUE)

dbWriteTable(con, &quot;oa_coauthor_matching&quot;, oa_coauthor_matching, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="coauthor-altmetric-attention-per-orcid" class="section level2"
number="7.3">
<h2><span class="header-section-number">7.3</span> Coauthor Altmetric
attention (per ORCID)</h2>
<p>Use the same coauthor list, but now to pull the attention data from
Altmetric. Only pull the data for those coauthors who</p>
<pre class="r"><code># get the coauthorship list
coauthor_list &lt;- dbReadTable(con, &quot;oa_coauthor_info&quot;)

# unique IDs
coauthor_altmetric_list &lt;- distinct(coauthor_list, au_id, .keep_all = TRUE)
# we have 1 344 508 of these
length(unique(coauthor_altmetric_list$au_id))

# leave only those with ORCID IDs
coauthor_altmetric_list &lt;- filter(coauthor_altmetric_list,
                                  !is.na(au_orcid))

# this leaves us with only 457 200 IDs
length(unique(coauthor_altmetric_list$au_orcid))

# drop redundant data
rm(coauthor_list)
gc()</code></pre>
<p>Loop through the ORCIDs and get authors’ attention:</p>
<pre class="r"><code>coauthor_attention_list &lt;- data.frame(matrix(NA, nrow = 0, ncol = 4))
colnames(coauthor_attention_list) &lt;- c(&quot;mention_type&quot;, &quot;year&quot;, &quot;yearly_count&quot;, &quot;id&quot;)

for (i in 1:nrow(coauthor_altmetric_list)){
  # not sure this is correct!
  orcid &lt;- coauthor_altmetric_list$au_orcid[i]
  coauthor_attention &lt;- NA
  # query the info
  try(coauthor_attention &lt;- altmetric_api_orcid_caller(orcid = orcid,
                                                       api_secret = api_secret,
                                                       api_key = api_key,
                                                       endpoint = &quot;attention&quot;))
  
  # if any data, unnest twice to unravel the info
  if (!all(is.na(coauthor_attention))){
    #deduplicate
    coauthor_attention &lt;- coauthor_attention %&gt;% distinct(id, .keep_all =  TRUE)
    coauthor_attention &lt;- unnest(coauthor_attention, cols = c(&quot;meta&quot;))
    coauthor_attention &lt;- unnest(coauthor_attention, cols = c(&quot;dates&quot;))
    # now, extract the year and group mentions by year
    coauthor_attention$year &lt;- year(ymd(coauthor_attention$date))
    coauthor_attention_year &lt;- coauthor_attention %&gt;%
      group_by(id, year)%&gt;%
      summarise(yearly_count = sum(count))
    # tidy up the column names
    colnames(coauthor_attention_year)[1] &lt;- c(&quot;mention_type&quot;)
    # add in the coauthor OA ID
    coauthor_attention_year$id &lt;- coauthor_altmetric_list$au_id[i]
    
    if (nrow(coauthor_attention_year)&gt;0){
      # filter out the duplicates
      coauthor_attention_year &lt;- filter(coauthor_attention_year, 
                                        ! id %in% coauthor_attention_list$id)
      
      coauthor_attention_list &lt;- rbind(coauthor_attention_list,
                                       coauthor_attention_year)
    }
  }
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, nrow(coauthor_altmetric_list)))
}

dbWriteTable(con, &quot;altmetric_coauthor_attention&quot;, coauthor_attention_list, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="topics-for-each-professor" class="section level2" number="7.4">
<h2><span class="header-section-number">7.4</span> Topics for each
professor</h2>
<p>First, get a distinct publication list:</p>
<pre class="r"><code>oa_prof_pubs &lt;- dbReadTable(con, &quot;oa_prof_pubs&quot;)

oa_distinct_pubs &lt;- oa_prof_pubs%&gt;%
  distinct(., id, .keep_all = TRUE)%&gt;%
    select(id:display_name, ab:is_retracted)

oa_prof_pub_match &lt;- oa_prof_pubs %&gt;%
  distinct(., id, profile_id, .keep_all = TRUE)%&gt;%
    select(id, au_id, au_display_name, oa_id, profile_id)

dbWriteTable(con, &quot;oa_distinct_pubs&quot;, oa_distinct_pubs)
dbWriteTable(con, &quot;oa_prof_pub_match&quot;, oa_prof_pub_match)</code></pre>
<p>Get the topics for each publication:</p>
<pre class="r"><code># batch size
batch_size &lt;- 100
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(oa_distinct_pubs$id), by=batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(oa_distinct_pubs$id)+1)

# per batch
for (i in 1:length(batches)){
  # get the list
  batch_ids &lt;- oa_distinct_pubs$id[batches[i]:(batches[i+1]-1)]
  batch_ids &lt;- str_remove(batch_ids, &quot;https\\:\\/\\/openalex.org\\/&quot;)
  # collapse them so that we can fetch all of them at once from the API
  batch_ids &lt;- paste(batch_ids, collapse = &quot;|&quot;)
  get_api &lt;- fromJSON(paste0(&quot;https://api.openalex.org/works?filter=ids.openalex:&quot;, batch_ids, &quot;&amp;per-page=100&quot;))
  if (&#39;topics&#39; %in% names(get_api[[&quot;results&quot;]])){
    result_ids &lt;- get_api[[&quot;results&quot;]][[&quot;id&quot;]]
    topics &lt;- get_api[[&quot;results&quot;]][[&quot;topics&quot;]]
    if (length(topics) &gt; 0){
      topics_df &lt;- bind_rows(topics, .id = &quot;column_label&quot;)
      topics_df &lt;- unnest(topics_df, cols = c(subfield, field, domain), names_sep = &quot;_&quot;)
      colnames(topics_df)[2] &lt;- &quot;topic_id&quot;
      oa_id_matching &lt;- cbind.data.frame(column_label = c(1:100),
                                         id = get_api[[&quot;results&quot;]][[&quot;id&quot;]])
      
      topics_df &lt;- merge(topics_df,
                         oa_id_matching,
                         by = &quot;column_label&quot;)
      
      
      if (dbExistsTable(con, &quot;oa_pubs_topics&quot;)){
        # check fields in the existing table
        fields &lt;- dbListFields(con, &quot;oa_pubs_topics&quot;)
        # if not all fields there
        if(!all(fields %in% colnames(topics_df))){
          n_missing &lt;- which(!fields %in% colnames(topics_df))
          padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
          colnames(padding) &lt;- fields[which(!fields %in% colnames(topics_df))]
          topics_df &lt;- bind_cols(topics_df,
                              padding)
          topics_df &lt;- topics_df[fields]
        }
        # only leave these fields in
        topics_df &lt;-  topics_df %&gt;%
          select(all_of(fields))
        
        dbAppendTable(con, &quot;oa_pubs_topics&quot;, topics_df, row.names=NULL, append=TRUE)
      }else{
        dbWriteTable(con, &quot;oa_pubs_topics&quot;, topics_df, row.names=FALSE, append=TRUE)
      }
    }
  }
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(batches)))
}

# 
# for (oa_id in oa_distinct_pubs$id){
#   # fetch from the official API
#   get_api2 &lt;- fromJSON(paste(&quot;https://api.openalex.org/&quot;, str_remove(oa_id, &quot;https\\:\\/\\/openalex.org\\/&quot;), &quot;&amp;per-page=100&quot;, sep = &quot;&quot;))
#   if (&#39;topics&#39; %in% names(get_api)){
#     topics &lt;- get_api[[&#39;topics&#39;]]
#     if (length(topics) &gt; 0){
#       topics &lt;- unnest(topics, cols = c(subfield, field, domain), names_sep = &quot;_&quot;)
#       colnames(topics)[1] &lt;- &quot;topic_id&quot;
#       topics$id &lt;- oa_id
#       
#       if (dbExistsTable(con, &quot;oa_pubs_topics&quot;)){
#         # check fields in the existing table
#         fields &lt;- dbListFields(con, &quot;oa_pubs_topics&quot;)
#         # if not all fields there
#         if(!all(fields %in% colnames(topics))){
#           n_missing &lt;- which(!fields %in% colnames(topics))
#           padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
#           colnames(padding) &lt;- fields[which(!fields %in% colnames(topics))]
#           topics &lt;- bind_cols(topics,
#                               padding)
#           topics &lt;- topics[fields]
#         }
#         # only leave these fields in
#         topics &lt;-  topics %&gt;%
#           select(all_of(fields))
#         
#         dbAppendTable(con, &quot;oa_pubs_topics&quot;, topics, row.names=NULL, append=TRUE)
#       }else{
#         dbWriteTable(con, &quot;oa_pubs_topics&quot;, topics, row.names=FALSE, append=TRUE)
#       }
#       print(which(oa_distinct_pubs$id == oa_id))
#     }
#   }
# }</code></pre>
</div>
<div id="institutional-affiliations" class="section level2"
number="7.5">
<h2><span class="header-section-number">7.5</span> Institutional
affiliations</h2>
<p>Load professor publications:</p>
<pre class="r"><code>oa_pubs_unique &lt;- dbReadTable(con, &quot;oa_prof_pubs_unique&quot;)
oa_prof_pub_matching &lt;- dbReadTable(con, &quot;oa_prof_pub_match&quot;)

oa_ids &lt;- dbReadTable(con, &quot;oa_id_mapping&quot;)</code></pre>
<p>For each professor, construct a list of affiliations they’ve had:</p>
<pre class="r"><code>list_profs &lt;- unique(oa_ids$oa_id)
all_results &lt;- data.frame(matrix(NA, ncol = 7, nrow = 0))

for (i in 1:length(list_profs)){
  # get the list
  prof &lt;- list_profs[i]
  get_api &lt;- fromJSON(paste0(&quot;https://api.openalex.org/authors?filter=ids.openalex:&quot;, prof))
  
  if (&#39;affiliations&#39; %in% names(get_api[[&quot;results&quot;]])){
    result_institutions &lt;- get_api[[&quot;results&quot;]][[&quot;affiliations&quot;]][[1]][[&quot;institution&quot;]]
    if (!all(is.na(result_institutions))){
      result_institutions$au_id &lt;- prof
      all_results &lt;- rbind.data.frame(all_results,
                                      result_institutions)
    }
  }
  print(i)
}


all_results_sel &lt;- all_results %&gt;%
  select(-lineage)

# write out a table
dbWriteTable(con, &quot;oa_prof_affiliations&quot;, all_results_sel)</code></pre>
<p>For each unique institution, also get alternative names:</p>
<pre class="r"><code>unique_institutions &lt;- unique(all_results_sel$id)
all_institution_names &lt;- data.frame(matrix(NA, ncol = 2, nrow = 0))

for (inst in unique_institutions){
  get_api &lt;- fromJSON(paste0(&quot;https://api.openalex.org/institutions?filter=ids.openalex:&quot;, inst))
  if (&#39;display_name_alternatives&#39; %in% names(get_api[[&quot;results&quot;]])){
    alt_names &lt;- get_api[[&quot;results&quot;]][[&quot;display_name_alternatives&quot;]][[1]]
    name &lt;- get_api[[&quot;results&quot;]][[&quot;display_name&quot;]]
    institution_name_list &lt;- paste(c(name,alt_names), collapse = &quot;, &quot;)
    # get a list for string matching
    institution_name_list_str_match &lt;- c(name, alt_names)
    institution_name_list_str_match &lt;- paste0(paste0(&quot;\\b&quot;, institution_name_list_str_match), &quot;\\b&quot;)
    institution_name_list_str_match &lt;- paste(institution_name_list_str_match, collapse = &quot;|&quot;)
    
    institution_output &lt;- cbind.data.frame(id = inst,
                                           display_names = institution_name_list,
                                           string_match_names = institution_name_list_str_match)
    
    all_institution_names &lt;- rbind.data.frame(all_institution_names,
                                              institution_output)
  }
  
  print(which(unique_institutions == inst))
  
}

dbWriteTable(con, &quot;oa_affiliation_display_names&quot;, all_institution_names)</code></pre>
<p>For each professor, compile all institutions they are affiliated with
into a single field:</p>
<pre class="r"><code>list_profs &lt;- unique(profs_full$profile_id)
all_prof_inst_search &lt;- data.frame(matrix(NA, ncol = 2, nrow = 0))

for (i in 1:length(list_profs)){
  # get the list
  prof &lt;- list_profs[i]
  
  prof_oa_ids &lt;- filter(oa_ids, 
                   profile_id == prof)
  
  rel_inst &lt;- filter(all_results_sel,
                     au_id %in% prof_oa_ids$oa_id)%&gt;%
    distinct(id, .keep_all = TRUE)
  
  institution_names &lt;- filter(all_institution_names,
                              id %in% rel_inst$id)
  
  institution_names_prof &lt;- paste(institution_names$string_match_names, collapse = &quot;|&quot;)
  
  prof_inst_search &lt;- cbind.data.frame(au_id = prof,
                                           string_match_names = institution_names_prof)
  
  all_prof_inst_search &lt;- rbind.data.frame(all_prof_inst_search,
                                           prof_inst_search)
  
  print(i)
}

dbWriteTable(con, &quot;oa_affiliation_string_search&quot;, all_prof_inst_search)</code></pre>
</div>
</div>

<<<<<<< HEAD
# get a list of ORCIDs
orcid_list &lt;- str_remove(orcid_table$ORCID, &quot;https://orcid.org/&quot;)

# loop through the list and retrieve employment history wherever available:

all_orcid_employment &lt;- data.frame(matrix(NA, ncol = 6, nrow = 0))

for (i in 1:length(orcid_list)){
  prof_orcid &lt;- orcid_list[i]
  
  #if ORCID not NA
  if (!is.na(prof_orcid)){
    employment &lt;- NA
    # get employment data
    try(employment &lt;- orcid_employments(orcid = prof_orcid)%&gt;%
          map(., pluck, &quot;affiliation-group&quot;, &quot;summaries&quot;) %&gt;% 
          flatten_dfr() %&gt;%
          clean_names())
    # if there is any employment data  
    if (!all(is.na(employment))){
      if(nrow(employment)&gt;0){
        # fill in missing columns
        if (!&quot;employment_summary_start_date_year_value&quot; %in% colnames(employment)){
          employment$employment_summary_start_date_year_value &lt;- NA
        }
        
        # select relevant columns
        employment &lt;- employment %&gt;%
          select(employment_summary_department_name, employment_summary_role_title,
                 employment_summary_start_date_year_value,
                 employment_summary_organization_name, employment_summary_organization_address_country)
        # tidy up the dataframe
        colnames(employment) &lt;- c(&quot;department&quot;, &quot;position&quot;,
                                  &quot;start&quot;, &quot;organization&quot;, &quot;country&quot;)
        # add the orcid back in
        employment$orcid &lt;- prof_orcid
        # append
        all_orcid_employment &lt;- rbind(all_orcid_employment,
                                      employment)
      }
    }
}

  #print(i)
  
}</code></pre>
<p>Clean this up, removing positions we have no info on, or don’t know
the starting date of, filtering only those that contain “professor” or
“hoogleraar”, and are in the Netherlands:</p>
<pre class="r"><code>all_orcid_employment_tidy &lt;- all_orcid_employment %&gt;%
  filter(!is.na(position) &amp; !is.na(start) &amp;  country == &quot;NL&quot;)

all_orcid_employment_tidy$position &lt;- tolower(all_orcid_employment_tidy$position)

all_orcid_employment_tidy$prof &lt;- str_detect(all_orcid_employment_tidy$position,
                                             &quot;prof|hoog&quot;)

all_orcid_employment_tidy &lt;- all_orcid_employment_tidy %&gt;%
  filter(prof == TRUE)

# and now ensure they don&#39;t contain &quot;assistant&quot; or &quot;associate&quot;
all_orcid_employment_tidy$asst &lt;- str_detect(all_orcid_employment_tidy$position,
                                             &quot;assistant|assistent|asst|associate|assoc|asisst|asistant|assoc|asssociate|associatie|assitant&quot;)

all_orcid_employment_tidy &lt;- all_orcid_employment_tidy %&gt;%
  filter(asst == FALSE)

# for each prof with multiple, keep the earliest appointment
prof_entry &lt;- all_orcid_employment_tidy %&gt;%
  group_by(orcid)%&gt;%
  slice(which.min(start))%&gt;%
  select(orcid, position, organization, department, start)


# merge with profile_ids
colnames(orcid_table)[2] &lt;- &quot;orcid&quot;
orcid_table$orcid &lt;- str_remove(orcid_table$orcid, &quot;https://orcid.org/&quot;)
prof_entry &lt;- merge(prof_entry,
                    orcid_table,
                    by = &quot;orcid&quot;)</code></pre>
<p>Write this out into our database:</p>
<pre class="r"><code>dbWriteTable(con, &quot;orcid_employment_entry&quot;, prof_entry)</code></pre>
<div id="positions-in-the-government-and-advisory-bodies"
class="section level2" number="8.1">
<h2><span class="header-section-number">8.1</span> Positions in the
government and advisory bodies</h2>
<p>Load the manually curated output of the python script that used
information from the Dutch governmental websites and the Dutch Wikipedia
to find professors’ roles within the governments (as ministers or
secretaries, or as government formateurs) or their roles within advisory
bodies to the government. Then match these data to the profile IDs and
store in our database.</p>
<pre class="r"><code>govt_positions &lt;- read_csv(&quot;../dutch_media_profs_python/output-data/govt_list_manual.csv&quot;)
info_positions &lt;- read_csv(&quot;../dutch_media_profs_python/output-data/info_list_manual.csv&quot;)
advisory_positions &lt;- read_csv(&quot;../dutch_media_profs_python/output-data/advisory_list_manual.csv&quot;)</code></pre>
<p>First, for governmental and advisory positions, ensure that we have
individual rows for each year a professor held a position (rather than a
“start-end” format):</p>
<pre class="r"><code>govt_positions_long &lt;- govt_positions
colnames(govt_positions_long)[4] &lt;- &quot;timespan&quot;
govt_positions_long$start &lt;- str_split_i(govt_positions_long$timespan, &quot;-&quot;, 1)
govt_positions_long$end &lt;- str_split_i(govt_positions_long$timespan, &quot;-&quot;, 2)

govt_positions_long &lt;- govt_positions_long %&gt;%
  mutate(year = map2(start, end, seq)) %&gt;%
  unnest(year) %&gt;%
  ## deal with overlaps by keeping the max start age:
  group_by(name, year) %&gt;%
  slice_max(start) %&gt;%
  ungroup %&gt;%
  select(name, post, year)

# add some more variables
govt_positions_long$raad &lt;- &quot;Government&quot;
govt_positions_long$raad_abv &lt;- &quot;GVT&quot;

govt_positions_long &lt;- govt_positions_long %&gt;%
  select(name, post, raad, raad_abv, year)

advisory_positions_long &lt;- advisory_positions
colnames(advisory_positions_long)[5] &lt;- &quot;timespan&quot;
advisory_positions_long$start &lt;- str_split_i(advisory_positions_long$timespan, &quot;-&quot;, 1)
advisory_positions_long$end &lt;- str_split_i(advisory_positions_long$timespan, &quot;-&quot;, 2)
advisory_positions_long$end[which(is.na(advisory_positions_long$end))] &lt;- advisory_positions_long$start[which(is.na(advisory_positions_long$end))]

# for advisory, leave positions that are not a mere &quot;raadslid&quot;
advisory_positions_long &lt;- advisory_positions_long %&gt;%
  mutate(year = map2(start, end, seq)) %&gt;%
  unnest(year) %&gt;%
  ## deal with overlaps by keeping the max start age:
  group_by(person, year) %&gt;%
  slice_max(start) %&gt;%
  ungroup %&gt;%
  select(person, post, raad, raad_abv, year)%&gt;%
  filter(post != &quot;Raadslid&quot;)

colnames(advisory_positions_long)[1] &lt;- &quot;name&quot;

# for (in)formateurs, tidy the data up a bit
info_positions$raad &lt;- &quot;Government&quot;
info_positions$raad_abv &lt;- &quot;GVT&quot;
info_positions_long &lt;- info_positions %&gt;%
  select(name, post, raad, raad_abv, year)</code></pre>
<p>Combine the three sources:</p>
<pre class="r"><code>all_govt_positions &lt;- rbind(govt_positions_long,
                            info_positions_long,
                            advisory_positions_long)

colnames(all_govt_positions) &lt;- c(&quot;name&quot;, &quot;position&quot;, &quot;institution&quot;, &quot;institution_abv&quot;, &quot;year&quot;)</code></pre>
<p>Match the people with their profile ids:</p>
<pre class="r"><code>prof_name_match &lt;- profs_full[c(&quot;profile_id&quot;, &quot;first&quot;, &quot;last&quot;)]
prof_name_match$name &lt;- paste(prof_name_match$first, prof_name_match$last)

all_govt_positions_match &lt;- merge(all_govt_positions,
                                  prof_name_match[c(&quot;profile_id&quot;, &quot;name&quot;)],
                                  by = &quot;name&quot;,
                                  all.x = TRUE)

# match missing for balkenende, so fill it  in by hand
all_govt_positions_match$profile_id[which(is.na(all_govt_positions_match$profile_id))] &lt;- &quot;https://www.narcis.nl/person/RecordID/PRS1238628&quot;</code></pre>
<p>Write this out:</p>
<pre class="r"><code>dbWriteTable(con, &quot;govt_positions&quot;, all_govt_positions_match)</code></pre>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIk9wZW5BbGV4X0FsdG1ldHJpY19kYXRhX2Rvd25sb2FkIg0KYXV0aG9yOiAiQW5hIE1hY2Fub3ZpYyINCmRhdGU6ICIyMDI0LTAxLTA2Ig0KLS0tDQoNClRoaXMgc2NyaXB0IHVzZXMgT3BlbkFsZXggYW5kIEFsdG1ldHJpYyBkYXRhYmFzZXMsIGFuZCBPUkNJRCBBUEkgdG8gZG93bmxvYWQgZGF0YSBvbiBwcm9mZXNzb3JzIGluIG91ciBzYW1wbGUuDQoNCkxvYWQgdGhlIG5lY2Vzc2FyeSBwYWNrYWdlczoNCmBgYHtyIG1lc3NhZ2U9ICBGLCB3YXJuaW5nID0gRiwgZXZhbCA9IEZ9DQojIGxvYWQgdGhlIGhlbHBlciBmdW5jdGlvbiBmaWxlDQpzb3VyY2UoImhlbHBlcl9mdW5jdGlvbnMuUiIpDQpwYWNrYWdlc190b19sb2FkIDwtIGMoInJlYWRyIiwgImRwbHlyIiwNCiAgICAgICAgICAgICAgICAgICAgICAiZ2dwbG90MiIsICJzdHJpbmdyIiwgInRpZHlyIiwNCiAgICAgICAgICAgICAgICAgICAgICAianNvbmxpdGUiLCAieG1sMiIsICJ0aWR5dmVyc2UiLA0KICAgICAgICAgICAgICAgICAgICAgICJSUG9zdGdyZXMiLCAibHVicmlkYXRlIiwiZGlnZXN0IiwNCiAgICAgICAgICAgICAgICAgICAgICAiREJJIiwgIlJPREJDIiwgIm9kYmMiLCAia25pdHIiLA0KICAgICAgICAgICAgICAgICAgICAgICJyb3JjaWQiLCAiamFuaXRvciIsICJwdXJyciIpDQoNCmZwYWNrYWdlX2NoZWNrKHBhY2thZ2VzX3RvX2xvYWQpDQoNCiMgRm9yIGZ1bGwgcmVwcm9kdWNpYmlsaXR5LCBsb2FkIHRoZSBwYWNrYWdlcyB3aXRoIGdyb3VuZGhvZyB1c2luZyB0aGUgY29kZSBiZWxvdyBpbnN0ZWFkDQojIG9mIHRoZSBmcGFja2FnZV9jaGVjayBmdW5jdGlvbg0KDQojIGxpYnJhcnkoZ3JvdW5kaG9nKQ0KIyBncm91bmRob2cubGlicmFyeShwYWNrYWdlc190b19sb2FkLCBkYXRlID0gIjIwMjMtMTItMDEiKQ0KDQojIHdlJ3ZlIGFsc28gYWRkZWQgb3VyIGVtYWlsIHRvIHRoZSAicG9saXRlIHBvb2wiIG9mIE9wZW5BbGV4IGJ5DQojIGFkZGluZyBhIGxpbmUgaW4gdGhlIC5ScHJvZmlsZQ0KIyBrZWVwIG9wZW5hbGV4UiB1cGRhdGVkIHRvIHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIGZvciBBUEkgY29tcGF0aWJpbGl0eSENCmxpYnJhcnkoIm9wZW5hbGV4UiIpDQpgYGANCg0KDQpgYGB7ciBpbmNsdWRlPUZBTFNFfQ0Kb3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpDQpvcHRzX2NodW5rJHNldChldmFsID0gRkFMU0UpDQpvcHRzX2NodW5rJHNldCh3YXJuaW5nID0gRkFMU0UpDQpvcHRzX2NodW5rJHNldChtZXNzYWdlID0gRkFMU0UpDQpgYGANCg0KQ29ubmVjdCB0byBvdXIgZGF0YWJhc2U6DQpgYGB7cn0NCiMgZmlsbCBpbiBvd24gY3JlZGVudGlhbHMNCnBvcnQgPC0gNTQzMg0KdXNlciA8LSAicG9zdGdyZXMiDQpwYXNzd29yZCA8LSAiZHV0Y2htZWRpYXByb2Zzc3FsIg0KZGF0YWJhc2VfbmFtZSA8LSAicG9zdGdyZXMiDQoNCmNvbiA8LSBkYkNvbm5lY3QoUG9zdGdyZXMoKSwNCiAgICAgICAgICAgICAgICAgZGJuYW1lPSBkYXRhYmFzZV9uYW1lLA0KICAgICAgICAgICAgICAgICBwb3J0ID0gcG9ydCwNCiAgICAgICAgICAgICAgICAgdXNlciA9IHVzZXIsIA0KICAgICAgICAgICAgICAgICBwYXNzd29yZCA9IHBhc3N3b3JkKQ0KDQpjb24gIyBDaGVja3MgY29ubmVjdGlvbiBpcyB3b3JraW5nDQpgYGANCg0KDQojIFRpZHkgdXAgcHJvZmVzc29yIGRhdGEgZnJvbSBOQVJDSVMNCg0KTG9hZCB0aGUgcHJvZmVzc29yIHByb2ZpbGVzOg0KYGBge3IgbWVzc2FnZSA9IEYsIHdhcm5pbmcgPSBGfQ0KbG9hZCgicmF3X2RhdGEvbWVkaWFfcHJvZnNfcHJvZmlsZXMucmRhIikNCnByb2ZzIDwtIHJlYWRfY3N2KCJyYXdfZGF0YS9kdXRjaF9wcm9mc191cmxzLmNzdiIpDQoNCiMgbWVyZ2UgdGhlIHByb2ZzIHdpdGggdGhlaXIgT1JDSURzDQpjb2xuYW1lcyhwcm9mcylbYygxLDcpXSA8LSBjKCJpZCIsICJwcm9maWxlX2lkIikNCg0KcHJvZnNfZnVsbCA8LSBtZXJnZShwcm9mcywNCiAgICAgICAgICAgICAgICAgICAgbWV0YWRmWywgYygxOjQsIDM2MSldLA0KICAgICAgICAgICAgICAgICAgICBieSA9ICJwcm9maWxlX2lkIikNCg0KIyBXcml0ZSB0aGlzIG91dCBpbnRvIG91ciBEQg0KI2RiV3JpdGVUYWJsZShjb24sICJuYXJjaXNfcHJvZl9pbmZvIiwgcHJvZnNfZnVsbCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQpDaGVjayBmb3IgcHJvZmVzc29ycyB3aXRoIGR1cGxpY2F0ZSBuYW1lczoNCmBgYHtyfQ0KcHJvZnNfZnVsbF9kdXBsIDwtIHByb2ZzX2Z1bGwNCnByb2ZzX2Z1bGxfZHVwbCRkdXBsIDwtIGR1cGxpY2F0ZWQocHJvZnNfZnVsbF9kdXBsJGZ1bGwpDQpkdXBsX25hbWVzIDwtIGZpbHRlcihwcm9mc19mdWxsX2R1cGwsIGR1cGwgPT0gVFJVRSkkZnVsbA0KDQoNCnByb2ZzX2R1cGxpY2F0ZXMgPC0gZmlsdGVyKHByb2ZzX2Z1bGxfZHVwbCwgZnVsbCAlaW4lIGR1cGxfbmFtZXMpDQpgYGANCg0KDQojIFRpZHkgdXAgdGhlIHB1YmxpY2F0aW9uIGRhdGEgZnJvbSBOQVJDSVMNCkxvYWQgdGhlIHB1YmxpY2F0aW9uIGRhdGE6DQpgYGB7cn0NCiMgZmV0Y2ggdGhlIHBhcGVycw0KbG9hZCgifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcmF3X2RhdGEvbWVkaWFfcHJvZnNfcHVicy5yZGEiKQ0KIyBtYXRjaCB0aGUgcHVibGljYXRpb24gZGF0YSB0byBhdXRob3JzaGlwcw0KbG9hZCgifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcmF3X2RhdGEvbWVkaWFfcHJvZnNfcHViX3RvX3Byb2ZpbGVfaWRzLnJkYSIpDQpjb2xuYW1lcyhwdWJfdG9fcHJvZmlsZV9pZClbMV0gPC0gIm5hcmNpc191cmwiDQoNCnByb2ZfcHVic19mdWxsIDwtIG1lcmdlKHB1YnNfbWV0YWRmWywgYygxOjIzKV0sDQogICAgICAgICAgICAgICAgICAgICAgICBwdWJfdG9fcHJvZmlsZV9pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gIm5hcmNpc191cmwiKQ0KIyBzdHJpcCB0aGUgbGFzdCAvIGZyb20gdGhlIHByb2ZpbGUgaWRzIGhlcmUNCnByb2ZfcHVic19mdWxsJHByb2ZpbGVfaWQgPC0gc3RyX3N1Yihwcm9mX3B1YnNfZnVsbCRwcm9maWxlX2lkLCBlbmQgPSAtMikNCg0KIyB0aWR5IHVwIHNvbWUgbWlzYmVoYXZpbmcgRE9Jcw0KcHJvZl9wdWJzX2Z1bGwkbl93b3JkcyA8LSBzdHJfY291bnQocHJvZl9wdWJzX2Z1bGwkRE9JLCAiICIpDQoNCiMgbGV0J3MgbWFudWFsbHkgZml4IHRoZW0gc2luY2UgdGhlcmUgYXJlIHNvIGZldyBwcm9ibGVtYXRpYyBvbmVzDQpwdWJzX2RvaV93b3JkcyA8LSBmaWx0ZXIocHJvZl9wdWJzX2Z1bGwsIG5fd29yZHMgPiAwKQ0KIyB0aGVzZSBhcmUganVzdCB0aGUgRE9JcyB3aGVyZSB3ZSBoYXZlIG1hbnVhbGx5IHJlbW92ZWQgdGhlIHNwYWNlcyBvciByZWR1bmRhbnQgdGV4dA0KcHVic19kb2lfd29yZHMkRE9JIDwtIGMoIjEwLjEwMTYvai5qaHlkcm9sLjIwMTEuMDMuMDQ3IiwgIjEwLjExMTEvai4xMzY1LTMwOTEuMjAxMi4wMTM2NS54IiwgICANCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTEyMC9qYWNtcC52MTdpNC42MTE3IiwgIjEwLjIyMjAzL2VjbS52MDMyYTExIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4yMjIwMy9lY20udjAzMmExMSIsICIxMC4xMTY3L2lvdnMuMTYtMjA3OTkiLCAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMzYvYm1qc2VtLTIwMTgtMDAwNDI3IiwgIjEwLjExMTEvaGFlLjEyMzUzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTEyOC9pYWkuNjQuMTAuNDIyMC00MjI1LjE5OTYiLCAiMTAuMTAzOS9iMzAyMDk3ZSIsICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDM5L2IzMDIwOTdlIiwgIjEwLjEwMTYvczAwMTYtNTA4NSgxOSkzODA1Mi03IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTAzOS9iMjA5Mzc4YiIsICIxMC4zODUwLzk3OC05ODEtMDctMjYxNS03LTI5MCIsICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0wNy0yNjE1LTcgMjg5IiwgIjEwLjEwMTYvczAwNDAtNjA5MCg5NikwOTI0OC02IiwgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjEwNjEoYXNjZSltdC4xOTQzLTU1MzMuMDAwMjE2OSIsICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMDU5NjAwIiwgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMDU5NjAwIiwgIjEwLjEzNzEvam91cm5hbC5wb25lLjAwNTk2MDAiLCAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTEwOS9pc2JpLjIwMTYuNzQ5MzUzMiIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTEwOS9pc2JpLjIwMTYuNzQ5MzUzMiIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTA4MC8wMzc5NzcyMDEyMDA4MjY1MSIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0xMS0yNzI0LTNfMDY0MS1jZCIsICIxMC4zODUwLzk3OC05ODEtMTEtMjcyNC0zXzA2NDEtY2QiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wNTk2LWNkIiwgIjEwLjExMzYvYm1qb3Blbi0yMDE3LTAxNjA3NyIsICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMTAzL3BoeXNyZXZsZXR0LjExNS4xNTk5MDEiLCAiMTAuMTUxNS9saW5ndmFuLTIwMTYtMDA0OCIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDgvamZyYy0wNy0yMDE4LTAxMDMiLCAiMTAuMTA5Ny8wMS5icnMuMDAwMDIwNjM4MS4xNTIyNC4wIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTA4MC8yMTUwNzc0MC4yMDE2LjEyNTE5OTAiLCAiMTAuMTAyMS9pZTA0OTI0NDkgczA4ODgtNTg4NSgwNCkwOTI0NC05IiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDIxL2llMDQ5MjQ0OSBzMDg4OC01ODg1KDA0KTA5MjQ0LTkiLCAiMTAuMjQ3OC92MTAzMDQtMDEyLTAwMTEteSIsICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjEwMDcvczEwODUzLTAxMS01NjgyLTYiLCAiMTAuMTAyMS9qYTA0NTU2NTBzMDAwMi03ODYzKDA0KTA1NTY1LTkiLCAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDIxL2pvMDQwMTIyMC1zMDAyMi0zMjYzKDA0KTAwMTIyLTciLCIxMC4xMDA3L3MxMDEwMy0wMDgtMDYyNi0zIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMjE2NzQzIiwgIjEwLjExNzcvMDAyMTg4NjMxNjY3MjcyNCIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjUxOTQvc2UtMTAtNTE3LTIwMTkiLCAiMTAuMTg2OTAvOTc4LTk2MS0yODYtMDYxLTUuMyIsICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjE4NjkwLzk3OC05NjEtMjg2LTA2MS01LjMiLCAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wNDQxLWNkIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0xMS0yNzI1LTAtaXMzLTUtY2QiLCAiMTAuMzM5MC9hdG1vczEyMTIxNjMzIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4zODUwLzk3OC05ODEtMTQtODU5My0wLTQxMzktY2QiLCAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wMjQ4LWNkIikgDQojIGZpeCB0aGUgcHViIGxpc3QNCiMgZmlsdGVyIG91dCB0aGUgcHJvYmxlbWF0aWMgZG9pcw0KcHJvZl9wdWJzX2Z1bGxfZml4IDwtIGZpbHRlcihwcm9mX3B1YnNfZnVsbCwgKGlzLm5hKG5fd29yZHMpfG5fd29yZHMgPT0gMCkpDQojIGFuZCB0aGVuIHB1dCB0aGVtIGJhY2sNCnByb2ZfcHVic19mdWxsIDwtIHJiaW5kKHByb2ZfcHVic19mdWxsX2ZpeCwNCiAgICAgICAgICAgICAgICAgICAgICAgIHB1YnNfZG9pX3dvcmRzKQ0KDQoNCiMgZHJvcCBsYXJnZSBmaWxlcyBmcm9tIHRoZSBtZW1vcnkgYXMgd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmUNCnJtKHB1YnNfbWV0YWRmKQ0Kcm0obWV0YWRmKQ0Kcm0ocHViX3RvX3Byb2ZpbGVfaWQpDQpnYygpDQoNCiMgV3JpdGUgdGhpcyBvdXQgaW50byBvdXIgREINCiNkYldyaXRlVGFibGUoY29uLCAibmFyY2lzX3B1Yl9pbmZvIiwgcHJvZl9wdWJzX2Z1bGwsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KIyBPQSBkYXRhDQoNCiMjIFNlZWsgcHJvZmVzc29yIGlkZW50aWZpZXJzIGluIE9wZW5BbGV4DQoNCkRlZmluZSB0aGUgZnVuY3Rpb24gdGhhdCBoZWxwcyB1cyBzZWVrIGlkZW50aWZpZXJzIGZyb206DQoxLiBQcm9mZXNzb3IncyBOYXJjaXMgcHVibGljYXRpb24gbGlzdCAoYmFzZWQgb24gRE9JKQ0KMi4gUHJvZmVzc29yJ3MgT1JDSUQgYXMgaW4gTmFyY2lzDQozLiBQcm9mZXNzb3IncyBuYW1lICsgTkwgYXMgdGhlIGNvdW50cnkgb2YgdGhlaXIgbGFzdCBrbm93biBpbnN0aXR1dGlvbg0KDQpUaGlzIGRpYWdyYW0gZGVzY3JpYmVzIGhvdyB3ZSBkbyBpdDoNCiFbRmlndXJlIDFdKGltYWdlcy9wcm9mZXNzb3JfaWRlbnRpZmllcl9yZXRyaWV2ZXJfZGlhZ3JhbS5wbmcpDQoNCkxvb3AgdGhyb3VnaCBwcm9mZXNzb3JzIGFuZCBmaW5kIHRoZWlyIGlkZW50aWZpZXJzOg0KYGBge3J9DQpuYXJjaXNfaWRzIDwtIHByb2ZzX2Z1bGwkcHJvZmlsZV9pZA0KcHJvZl9pZGVudGlmaWVyX2xpc3QgPC0gbGlzdCgpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChuYXJjaXNfaWRzKSl7DQogIG5hcmNpc19pZCA8LSBuYXJjaXNfaWRzW2ldDQogIA0KICBwcm9mX2lkcyA8LSBOQQ0KICANCiAgdHJ5KHByb2ZfaWRzIDwtIHByb2Zlc3Nvcl9pZGVudGlmaWVyX3JldHJpZXZlcihuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHViX2RhdGEgPSBwcm9mX3B1YnNfZnVsbCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2RhdGEgPSBwcm9mc19mdWxsKQ0KICApDQogIA0KICBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dIDwtIHByb2ZfaWRzDQogIG5hbWVzKHByb2ZfaWRlbnRpZmllcl9saXN0KVtbaV1dIDwtIG5hcmNpc19pZA0KICANCiAgcHJpbnQocGFzdGUoImRvbmUgd2l0aCIsIGksICJvdXQgb2YiLCBsZW5ndGgobmFyY2lzX2lkcykpKQ0KICANCn0NCmBgYA0KDQpXZSBmYWlsIHRvIGZpbmQgYW55IE9BIGlkcyBmb3Igc29tZSBwcm9mZXNzb3JzLg0KRmluZCB0aGVpciBPQSBJRHMgbWFudWFsbHk6DQpgYGB7cn0NCiMgbWFudWFsbHkgZ2V0IHRoZSBjb3JyZWN0IHNlYXJjaCB0ZXJtcyBmb3IgdGhlIG1pc3NpbmcgcHJvZmVzc29yczoNCm1pc3NpbmdfaWRzIDwtIGMoImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzNjYzNCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzY4NjkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM2OTYwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzNzg1MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzgwNDUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM4NTQyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzODg4MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzg4OTgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM5MTIyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzOTYwNiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzk4NDEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQwMTk0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MTIxOCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDEyNjYiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQxNTYyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MTgzNyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDIwMzUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQyMjQzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MzEwOSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDcxMTIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjUxNjUwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI1MzgwMSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNTU5MDkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjYzMDE3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI2NTUwMyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNzM4NTgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjc2NDQ4IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4MTg0NCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODE4NDUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjgxODc1IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4Mzk4NCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODYzNTQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjg4MzQwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4ODU1MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODkyOTkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjkxMDUxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5MTkxOSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyOTE5MzgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjk1NDY5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5NTU2OSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyOTYzMTMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjk3MjIzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5NzkyOSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMDA3NjgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzAzNTUyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMwNDY1MSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMTM3ODEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzE0MTc4IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMxNjA2OCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMTc4MDYiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzE5MjQxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMxOTgxMiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjAxNzQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzIxMTAzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMyNDE2MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjUxMjAiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzI5MTY2IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMTM2MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzE0NTIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzMzNjE0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMzgwMSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzQwNDMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM1NjU0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzNTY1OSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzYzNjUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM2NTQ5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MDg4NyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDA5NzgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQxNTU3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MjE4MSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDIxOTUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQyMjc1IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0Nzg5NyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDgyNDEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQ4MzUzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0OTczMiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNTAzMjgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUwOTM3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM1MTMwNiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNTEzMDgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUxMzY0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM1MTQ4MSIpDQoNCm1pc3Npbmdfc2VhcmNoX3Rlcm1zIDwtIGMoIlcuSC5NLiBSZWVodWlzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlBoaWxpcCBILiBKLiBHLiB2YW4gSHVpemVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkouQy5FLiB2YW4gS29sbGVuYnVyZyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJBLkkuTS4gdmFuIE1pZXJsbyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKZWFuLUJlcm5hcmQgTWFydGVucyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJSLlAuSi5MLiBUaml0dGVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkouVy4gRHV5dmVuZGFrIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkplYW4tUGllcnJlIFdpbHMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiVy5HLiBIdWlqZ2VuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkphbiBBLiBCcnVpam4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQW5uZS1NYXJpZSBLb3J0ZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJHLlcuSi5NLiBLYW1wc2Now7ZlciIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIm0uaC4gY29yYmV5IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkEuTS4gTHVib3Rza3kiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly9vcGVuYWxleC5vcmcvQTUwNDE5MzAxNTciLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiRS5GLiBTdGVlbm5pcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJWZW51Z29wYWwgVmVua2F0YXJhbWFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImhvZWZ0ZSByb3NlbWFyaWpuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkIuUC5NLiB2YW4gUmF2ZWxzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImtvcnN0ZW4gZi53LmEuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkFsYmVyZGluYSBIb3V0bWFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIk1hcmNvIFAgTmlldXdlIFdlbWUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSmFuLURpZWRlcmlrIHZhbiBXZWVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJDLkQuSi4gQnVsdGVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkEuTS5CLiBEZVdhZWdlbmFlcmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiV2lsbGVt4oCQSmFuIHZhbiBkZW4gSGV1dmVsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkUuQy5DLiBQdW5zZWxpZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkcuIHZhbiBSaWpzc2VuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJNLkEuIFZlcmJydWdoIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkh1aWJlcnQgRGllZGVyaWsgdmFuIFJvbWJ1cmdoIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJLYXRhcnp5bmEgSi4gQ3dpZXJ0a2EiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSi5XLiBGb3BwZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiUGV0ZXIgdmFuIEdvb2wiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSC5KLk0uIEhhdmVrZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImkuYS5tLiBzYWxvdWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiZS5qLmouIGJldWxlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJPbGV4YW5kZXIgWWFyb3Z5aSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJSLlAuIEJvdGhhIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkEuIE0uIEJhcnlzaGV2IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgInN5bHZpYSBidXJnLXZlcm1ldWxlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKLlMuTC5BLlcuQi4gUm9lcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKYW4gSGVpbiBGdXJuw6llIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkFubmV0dGUgRnJleWJlcmfigJBJbmFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkdlcnQgSmFuIHZhbiBkZXIgU21hbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQy4gR291a2Vucy1NZXJ0ZW5zIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJHLlIuQi5FLiBSw7ZtZXIiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAicC5oLmwubS4ga3V5cGVycyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJHZW5zZXJpayBSZW5pZXJzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlN0ZXBoYW4gV2Vuc3ZlZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiT25ubyBLcmFuZW5idXJnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlNjaHdhcnR6LUxhbmRzbWFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkcuSi5DLiBSZW5zZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSy5XLkguIEJyb2VraHVpemVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlMuSC5NLkEuIER1bW91bGluIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlMuIEpvbmcgS29uIENoaW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiUy5QLkouIHZhbiBBbHBoZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQ2h1buKAkEtldW5nIEhvaSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJTZXJnZXkgTmVqZW50c2V2IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImx1ZG92aWNvIGFsY29ydGEiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAicC5hLm0uZy4gZGUga29jayIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJoYWVyc29sdGUtdmFuIGhvZiBqYWNvbWlqbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJFdWdlbmlhIEhvdXZlbmFnaGVsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIm0uYS4gdmFuIHdpbGxpZ2VuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImFydGh1ciB0ZW4gY2F0ZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJQZXRlciBLb3VkaWpzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkZ1bHZpbyBSZWdnaW9yaSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkFudG9uaXMgUGFwYXBhbnRvbGVvbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJhLmMuIGJvZXJzdHJhIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkxlb25pZSBIZXJlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJUaG9tYXMgUC4gTW9saXRlcm5vIikNCg0KbGVuZ3RoKHdoaWNoKGlzLm5hKG1pc3Npbmdfc2VhcmNoX3Rlcm1zKSkpDQpgYGANCldlIGNhbm5vdCBmaW5kIGEgcmVsaWFibGUgT0EgSUQgZm9yIDEyIHByb2Zlc3NvcnMgaW4gb3VyIGRhdGFzZXQuIA0KDQpMb29wIHRocm91Z2ggdGhlIGlkZW50aWZpZXIgbGlzdCB0byBmaWxsIHRoZSBJRHMgaW46DQpgYGB7cn0NCmZvciAoaSBpbiAxOmxlbmd0aChtaXNzaW5nX2lkcykpew0KICBuYXJjaXNfaWQgPC0gbWlzc2luZ19pZHNbaV0NCiAgDQogIHNlYXJjaF90ZXJtIDwtIG1pc3Npbmdfc2VhcmNoX3Rlcm1zW2ldDQogIA0KICBwcm9mX2xpc3RfaXRlbSA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbbmFyY2lzX2lkXV0NCiAgDQogIGlmICghaXMubmEoc2VhcmNoX3Rlcm0pKXsNCiAgICANCiAgICBpZihzZWFyY2hfdGVybSA9PSAiaHR0cHM6Ly9vcGVuYWxleC5vcmcvQTUwNDE5MzAxNTciKXsNCiAgICAgIHByb2Zfb2FfaWRzIDwtIG9hX2ZldGNoKA0KICAgICAgICBlbnRpdHkgPSAiYXV0aG9yIiwgJ0E1MDQxOTMwMTU3JykNCiAgICB9ZWxzZXsNCiAgICAgIHByb2Zfb2FfaWRzIDwtIG9hX2ZldGNoKCJhdXRob3IiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoX3Rlcm0pDQogICAgfQ0KICAgIA0KICAgIGlmIChucm93KHByb2Zfb2FfaWRzKT4wKXsNCiAgICAgIG9hX2lkc19uYW1lcyA8LSBwcm9mX29hX2lkcyRpZHMNCiAgICAgICMgaWYgYSBsaXN0LCBvbmx5IHJldGFpbiB0aGUgT0EgSURzOg0KICAgICAgaWYoY2xhc3Mob2FfaWRzX25hbWVzKSA9PSAibGlzdCIpew0KICAgICAgICBvYV9pZHNfbmFtZXMgPC0gYygpDQogICAgICAgIGZvciAoaiBpbiAxOm5yb3cocHJvZl9vYV9pZHMpKXsNCiAgICAgICAgICBpZCA8LSBwcm9mX29hX2lkcyRpZHNbW2pdXVsnb3BlbmFsZXgnXQ0KICAgICAgICAgIG9hX2lkc19uYW1lcyA8LSBjKG9hX2lkc19uYW1lcywgaWQpDQogICAgICAgIH0NCiAgICAgICAgb2FfaWRzX25hbWVzIDwtIHVubmFtZShvYV9pZHNfbmFtZXMpDQogICAgICB9DQogICAgICANCiAgICAgIHByb2ZfbGlzdF9pdGVtWyJvYV9pZHNfbmFtZXMiXSA8LSBsaXN0KG9hX2lkc19uYW1lcykNCiAgICB9DQogIH0NCiAgDQogIHByb2ZfaWRlbnRpZmllcl9saXN0W1tuYXJjaXNfaWRdXSA8LSBwcm9mX2xpc3RfaXRlbQ0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChtaXNzaW5nX2lkcykpKQ0KICANCn0NCmBgYA0KDQpFeHRyYWN0IHByb2Zlc3NvciBJRHMgYW5kIHNvdXJjZXMgZm9yIGVhY2ggcHJvZmVzc29yOg0KYGBge3J9DQpwcm9mX29hX21hcHBpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChwcm9mX2lkZW50aWZpZXJfbGlzdCkpew0KICAjIGluaXRpYXRlIGEgZGF0YWZyYW1lIHRvIHN0b3JlIHRoaXMgcHJvZmVzc29yJ3MgZGF0YQ0KICBwcm9mX29hX2lkcyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAzKSkNCiAgIyByZXRyaWV2ZSB0aGlzIHByb2Zlc3NvcidzIGxpc3Qgb2YgaWRlbnRpZmllcnMNCiAgcHJvZl9pZGVudGlmaWVycyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dDQogICMgZ2V0IHRoZWlyIE5hcmNpcyBJRCBhbmQgYWxsIHRoZSByZXRyaWV2ZWQgT0EgSURzDQogIG5hcmNpc19pZCA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sibmFyY2lzX2lkIl1dDQogIA0KICBwdWJfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfcHVicyJdXQ0KICANCiAgb3JjaWRfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfb3JjaWQiXV0NCiAgDQogIG5hbWVfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfbmFtZXMiXV0NCiAgDQogICMgYWRkIGFueSBJRHMgcmV0cmlldmVkIGZyb20gdGhlIHB1YmxpY2F0aW9uIGxpc3QNCiAgaWYgKCFhbGwoaXMubmEocHViX2lkcykpKXsNCiAgDQogIHB1Yl9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gcHViX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gInB1YmxpY2F0aW9ucyIpDQogIA0KICBwcm9mX29hX2lkcyA8LSByYmluZChwcm9mX29hX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgcHViX2lkcykNCiAgfQ0KICAjIGFkZCBhbnkgSURzIGFzc29jaWF0ZWQgd2l0aCBwcm9mJ3MgT1JDSUQNCiAgaWYgKCFhbGwoaXMubmEob3JjaWRfaWRzKSkpew0KICBvcmNpZF9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gb3JjaWRfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNvdXJjZSIgPSAib3JjaWQiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIG9yY2lkX2lkcykNCiAgfQ0KICAjIGFkZCBhbnkgSURzIGZyb20gbmFtZSBzZWFyY2ggKyBOTCBjb3VudHJ5DQogIGlmICghYWxsKGlzLm5hKG5hbWVfaWRzKSkpew0KICBuYW1lX2lkcyA8LSBjYmluZC5kYXRhLmZyYW1lKCJwcm9maWxlX2lkIiA9IG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYV9pZCIgPSBuYW1lX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gIm5hbWUiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIG5hbWVfaWRzKQ0KICB9DQogIA0KICAjIGlmIGFueSByb3dzDQogIGlmIChucm93KHByb2Zfb2FfaWRzKSA+IDApew0KICAgIA0KICAgICMgZGVkdXBsaWNhdGUNCiAgICBwcm9mX29hX2lkcyRkdXBsaWNhdGUgPC0gZHVwbGljYXRlZChwcm9mX29hX2lkc1tjKCJwcm9maWxlX2lkIiwgIm9hX2lkIildKQ0KICAgIHByb2Zfb2FfaWRzIDwtIGZpbHRlcihwcm9mX29hX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID09IEZBTFNFKQ0KICAgIHByb2Zfb2FfaWRzIDwtIHByb2Zfb2FfaWRzWywgLTRdDQogICAgDQogICAgcHJvZl9vYV9tYXBwaW5nIDwtIHJiaW5kKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9pZHMpDQogIH0gZWxzZXsNCiAgICBwcm9mX29hX2lkcyA8LSBjYmluZC5kYXRhLmZyYW1lKCJwcm9maWxlX2lkIiA9IG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYV9pZCIgPSBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gTkEpDQogICAgcHJvZl9vYV9tYXBwaW5nIDwtIHJiaW5kKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9pZHMpDQogIH0NCiAgcHJpbnQocGFzdGUoImRvbmUgd2l0aCIsIGksICJvdXQgb2YiLCBsZW5ndGgobmFyY2lzX2lkcykpKQ0KfQ0KDQpgYGANCg0KRm9yIHByb2Zlc3NvcnMgd2hlcmUgd2UgaGF2ZSBwdWJsaWNhdGlvbiBhbmQgT1JDSUQtYmFzZWQgT0EgSURzLCB3ZSB3aWxsIG9ubHkNCnVzZSB0aG9zZSAod2hpY2ggaXMgNTQ1MiBwcm9mZXNzb3JzKQ0KYGBge3J9DQpwcm9mX29hX21hcHBpbmdfcHViX29yY2lkIDwtIGZpbHRlcihwcm9mX29hX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgIT0gIm5hbWUiKQ0KDQpsZW5ndGgodW5pcXVlKHByb2Zfb2FfbWFwcGluZ19wdWJfb3JjaWQkcHJvZmlsZV9pZCkpDQpgYGANCkFuZCBub3csIGZvciB0aGUgcmVtYWluaW5nIHByb2Zlc3NvcnMsIGdldCB0aGVpciBuYW1lLWJhc2VkIElEcyAoMTM2NiBwcm9mZXNzb3JzKSwgYnV0IHdhdGNoIG91dCBmb3INCmFueSBvZGRpdGllcyAoZS5nLiwgYW4gZXh0cmVtZSBudW1iZXIgb2YgSURzKToNCmBgYHtyfQ0KcHJvZl9vYV9tYXBwaW5nX25hbWUgPC0gZmlsdGVyKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPT0gIm5hbWUiICYgISBwcm9maWxlX2lkICVpbiUgcHJvZl9vYV9tYXBwaW5nX3B1Yl9vcmNpZCRwcm9maWxlX2lkKQ0KDQpsZW5ndGgodW5pcXVlKHByb2Zfb2FfbWFwcGluZ19uYW1lJHByb2ZpbGVfaWQpKQ0KDQojIGNoZWNrIG1hbnVhbGx5IGZvciBvZGQgbnVtYmVycyBvZiBJRHMNCm9hX2lkX2NoZWNrIDwtIHByb2Zfb2FfbWFwcGluZ19uYW1lICU+JSANCiAgY291bnQocHJvZmlsZV9pZCwgc291cmNlLCBzb3J0ID0gVFJVRSkNCg0KIyBoZXJlIGFyZSBwcm9mZXNzb3IgSURzIHdpdGggbW9yZSB0aGFuIDEwIGRpZmZlcmVudCBJRHMgd2hlcmUgd2Ugc2VlIGluY29uc2lzdGVudCBuYW1lLWJhc2VkIHJlc3VsdHMNCnByb2JsZW1hdGljX2lkcyA8LSBjKCJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzYyMDMiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzNjIyMiIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM0MDI4IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMDMxOTAiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMDY3MyIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM0MDA3IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjU3NjYiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MDE1NiIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUwODA5IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzIyODgiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MDkwMSIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM2MTc4IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDA3MTkiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MjYzNCIsIA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMjcwMCIpDQoNCiMgZmlsdGVyIHRoZW0gb3V0DQpwcm9mX29hX21hcHBpbmdfbmFtZSA8LSBmaWx0ZXIocHJvZl9vYV9tYXBwaW5nX25hbWUsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISBwcm9maWxlX2lkICVpbiUgcHJvYmxlbWF0aWNfaWRzKQ0KYGBgDQoNCkNvbWJpbmUgdGhlIHJlbGlhYmxlIHJlc3VsdHMgdG9nZXRoZXIuIEluIHRvdGFsLCB3ZSBtaXNzIE9BIElEcyBmb3IgMjcgcHJvZmVzc29ycw0KKDAuNCUgb2YgYWxsIG9ic2VydmF0aW9ucyk6DQpgYGB7cn0NCnByb2Zfb2FfbWFwcGluZ19maXggPC0gcmJpbmQocHJvZl9vYV9tYXBwaW5nX3B1Yl9vcmNpZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9tYXBwaW5nX25hbWUpDQoNCmxlbmd0aCh1bmlxdWUocHJvZl9vYV9tYXBwaW5nX2ZpeCRwcm9maWxlX2lkKSkNCihucm93KHByb2ZzX2Z1bGwpLWxlbmd0aCh1bmlxdWUocHJvZl9vYV9tYXBwaW5nX2ZpeCRwcm9maWxlX2lkKSkpL25yb3cocHJvZnNfZnVsbCkqMTAwDQpgYGANCg0KQW5kIGRvIG5vdCBxdWVyeSBwcm9mZXNzb3JzIHdobyBoYXZlIG5hbWVzIHRoYXQgYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIHRoZQ0KZGF0YXNldCwgYW5kIHdob3NlIE9BIElEcyB3ZSBvbmx5IHF1ZXJ5IHZpYSBuYW1lOg0KYGBge3J9DQojIHdoaWNoIHByb2ZzIGZyb20gdGhlIGR1cGxpY2F0ZSBsaXN0IGhhdmUgT0EgSURzIHB1bGxlZCBmcm9tIHRoZWlyIG5hbWVzIG9ubHk/DQpwcm9mc19kdXBsaWNhdGVzX29hIDwtIGZpbHRlcihwcm9mX29hX21hcHBpbmdfZml4LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZV9pZCAlaW4lIHByb2ZzX2R1cGxpY2F0ZXMkcHJvZmlsZV9pZCkNCg0KIyBkcm9wICB0aGUgcHJvZnMgZm9yIHdob20gd2UgaGF2ZSBuYW1lLWJhc2VkIElEcyBvbmx5DQpwcm9mc19kdXBsaWNhdGVzX2Ryb3AgPC0gcHJvZnNfZHVwbGljYXRlc19vYSAlPiUgIGdyb3VwX2J5KHByb2ZpbGVfaWQpICU+JSBmaWx0ZXIoYW55KHNvdXJjZSA9PSAnbmFtZScpKQ0KDQoNCnByb2Zfb2FfbWFwcGluZ19maXggPC0gZmlsdGVyKHByb2Zfb2FfbWFwcGluZ19maXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISBwcm9maWxlX2lkICVpbiUgcHJvZnNfZHVwbGljYXRlc19kcm9wJHByb2ZpbGVfaWQpDQpgYGANCg0KV2hhdCBkbyB3ZSBtaXNzPyBXZSBtaXNzIElEcyBmb3IgMzEgcHJvZmVzc29yLiANCmBgYHtyfQ0KbGVuZ3RoKHVuaXF1ZShwcm9mX29hX21hcHBpbmdfZml4JHByb2ZpbGVfaWQpKQ0KKG5yb3cocHJvZnNfZnVsbCktbGVuZ3RoKHVuaXF1ZShwcm9mX29hX21hcHBpbmdfZml4JHByb2ZpbGVfaWQpKSkNCihucm93KHByb2ZzX2Z1bGwpLWxlbmd0aCh1bmlxdWUocHJvZl9vYV9tYXBwaW5nX2ZpeCRwcm9maWxlX2lkKSkpL25yb3cocHJvZnNfZnVsbCkqMTAwDQpgYGANCg0KDQpXcml0ZSB0aGUgZGF0YSBvdXQ6DQpgYGB7cn0NCmRiV3JpdGVUYWJsZShjb24sICJvYV9pZF9tYXBwaW5nIiwgcHJvZl9vYV9tYXBwaW5nX2ZpeCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQoNCiMjIE9SQ0lEcw0KDQpOb3csIGZpbmQgcHJvZmVzc29yJ3MgT1JDSURzIGJhc2VkIG9uIG91ciBOQVJDSVMgZGF0YSAoYWx3YXlzIGhhcyB0aGUgcHJlZmVyZW5jZSkNCmFuZCwgd2hlcmUgbm90IGF2YWlsYWJsZSwgb24gdGhlIE9SQ0lEcyBleHRyYWN0ZWQgYmFzZWQgb24gdGhlaXIgT0EgSURzOg0KYGBge3J9DQpvYV9pZF9saXN0IDwtIHVuaXF1ZShwcm9mX29hX21hcHBpbmdfZml4JG9hX2lkKQ0KIyBub3cgZmV0Y2ggdGhlIHByb2Zlc3NvciBpbmZvIGZyb20gT0EgYmFzZWQgb24gdGhlaXIgSUQsIHRvIHNlZWsgdGhlaXIgT1JDSURzDQpwcm9mX2luZm9fYWxsIDwtIG9hX2ZldGNoKA0KICBlbnRpdHkgPSAiYXV0aG9ycyIsIA0KICBvcGVuYWxleF9pZCA9IG9hX2lkX2xpc3QpDQoNCiMgb25seSBsZWF2ZSB0aGUgSURzIHRoYXQgaGF2ZSBPUkNJRHMNCnByb2ZfaW5mb19vcmNpZHNfMSA8LSBmaWx0ZXIocHJvZl9pbmZvX2FsbCwgIWlzLm5hKG9yY2lkKSklPiUNCiAgc2VsZWN0KGlkLCBvcmNpZCkNCiMgdGlkeSB1cCB0aGUgY29sbmFtZXMNCmNvbG5hbWVzKHByb2ZfaW5mb19vcmNpZHNfMSkgPC0gYygib2FfaWQiLCAiT1JDSUQiKQ0KIyBhbmQgbWF0Y2ggdG8gTmFyY2lzIElEcw0KcHJvZl9pbmZvX29yY2lkc18xIDwtIG1lcmdlKHByb2Zfb2FfbWFwcGluZ19maXhbMToyXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2luZm9fb3JjaWRzXzEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAib2FfaWQiKQ0KDQojIG5vdywgZ2V0IHRoZSBPUkNJRHMgd2UgYWxyZWFkeSBoYXZlIGZyb20gTmFyY2lzDQpwcm9mX2luZm9fb3JjaWRzXzIgPC0gZmlsdGVyKHByb2ZzX2Z1bGwsICFpcy5uYShPUkNJRCkpJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCBPUkNJRCkNCg0KcHJvZl9pbmZvX29yY2lkc18yIDwtIG1lcmdlKHByb2Zfb2FfbWFwcGluZ19maXhbMToyXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2luZm9fb3JjaWRzXzIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAicHJvZmlsZV9pZCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsLnkgPSBUUlVFKQ0KDQojIG9ubHkgc2VsZWN0IHByb2Zlc3NvcnMgZm9yIHdob20gd2UgZG9uJ3QgaGF2ZSBhbiBPUkNJRCBpbiBvdXIgTmFyY2lzIGRhdGEsDQojIGFzIE5hcmNpcyBkYXRhIGlzIGFsd2F5cyBvdXIgZmlyc3QgY2hvaWNlDQpwcm9mX2luZm9fb3JjaWRzXzEgPC0gZmlsdGVyKHByb2ZfaW5mb19vcmNpZHNfMSwgISBwcm9maWxlX2lkICVpbiUgcHJvZl9pbmZvX29yY2lkc18yJHByb2ZpbGVfaWQpDQoNCiMgY29tYmluZSB0aGUgdHdvIHNvdXJjZXMNCnByb2ZfaW5mb19vcmNpZHNfMiA8LSBwcm9mX2luZm9fb3JjaWRzXzJbY29sbmFtZXMocHJvZl9pbmZvX29yY2lkc18xKV0NCg0KcHJvZl9pbmZvX29yY2lkc19jb21iaSA8LSByYmluZChwcm9mX2luZm9fb3JjaWRzXzEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfaW5mb19vcmNpZHNfMikNCg0KIyBhbmQga2VlcCBvbmx5IG9uZSByb3cgd2l0aCBPUkNJRCdzIHBlciBOYXJjaXMgSUQNCnByb2ZfaW5mb19vcmNpZHNfY29tYmkgPC0gcHJvZl9pbmZvX29yY2lkc19jb21iaSAlPiUNCiAgZGlzdGluY3QoLiwgcHJvZmlsZV9pZCwgT1JDSUQsIC5rZWVwX2FsbCA9IFRSVUUpJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCBPUkNJRCkNCiAgDQojIHNvIHdlIGhhdmUgT1JDSURzIGZvciA1NDc4IHByb2Zlc3NvcnMsIG9yIHNvbWUgODAlIG9mIG91ciBkYXRhc2V0DQpucm93KHByb2ZfaW5mb19vcmNpZHNfY29tYmkpDQpucm93KHByb2ZfaW5mb19vcmNpZHNfY29tYmkpL25yb3cocHJvZnNfZnVsbCkqMTAwDQoNCmRiV3JpdGVUYWJsZShjb24sICJvcmNpZF9tYXBwaW5nIiwgcHJvZl9pbmZvX29yY2lkc19jb21iaSwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQoNCiMjIEV4dHJhY3QgcHVibGljYXRpb25zIGJhc2VkIG9uIE9BIElEcw0KDQpEZWZpbmUgdGhlIGRhdGEgcXVlcnlpbmcgZnVuY3Rpb24sIHdoaWNoIHB1bGxzIGRhdGEgZnJvbSBPQSBhcyBzaG93biBpbiB0aGUNCkRpYWdyYW0gYmVsb3c6DQohW0ZpZ3VyZSAyXShpbWFnZXMvcHJvZmVzc29yX2luZm9fcmV0cmlldmVyX2RpYWdyYW0ucG5nKQ0KDQpQdWxsIHRoZSBwcm9mZXNzb3IgZGF0YToNCmBgYHtyfQ0KIyBnZXQgdGhlIGxpc3Qgb2YgSURzDQpuYXJjaXNfaWRzIDwtIHByb2ZzX2Z1bGwkcHJvZmlsZV9pZA0KDQojIDI0MzUgaXMgdGhlIG5leHQgb25lDQojIGxvb3AgdGhyb3VnaCB0aGUgYmF0Y2hlcw0KZm9yKGkgaW4gMTpsZW5ndGgobmFyY2lzX2lkcykpew0KICBuYXJjaXNfaWQgPC0gbmFyY2lzX2lkc1tpXQ0KICANCiAgcHJvZmVzc29yX3B1Yl9pbmZvX3JldHJpZXZlcihwcm9mX29hX2lkcyA9IHByb2Zfb2FfbWFwcGluZ19maXgsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFyY2lzX2lkID0gbmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Yl9kYXRhID0gcHJvZl9wdWJzX2Z1bGwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9kYXRhID0gcHJvZnNfZnVsbCkNCiAgIyBwcmludCBzb21lIGluZm8gb3V0DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKG5hcmNpc19pZHMpKSkNCn0NCg0KYGBgDQoNCldyaXRlIG91dCB0aGUgdW5pcXVlIHB1YmxpY2F0aW9uIGxpc3Q6DQpgYGB7cn0NCm9hX3Byb2ZfcHVicyA8LSBkYlJlYWRUYWJsZShjb24sICJvYV9wcm9mX3B1YnMiKQ0KDQpvYV9wcm9mX3B1YnNfdW5pcXVlIDwtIGRpc3RpbmN0KG9hX3Byb2ZfcHVicywgaWQsIC5rZWVwX2FsbCA9IFRSVUUpDQoNCm9hX3Byb2ZfcHVic191bmlxdWUgPC0gb2FfcHJvZl9wdWJzX3VuaXF1ZSAlPiUNCiAgc2VsZWN0KC1jb3VudHNfYnlfeWVhcl95ZWFyLCAtY291bnRzX2J5X3llYXJfY2l0ZWRfYnlfY291bnQpJT4lDQogIHNlbGVjdCgtYyhhdV9pZDppbnN0aXR1dGlvbl9saW5lYWdlKSkgJT4lDQogIHNlbGVjdCgtYyhvYV9pZDpwcm9maWxlX2lkKSkNCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3Byb2ZfcHVic191bmlxdWUiLCBvYV9wcm9mX3B1YnNfdW5pcXVlKQ0KYGBgDQoNCg0KIyBQcm9mZXNzb3IgQWx0bWV0cmljIGRhdGENCg0KIyMgUHJvZmVzc29yIGF0dGVudGlvbiBkYXRhIChET0kgYmFzZWQsIGV4Y2x1ZGluZyBUd2l0dGVyKQ0KDQpHZXQgdGhlIGFsdG1ldHJpYyBhdHRlbnRpb24gZm9yIG91ciBwcm9mZXNzb3JzLCBwZXIgRE9JOg0KYGBge3J9DQojIGFwaSBrZXkgZm9yIHRoZSBEZXRhaWxzIEFQSQ0KYWx0bWV0cmljX2RldGFpbHNfYXBpX2tleSA8LSAnJw0KDQojIGdldCB0aGUgbGlzdCBvZiBwdWJsaWNhdGlvbnMgdG8gZXh0cmFjdA0Kb2FfcHVicyA8LSBkYkdldFF1ZXJ5KGNvbiwgInNlbGVjdCAqIGZyb20gb2FfcHJvZl9wdWJzOyIpDQoNCiMgZ2V0IGEgdW5pcXVlIGxpc3Qgb2YgcHVibGljYXRpb25zIHRvIGZldGNoIG1lbnRpb25zIGZvcg0KZG9pX2xpc3QgPC0gZmlsdGVyKG9hX3B1YnMsICFpcy5uYShkb2kpKSU+JQ0KICBkaXN0aW5jdChkb2ksIC5rZWVwX2FsbCA9IFRSVUUpDQoNCiMgbG9vcCB0aHJvdWdoIHRoZSBkb2lzDQpmb3IoaSBpbiAxOm5yb3coZG9pX2xpc3QpKXsNCiAgZG9pIDwtIGRvaV9saXN0W2ksXQ0KIA0KICBhbHRtZXRyaWNfbWVudGlvbl9yZXRyaWV2ZXIoYXBpX2tleSA9IGFsdG1ldHJpY19kZXRhaWxzX2FwaV9rZXksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2kgPSBkb2ksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlX3R3aXR0ZXIgPSBGQUxTRSkNCiAgDQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbnJvdyhkb2lfbGlzdCkpKQ0KfQ0KYGBgDQoNCg0KIyMgUmV0cmlldmUgVHdpdHRlciBtZW50aW9ucyAocGVyIE9SQ0lEKQ0KDQpVc2luZyBwcm9mZXNzb3IgT1JDSURzLCBwdWxsIHRoZSBhdHRlbnRpb24gVHdpdHRlciBkYXRhIGZyb20gdGhlDQpBbHRtZXRyaWMgRXhwbG9yZXIgQVBJOg0KYGBge3J9DQojIHJldHJpZXZlIHRoZSBPUkNJRCB0YWJsZQ0KcHJvZl9vcmNpZHMgPC0gZGJHZXRRdWVyeShjb25uID0gY29uLCBzdGF0ZW1lbnQgPSAic2VsZWN0ICogZnJvbSBvcmNpZF9tYXBwaW5nOyIpDQoNCiMgZ2V0IHRoZSBBbHRtZXRyaWMgRXhwbG9yZXIgQVBJIGFwaSBrZXlzIChmaWxsIGluIG93bikNCmFwaV9zZWNyZXQgPC0gJycNCmFwaV9rZXkgPC0gJycNCmBgYA0KDQpXZSBwdWxsIGFsbCBhdHRlbnRpb24gZm9yIHJvYnVzdG5lc3MgY2hlY2tzIGFnYWluc3QgdGhlIEFsdG1ldHJpYyBEZXRhaWxzIFBhZ2UNCmluZm8gd2UgZ2V0IGJ5IHNlYXJjaGluZyBhdHRlbnRpb24gdmlhIERPSS4NCg0KTG9vcCB0aHJvdWdoIHRoZSBPUkNJRHMgYW5kIGdldCBwcm9mJyBhdHRlbnRpb24gKGluY2x1ZGluZyB0d2l0dGVyKS4NCmBgYHtyfQ0KcHJvZl9hdHRlbnRpb25fbGlzdCA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSA0KSkNCmNvbG5hbWVzKHByb2ZfYXR0ZW50aW9uX2xpc3QpIDwtIGMoIm1lbnRpb25fdHlwZSIsICJ5ZWFyIiwgInllYXJseV9jb3VudCIsICJwcm9maWxlX2lkIikNCg0KDQpmb3IgKGkgaW4gMTpucm93KHByb2Zfb3JjaWRzKSl7DQogICMgbm90IHN1cmUgdGhpcyBpcyBjb3JyZWN0IQ0KICBvcmNpZCA8LSBwcm9mX29yY2lkcyRPUkNJRFtpXQ0KICBwcm9mX2F0dGVudGlvbiA8LSBOQQ0KICAjIHF1ZXJ5IHRoZSBpbmZvDQogIHRyeShwcm9mX2F0dGVudGlvbiA8LSBhbHRtZXRyaWNfYXBpX29yY2lkX2NhbGxlcihvcmNpZCA9IG9yY2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9zZWNyZXQgPSBhcGlfc2VjcmV0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXkgPSBhcGlfa2V5LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gImF0dGVudGlvbiIpKQ0KICANCiAgIyBpZiBhbnkgZGF0YSwgdW5uZXN0IHR3aWNlIHRvIHVucmF2ZWwgdGhlIGluZm8NCiAgaWYgKCFhbGwoaXMubmEocHJvZl9hdHRlbnRpb24pKSl7DQogICAgcHJvZl9hdHRlbnRpb24gPC0gcHJvZl9hdHRlbnRpb24gJT4lIGRpc3RpbmN0KGlkLCAua2VlcF9hbGwgPSBUUlVFKQ0KICAgIHByb2ZfYXR0ZW50aW9uIDwtIHVubmVzdChwcm9mX2F0dGVudGlvbiwgY29scyA9IGMoIm1ldGEiKSkNCiAgICBwcm9mX2F0dGVudGlvbiA8LSB1bm5lc3QocHJvZl9hdHRlbnRpb24sIGNvbHMgPSBjKCJkYXRlcyIpKQ0KICAgICMgbm93LCBleHRyYWN0IHRoZSB5ZWFyIGFuZCBncm91cCBtZW50aW9ucyBieSB5ZWFyDQogICAgcHJvZl9hdHRlbnRpb24keWVhciA8LSB5ZWFyKHltZChwcm9mX2F0dGVudGlvbiRkYXRlKSkNCiAgICBwcm9mX2F0dGVudGlvbl95ZWFyIDwtIHByb2ZfYXR0ZW50aW9uICU+JQ0KICAgICAgZ3JvdXBfYnkoaWQsIHllYXIpJT4lDQogICAgICBzdW1tYXJpc2UoeWVhcmx5X2NvdW50ID0gc3VtKGNvdW50KSkNCiAgICAjIHRpZHkgdXAgdGhlIGNvbHVtbiBuYW1lcw0KICAgIGNvbG5hbWVzKHByb2ZfYXR0ZW50aW9uX3llYXIpWzFdIDwtIGMoIm1lbnRpb25fdHlwZSIpDQogICAgIyBhZGQgaW4gdGhlIGNvYXV0aG9yIE9BIElEDQogICAgcHJvZl9hdHRlbnRpb25feWVhciRwcm9maWxlX2lkIDwtIHByb2Zfb3JjaWRzJHByb2ZpbGVfaWRbaV0NCiAgICANCiAgICBpZiAobnJvdyhwcm9mX2F0dGVudGlvbl95ZWFyKT4wKXsNCiAgICAgICMgZmlsdGVyIG91dCB0aGUgZHVwbGljYXRlcw0KICAgICAgcHJvZl9hdHRlbnRpb25feWVhciA8LSBmaWx0ZXIocHJvZl9hdHRlbnRpb25feWVhciwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISBwcm9maWxlX2lkICVpbiUgcHJvZl9hdHRlbnRpb25fbGlzdCRwcm9maWxlX2lkKQ0KICAgICAgDQogICAgICBwcm9mX2F0dGVudGlvbl9saXN0IDwtIHJiaW5kKHByb2ZfYXR0ZW50aW9uX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2F0dGVudGlvbl95ZWFyKQ0KICAgIH0NCiAgfQ0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIG5yb3cocHJvZl9vcmNpZHMpKSkNCn0NCg0KZGJXcml0ZVRhYmxlKGNvbiwgImFsdG1ldHJpY19wcm9mX2F0dGVudGlvbiIsIHByb2ZfYXR0ZW50aW9uX2xpc3QsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KDQojIyBSZXRyaWV2ZSBUd2l0dGVyIG1lbnRpb25zIChwZXIgcHVibGljYXRpb24pDQoNCkdldCB0d2l0dGVyIGRhdGEgdGhhdCB3YXMgaW5pdGlhbGx5IG5vdCBwdWxsZWQgdXNpbmcgQWx0bWV0cmljIGFuZCB3cml0ZSBpdCB0byBvdXINCmRhdGFiYXNlIGFzIHdlbGwuDQoNCkNvbm5lY3QgdG8gdGhlIHBvc3RncmVzIGRhdGFiYXNlIGFuZCBwdWxsIHRoZSBwdWJsaWNhdGlvbnMgdGFibGU6DQpgYGB7cn0NCiMgcHVsbCBhbGwgdGhlIHB1YmxpY2F0aW9uIGRhdGENCnF1ZXJ5IDwtIHBhc3RlMCgic2VsZWN0ICogZnJvbSBvYV9wcm9mX3B1YnM7IikNCmFsbF9vYV9wdWJzIDwtIGRiR2V0UXVlcnkoY29ubiA9IGNvbiwgc3RhdGVtZW50ID0gcXVlcnkpDQpgYGANCg0KTm93IGZldGNoIHRoZSB0d2l0dGVyIG1lbnRpb25zIGZvciBlYWNoIHB1YmxpY2F0aW9uLg0KU2luY2UgdGhlcmUgaXMgYSBsaW1pdCBmb3IgVHdlZXQgSURzIHRoYXQgY2FuIGJlIHB1bGxlZCBmcm9tIEFsdG1ldHJpYywNCndlIHJldHJpZXZlIHR3ZWV0cyBwZXIgcGFwZXIsIGFuZCBub3QgdGhlIGF1dGhvciwgdG8gYXZvaWQgZG91YmxlIEFQSSBjYWxscywgYW5kDQp3aWxsIG1hdGNoIHRoZXNlIHdpdGggYXV0aG9ycyBsYXRlciBvbjoNCmBgYHtyIHdhcm5pbmcgPSBGLCBtZXNzYWdlPSBGfQ0KIyBnZXQgYSB1bmlxdWUgbGlzdCBvZiBPQSBJRHMgdG8gcHVsbCB0aGUgZGF0YSBmb3IgYW5kIGVuc3VyZSB0aGV5IGhhdmUgYSBET0kNCnJlbGV2YW50X29hX3B1YnMgPC0gZmlsdGVyKGFsbF9vYV9wdWJzLCAhaXMubmEoZG9pKSklPiUNCiAgZGlzdGluY3QoLiwgaWQsIC5rZWVwX2FsbCA9IFRSVUUpDQoNCiMgcmVtb3ZlIHJlZHVuZGFudCBpdGVtcyBmcm9tIG1lbW9yeQ0Kcm0oYWxsX29hX3B1YnMpDQpnYygpDQoNCiMgYmF0Y2ggc2l6ZQ0KYmF0Y2hfc2l6ZSA8LSAxMDAwDQojIHZlY3RvciBvZiBpbmRpY2VzIHRvIGxvb3AgdGhyb3VnaA0KYmF0Y2hlcyA8LSBzZXEoZnJvbT0xLCB0bz1ucm93KHJlbGV2YW50X29hX3B1YnMpLCBieT1iYXRjaF9zaXplKQ0KIyB0byBiZSBhYmxlIHRvIHN1YnNldCwgYWxzbyBhZGQgdGhlIGZpbmFsIGluZGV4KzENCmJhdGNoZXMgPC0gYyhiYXRjaGVzLCBsZW5ndGgocmVsZXZhbnRfb2FfcHVicykrMSkNCg0KIyBwZXIgYmF0Y2gNCmZvciAoaSBpbiAxOmxlbmd0aChiYXRjaGVzKSl7DQogICMgZ2V0IHRoZSBsaXN0DQogIGJhdGNoX3B1YnMgPC0gcmVsZXZhbnRfb2FfcHVic1tiYXRjaGVzW2ldOihiYXRjaGVzW2krMV0tMSksXQ0KICANCiAgdHdlZXRfaW5mb19mdWxsIDwtIE5BDQogIA0KICAjIHRyeSBnZXR0aW5nIHRoZSB0d2VldCBpbmZvDQogIHRyeSh0d2VldF9pbmZvX2Z1bGwgPC0gYWx0bWV0cmljX3R3aXR0ZXJfcmV0cmlldmVyKHB1YmxpY2F0aW9uX2xpc3QgPSBiYXRjaF9wdWJzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleSA9IGFsdG1ldHJpY19hcGlfa2V5KSwNCiAgICAgIHNpbGVudCA9IFRSVUUpDQogIA0KICAjIGFuZCB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgIyBpZiBub3QgZW1wdHkNCiAgaWYgKCFhbGwoaXMubmEodHdlZXRfaW5mb19mdWxsKSkpew0KICAgICMgaWYgdGhlcmUgaXMgbm8gdGFibGUgeWV0LCB3cml0ZSBpdCBhcyBhIG5ldyB0YWJsZQ0KICAgIGlmICghIGRiRXhpc3RzVGFibGUoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfdHdpdHRlciIpKXsNCiAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICBkYldyaXRlVGFibGUoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfdHdpdHRlciIsIHR3ZWV0X2luZm9fZnVsbCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkgDQogICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgfWVsc2V7DQogICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfdHdpdHRlciIpDQogICAgICAjIGlmIG5lZWRlZCwgcGFkIHRoZSBkYXRhc2V0DQogICAgICBpZighYWxsKGZpZWxkcyAlaW4lIGNvbG5hbWVzKHR3ZWV0X2luZm9fZnVsbCkpKXsNCiAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyh0d2VldF9pbmZvX2Z1bGwpKQ0KICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXModHdlZXRfaW5mb19mdWxsKSldDQogICAgICAgIHR3ZWV0X2luZm9fZnVsbCA8LSBiaW5kX2NvbHModHdlZXRfaW5mb19mdWxsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgICB0d2VldF9pbmZvX2Z1bGwgPC0gdHdlZXRfaW5mb19mdWxsW2ZpZWxkc10NCiAgICAgIH0NCiAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiAgICAgIHR3ZWV0X2luZm9fZnVsbCA8LSAgdHdlZXRfaW5mb19mdWxsICU+JQ0KICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgImFsdG1ldHJpY19wdWJfYXR0X3R3aXR0ZXIiLCB0d2VldF9pbmZvX2Z1bGwsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkgDQogICAgfQ0KICB9DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKGJhdGNoZXMpLCBzZXAgPSAiICIpKQ0KfQ0KYGBgDQoNCg0KDQojIEdlbmRlciBkYXRhDQoNClNlZSBzY3JpcHQgIlByb2ZfZ2VuZGVyLlJtZCIuDQpgYGB7cn0NCnByb2ZzX2Z1bGxfZ2VuZGVyIDwtIHJlYWRSRFMoIn4vUG9zdGRvYy9Qcm9qZWN0cy9kdXRjaF9tZWRpYV9wcm9mc19yL3Byb2Nlc3NlZF9kYXRhL3Byb2ZzX2Z1bGxfZ2VuZGVyLlJEUyIpDQpkYldyaXRlVGFibGUoY29uLCAiZ2VuZGVyX3RhYmxlIiwgcHJvZnNfZnVsbF9nZW5kZXIsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KIyBHcmFudHMgTldPIGFuZCBFUkMNCg0KRmlyc3QsIGdldCB0aGUgZGF0YSBzY3JhcGVkIGZyb20gdGhlIE5XTyB1c2luZyB0aGUgcHl0aG9uIHNjcmlwdCBbcHVsbGluZy1ud28tZ3JhbnQtZGF0YS5pcHluYl0gYW5kDQpwYXJzZWQgdXNpbmcgdGhlIFtHcmFudF9wYXJzaW5nLlJtZF0gc2NyaXB0LiBUaGVuLCBhbHNvIGxvYWQgdGhlIE5XTyBncmFudCBpbmZvDQpmcm9tIE5BUkNJUzoNCmBgYHtyfQ0KIyBkYXRhIHNjcmFwZWQgZnJvbSB0aGUgTldPIHdlYnNpdGUNCm53b19ncmFudHMgPC0gcmVhZFJEUygifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcHJvY2Vzc2VkX2RhdGEvbndvX2dyYW50c19pbnRlcm1lZGlhdGUuUkRTIikNCg0KIyBkYXRhIGZyb20gTkFSQ0lTDQpsb2FkKCJ+L1Bvc3Rkb2MvUHJvamVjdHMvZHV0Y2hfbWVkaWFfcHJvZnNfci9yYXdfZGF0YS9tZWRpYV9wcm9mc19wcm9maWxlcy5yZGEiKQ0KIyBnZXQgdGhlIGNvbHVtbnMgb2YgaW50ZXJlc3QNCm53b19ncmFudHNfbmFyY2lzIDwtIG1ldGFkZltjKCJHcmFudHMvcHJpemVzIiwgIm5hcmNpc191cmwiKV0NCiMgc3BsaXQgdGhlIHRleHR1YWwgaW5mbw0KbndvX2dyYW50c19uYXJjaXNfbGlzdCA8LSBud29fZ3JhbnRzX25hcmNpcyAlPiUgDQogIHNlcGFyYXRlX3dpZGVyX2RlbGltKGNvbHMgPSBgR3JhbnRzL3ByaXplc2AsIA0KICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9ICI7IiwNCiAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMgPSBjKCJncmFudF8xIiwgImdyYW50XzIiLCAiZ3JhbnRfMyIsICJncmFudF80IiksDQogICAgICAgICAgICAgICAgICAgICAgIHRvb19mZXcgPSAiYWxpZ25fc3RhcnQiKQ0KDQojIGNvbnZlcnQgdG8gYSBsb25nIGRhdGFmcmFtZQ0KbndvX2dyYW50c19uYXJjaXNfbG9uZyA8LSBnYXRoZXIobndvX2dyYW50c19uYXJjaXNfbGlzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW50X3N0cmluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW50XzE6Z3JhbnRfNCklPiUNCiAgZmlsdGVyKCFpcy5uYShncmFudF9zdHJpbmcpKQ0KDQojIGV4dHJhY3QgdGhlIGdyYW50IG5hbWVzIGFuZCB5ZWFycw0KbndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudF9zdHJpbmdfMiA8LSBpZmVsc2Uoc3RyX2RldGVjdChud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZywgIlNwaW5vemEiKSA9PSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cl9zcGxpdF9pKG53b19ncmFudHNfbmFyY2lzX2xvbmckZ3JhbnRfc3RyaW5nLCAiLSIsIDIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyX3NwbGl0X2kobndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudF9zdHJpbmcsICIgLSAiLCAyKSkNCg0KbndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudF9zdHJpbmdfMiA8LSBzdHJfcmVtb3ZlKG53b19ncmFudHNfbmFyY2lzX2xvbmckZ3JhbnRfc3RyaW5nXzIsICJBd2FyZCIpDQpud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZ18yIDwtIHN0cl9zcXVpc2gobndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudF9zdHJpbmdfMikNCg0KbndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudCA8LSBzdHJfc3BsaXRfaShud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZ18yLCAiICIsIDEpDQpud29fZ3JhbnRzX25hcmNpc19sb25nJHllYXIgPC0gc3RyX3NwbGl0X2kobndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudF9zdHJpbmdfMiwgIiAiLCAyKQ0KbndvX2dyYW50c19uYXJjaXNfbG9uZyR5ZWFyIDwtIHN0cl9zcGxpdF9pKG53b19ncmFudHNfbmFyY2lzX2xvbmckeWVhciwgIi8iLCAxKQ0KDQoNCiMgZ2V0IHRoZSBmaW5hbCBkYXRhZnJhbWUNCm53b19ncmFudHNfbmFyY2lzIDwtIG53b19ncmFudHNfbmFyY2lzX2xvbmdbYygibmFyY2lzX3VybCIsICJncmFudCIsICJ5ZWFyIildDQpud29fZ3JhbnRzX25hcmNpcyRncmFudCA8LSB0b2xvd2VyKG53b19ncmFudHNfbmFyY2lzJGdyYW50KQ0KY29sbmFtZXMobndvX2dyYW50c19uYXJjaXMpWzFdIDwtICJwcm9maWxlX2lkIg0KYGBgDQoNCkNoZWNrIGlmIG91ciBOQVJDSVMgZGF0YSBtaXNzZWQgb3V0IG9uIGFueSBzY3JhcGVkIGluZm86DQpgYGB7cn0NCiMgZmlyc3QsIGdldCB0aGVtIGludG8gdGhlIHNhbWUgZm9ybWF0DQpud29fZ3JhbnRzX25hcmNpcyA8LSBud29fZ3JhbnRzX25hcmNpc1tjKGNvbG5hbWVzKG53b19ncmFudHMpKV0NCm53b19ncmFudHNfbmFyY2lzJHllYXIgPC0gYXMubnVtZXJpYyhud29fZ3JhbnRzX25hcmNpcyR5ZWFyKQ0KbndvX2dyYW50c19uYXJjaXMkcGVyc29uX2dyYW50IDwtIHBhc3RlKG53b19ncmFudHNfbmFyY2lzJHByb2ZpbGVfaWQsIG53b19ncmFudHNfbmFyY2lzJGdyYW50LCBzZXAgPSAiXyIpDQpud29fZ3JhbnRzJHBlcnNvbl9ncmFudCA8LSBwYXN0ZShud29fZ3JhbnRzJHByb2ZpbGVfaWQsIG53b19ncmFudHMkZ3JhbnQsIHNlcCA9ICJfIikNCg0KIyBnZXQgc29tZSBncmFudHMgd2Ugc2NyYXBlZCwgYnV0IHdlcmUgbm90IGluIHRoZSBOQVJDSVMgZGF0YSwgbW9zdCBmcm9tIDIwMjINCm53b19ncmFudHNfY2hlY2sgPC0gZmlsdGVyKG53b19ncmFudHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAhcGVyc29uX2dyYW50ICVpbiUgbndvX2dyYW50c19uYXJjaXMkcGVyc29uX2dyYW50KQ0KDQojIGFkZCB0aGVtIHRvIHRoZSBOQVJDSVMgZGF0YQ0KbndvX2dyYW50c19uYXJjaXMgPC0gcmJpbmQobndvX2dyYW50c19uYXJjaXMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBud29fZ3JhbnRzX2NoZWNrKQ0KDQpud29fZ3JhbnRzX25hcmNpcyA8LSBud29fZ3JhbnRzX25hcmNpc1tjKCJncmFudCIsICJ5ZWFyIiwgInByb2ZpbGVfaWQiKV0NCmBgYA0KDQpXcml0ZSBpbnRvIGEgZGF0YWJhc2U6DQpgYGB7cn0NCmRiV3JpdGVUYWJsZShjb24sICJuYXJjaXNfbndvX2dyYW50X2luZm8iLCBud29fZ3JhbnRzX25hcmNpcywgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkgDQpgYGANCg0KVGhpcyBtaXNzZXMgRVJDIGdyYW50cy4gTm93IGFsc28gZ2V0IHRoZSBFUkMgZ3JhbnRzIGJ5IGRvd25sb2FkaW5nIHRoZSBjc3YuIGZpbGUNCmxpc3RpbmcgYWxsIER1dGNoIGdyYW50cyBmcm9tIFtoZXJlXShodHRwczovL2VyYy5lYXNtZS13ZWIuZXU/bW9kZT03JmNvdW50cmllcz1OTCk6DQpgYGB7ciB3YXJuaW5nID0gRiwgbWVzc2FnZSA9IEZ9DQplcmNfZGF0YSA8LSByZWFkX2RlbGltKCJwcm9jZXNzZWRfZGF0YS9lcmNfZGF0YS5jc3YiLCANCiAgICBkZWxpbSA9ICI7IiwgZXNjYXBlX2RvdWJsZSA9IEZBTFNFLCB0cmltX3dzID0gVFJVRSkNCmBgYA0KDQpTZWUgaWYgd2UgY2FuIG1lcmdlIEVSQyBncmFudHMgd2l0aCBwcm9mZXNzb3IgbmFtZXMgaW4gb3VyIGRhdGE6DQpgYGB7cn0NCmVyY19kYXRhJFBJIDwtIHRvbG93ZXIoZXJjX2RhdGEkUEkpDQoNCnByb2ZzJFBJIDwtIHRvbG93ZXIocGFzdGUocHJvZnMkbGFzdCwgcHJvZnMkZmlyc3QpKQ0KDQplcmNfZGF0YV9tZXJnZSA8LSBtZXJnZShlcmNfZGF0YSwNCiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZzW2MoInByb2ZpbGVfaWQiLCAiUEkiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICBieSA9ICJQSSIpDQoNCiMgZXh0cmFjdCB0aGUgeWVhcg0KZXJjX2RhdGFfbWVyZ2UkeWVhciA8LSBwYXJzZV9udW1iZXIoZXJjX2RhdGFfbWVyZ2UkYENhbGwgSURgKQ0KZXJjX2RhdGFfbWVyZ2UkeWVhciA8LSBzdHJfcmVtb3ZlKGVyY19kYXRhX21lcmdlJHllYXIsICItIikNCg0KIyB0aWR5IHVwIHRoZSBjb2xuYW1lcw0KY29sbmFtZXMoZXJjX2RhdGFfbWVyZ2UpIDwtIHRvbG93ZXIoc3RyX3JlcGxhY2VfYWxsKGNvbG5hbWVzKGVyY19kYXRhX21lcmdlKSwgIiAiLCAiXyIpKQ0KDQojIHRpZHkgdXAgdGhlIGNpdHkgY29sdW1uDQplcmNfZGF0YV9tZXJnZSRjaXR5IDwtIHN0cl90b190aXRsZShlcmNfZGF0YV9tZXJnZSRjaXR5KQ0KYGBgDQoNCldyaXRlIGludG8gYSBkYXRhYmFzZToNCmBgYHtyfQ0KZGJXcml0ZVRhYmxlKGNvbiwgImVyY19ncmFudF9pbmZvIiwgZXJjX2RhdGFfbWVyZ2UsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpIA0KYGBgDQoNCg0KDQojIENvYXV0aG9yIGRhdGENCg0KIyMgT0EgY29hdXRob3IgcHVibGljYXRpb24gZGF0YQ0KDQpXZSBhbHNvIG5lZWQsIGZvciBlYWNoIHByb2Zlc3NvciwgdGhlIG1vcmUgZGV0YWlsZWQgZGF0YSBhYm91dCB0aGVpciBjby1hdXRob3JzLiANCg0KDQpGb3IgZWFjaCBwcm9mZXNzb3IsIHdlIHdpbGwgcXVlcnkgdGhlaXIgY29hdXRob3JzJyBkYXRhLg0KV2Ugb3V0cHV0IHRoZSBmb2xsb3dpbmc6DQoxLiBBIGZ1bGwgbGlzdCBvZiBhdXRob3IncyBPQSBkYXRhDQoyLiBBIGZ1bGwgbGlzdCBvZiBhdXRob3IncyBuYW1lcw0KMy4gQSBmdWxsIGxpc3Qgb2YgYXV0aG9yJ3MgeWVhcmx5IGF0dGVudGlvbiBmcm9tIEFsdG1ldHJpYw0KDQojIyBDb2F1dGhvciBPQSBkYXRhDQoNCkZpcnN0LCBnZXQgYWxsIHRoZSBjb2F1dGhvciB5ZWFybHkgT0Egc3RhdGlzdGljcyBhbmQgYSBmdWxsIGxpc3Qgb2YgbmFtZXM6DQpgYGB7cn0NCiMgZ2V0IGFsbCB0aGUgY29hdXRob3IgaW5mbw0KY29hdXRob3JfbGlzdCA8LSBkYkdldFF1ZXJ5KGNvbm4gPSBjb24sIHN0YXRlbWVudCA9IHBhc3RlMCgic2VsZWN0ICogZnJvbSBvYV9jb2F1dGhvcl9pbmZvOyIpKQ0KDQojZ2V0IHRoZSB1bmlxdWUgT0EgSURzIG9mIGNvYXV0aG9ycw0KY29hdXRob3Jfb2EgPC0gY29hdXRob3JfbGlzdCU+JSANCiAgZGlzdGluY3QoYXVfaWQpDQoNCmNvYXV0aG9yX29hIDwtIGNvYXV0aG9yX29hJGF1X2lkDQojIGRyb3AgcmVkdW5kYW50IGRhdGENCnJtKGNvYXV0aG9yX2xpc3QpDQpnYygpDQoNCiMgY29hdXRob3IgYWZmaWxpYXRpb24gZXRjIGxpc3QNCmNvYXV0aG9yX2luZm9fbGlzdCA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAxNCkpDQojIGtlZXAgYSBsaXN0IG9mIGNvLWF1dGhvciBuYW1lcyB3aXRoIGluZmVycmVkIGdlbmRlcnMgdGhhdCB3ZSBjYW4gY29tcGxlbWVudCBmdXJ0aGVyIGFuZCBmdXJ0aGVyDQojIGFzIHdlIGxvb3AgdGhyb3VnaCB0aGUgZGF0YQ0KY29hdXRob3JfbmFtZV9saXN0IDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDMpKQ0KDQpwcm9mX2JhdGNoX3NpemUgPC0gMTAwMA0KIyB2ZWN0b3Igb2YgaW5kaWNlcyB0byBsb29wIHRocm91Z2gNCmJhdGNoZXMgPC0gc2VxKGZyb209MSwgdG89bGVuZ3RoKGNvYXV0aG9yX29hKSwgYnk9cHJvZl9iYXRjaF9zaXplKQ0KIyB0byBiZSBhYmxlIHRvIHN1YnNldCwgYWxzbyBhZGQgdGhlIGZpbmFsIGluZGV4KzENCmJhdGNoZXMgPC0gYyhiYXRjaGVzLCBsZW5ndGgoY29hdXRob3Jfb2EpKzEpDQoNCg0KIyBxdWVyeSBhZGRpdGlvbmFsIHByb2YgaW5mbw0KZm9yKGkgaW4gMToobGVuZ3RoKGJhdGNoZXMpLTEpKXsNCiAgIyBnZXQgdGhlIG5hcmNpcyBpZHMgZnJvbSB0aGUgYmF0Y2gNCiAgcHJvZl9iYXRjaCA8LSBjb2F1dGhvcl9vYVtiYXRjaGVzW2ldOihiYXRjaGVzW2krMV0tMSldDQogIHByb2ZfY29hdXRob3JfaW5mb19vYSA8LSBOQQ0KICANCiAgdHJ5KHByb2ZfY29hdXRob3JfaW5mb19vYSA8LSBvYV9mZXRjaCgNCiAgICBlbnRpdHkgPSAiYXV0aG9ycyIsIA0KICAgIG9wZW5hbGV4X2lkID0gcHJvZl9iYXRjaCkpDQogIA0KICBpZiAoIWFsbChpcy5uYShwcm9mX2NvYXV0aG9yX2luZm9fb2EpKSl7DQogICAgDQogICAgIyB1bm5lc3QgdGhlIGRhdGEgDQogICAgcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCA8LSB1bm5lc3QocHJvZl9jb2F1dGhvcl9pbmZvX29hLCBjb2xzID0gYyhjb3VudHNfYnlfeWVhciksIG5hbWVzX3NlcCA9ICJfIiklPiUNCiAgICAgIHNlbGVjdCgteF9jb25jZXB0cykNCiAgICANCiAgICAjIGdldCB0aGVpciBuYW1lcw0KICAgICMgZmlyc3QsIGdldCBhbGwgdGhlIG5hbWUgYWx0ZXJuYXRpdmVzIGFzIHdlbGwNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMgPC0gcHJvZl9jb2F1dGhvcl9pbmZvX29hICU+JQ0KICAgICAgc2VsZWN0KGlkLCBkaXNwbGF5X25hbWUsIGRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMpJT4lDQogICAgICB1bm5lc3QoLiwgY29scyA9IGMoZGlzcGxheV9uYW1lX2FsdGVybmF0aXZlcykpDQogICAgIyB3aWRlIHRvIGxvbmcsIHdpdGggYWxsIHZhcmlhdGlvbnMNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMgPC0gZ2F0aGVyKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbF9uYW1lLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTpkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3Rvcl9rZXk9RkFMU0UpDQogICAgDQogICAgIyBub3csIGlkZW50aWZ5IHdoaWNoIG9uZXMgYXJlIGFjdHVhbHkgbmFtZXMsIGFuZCBub3QganVzdCBpbml0aWFscw0KICAgICMgZ2V0IHRoZSBmaXJzdCB3b3JkLCBhbmQgZGV0ZWN0IGlmIGxvbmdlciB0aGFuIDEgY2hhcmFjdGVyIGFuZC9vciBkb2VzIG5vdCBjb250YWluIGFueSBmdWxsIHN0b3BzDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZpcnN0IDwtIHdvcmQoY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZ1bGxfbmFtZSwgMSkNCiAgICBjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkdmFsaWRfbmFtZSA8LSBpZmVsc2Uoc3RyX2RldGVjdChjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMkZmlyc3QsICJcXC4iKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkZBTFNFIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlRSVUUiKQ0KICAgICMgZ2V0IHRoZSBuYW1lIHZhcmlhdGlvbiBsZW5ndGhzDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGxlbmd0aF9maXJzdCA8LSAgbmNoYXIoY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZpcnN0KSANCiAgICBjb2F1dGhvcl9uYW1lcyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAzKSkNCiAgICAjIGxlYXZlIG9ubHkgdGhlIG9uZXMgd2hlcmUgd2Ugc2VlbSB0byBoYXZlIGEgc2hvcnRlc3QgbmFtZSBsb25nZXIgdGhhbiAyIGNoYXJhY3RlcnMNCiAgICBjb2F1dGhvcl9uYW1lcyA8LSBmaWx0ZXIoY29hdXRob3JfbmFtZV92YXJpYXRpb25zLCB2YWxpZF9uYW1lID09IFRSVUUpJT4lDQogICAgICBncm91cF9ieShpZCklPiUNCiAgICAgIHNsaWNlKHdoaWNoLm1heChsZW5ndGhfZmlyc3QpKSU+JQ0KICAgICAgZmlsdGVyKC4sIGxlbmd0aF9maXJzdCA+IDIpJT4lDQogICAgICBzZWxlY3QoLXZhbGlkX25hbWUsIC1sZW5ndGhfZmlyc3QsIC10eXBlKQ0KICAgIA0KICAgICMgYXBwZW5kIHRoZSBuZXcgbmFtZXMgdG8gdGhlIG5hbWVzIGRhdGFmcmFtZQ0KICAgIGlmICghYWxsKGlzLm5hKGNvYXV0aG9yX25hbWVzKSkpew0KICAgICAgbmV3X25hbWVzIDwtIGZpbHRlcihjb2F1dGhvcl9uYW1lcywgDQogICAgICAgICAgICAgICAgICAgICAgICAgICEgaWQgJWluJSBjb2F1dGhvcl9uYW1lX2xpc3QkaWQpDQogICAgICBjb2F1dGhvcl9uYW1lX2xpc3QgPC0gcmJpbmQoY29hdXRob3JfbmFtZV9saXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19uYW1lcykNCiAgICB9DQogICAgDQogICAgIyBzZWxlY3QgcHJvZiBpbmZvDQogICAgY29hdXRob3JfaW5mbyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAxNCkpDQogICAgY29sdW1ucyA8LSBjKCJpZCIsICJkaXNwbGF5X25hbWUiLCAib3JjaWQiLCAid29ya3NfY291bnQiLA0KICAgICAgICAgICAgICAgICAiY2l0ZWRfYnlfY291bnQiLCAiY291bnRzX2J5X3llYXJfeWVhciIsICJjb3VudHNfYnlfeWVhcl93b3Jrc19jb3VudCIsIA0KICAgICAgICAgICAgICAgICAiY291bnRzX2J5X3llYXJfY2l0ZWRfYnlfY291bnQiLCAiYWZmaWxpYXRpb25fZGlzcGxheV9uYW1lIiwgDQogICAgICAgICAgICAgICAgICJhZmZpbGlhdGlvbl9pZCIsICJhZmZpbGlhdGlvbl9yb3IiLCAiYWZmaWxpYXRpb25fY291bnRyeV9jb2RlIiwNCiAgICAgICAgICAgICAgICAgImFmZmlsaWF0aW9uX3R5cGUiLCAid29ya3NfYXBpX3VybCIpDQogICAgIyBwYWRkaW5nIGluIGNhc2Ugc29tZSBjb2x1bW5zIGFyZSBtaXNzaW5nDQogICAgaWYoIWFsbChjb2x1bW5zICVpbiUgY29sbmFtZXMocHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCkpKXsNCiAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghY29sdW1ucyAlaW4lIGNvbG5hbWVzKHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QpKQ0KICAgICAgcGFkZGluZyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IGxlbmd0aChuX21pc3NpbmcpLCBucm93PTEpKQ0KICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gY29sdW1uc1t3aGljaCghY29sdW1ucyAlaW4lIGNvbG5hbWVzKHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QpKV0NCiAgICAgIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QgPC0gYmluZF9jb2xzKHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCA8LSBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0W2NvbHVtbnNdDQogICAgfQ0KICAgIA0KICAgIGNvYXV0aG9yX2luZm8gPC0gcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdCU+JQ0KICAgICAgc2VsZWN0KGlkLCBkaXNwbGF5X25hbWUsIG9yY2lkLCB3b3Jrc19jb3VudCwNCiAgICAgICAgICAgICBjaXRlZF9ieV9jb3VudCwgY291bnRzX2J5X3llYXJfeWVhciwgY291bnRzX2J5X3llYXJfd29ya3NfY291bnQsIA0KICAgICAgICAgICAgIGNvdW50c19ieV95ZWFyX2NpdGVkX2J5X2NvdW50LCBhZmZpbGlhdGlvbl9kaXNwbGF5X25hbWUsIA0KICAgICAgICAgICAgIGFmZmlsaWF0aW9uX2lkLCBhZmZpbGlhdGlvbl9yb3IsIGFmZmlsaWF0aW9uX2NvdW50cnlfY29kZSwNCiAgICAgICAgICAgICBhZmZpbGlhdGlvbl90eXBlLCB3b3Jrc19hcGlfdXJsKQ0KICAgIA0KICAgICMgYXBwZW5kIHRoZSBuZXcgaW5mbyB0byB0aGUgaW5mbyBkYXRhZnJhbWUNCiAgICBpZiAoIWFsbChpcy5uYShjb2F1dGhvcl9pbmZvKSkpew0KICAgICAgbmV3X2luZm8gPC0gZmlsdGVyKGNvYXV0aG9yX2luZm8sIA0KICAgICAgICAgICAgICAgICAgICAgICAgICEgaWQgJWluJSBjb2F1dGhvcl9pbmZvX2xpc3QkaWQpDQogICAgICANCiAgICAgIGNvYXV0aG9yX2luZm9fbGlzdCA8LSByYmluZChjb2F1dGhvcl9pbmZvX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2luZm8pDQogICAgfQ0KICB9DQogIA0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChiYXRjaGVzKSkpDQp9DQoNCmRiV3JpdGVUYWJsZShjb24sICJvYV9jb2F1dGhvcl9pbmZvX2Z1bGwiLCBjb2F1dGhvcl9pbmZvX2xpc3QsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQoNCmRiV3JpdGVUYWJsZShjb24sICJvYV9jb2F1dGhvcl9uYW1lX2xpc3QiLCBjb2F1dGhvcl9uYW1lX2xpc3QsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KV2UgaGF2ZSAxIDM3MSA4MTAgdW5pcXVlIGNvYXV0aG9ycyB3ZSBmZXRjaGVkIHRoZSBkYXRhIGZvciwgYW5kIDE3NyA4MjMgdW5pcXVlIGZpcnN0IG5hbWVzLiANCg0KV3JpdGUgb3V0IHVuaXF1ZSBjb21iaW5hdGlvbnMgb2YgcGFwZXJzLCBjb2F1dGhvcnMsIGFuZCBwcm9mZXNzb3JzOg0KYGBge3J9DQpvYV9jb2F1dGhvcl9tYXRjaGluZyA8LSBjb2F1dGhvcl9pbmZvX2xpc3QgJT4lIGRpc3RpbmN0KGlkLCBvYV9pZCwgcHJvZmlsZV9pZCwgLmtlZXBfYWxsID0gVFJVRSkNCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX2NvYXV0aG9yX21hdGNoaW5nIiwgb2FfY29hdXRob3JfbWF0Y2hpbmcsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KDQojIyBDb2F1dGhvciBBbHRtZXRyaWMgYXR0ZW50aW9uIChwZXIgT1JDSUQpDQoNClVzZSB0aGUgc2FtZSBjb2F1dGhvciBsaXN0LCBidXQgbm93IHRvIHB1bGwgdGhlIGF0dGVudGlvbiBkYXRhIGZyb20gQWx0bWV0cmljLg0KT25seSBwdWxsIHRoZSBkYXRhIGZvciB0aG9zZSBjb2F1dGhvcnMgd2hvDQpgYGB7cn0NCiMgZ2V0IHRoZSBjb2F1dGhvcnNoaXAgbGlzdA0KY29hdXRob3JfbGlzdCA8LSBkYlJlYWRUYWJsZShjb24sICJvYV9jb2F1dGhvcl9pbmZvIikNCg0KIyB1bmlxdWUgSURzDQpjb2F1dGhvcl9hbHRtZXRyaWNfbGlzdCA8LSBkaXN0aW5jdChjb2F1dGhvcl9saXN0LCBhdV9pZCwgLmtlZXBfYWxsID0gVFJVRSkNCiMgd2UgaGF2ZSAxIDM0NCA1MDggb2YgdGhlc2UNCmxlbmd0aCh1bmlxdWUoY29hdXRob3JfYWx0bWV0cmljX2xpc3QkYXVfaWQpKQ0KDQojIGxlYXZlIG9ubHkgdGhvc2Ugd2l0aCBPUkNJRCBJRHMNCmNvYXV0aG9yX2FsdG1ldHJpY19saXN0IDwtIGZpbHRlcihjb2F1dGhvcl9hbHRtZXRyaWNfbGlzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXMubmEoYXVfb3JjaWQpKQ0KDQojIHRoaXMgbGVhdmVzIHVzIHdpdGggb25seSA0NTcgMjAwIElEcw0KbGVuZ3RoKHVuaXF1ZShjb2F1dGhvcl9hbHRtZXRyaWNfbGlzdCRhdV9vcmNpZCkpDQoNCiMgZHJvcCByZWR1bmRhbnQgZGF0YQ0Kcm0oY29hdXRob3JfbGlzdCkNCmdjKCkNCmBgYA0KDQpMb29wIHRocm91Z2ggdGhlIE9SQ0lEcyBhbmQgZ2V0IGF1dGhvcnMnIGF0dGVudGlvbjoNCmBgYHtyIHdhcm5pbmcgPSBGLCBtZXNzYWdlID0gRn0NCmNvYXV0aG9yX2F0dGVudGlvbl9saXN0IDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDQpKQ0KY29sbmFtZXMoY29hdXRob3JfYXR0ZW50aW9uX2xpc3QpIDwtIGMoIm1lbnRpb25fdHlwZSIsICJ5ZWFyIiwgInllYXJseV9jb3VudCIsICJpZCIpDQoNCmZvciAoaSBpbiAxOm5yb3coY29hdXRob3JfYWx0bWV0cmljX2xpc3QpKXsNCiAgIyBub3Qgc3VyZSB0aGlzIGlzIGNvcnJlY3QhDQogIG9yY2lkIDwtIGNvYXV0aG9yX2FsdG1ldHJpY19saXN0JGF1X29yY2lkW2ldDQogIGNvYXV0aG9yX2F0dGVudGlvbiA8LSBOQQ0KICAjIHF1ZXJ5IHRoZSBpbmZvDQogIHRyeShjb2F1dGhvcl9hdHRlbnRpb24gPC0gYWx0bWV0cmljX2FwaV9vcmNpZF9jYWxsZXIob3JjaWQgPSBvcmNpZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlfc2VjcmV0ID0gYXBpX3NlY3JldCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlfa2V5ID0gYXBpX2tleSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9ICJhdHRlbnRpb24iKSkNCiAgDQogICMgaWYgYW55IGRhdGEsIHVubmVzdCB0d2ljZSB0byB1bnJhdmVsIHRoZSBpbmZvDQogIGlmICghYWxsKGlzLm5hKGNvYXV0aG9yX2F0dGVudGlvbikpKXsNCiAgICAjZGVkdXBsaWNhdGUNCiAgICBjb2F1dGhvcl9hdHRlbnRpb24gPC0gY29hdXRob3JfYXR0ZW50aW9uICU+JSBkaXN0aW5jdChpZCwgLmtlZXBfYWxsID0gIFRSVUUpDQogICAgY29hdXRob3JfYXR0ZW50aW9uIDwtIHVubmVzdChjb2F1dGhvcl9hdHRlbnRpb24sIGNvbHMgPSBjKCJtZXRhIikpDQogICAgY29hdXRob3JfYXR0ZW50aW9uIDwtIHVubmVzdChjb2F1dGhvcl9hdHRlbnRpb24sIGNvbHMgPSBjKCJkYXRlcyIpKQ0KICAgICMgbm93LCBleHRyYWN0IHRoZSB5ZWFyIGFuZCBncm91cCBtZW50aW9ucyBieSB5ZWFyDQogICAgY29hdXRob3JfYXR0ZW50aW9uJHllYXIgPC0geWVhcih5bWQoY29hdXRob3JfYXR0ZW50aW9uJGRhdGUpKQ0KICAgIGNvYXV0aG9yX2F0dGVudGlvbl95ZWFyIDwtIGNvYXV0aG9yX2F0dGVudGlvbiAlPiUNCiAgICAgIGdyb3VwX2J5KGlkLCB5ZWFyKSU+JQ0KICAgICAgc3VtbWFyaXNlKHllYXJseV9jb3VudCA9IHN1bShjb3VudCkpDQogICAgIyB0aWR5IHVwIHRoZSBjb2x1bW4gbmFtZXMNCiAgICBjb2xuYW1lcyhjb2F1dGhvcl9hdHRlbnRpb25feWVhcilbMV0gPC0gYygibWVudGlvbl90eXBlIikNCiAgICAjIGFkZCBpbiB0aGUgY29hdXRob3IgT0EgSUQNCiAgICBjb2F1dGhvcl9hdHRlbnRpb25feWVhciRpZCA8LSBjb2F1dGhvcl9hbHRtZXRyaWNfbGlzdCRhdV9pZFtpXQ0KICAgIA0KICAgIGlmIChucm93KGNvYXV0aG9yX2F0dGVudGlvbl95ZWFyKT4wKXsNCiAgICAgICMgZmlsdGVyIG91dCB0aGUgZHVwbGljYXRlcw0KICAgICAgY29hdXRob3JfYXR0ZW50aW9uX3llYXIgPC0gZmlsdGVyKGNvYXV0aG9yX2F0dGVudGlvbl95ZWFyLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhIGlkICVpbiUgY29hdXRob3JfYXR0ZW50aW9uX2xpc3QkaWQpDQogICAgICANCiAgICAgIGNvYXV0aG9yX2F0dGVudGlvbl9saXN0IDwtIHJiaW5kKGNvYXV0aG9yX2F0dGVudGlvbl9saXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29hdXRob3JfYXR0ZW50aW9uX3llYXIpDQogICAgfQ0KICB9DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbnJvdyhjb2F1dGhvcl9hbHRtZXRyaWNfbGlzdCkpKQ0KfQ0KDQpkYldyaXRlVGFibGUoY29uLCAiYWx0bWV0cmljX2NvYXV0aG9yX2F0dGVudGlvbiIsIGNvYXV0aG9yX2F0dGVudGlvbl9saXN0LCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KYGBgDQoNCg0KIyMgVG9waWNzIGZvciBlYWNoIHByb2Zlc3Nvcg0KDQpGaXJzdCwgZ2V0IGEgZGlzdGluY3QgcHVibGljYXRpb24gbGlzdDoNCmBgYHtyfQ0Kb2FfcHJvZl9wdWJzIDwtIGRiUmVhZFRhYmxlKGNvbiwgIm9hX3Byb2ZfcHVicyIpDQoNCm9hX2Rpc3RpbmN0X3B1YnMgPC0gb2FfcHJvZl9wdWJzJT4lDQogIGRpc3RpbmN0KC4sIGlkLCAua2VlcF9hbGwgPSBUUlVFKSU+JQ0KICAgIHNlbGVjdChpZDpkaXNwbGF5X25hbWUsIGFiOmlzX3JldHJhY3RlZCkNCg0Kb2FfcHJvZl9wdWJfbWF0Y2ggPC0gb2FfcHJvZl9wdWJzICU+JQ0KICBkaXN0aW5jdCguLCBpZCwgcHJvZmlsZV9pZCwgLmtlZXBfYWxsID0gVFJVRSklPiUNCiAgICBzZWxlY3QoaWQsIGF1X2lkLCBhdV9kaXNwbGF5X25hbWUsIG9hX2lkLCBwcm9maWxlX2lkKQ0KDQpkYldyaXRlVGFibGUoY29uLCAib2FfZGlzdGluY3RfcHVicyIsIG9hX2Rpc3RpbmN0X3B1YnMpDQpkYldyaXRlVGFibGUoY29uLCAib2FfcHJvZl9wdWJfbWF0Y2giLCBvYV9wcm9mX3B1Yl9tYXRjaCkNCmBgYA0KDQpHZXQgdGhlIHRvcGljcyBmb3IgZWFjaCBwdWJsaWNhdGlvbjoNCmBgYHtyfQ0KIyBiYXRjaCBzaXplDQpiYXRjaF9zaXplIDwtIDEwMA0KIyB2ZWN0b3Igb2YgaW5kaWNlcyB0byBsb29wIHRocm91Z2gNCmJhdGNoZXMgPC0gc2VxKGZyb209MSwgdG89bGVuZ3RoKG9hX2Rpc3RpbmN0X3B1YnMkaWQpLCBieT1iYXRjaF9zaXplKQ0KIyB0byBiZSBhYmxlIHRvIHN1YnNldCwgYWxzbyBhZGQgdGhlIGZpbmFsIGluZGV4KzENCmJhdGNoZXMgPC0gYyhiYXRjaGVzLCBsZW5ndGgob2FfZGlzdGluY3RfcHVicyRpZCkrMSkNCg0KIyBwZXIgYmF0Y2gNCmZvciAoaSBpbiAxOmxlbmd0aChiYXRjaGVzKSl7DQogICMgZ2V0IHRoZSBsaXN0DQogIGJhdGNoX2lkcyA8LSBvYV9kaXN0aW5jdF9wdWJzJGlkW2JhdGNoZXNbaV06KGJhdGNoZXNbaSsxXS0xKV0NCiAgYmF0Y2hfaWRzIDwtIHN0cl9yZW1vdmUoYmF0Y2hfaWRzLCAiaHR0cHNcXDpcXC9cXC9vcGVuYWxleC5vcmdcXC8iKQ0KICAjIGNvbGxhcHNlIHRoZW0gc28gdGhhdCB3ZSBjYW4gZmV0Y2ggYWxsIG9mIHRoZW0gYXQgb25jZSBmcm9tIHRoZSBBUEkNCiAgYmF0Y2hfaWRzIDwtIHBhc3RlKGJhdGNoX2lkcywgY29sbGFwc2UgPSAifCIpDQogIGdldF9hcGkgPC0gZnJvbUpTT04ocGFzdGUwKCJodHRwczovL2FwaS5vcGVuYWxleC5vcmcvd29ya3M/ZmlsdGVyPWlkcy5vcGVuYWxleDoiLCBiYXRjaF9pZHMsICImcGVyLXBhZ2U9MTAwIikpDQogIGlmICgndG9waWNzJyAlaW4lIG5hbWVzKGdldF9hcGlbWyJyZXN1bHRzIl1dKSl7DQogICAgcmVzdWx0X2lkcyA8LSBnZXRfYXBpW1sicmVzdWx0cyJdXVtbImlkIl1dDQogICAgdG9waWNzIDwtIGdldF9hcGlbWyJyZXN1bHRzIl1dW1sidG9waWNzIl1dDQogICAgaWYgKGxlbmd0aCh0b3BpY3MpID4gMCl7DQogICAgICB0b3BpY3NfZGYgPC0gYmluZF9yb3dzKHRvcGljcywgLmlkID0gImNvbHVtbl9sYWJlbCIpDQogICAgICB0b3BpY3NfZGYgPC0gdW5uZXN0KHRvcGljc19kZiwgY29scyA9IGMoc3ViZmllbGQsIGZpZWxkLCBkb21haW4pLCBuYW1lc19zZXAgPSAiXyIpDQogICAgICBjb2xuYW1lcyh0b3BpY3NfZGYpWzJdIDwtICJ0b3BpY19pZCINCiAgICAgIG9hX2lkX21hdGNoaW5nIDwtIGNiaW5kLmRhdGEuZnJhbWUoY29sdW1uX2xhYmVsID0gYygxOjEwMCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gZ2V0X2FwaVtbInJlc3VsdHMiXV1bWyJpZCJdXSkNCiAgICAgIA0KICAgICAgdG9waWNzX2RmIDwtIG1lcmdlKHRvcGljc19kZiwNCiAgICAgICAgICAgICAgICAgICAgICAgICBvYV9pZF9tYXRjaGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICBieSA9ICJjb2x1bW5fbGFiZWwiKQ0KICAgICAgDQogICAgICANCiAgICAgIGlmIChkYkV4aXN0c1RhYmxlKGNvbiwgIm9hX3B1YnNfdG9waWNzIikpew0KICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJvYV9wdWJzX3RvcGljcyIpDQogICAgICAgICMgaWYgbm90IGFsbCBmaWVsZHMgdGhlcmUNCiAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyh0b3BpY3NfZGYpKSl7DQogICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyh0b3BpY3NfZGYpKQ0KICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHRvcGljc19kZikpXQ0KICAgICAgICAgIHRvcGljc19kZiA8LSBiaW5kX2NvbHModG9waWNzX2RmLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICB0b3BpY3NfZGYgPC0gdG9waWNzX2RmW2ZpZWxkc10NCiAgICAgICAgfQ0KICAgICAgICAjIG9ubHkgbGVhdmUgdGhlc2UgZmllbGRzIGluDQogICAgICAgIHRvcGljc19kZiA8LSAgdG9waWNzX2RmICU+JQ0KICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiAgICAgICAgDQogICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAib2FfcHVic190b3BpY3MiLCB0b3BpY3NfZGYsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkNCiAgICAgIH1lbHNlew0KICAgICAgICBkYldyaXRlVGFibGUoY29uLCAib2FfcHVic190b3BpY3MiLCB0b3BpY3NfZGYsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQogICAgICB9DQogICAgfQ0KICB9DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKGJhdGNoZXMpKSkNCn0NCg0KIyANCiMgZm9yIChvYV9pZCBpbiBvYV9kaXN0aW5jdF9wdWJzJGlkKXsNCiMgICAjIGZldGNoIGZyb20gdGhlIG9mZmljaWFsIEFQSQ0KIyAgIGdldF9hcGkyIDwtIGZyb21KU09OKHBhc3RlKCJodHRwczovL2FwaS5vcGVuYWxleC5vcmcvIiwgc3RyX3JlbW92ZShvYV9pZCwgImh0dHBzXFw6XFwvXFwvb3BlbmFsZXgub3JnXFwvIiksICImcGVyLXBhZ2U9MTAwIiwgc2VwID0gIiIpKQ0KIyAgIGlmICgndG9waWNzJyAlaW4lIG5hbWVzKGdldF9hcGkpKXsNCiMgICAgIHRvcGljcyA8LSBnZXRfYXBpW1sndG9waWNzJ11dDQojICAgICBpZiAobGVuZ3RoKHRvcGljcykgPiAwKXsNCiMgICAgICAgdG9waWNzIDwtIHVubmVzdCh0b3BpY3MsIGNvbHMgPSBjKHN1YmZpZWxkLCBmaWVsZCwgZG9tYWluKSwgbmFtZXNfc2VwID0gIl8iKQ0KIyAgICAgICBjb2xuYW1lcyh0b3BpY3MpWzFdIDwtICJ0b3BpY19pZCINCiMgICAgICAgdG9waWNzJGlkIDwtIG9hX2lkDQojICAgICAgIA0KIyAgICAgICBpZiAoZGJFeGlzdHNUYWJsZShjb24sICJvYV9wdWJzX3RvcGljcyIpKXsNCiMgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiMgICAgICAgICBmaWVsZHMgPC0gZGJMaXN0RmllbGRzKGNvbiwgIm9hX3B1YnNfdG9waWNzIikNCiMgICAgICAgICAjIGlmIG5vdCBhbGwgZmllbGRzIHRoZXJlDQojICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyh0b3BpY3MpKSl7DQojICAgICAgICAgICBuX21pc3NpbmcgPC0gd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHRvcGljcykpDQojICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQojICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHRvcGljcykpXQ0KIyAgICAgICAgICAgdG9waWNzIDwtIGJpbmRfY29scyh0b3BpY3MsDQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQojICAgICAgICAgICB0b3BpY3MgPC0gdG9waWNzW2ZpZWxkc10NCiMgICAgICAgICB9DQojICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KIyAgICAgICAgIHRvcGljcyA8LSAgdG9waWNzICU+JQ0KIyAgICAgICAgICAgc2VsZWN0KGFsbF9vZihmaWVsZHMpKQ0KIyAgICAgICAgIA0KIyAgICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAib2FfcHVic190b3BpY3MiLCB0b3BpY3MsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkNCiMgICAgICAgfWVsc2V7DQojICAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3B1YnNfdG9waWNzIiwgdG9waWNzLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KIyAgICAgICB9DQojICAgICAgIHByaW50KHdoaWNoKG9hX2Rpc3RpbmN0X3B1YnMkaWQgPT0gb2FfaWQpKQ0KIyAgICAgfQ0KIyAgIH0NCiMgfQ0KYGBgDQoNCg0KDQojIyBJbnN0aXR1dGlvbmFsIGFmZmlsaWF0aW9ucw0KDQpMb2FkIHByb2Zlc3NvciBwdWJsaWNhdGlvbnM6DQpgYGB7cn0NCm9hX3B1YnNfdW5pcXVlIDwtIGRiUmVhZFRhYmxlKGNvbiwgIm9hX3Byb2ZfcHVic191bmlxdWUiKQ0Kb2FfcHJvZl9wdWJfbWF0Y2hpbmcgPC0gZGJSZWFkVGFibGUoY29uLCAib2FfcHJvZl9wdWJfbWF0Y2giKQ0KDQpvYV9pZHMgPC0gZGJSZWFkVGFibGUoY29uLCAib2FfaWRfbWFwcGluZyIpDQpgYGANCg0KRm9yIGVhY2ggcHJvZmVzc29yLCBjb25zdHJ1Y3QgYSBsaXN0IG9mIGFmZmlsaWF0aW9ucyB0aGV5J3ZlIGhhZDoNCmBgYHtyfQ0KbGlzdF9wcm9mcyA8LSB1bmlxdWUob2FfaWRzJG9hX2lkKQ0KYWxsX3Jlc3VsdHMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSA3LCBucm93ID0gMCkpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChsaXN0X3Byb2ZzKSl7DQogICMgZ2V0IHRoZSBsaXN0DQogIHByb2YgPC0gbGlzdF9wcm9mc1tpXQ0KICBnZXRfYXBpIDwtIGZyb21KU09OKHBhc3RlMCgiaHR0cHM6Ly9hcGkub3BlbmFsZXgub3JnL2F1dGhvcnM/ZmlsdGVyPWlkcy5vcGVuYWxleDoiLCBwcm9mKSkNCiAgDQogIGlmICgnYWZmaWxpYXRpb25zJyAlaW4lIG5hbWVzKGdldF9hcGlbWyJyZXN1bHRzIl1dKSl7DQogICAgcmVzdWx0X2luc3RpdHV0aW9ucyA8LSBnZXRfYXBpW1sicmVzdWx0cyJdXVtbImFmZmlsaWF0aW9ucyJdXVtbMV1dW1siaW5zdGl0dXRpb24iXV0NCiAgICBpZiAoIWFsbChpcy5uYShyZXN1bHRfaW5zdGl0dXRpb25zKSkpew0KICAgICAgcmVzdWx0X2luc3RpdHV0aW9ucyRhdV9pZCA8LSBwcm9mDQogICAgICBhbGxfcmVzdWx0cyA8LSByYmluZC5kYXRhLmZyYW1lKGFsbF9yZXN1bHRzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRfaW5zdGl0dXRpb25zKQ0KICAgIH0NCiAgfQ0KICBwcmludChpKQ0KfQ0KDQoNCmFsbF9yZXN1bHRzX3NlbCA8LSBhbGxfcmVzdWx0cyAlPiUNCiAgc2VsZWN0KC1saW5lYWdlKQ0KDQojIHdyaXRlIG91dCBhIHRhYmxlDQpkYldyaXRlVGFibGUoY29uLCAib2FfcHJvZl9hZmZpbGlhdGlvbnMiLCBhbGxfcmVzdWx0c19zZWwpDQpgYGANCg0KRm9yIGVhY2ggdW5pcXVlIGluc3RpdHV0aW9uLCBhbHNvIGdldCBhbHRlcm5hdGl2ZSBuYW1lczoNCmBgYHtyfQ0KdW5pcXVlX2luc3RpdHV0aW9ucyA8LSB1bmlxdWUoYWxsX3Jlc3VsdHNfc2VsJGlkKQ0KYWxsX2luc3RpdHV0aW9uX25hbWVzIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gMiwgbnJvdyA9IDApKQ0KDQpmb3IgKGluc3QgaW4gdW5pcXVlX2luc3RpdHV0aW9ucyl7DQogIGdldF9hcGkgPC0gZnJvbUpTT04ocGFzdGUwKCJodHRwczovL2FwaS5vcGVuYWxleC5vcmcvaW5zdGl0dXRpb25zP2ZpbHRlcj1pZHMub3BlbmFsZXg6IiwgaW5zdCkpDQogIGlmICgnZGlzcGxheV9uYW1lX2FsdGVybmF0aXZlcycgJWluJSBuYW1lcyhnZXRfYXBpW1sicmVzdWx0cyJdXSkpew0KICAgIGFsdF9uYW1lcyA8LSBnZXRfYXBpW1sicmVzdWx0cyJdXVtbImRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMiXV1bWzFdXQ0KICAgIG5hbWUgPC0gZ2V0X2FwaVtbInJlc3VsdHMiXV1bWyJkaXNwbGF5X25hbWUiXV0NCiAgICBpbnN0aXR1dGlvbl9uYW1lX2xpc3QgPC0gcGFzdGUoYyhuYW1lLGFsdF9uYW1lcyksIGNvbGxhcHNlID0gIiwgIikNCiAgICAjIGdldCBhIGxpc3QgZm9yIHN0cmluZyBtYXRjaGluZw0KICAgIGluc3RpdHV0aW9uX25hbWVfbGlzdF9zdHJfbWF0Y2ggPC0gYyhuYW1lLCBhbHRfbmFtZXMpDQogICAgaW5zdGl0dXRpb25fbmFtZV9saXN0X3N0cl9tYXRjaCA8LSBwYXN0ZTAocGFzdGUwKCJcXGIiLCBpbnN0aXR1dGlvbl9uYW1lX2xpc3Rfc3RyX21hdGNoKSwgIlxcYiIpDQogICAgaW5zdGl0dXRpb25fbmFtZV9saXN0X3N0cl9tYXRjaCA8LSBwYXN0ZShpbnN0aXR1dGlvbl9uYW1lX2xpc3Rfc3RyX21hdGNoLCBjb2xsYXBzZSA9ICJ8IikNCiAgICANCiAgICBpbnN0aXR1dGlvbl9vdXRwdXQgPC0gY2JpbmQuZGF0YS5mcmFtZShpZCA9IGluc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lcyA9IGluc3RpdHV0aW9uX25hbWVfbGlzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdfbWF0Y2hfbmFtZXMgPSBpbnN0aXR1dGlvbl9uYW1lX2xpc3Rfc3RyX21hdGNoKQ0KICAgIA0KICAgIGFsbF9pbnN0aXR1dGlvbl9uYW1lcyA8LSByYmluZC5kYXRhLmZyYW1lKGFsbF9pbnN0aXR1dGlvbl9uYW1lcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0aXR1dGlvbl9vdXRwdXQpDQogIH0NCiAgDQogIHByaW50KHdoaWNoKHVuaXF1ZV9pbnN0aXR1dGlvbnMgPT0gaW5zdCkpDQogIA0KfQ0KDQpkYldyaXRlVGFibGUoY29uLCAib2FfYWZmaWxpYXRpb25fZGlzcGxheV9uYW1lcyIsIGFsbF9pbnN0aXR1dGlvbl9uYW1lcykNCmBgYA0KDQpGb3IgZWFjaCBwcm9mZXNzb3IsIGNvbXBpbGUgYWxsIGluc3RpdHV0aW9ucyB0aGV5IGFyZSBhZmZpbGlhdGVkIHdpdGggaW50byBhIHNpbmdsZQ0KZmllbGQ6DQpgYGB7cn0NCmxpc3RfcHJvZnMgPC0gdW5pcXVlKHByb2ZzX2Z1bGwkcHJvZmlsZV9pZCkNCmFsbF9wcm9mX2luc3Rfc2VhcmNoIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gMiwgbnJvdyA9IDApKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgobGlzdF9wcm9mcykpew0KICAjIGdldCB0aGUgbGlzdA0KICBwcm9mIDwtIGxpc3RfcHJvZnNbaV0NCiAgDQogIHByb2Zfb2FfaWRzIDwtIGZpbHRlcihvYV9pZHMsIA0KICAgICAgICAgICAgICAgICAgIHByb2ZpbGVfaWQgPT0gcHJvZikNCiAgDQogIHJlbF9pbnN0IDwtIGZpbHRlcihhbGxfcmVzdWx0c19zZWwsDQogICAgICAgICAgICAgICAgICAgICBhdV9pZCAlaW4lIHByb2Zfb2FfaWRzJG9hX2lkKSU+JQ0KICAgIGRpc3RpbmN0KGlkLCAua2VlcF9hbGwgPSBUUlVFKQ0KICANCiAgaW5zdGl0dXRpb25fbmFtZXMgPC0gZmlsdGVyKGFsbF9pbnN0aXR1dGlvbl9uYW1lcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICVpbiUgcmVsX2luc3QkaWQpDQogIA0KICBpbnN0aXR1dGlvbl9uYW1lc19wcm9mIDwtIHBhc3RlKGluc3RpdHV0aW9uX25hbWVzJHN0cmluZ19tYXRjaF9uYW1lcywgY29sbGFwc2UgPSAifCIpDQogIA0KICBwcm9mX2luc3Rfc2VhcmNoIDwtIGNiaW5kLmRhdGEuZnJhbWUoYXVfaWQgPSBwcm9mLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ19tYXRjaF9uYW1lcyA9IGluc3RpdHV0aW9uX25hbWVzX3Byb2YpDQogIA0KICBhbGxfcHJvZl9pbnN0X3NlYXJjaCA8LSByYmluZC5kYXRhLmZyYW1lKGFsbF9wcm9mX2luc3Rfc2VhcmNoLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfaW5zdF9zZWFyY2gpDQogIA0KICBwcmludChpKQ0KfQ0KDQpkYldyaXRlVGFibGUoY29uLCAib2FfYWZmaWxpYXRpb25fc3RyaW5nX3NlYXJjaCIsIGFsbF9wcm9mX2luc3Rfc2VhcmNoKQ0KDQpgYGANCg0KIyBPUkNJRCBjYXJlZXIgZGF0YQ0KDQpXZSBub3cgY29sbGVjdCBwcm9mZXNzb3JzJyBlbXBsb3ltZW50IGhpc3RvcmllcyBmcm9tIHRoZSBPUkNJRCBBUEkuDQoNCk1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGdldCBhY2Nlc3MgdG8gdGhlIEFQSSB3aXRoaW4gUiBjYW4gYmUgZm91bmQgW2hlcmVdKGh0dHBzOi8vY2lha292eC5naXRodWIuaW8vcm9yY2lkLmh0bWwjcm9yY2lkKS4NCg0KRmlyc3QsIGdldCBhIGxpc3Qgb2YgYWxsIE9SQ0lEcyBpbiBvdXIgZGF0YXNldDoNCmBgYHtyfQ0KIyByZWFkIGluIG91ciBtYXBwaW5nDQpvcmNpZF90YWJsZSA8LSBkYlJlYWRUYWJsZShjb24sICJvcmNpZF9tYXBwaW5nIikNCg0KIyBnZXQgYSBsaXN0IG9mIE9SQ0lEcw0Kb3JjaWRfbGlzdCA8LSBzdHJfcmVtb3ZlKG9yY2lkX3RhYmxlJE9SQ0lELCAiaHR0cHM6Ly9vcmNpZC5vcmcvIikNCg0KIyBsb29wIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJldHJpZXZlIGVtcGxveW1lbnQgaGlzdG9yeSB3aGVyZXZlciBhdmFpbGFibGU6DQoNCmFsbF9vcmNpZF9lbXBsb3ltZW50IDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNiwgbnJvdyA9IDApKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgob3JjaWRfbGlzdCkpew0KICBwcm9mX29yY2lkIDwtIG9yY2lkX2xpc3RbaV0NCiAgDQogICNpZiBPUkNJRCBub3QgTkENCiAgaWYgKCFpcy5uYShwcm9mX29yY2lkKSl7DQogICAgZW1wbG95bWVudCA8LSBOQQ0KICAgICMgZ2V0IGVtcGxveW1lbnQgZGF0YQ0KICAgIHRyeShlbXBsb3ltZW50IDwtIG9yY2lkX2VtcGxveW1lbnRzKG9yY2lkID0gcHJvZl9vcmNpZCklPiUNCiAgICAgICAgICBtYXAoLiwgcGx1Y2ssICJhZmZpbGlhdGlvbi1ncm91cCIsICJzdW1tYXJpZXMiKSAlPiUgDQogICAgICAgICAgZmxhdHRlbl9kZnIoKSAlPiUNCiAgICAgICAgICBjbGVhbl9uYW1lcygpKQ0KICAgICMgaWYgdGhlcmUgaXMgYW55IGVtcGxveW1lbnQgZGF0YSAgDQogICAgaWYgKCFhbGwoaXMubmEoZW1wbG95bWVudCkpKXsNCiAgICAgIGlmKG5yb3coZW1wbG95bWVudCk+MCl7DQogICAgICAgICMgZmlsbCBpbiBtaXNzaW5nIGNvbHVtbnMNCiAgICAgICAgaWYgKCEiZW1wbG95bWVudF9zdW1tYXJ5X3N0YXJ0X2RhdGVfeWVhcl92YWx1ZSIgJWluJSBjb2xuYW1lcyhlbXBsb3ltZW50KSl7DQogICAgICAgICAgZW1wbG95bWVudCRlbXBsb3ltZW50X3N1bW1hcnlfc3RhcnRfZGF0ZV95ZWFyX3ZhbHVlIDwtIE5BDQogICAgICAgIH0NCiAgICAgICAgDQogICAgICAgICMgc2VsZWN0IHJlbGV2YW50IGNvbHVtbnMNCiAgICAgICAgZW1wbG95bWVudCA8LSBlbXBsb3ltZW50ICU+JQ0KICAgICAgICAgIHNlbGVjdChlbXBsb3ltZW50X3N1bW1hcnlfZGVwYXJ0bWVudF9uYW1lLCBlbXBsb3ltZW50X3N1bW1hcnlfcm9sZV90aXRsZSwNCiAgICAgICAgICAgICAgICAgZW1wbG95bWVudF9zdW1tYXJ5X3N0YXJ0X2RhdGVfeWVhcl92YWx1ZSwNCiAgICAgICAgICAgICAgICAgZW1wbG95bWVudF9zdW1tYXJ5X29yZ2FuaXphdGlvbl9uYW1lLCBlbXBsb3ltZW50X3N1bW1hcnlfb3JnYW5pemF0aW9uX2FkZHJlc3NfY291bnRyeSkNCiAgICAgICAgIyB0aWR5IHVwIHRoZSBkYXRhZnJhbWUNCiAgICAgICAgY29sbmFtZXMoZW1wbG95bWVudCkgPC0gYygiZGVwYXJ0bWVudCIsICJwb3NpdGlvbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXJ0IiwgIm9yZ2FuaXphdGlvbiIsICJjb3VudHJ5IikNCiAgICAgICAgIyBhZGQgdGhlIG9yY2lkIGJhY2sgaW4NCiAgICAgICAgZW1wbG95bWVudCRvcmNpZCA8LSBwcm9mX29yY2lkDQogICAgICAgICMgYXBwZW5kDQogICAgICAgIGFsbF9vcmNpZF9lbXBsb3ltZW50IDwtIHJiaW5kKGFsbF9vcmNpZF9lbXBsb3ltZW50LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbXBsb3ltZW50KQ0KICAgICAgfQ0KICAgIH0NCn0NCg0KICAjcHJpbnQoaSkNCiAgDQp9DQpgYGANCg0KQ2xlYW4gdGhpcyB1cCwgcmVtb3ZpbmcgcG9zaXRpb25zIHdlIGhhdmUgbm8gaW5mbyBvbiwgb3IgZG9uJ3Qga25vdyB0aGUgc3RhcnRpbmcgDQpkYXRlIG9mLCBmaWx0ZXJpbmcgb25seSB0aG9zZSB0aGF0IGNvbnRhaW4gInByb2Zlc3NvciIgb3IgImhvb2dsZXJhYXIiLCBhbmQgYXJlDQppbiB0aGUgTmV0aGVybGFuZHM6DQpgYGB7cn0NCmFsbF9vcmNpZF9lbXBsb3ltZW50X3RpZHkgPC0gYWxsX29yY2lkX2VtcGxveW1lbnQgJT4lDQogIGZpbHRlcighaXMubmEocG9zaXRpb24pICYgIWlzLm5hKHN0YXJ0KSAmICBjb3VudHJ5ID09ICJOTCIpDQoNCmFsbF9vcmNpZF9lbXBsb3ltZW50X3RpZHkkcG9zaXRpb24gPC0gdG9sb3dlcihhbGxfb3JjaWRfZW1wbG95bWVudF90aWR5JHBvc2l0aW9uKQ0KDQphbGxfb3JjaWRfZW1wbG95bWVudF90aWR5JHByb2YgPC0gc3RyX2RldGVjdChhbGxfb3JjaWRfZW1wbG95bWVudF90aWR5JHBvc2l0aW9uLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2Z8aG9vZyIpDQoNCmFsbF9vcmNpZF9lbXBsb3ltZW50X3RpZHkgPC0gYWxsX29yY2lkX2VtcGxveW1lbnRfdGlkeSAlPiUNCiAgZmlsdGVyKHByb2YgPT0gVFJVRSkNCg0KIyBhbmQgbm93IGVuc3VyZSB0aGV5IGRvbid0IGNvbnRhaW4gImFzc2lzdGFudCIgb3IgImFzc29jaWF0ZSINCmFsbF9vcmNpZF9lbXBsb3ltZW50X3RpZHkkYXNzdCA8LSBzdHJfZGV0ZWN0KGFsbF9vcmNpZF9lbXBsb3ltZW50X3RpZHkkcG9zaXRpb24sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXNzaXN0YW50fGFzc2lzdGVudHxhc3N0fGFzc29jaWF0ZXxhc3NvY3xhc2lzc3R8YXNpc3RhbnR8YXNzb2N8YXNzc29jaWF0ZXxhc3NvY2lhdGllfGFzc2l0YW50IikNCg0KYWxsX29yY2lkX2VtcGxveW1lbnRfdGlkeSA8LSBhbGxfb3JjaWRfZW1wbG95bWVudF90aWR5ICU+JQ0KICBmaWx0ZXIoYXNzdCA9PSBGQUxTRSkNCg0KIyBmb3IgZWFjaCBwcm9mIHdpdGggbXVsdGlwbGUsIGtlZXAgdGhlIGVhcmxpZXN0IGFwcG9pbnRtZW50DQpwcm9mX2VudHJ5IDwtIGFsbF9vcmNpZF9lbXBsb3ltZW50X3RpZHkgJT4lDQogIGdyb3VwX2J5KG9yY2lkKSU+JQ0KICBzbGljZSh3aGljaC5taW4oc3RhcnQpKSU+JQ0KICBzZWxlY3Qob3JjaWQsIHBvc2l0aW9uLCBvcmdhbml6YXRpb24sIGRlcGFydG1lbnQsIHN0YXJ0KQ0KDQoNCiMgbWVyZ2Ugd2l0aCBwcm9maWxlX2lkcw0KY29sbmFtZXMob3JjaWRfdGFibGUpWzJdIDwtICJvcmNpZCINCm9yY2lkX3RhYmxlJG9yY2lkIDwtIHN0cl9yZW1vdmUob3JjaWRfdGFibGUkb3JjaWQsICJodHRwczovL29yY2lkLm9yZy8iKQ0KcHJvZl9lbnRyeSA8LSBtZXJnZShwcm9mX2VudHJ5LA0KICAgICAgICAgICAgICAgICAgICBvcmNpZF90YWJsZSwNCiAgICAgICAgICAgICAgICAgICAgYnkgPSAib3JjaWQiKQ0KYGBgDQoNCldyaXRlIHRoaXMgb3V0IGludG8gb3VyIGRhdGFiYXNlOg0KYGBge3J9DQpkYldyaXRlVGFibGUoY29uLCAib3JjaWRfZW1wbG95bWVudF9lbnRyeSIsIHByb2ZfZW50cnkpDQpgYGANCg0KIyMgUG9zaXRpb25zIGluIHRoZSBnb3Zlcm5tZW50IGFuZCBhZHZpc29yeSBib2RpZXMNCg0KTG9hZCB0aGUgbWFudWFsbHkgY3VyYXRlZCBvdXRwdXQgb2YgdGhlIHB5dGhvbiBzY3JpcHQgdGhhdCB1c2VkIGluZm9ybWF0aW9uDQpmcm9tIHRoZSBEdXRjaCBnb3Zlcm5tZW50YWwgd2Vic2l0ZXMgYW5kIHRoZSBEdXRjaCBXaWtpcGVkaWEgdG8gZmluZCBwcm9mZXNzb3JzJw0Kcm9sZXMgd2l0aGluIHRoZSBnb3Zlcm5tZW50cyAoYXMgbWluaXN0ZXJzIG9yIHNlY3JldGFyaWVzLCBvciBhcyBnb3Zlcm5tZW50DQpmb3JtYXRldXJzKSBvciB0aGVpciByb2xlcyB3aXRoaW4gYWR2aXNvcnkgYm9kaWVzIHRvIHRoZSBnb3Zlcm5tZW50Lg0KVGhlbiBtYXRjaCB0aGVzZSBkYXRhIHRvIHRoZSBwcm9maWxlIElEcyBhbmQgc3RvcmUgaW4gb3VyIGRhdGFiYXNlLg0KYGBge3Igd2FybmluZyA9IEYsIG1lc3NhZ2UgPSBGfQ0KZ292dF9wb3NpdGlvbnMgPC0gcmVhZF9jc3YoIi4uL2R1dGNoX21lZGlhX3Byb2ZzX3B5dGhvbi9vdXRwdXQtZGF0YS9nb3Z0X2xpc3RfbWFudWFsLmNzdiIpDQppbmZvX3Bvc2l0aW9ucyA8LSByZWFkX2NzdigiLi4vZHV0Y2hfbWVkaWFfcHJvZnNfcHl0aG9uL291dHB1dC1kYXRhL2luZm9fbGlzdF9tYW51YWwuY3N2IikNCmFkdmlzb3J5X3Bvc2l0aW9ucyA8LSByZWFkX2NzdigiLi4vZHV0Y2hfbWVkaWFfcHJvZnNfcHl0aG9uL291dHB1dC1kYXRhL2Fkdmlzb3J5X2xpc3RfbWFudWFsLmNzdiIpDQpgYGANCg0KRmlyc3QsIGZvciBnb3Zlcm5tZW50YWwgYW5kIGFkdmlzb3J5IHBvc2l0aW9ucywgZW5zdXJlIHRoYXQgd2UgaGF2ZSBpbmRpdmlkdWFsIHJvd3MNCmZvciBlYWNoIHllYXIgYSBwcm9mZXNzb3IgaGVsZCBhIHBvc2l0aW9uIChyYXRoZXIgdGhhbiBhICJzdGFydC1lbmQiIGZvcm1hdCk6DQpgYGB7cn0NCmdvdnRfcG9zaXRpb25zX2xvbmcgPC0gZ292dF9wb3NpdGlvbnMNCmNvbG5hbWVzKGdvdnRfcG9zaXRpb25zX2xvbmcpWzRdIDwtICJ0aW1lc3BhbiINCmdvdnRfcG9zaXRpb25zX2xvbmckc3RhcnQgPC0gc3RyX3NwbGl0X2koZ292dF9wb3NpdGlvbnNfbG9uZyR0aW1lc3BhbiwgIi0iLCAxKQ0KZ292dF9wb3NpdGlvbnNfbG9uZyRlbmQgPC0gc3RyX3NwbGl0X2koZ292dF9wb3NpdGlvbnNfbG9uZyR0aW1lc3BhbiwgIi0iLCAyKQ0KDQpnb3Z0X3Bvc2l0aW9uc19sb25nIDwtIGdvdnRfcG9zaXRpb25zX2xvbmcgJT4lDQogIG11dGF0ZSh5ZWFyID0gbWFwMihzdGFydCwgZW5kLCBzZXEpKSAlPiUNCiAgdW5uZXN0KHllYXIpICU+JQ0KICAjIyBkZWFsIHdpdGggb3ZlcmxhcHMgYnkga2VlcGluZyB0aGUgbWF4IHN0YXJ0IGFnZToNCiAgZ3JvdXBfYnkobmFtZSwgeWVhcikgJT4lDQogIHNsaWNlX21heChzdGFydCkgJT4lDQogIHVuZ3JvdXAgJT4lDQogIHNlbGVjdChuYW1lLCBwb3N0LCB5ZWFyKQ0KDQojIGFkZCBzb21lIG1vcmUgdmFyaWFibGVzDQpnb3Z0X3Bvc2l0aW9uc19sb25nJHJhYWQgPC0gIkdvdmVybm1lbnQiDQpnb3Z0X3Bvc2l0aW9uc19sb25nJHJhYWRfYWJ2IDwtICJHVlQiDQoNCmdvdnRfcG9zaXRpb25zX2xvbmcgPC0gZ292dF9wb3NpdGlvbnNfbG9uZyAlPiUNCiAgc2VsZWN0KG5hbWUsIHBvc3QsIHJhYWQsIHJhYWRfYWJ2LCB5ZWFyKQ0KDQphZHZpc29yeV9wb3NpdGlvbnNfbG9uZyA8LSBhZHZpc29yeV9wb3NpdGlvbnMNCmNvbG5hbWVzKGFkdmlzb3J5X3Bvc2l0aW9uc19sb25nKVs1XSA8LSAidGltZXNwYW4iDQphZHZpc29yeV9wb3NpdGlvbnNfbG9uZyRzdGFydCA8LSBzdHJfc3BsaXRfaShhZHZpc29yeV9wb3NpdGlvbnNfbG9uZyR0aW1lc3BhbiwgIi0iLCAxKQ0KYWR2aXNvcnlfcG9zaXRpb25zX2xvbmckZW5kIDwtIHN0cl9zcGxpdF9pKGFkdmlzb3J5X3Bvc2l0aW9uc19sb25nJHRpbWVzcGFuLCAiLSIsIDIpDQphZHZpc29yeV9wb3NpdGlvbnNfbG9uZyRlbmRbd2hpY2goaXMubmEoYWR2aXNvcnlfcG9zaXRpb25zX2xvbmckZW5kKSldIDwtIGFkdmlzb3J5X3Bvc2l0aW9uc19sb25nJHN0YXJ0W3doaWNoKGlzLm5hKGFkdmlzb3J5X3Bvc2l0aW9uc19sb25nJGVuZCkpXQ0KDQojIGZvciBhZHZpc29yeSwgbGVhdmUgcG9zaXRpb25zIHRoYXQgYXJlIG5vdCBhIG1lcmUgInJhYWRzbGlkIg0KYWR2aXNvcnlfcG9zaXRpb25zX2xvbmcgPC0gYWR2aXNvcnlfcG9zaXRpb25zX2xvbmcgJT4lDQogIG11dGF0ZSh5ZWFyID0gbWFwMihzdGFydCwgZW5kLCBzZXEpKSAlPiUNCiAgdW5uZXN0KHllYXIpICU+JQ0KICAjIyBkZWFsIHdpdGggb3ZlcmxhcHMgYnkga2VlcGluZyB0aGUgbWF4IHN0YXJ0IGFnZToNCiAgZ3JvdXBfYnkocGVyc29uLCB5ZWFyKSAlPiUNCiAgc2xpY2VfbWF4KHN0YXJ0KSAlPiUNCiAgdW5ncm91cCAlPiUNCiAgc2VsZWN0KHBlcnNvbiwgcG9zdCwgcmFhZCwgcmFhZF9hYnYsIHllYXIpJT4lDQogIGZpbHRlcihwb3N0ICE9ICJSYWFkc2xpZCIpDQoNCmNvbG5hbWVzKGFkdmlzb3J5X3Bvc2l0aW9uc19sb25nKVsxXSA8LSAibmFtZSINCg0KIyBmb3IgKGluKWZvcm1hdGV1cnMsIHRpZHkgdGhlIGRhdGEgdXAgYSBiaXQNCmluZm9fcG9zaXRpb25zJHJhYWQgPC0gIkdvdmVybm1lbnQiDQppbmZvX3Bvc2l0aW9ucyRyYWFkX2FidiA8LSAiR1ZUIg0KaW5mb19wb3NpdGlvbnNfbG9uZyA8LSBpbmZvX3Bvc2l0aW9ucyAlPiUNCiAgc2VsZWN0KG5hbWUsIHBvc3QsIHJhYWQsIHJhYWRfYWJ2LCB5ZWFyKQ0KYGBgDQoNCkNvbWJpbmUgdGhlIHRocmVlIHNvdXJjZXM6DQpgYGB7cn0NCmFsbF9nb3Z0X3Bvc2l0aW9ucyA8LSByYmluZChnb3Z0X3Bvc2l0aW9uc19sb25nLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9fcG9zaXRpb25zX2xvbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2aXNvcnlfcG9zaXRpb25zX2xvbmcpDQoNCmNvbG5hbWVzKGFsbF9nb3Z0X3Bvc2l0aW9ucykgPC0gYygibmFtZSIsICJwb3NpdGlvbiIsICJpbnN0aXR1dGlvbiIsICJpbnN0aXR1dGlvbl9hYnYiLCAieWVhciIpDQpgYGANCg0KTWF0Y2ggdGhlIHBlb3BsZSB3aXRoIHRoZWlyIHByb2ZpbGUgaWRzOg0KYGBge3J9DQpwcm9mX25hbWVfbWF0Y2ggPC0gcHJvZnNfZnVsbFtjKCJwcm9maWxlX2lkIiwgImZpcnN0IiwgImxhc3QiKV0NCnByb2ZfbmFtZV9tYXRjaCRuYW1lIDwtIHBhc3RlKHByb2ZfbmFtZV9tYXRjaCRmaXJzdCwgcHJvZl9uYW1lX21hdGNoJGxhc3QpDQoNCmFsbF9nb3Z0X3Bvc2l0aW9uc19tYXRjaCA8LSBtZXJnZShhbGxfZ292dF9wb3NpdGlvbnMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9uYW1lX21hdGNoW2MoInByb2ZpbGVfaWQiLCAibmFtZSIpXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9ICJuYW1lIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueCA9IFRSVUUpDQoNCiMgbWF0Y2ggbWlzc2luZyBmb3IgYmFsa2VuZW5kZSwgc28gZmlsbCBpdCAgaW4gYnkgaGFuZA0KYWxsX2dvdnRfcG9zaXRpb25zX21hdGNoJHByb2ZpbGVfaWRbd2hpY2goaXMubmEoYWxsX2dvdnRfcG9zaXRpb25zX21hdGNoJHByb2ZpbGVfaWQpKV0gPC0gImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzODYyOCINCmBgYA0KDQpXcml0ZSB0aGlzIG91dDoNCmBgYHtyfQ0KZGJXcml0ZVRhYmxlKGNvbiwgImdvdnRfcG9zaXRpb25zIiwgYWxsX2dvdnRfcG9zaXRpb25zX21hdGNoKQ0KYGBgDQoNCg==</div>
=======
<div id="rmd-source-code">LS0tDQp0aXRsZTogIk9wZW5BbGV4X0FsdG1ldHJpY19kYXRhX2Rvd25sb2FkIg0KYXV0aG9yOiAiQW5hIE1hY2Fub3ZpYyINCmRhdGU6ICIyMDI0LTAxLTA2Ig0KLS0tDQoNClRoaXMgc2NyaXB0IHVzZXMgT3BlbkFsZXggYW5kIEFsdG1ldHJpYyBkYXRhYmFzZXMgIHRvIGRvd25sb2FkIGRhdGEgb24gcHJvZmVzc29ycyBpbiBvdXIgc2FtcGxlLg0KDQpgYGB7ciBpbmNsdWRlPUZBTFNFfQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGVjaG8gPSBUUlVFKQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGV2YWwgPSBGQUxTRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldCh3YXJuaW5nID0gRkFMU0UpDQprbml0cjo6b3B0c19jaHVuayRzZXQobWVzc2FnZSA9IEZBTFNFKQ0KYGBgDQoNCkxvYWQgdGhlIG5lY2Vzc2FyeSBwYWNrYWdlczoNCmBgYHtyIG1lc3NhZ2U9ICBGLCB3YXJuaW5nID0gRiwgZXZhbCA9IFR9DQpsaWJyYXJ5KGdyb3VuZGhvZykNCnBhY2thZ2VzX3RvX2xvYWQgPC0gYygicmVhZHIiLCAiZHBseXIiLCAib3BlbmFsZXhSIiwNCiAgICAgICAgICAgICAgICAgICAgICAiZ2dwbG90MiIsICJzdHJpbmdyIiwgInRpZHlyIiwNCiAgICAgICAgICAgICAgICAgICAgICAianNvbmxpdGUiLCAieG1sMiIsICJ0aWR5dmVyc2UiLA0KICAgICAgICAgICAgICAgICAgICAgICJSUG9zdGdyZXMiLCAibHVicmlkYXRlIiwiZGlnZXN0IiwNCiAgICAgICAgICAgICAgICAgICAgICAiREJJIiwgIlJPREJDIiwgIm9kYmMiKQ0KZ3JvdW5kaG9nLmxpYnJhcnkocGFja2FnZXNfdG9fbG9hZCwgZGF0ZSA9ICIyMDIzLTEyLTAxIikNCg0KIyB3ZSd2ZSBhbHNvIGFkZGVkIG91ciBlbWFpbCB0byB0aGUgInBvbGl0ZSBwb29sIiBvZiBPcGVuQWxleCBieQ0KIyBhZGRpbmcgYSBsaW5lIGluIHRoZSAuUnByb2ZpbGUNCg0KIyBsb2FkIHRoZSBoZWxwZXIgZnVuY3Rpb24gZmlsZQ0Kc291cmNlKCJoZWxwZXJfZnVuY3Rpb25zLlIiKQ0KYGBgDQoNCkNvbm5lY3QgdG8gb3VyIGRhdGFiYXNlOg0KYGBge3J9DQpwb3J0IDwtIA0KdXNlciA8LSAiIg0KcGFzc3dvcmQgPC0gIiINCmRhdGFiYXNlX25hbWUgPC0gIiINCg0KY29uIDwtIFJQb3N0Z3Jlczo6ZGJDb25uZWN0KFJQb3N0Z3Jlczo6UG9zdGdyZXMoKSwNCiAgICAgICAgICAgICAgICAgZGJuYW1lPSBkYXRhYmFzZV9uYW1lLA0KICAgICAgICAgICAgICAgICBwb3J0ID0gcG9ydCwNCiAgICAgICAgICAgICAgICAgdXNlciA9IHVzZXIsIA0KICAgICAgICAgICAgICAgICBwYXNzd29yZCA9IHBhc3N3b3JkKQ0KDQpjb24gIyBDaGVja3MgY29ubmVjdGlvbiBpcyB3b3JraW5nDQpgYGANCg0KDQojIFRpZHkgdXAgcHJvZmVzc29yIGRhdGEgZnJvbSBOQVJDSVMNCg0KTG9hZCB0aGUgcHJvZmVzc29yIHByb2ZpbGVzOg0KYGBge3IgbWVzc2FnZSA9IEYsIHdhcm5pbmcgPSBGfQ0KbG9hZCgicmF3X2RhdGEvbWVkaWFfcHJvZnNfcHJvZmlsZXMucmRhIikNCnByb2ZzIDwtIHJlYWRfY3N2KCJyYXdfZGF0YS9kdXRjaF9wcm9mc191cmxzLmNzdiIpDQoNCiMgbWVyZ2UgdGhlIHByb2ZzIHdpdGggdGhlaXIgT1JDSURzDQpjb2xuYW1lcyhwcm9mcylbYygxLDcpXSA8LSBjKCJpZCIsICJwcm9maWxlX2lkIikNCg0KcHJvZnNfZnVsbCA8LSBtZXJnZShwcm9mcywNCiAgICAgICAgICAgICAgICAgICAgbWV0YWRmWywgYygxOjQsIDM2MSldLA0KICAgICAgICAgICAgICAgICAgICBieSA9ICJwcm9maWxlX2lkIikNCg0KIyBXcml0ZSB0aGlzIG91dCBpbnRvIG91ciBEQg0KI2RiV3JpdGVUYWJsZShjb24sICJuYXJjaXNfcHJvZl9pbmZvIiwgcHJvZnNfZnVsbCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQpDaGVjayBmb3IgcHJvZmVzc29ycyB3aXRoIGR1cGxpY2F0ZSBuYW1lczoNCmBgYHtyfQ0KcHJvZnNfZnVsbF9kdXBsIDwtIHByb2ZzX2Z1bGwNCnByb2ZzX2Z1bGxfZHVwbCRkdXBsIDwtIGR1cGxpY2F0ZWQocHJvZnNfZnVsbF9kdXBsJGZ1bGwpDQpkdXBsX25hbWVzIDwtIGZpbHRlcihwcm9mc19mdWxsX2R1cGwsIGR1cGwgPT0gVFJVRSkkZnVsbA0KDQoNCnByb2ZzX2R1cGxpY2F0ZXMgPC0gZmlsdGVyKHByb2ZzX2Z1bGxfZHVwbCwgZnVsbCAlaW4lIGR1cGxfbmFtZXMpDQpgYGANCg0KDQojIFRpZHkgdXAgdGhlIHB1YmxpY2F0aW9uIGRhdGEgZnJvbSBOQVJDSVMNCkxvYWQgdGhlIHB1YmxpY2F0aW9uIGRhdGE6DQpgYGB7cn0NCiMgZmV0Y2ggdGhlIHBhcGVycw0KbG9hZCgifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcmF3X2RhdGEvbWVkaWFfcHJvZnNfcHVicy5yZGEiKQ0KIyBtYXRjaCB0aGUgcHVibGljYXRpb24gZGF0YSB0byBhdXRob3JzaGlwcw0KbG9hZCgifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcmF3X2RhdGEvbWVkaWFfcHJvZnNfcHViX3RvX3Byb2ZpbGVfaWRzLnJkYSIpDQpjb2xuYW1lcyhwdWJfdG9fcHJvZmlsZV9pZClbMV0gPC0gIm5hcmNpc191cmwiDQoNCnByb2ZfcHVic19mdWxsIDwtIG1lcmdlKHB1YnNfbWV0YWRmWywgYygxOjIzKV0sDQogICAgICAgICAgICAgICAgICAgICAgICBwdWJfdG9fcHJvZmlsZV9pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gIm5hcmNpc191cmwiKQ0KIyBzdHJpcCB0aGUgbGFzdCAvIGZyb20gdGhlIHByb2ZpbGUgaWRzIGhlcmUNCnByb2ZfcHVic19mdWxsJHByb2ZpbGVfaWQgPC0gc3RyX3N1Yihwcm9mX3B1YnNfZnVsbCRwcm9maWxlX2lkLCBlbmQgPSAtMikNCg0KIyB0aWR5IHVwIHNvbWUgbWlzYmVoYXZpbmcgRE9Jcw0KcHJvZl9wdWJzX2Z1bGwkbl93b3JkcyA8LSBzdHJfY291bnQocHJvZl9wdWJzX2Z1bGwkRE9JLCAiICIpDQoNCiMgbGV0J3MgbWFudWFsbHkgZml4IHRoZW0gc2luY2UgdGhlcmUgYXJlIHNvIGZldyBwcm9ibGVtYXRpYyBvbmVzDQpwdWJzX2RvaV93b3JkcyA8LSBmaWx0ZXIocHJvZl9wdWJzX2Z1bGwsIG5fd29yZHMgPiAwKQ0KIyB0aGVzZSBhcmUganVzdCB0aGUgRE9JcyB3aGVyZSB3ZSBoYXZlIG1hbnVhbGx5IHJlbW92ZWQgdGhlIHNwYWNlcyBvciByZWR1bmRhbnQgdGV4dA0KcHVic19kb2lfd29yZHMkRE9JIDwtIGMoIjEwLjEwMTYvai5qaHlkcm9sLjIwMTEuMDMuMDQ3IiwgIjEwLjExMTEvai4xMzY1LTMwOTEuMjAxMi4wMTM2NS54IiwgICANCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTEyMC9qYWNtcC52MTdpNC42MTE3IiwgIjEwLjIyMjAzL2VjbS52MDMyYTExIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4yMjIwMy9lY20udjAzMmExMSIsICIxMC4xMTY3L2lvdnMuMTYtMjA3OTkiLCAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMzYvYm1qc2VtLTIwMTgtMDAwNDI3IiwgIjEwLjExMTEvaGFlLjEyMzUzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTEyOC9pYWkuNjQuMTAuNDIyMC00MjI1LjE5OTYiLCAiMTAuMTAzOS9iMzAyMDk3ZSIsICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDM5L2IzMDIwOTdlIiwgIjEwLjEwMTYvczAwMTYtNTA4NSgxOSkzODA1Mi03IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTAzOS9iMjA5Mzc4YiIsICIxMC4zODUwLzk3OC05ODEtMDctMjYxNS03LTI5MCIsICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0wNy0yNjE1LTcgMjg5IiwgIjEwLjEwMTYvczAwNDAtNjA5MCg5NikwOTI0OC02IiwgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjEwNjEoYXNjZSltdC4xOTQzLTU1MzMuMDAwMjE2OSIsICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMDU5NjAwIiwgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMDU5NjAwIiwgIjEwLjEzNzEvam91cm5hbC5wb25lLjAwNTk2MDAiLCAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTEwOS9pc2JpLjIwMTYuNzQ5MzUzMiIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTEwOS9pc2JpLjIwMTYuNzQ5MzUzMiIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTA4MC8wMzc5NzcyMDEyMDA4MjY1MSIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0xMS0yNzI0LTNfMDY0MS1jZCIsICIxMC4zODUwLzk3OC05ODEtMTEtMjcyNC0zXzA2NDEtY2QiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wNTk2LWNkIiwgIjEwLjExMzYvYm1qb3Blbi0yMDE3LTAxNjA3NyIsICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMTAzL3BoeXNyZXZsZXR0LjExNS4xNTk5MDEiLCAiMTAuMTUxNS9saW5ndmFuLTIwMTYtMDA0OCIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDgvamZyYy0wNy0yMDE4LTAxMDMiLCAiMTAuMTA5Ny8wMS5icnMuMDAwMDIwNjM4MS4xNTIyNC4wIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTA4MC8yMTUwNzc0MC4yMDE2LjEyNTE5OTAiLCAiMTAuMTAyMS9pZTA0OTI0NDkgczA4ODgtNTg4NSgwNCkwOTI0NC05IiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDIxL2llMDQ5MjQ0OSBzMDg4OC01ODg1KDA0KTA5MjQ0LTkiLCAiMTAuMjQ3OC92MTAzMDQtMDEyLTAwMTEteSIsICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjEwMDcvczEwODUzLTAxMS01NjgyLTYiLCAiMTAuMTAyMS9qYTA0NTU2NTBzMDAwMi03ODYzKDA0KTA1NTY1LTkiLCAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDIxL2pvMDQwMTIyMC1zMDAyMi0zMjYzKDA0KTAwMTIyLTciLCIxMC4xMDA3L3MxMDEwMy0wMDgtMDYyNi0zIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMjE2NzQzIiwgIjEwLjExNzcvMDAyMTg4NjMxNjY3MjcyNCIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjUxOTQvc2UtMTAtNTE3LTIwMTkiLCAiMTAuMTg2OTAvOTc4LTk2MS0yODYtMDYxLTUuMyIsICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjE4NjkwLzk3OC05NjEtMjg2LTA2MS01LjMiLCAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wNDQxLWNkIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0xMS0yNzI1LTAtaXMzLTUtY2QiLCAiMTAuMzM5MC9hdG1vczEyMTIxNjMzIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4zODUwLzk3OC05ODEtMTQtODU5My0wLTQxMzktY2QiLCAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wMjQ4LWNkIikgDQojIGZpeCB0aGUgcHViIGxpc3QNCiMgZmlsdGVyIG91dCB0aGUgcHJvYmxlbWF0aWMgZG9pcw0KcHJvZl9wdWJzX2Z1bGxfZml4IDwtIGZpbHRlcihwcm9mX3B1YnNfZnVsbCwgKGlzLm5hKG5fd29yZHMpfG5fd29yZHMgPT0gMCkpDQojIGFuZCB0aGVuIHB1dCB0aGVtIGJhY2sNCnByb2ZfcHVic19mdWxsIDwtIHJiaW5kKHByb2ZfcHVic19mdWxsX2ZpeCwNCiAgICAgICAgICAgICAgICAgICAgICAgIHB1YnNfZG9pX3dvcmRzKQ0KDQoNCiMgZHJvcCBsYXJnZSBmaWxlcyBmcm9tIHRoZSBtZW1vcnkgYXMgd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmUNCnJtKHB1YnNfbWV0YWRmKQ0Kcm0obWV0YWRmKQ0Kcm0ocHViX3RvX3Byb2ZpbGVfaWQpDQpnYygpDQoNCiMgV3JpdGUgdGhpcyBvdXQgaW50byBvdXIgREINCiNkYldyaXRlVGFibGUoY29uLCAibmFyY2lzX3B1Yl9pbmZvIiwgcHJvZl9wdWJzX2Z1bGwsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KIyBPQSBkYXRhDQoNCiMjIFNlZWsgcHJvZmVzc29yIGlkZW50aWZpZXJzIGluIE9wZW5BbGV4DQoNCkRlZmluZSB0aGUgZnVuY3Rpb24gdGhhdCBoZWxwcyB1cyBzZWVrIGlkZW50aWZpZXJzIGZyb206DQoxLiBQcm9mZXNzb3IncyBOYXJjaXMgcHVibGljYXRpb24gbGlzdCAoYmFzZWQgb24gRE9JKQ0KMi4gUHJvZmVzc29yJ3MgT1JDSUQgYXMgaW4gTmFyY2lzDQozLiBQcm9mZXNzb3IncyBuYW1lICsgTkwgYXMgdGhlIGNvdW50cnkgb2YgdGhlaXIgbGFzdCBrbm93biBpbnN0aXR1dGlvbg0KDQpUaGlzIGRpYWdyYW0gZGVzY3JpYmVzIGhvdyB3ZSBkbyBpdDoNCiFbRmlndXJlIDFdKGltYWdlcy9wcm9mZXNzb3JfaWRlbnRpZmllcl9yZXRyaWV2ZXJfZGlhZ3JhbS5wbmcpDQoNCkxvb3AgdGhyb3VnaCBwcm9mZXNzb3JzIGFuZCBmaW5kIHRoZWlyIGlkZW50aWZpZXJzOg0KYGBge3J9DQpuYXJjaXNfaWRzIDwtIHByb2ZzX2Z1bGwkcHJvZmlsZV9pZA0KcHJvZl9pZGVudGlmaWVyX2xpc3QgPC0gbGlzdCgpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChuYXJjaXNfaWRzKSl7DQogIG5hcmNpc19pZCA8LSBuYXJjaXNfaWRzW2ldDQogIA0KICBwcm9mX2lkcyA8LSBOQQ0KICANCiAgdHJ5KHByb2ZfaWRzIDwtIHByb2Zlc3Nvcl9pZGVudGlmaWVyX3JldHJpZXZlcihuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHViX2RhdGEgPSBwcm9mX3B1YnNfZnVsbCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2RhdGEgPSBwcm9mc19mdWxsKQ0KICApDQogIA0KICBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dIDwtIHByb2ZfaWRzDQogIG5hbWVzKHByb2ZfaWRlbnRpZmllcl9saXN0KVtbaV1dIDwtIG5hcmNpc19pZA0KICANCiAgcHJpbnQocGFzdGUoImRvbmUgd2l0aCIsIGksICJvdXQgb2YiLCBsZW5ndGgobmFyY2lzX2lkcykpKQ0KICANCn0NCmBgYA0KDQpXZSBmYWlsIHRvIGZpbmQgYW55IE9BIGlkcyBmb3Igc29tZSBwcm9mZXNzb3JzLg0KRmluZCB0aGVpciBPQSBJRHMgbWFudWFsbHk6DQpgYGB7cn0NCiMgbWFudWFsbHkgZ2V0IHRoZSBjb3JyZWN0IHNlYXJjaCB0ZXJtcyBmb3IgdGhlIG1pc3NpbmcgcHJvZmVzc29yczoNCm1pc3NpbmdfaWRzIDwtIGMoImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzNjYzNCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzY4NjkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM2OTYwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzNzg1MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzgwNDUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM4NTQyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzODg4MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzg4OTgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM5MTIyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzOTYwNiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzk4NDEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQwMTk0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MTIxOCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDEyNjYiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQxNTYyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MTgzNyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDIwMzUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQyMjQzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MzEwOSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDcxMTIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjUxNjUwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI1MzgwMSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNTU5MDkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjYzMDE3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI2NTUwMyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNzM4NTgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjc2NDQ4IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4MTg0NCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODE4NDUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjgxODc1IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4Mzk4NCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODYzNTQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjg4MzQwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4ODU1MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODkyOTkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjkxMDUxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5MTkxOSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyOTE5MzgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjk1NDY5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5NTU2OSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyOTYzMTMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjk3MjIzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5NzkyOSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMDA3NjgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzAzNTUyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMwNDY1MSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMTM3ODEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzE0MTc4IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMxNjA2OCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMTc4MDYiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzE5MjQxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMxOTgxMiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjAxNzQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzIxMTAzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMyNDE2MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjUxMjAiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzI5MTY2IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMTM2MCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzE0NTIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzMzNjE0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMzgwMSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzQwNDMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM1NjU0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzNTY1OSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzYzNjUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM2NTQ5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MDg4NyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDA5NzgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQxNTU3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MjE4MSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDIxOTUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQyMjc1IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0Nzg5NyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDgyNDEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQ4MzUzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0OTczMiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNTAzMjgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUwOTM3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM1MTMwNiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNTEzMDgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUxMzY0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM1MTQ4MSIpDQoNCm1pc3Npbmdfc2VhcmNoX3Rlcm1zIDwtIGMoIlcuSC5NLiBSZWVodWlzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlBoaWxpcCBILiBKLiBHLiB2YW4gSHVpemVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkouQy5FLiB2YW4gS29sbGVuYnVyZyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJBLkkuTS4gdmFuIE1pZXJsbyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKZWFuLUJlcm5hcmQgTWFydGVucyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJSLlAuSi5MLiBUaml0dGVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkouVy4gRHV5dmVuZGFrIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkplYW4tUGllcnJlIFdpbHMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiVy5HLiBIdWlqZ2VuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkphbiBBLiBCcnVpam4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQW5uZS1NYXJpZSBLb3J0ZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJHLlcuSi5NLiBLYW1wc2Now7ZlciIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIm0uaC4gY29yYmV5IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkEuTS4gTHVib3Rza3kiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly9vcGVuYWxleC5vcmcvQTUwNDE5MzAxNTciLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiRS5GLiBTdGVlbm5pcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJWZW51Z29wYWwgVmVua2F0YXJhbWFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImhvZWZ0ZSByb3NlbWFyaWpuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkIuUC5NLiB2YW4gUmF2ZWxzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImtvcnN0ZW4gZi53LmEuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkFsYmVyZGluYSBIb3V0bWFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIk1hcmNvIFAgTmlldXdlIFdlbWUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSmFuLURpZWRlcmlrIHZhbiBXZWVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJDLkQuSi4gQnVsdGVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkEuTS5CLiBEZVdhZWdlbmFlcmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiV2lsbGVt4oCQSmFuIHZhbiBkZW4gSGV1dmVsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkUuQy5DLiBQdW5zZWxpZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkcuIHZhbiBSaWpzc2VuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJNLkEuIFZlcmJydWdoIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkh1aWJlcnQgRGllZGVyaWsgdmFuIFJvbWJ1cmdoIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJLYXRhcnp5bmEgSi4gQ3dpZXJ0a2EiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSi5XLiBGb3BwZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiUGV0ZXIgdmFuIEdvb2wiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSC5KLk0uIEhhdmVrZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImkuYS5tLiBzYWxvdWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiZS5qLmouIGJldWxlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJPbGV4YW5kZXIgWWFyb3Z5aSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJSLlAuIEJvdGhhIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkEuIE0uIEJhcnlzaGV2IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgInN5bHZpYSBidXJnLXZlcm1ldWxlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKLlMuTC5BLlcuQi4gUm9lcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKYW4gSGVpbiBGdXJuw6llIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkFubmV0dGUgRnJleWJlcmfigJBJbmFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkdlcnQgSmFuIHZhbiBkZXIgU21hbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQy4gR291a2Vucy1NZXJ0ZW5zIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJHLlIuQi5FLiBSw7ZtZXIiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAicC5oLmwubS4ga3V5cGVycyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJHZW5zZXJpayBSZW5pZXJzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlN0ZXBoYW4gV2Vuc3ZlZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiT25ubyBLcmFuZW5idXJnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlNjaHdhcnR6LUxhbmRzbWFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkcuSi5DLiBSZW5zZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSy5XLkguIEJyb2VraHVpemVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlMuSC5NLkEuIER1bW91bGluIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlMuIEpvbmcgS29uIENoaW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiUy5QLkouIHZhbiBBbHBoZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQ2h1buKAkEtldW5nIEhvaSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJTZXJnZXkgTmVqZW50c2V2IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImx1ZG92aWNvIGFsY29ydGEiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAicC5hLm0uZy4gZGUga29jayIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJoYWVyc29sdGUtdmFuIGhvZiBqYWNvbWlqbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJFdWdlbmlhIEhvdXZlbmFnaGVsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIm0uYS4gdmFuIHdpbGxpZ2VuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImFydGh1ciB0ZW4gY2F0ZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJQZXRlciBLb3VkaWpzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkZ1bHZpbyBSZWdnaW9yaSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkFudG9uaXMgUGFwYXBhbnRvbGVvbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJhLmMuIGJvZXJzdHJhIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkxlb25pZSBIZXJlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJUaG9tYXMgUC4gTW9saXRlcm5vIikNCg0KbGVuZ3RoKHdoaWNoKGlzLm5hKG1pc3Npbmdfc2VhcmNoX3Rlcm1zKSkpDQpgYGANCldlIGNhbm5vdCBmaW5kIGEgcmVsaWFibGUgT0EgSUQgZm9yIDEyIHByb2Zlc3NvcnMgaW4gb3VyIGRhdGFzZXQuIA0KDQpMb29wIHRocm91Z2ggdGhlIGlkZW50aWZpZXIgbGlzdCB0byBmaWxsIHRoZSBJRHMgaW46DQpgYGB7cn0NCmZvciAoaSBpbiAxOmxlbmd0aChtaXNzaW5nX2lkcykpew0KICBuYXJjaXNfaWQgPC0gbWlzc2luZ19pZHNbaV0NCiAgDQogIHNlYXJjaF90ZXJtIDwtIG1pc3Npbmdfc2VhcmNoX3Rlcm1zW2ldDQogIA0KICBwcm9mX2xpc3RfaXRlbSA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbbmFyY2lzX2lkXV0NCiAgDQogIGlmICghaXMubmEoc2VhcmNoX3Rlcm0pKXsNCiAgICANCiAgICBpZihzZWFyY2hfdGVybSA9PSAiaHR0cHM6Ly9vcGVuYWxleC5vcmcvQTUwNDE5MzAxNTciKXsNCiAgICAgIHByb2Zfb2FfaWRzIDwtIG9hX2ZldGNoKA0KICAgICAgICBlbnRpdHkgPSAiYXV0aG9yIiwgJ0E1MDQxOTMwMTU3JykNCiAgICB9ZWxzZXsNCiAgICAgIHByb2Zfb2FfaWRzIDwtIG9hX2ZldGNoKCJhdXRob3IiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoX3Rlcm0pDQogICAgfQ0KICAgIA0KICAgIGlmIChucm93KHByb2Zfb2FfaWRzKT4wKXsNCiAgICAgIG9hX2lkc19uYW1lcyA8LSBwcm9mX29hX2lkcyRpZHMNCiAgICAgICMgaWYgYSBsaXN0LCBvbmx5IHJldGFpbiB0aGUgT0EgSURzOg0KICAgICAgaWYoY2xhc3Mob2FfaWRzX25hbWVzKSA9PSAibGlzdCIpew0KICAgICAgICBvYV9pZHNfbmFtZXMgPC0gYygpDQogICAgICAgIGZvciAoaiBpbiAxOm5yb3cocHJvZl9vYV9pZHMpKXsNCiAgICAgICAgICBpZCA8LSBwcm9mX29hX2lkcyRpZHNbW2pdXVsnb3BlbmFsZXgnXQ0KICAgICAgICAgIG9hX2lkc19uYW1lcyA8LSBjKG9hX2lkc19uYW1lcywgaWQpDQogICAgICAgIH0NCiAgICAgICAgb2FfaWRzX25hbWVzIDwtIHVubmFtZShvYV9pZHNfbmFtZXMpDQogICAgICB9DQogICAgICANCiAgICAgIHByb2ZfbGlzdF9pdGVtWyJvYV9pZHNfbmFtZXMiXSA8LSBsaXN0KG9hX2lkc19uYW1lcykNCiAgICB9DQogIH0NCiAgDQogIHByb2ZfaWRlbnRpZmllcl9saXN0W1tuYXJjaXNfaWRdXSA8LSBwcm9mX2xpc3RfaXRlbQ0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChtaXNzaW5nX2lkcykpKQ0KICANCn0NCmBgYA0KDQpFeHRyYWN0IHByb2Zlc3NvciBJRHMgYW5kIHNvdXJjZXMgZm9yIGVhY2ggcHJvZmVzc29yOg0KYGBge3J9DQpwcm9mX29hX21hcHBpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChwcm9mX2lkZW50aWZpZXJfbGlzdCkpew0KICAjIGluaXRpYXRlIGEgZGF0YWZyYW1lIHRvIHN0b3JlIHRoaXMgcHJvZmVzc29yJ3MgZGF0YQ0KICBwcm9mX29hX2lkcyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAzKSkNCiAgIyByZXRyaWV2ZSB0aGlzIHByb2Zlc3NvcidzIGxpc3Qgb2YgaWRlbnRpZmllcnMNCiAgcHJvZl9pZGVudGlmaWVycyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dDQogICMgZ2V0IHRoZWlyIE5hcmNpcyBJRCBhbmQgYWxsIHRoZSByZXRyaWV2ZWQgT0EgSURzDQogIG5hcmNpc19pZCA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sibmFyY2lzX2lkIl1dDQogIA0KICBwdWJfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfcHVicyJdXQ0KICANCiAgb3JjaWRfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfb3JjaWQiXV0NCiAgDQogIG5hbWVfaWRzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJvYV9pZHNfbmFtZXMiXV0NCiAgDQogICMgYWRkIGFueSBJRHMgcmV0cmlldmVkIGZyb20gdGhlIHB1YmxpY2F0aW9uIGxpc3QNCiAgaWYgKCFhbGwoaXMubmEocHViX2lkcykpKXsNCiAgDQogIHB1Yl9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gcHViX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gInB1YmxpY2F0aW9ucyIpDQogIA0KICBwcm9mX29hX2lkcyA8LSByYmluZChwcm9mX29hX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgcHViX2lkcykNCiAgfQ0KICAjIGFkZCBhbnkgSURzIGFzc29jaWF0ZWQgd2l0aCBwcm9mJ3MgT1JDSUQNCiAgaWYgKCFhbGwoaXMubmEob3JjaWRfaWRzKSkpew0KICBvcmNpZF9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gb3JjaWRfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNvdXJjZSIgPSAib3JjaWQiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIG9yY2lkX2lkcykNCiAgfQ0KICAjIGFkZCBhbnkgSURzIGZyb20gbmFtZSBzZWFyY2ggKyBOTCBjb3VudHJ5DQogIGlmICghYWxsKGlzLm5hKG5hbWVfaWRzKSkpew0KICBuYW1lX2lkcyA8LSBjYmluZC5kYXRhLmZyYW1lKCJwcm9maWxlX2lkIiA9IG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYV9pZCIgPSBuYW1lX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gIm5hbWUiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIG5hbWVfaWRzKQ0KICB9DQogIA0KICAjIGlmIGFueSByb3dzDQogIGlmIChucm93KHByb2Zfb2FfaWRzKSA+IDApew0KICAgIA0KICAgICMgZGVkdXBsaWNhdGUNCiAgICBwcm9mX29hX2lkcyRkdXBsaWNhdGUgPC0gZHVwbGljYXRlZChwcm9mX29hX2lkc1tjKCJwcm9maWxlX2lkIiwgIm9hX2lkIildKQ0KICAgIHByb2Zfb2FfaWRzIDwtIGZpbHRlcihwcm9mX29hX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID09IEZBTFNFKQ0KICAgIHByb2Zfb2FfaWRzIDwtIHByb2Zfb2FfaWRzWywgLTRdDQogICAgDQogICAgcHJvZl9vYV9tYXBwaW5nIDwtIHJiaW5kKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9pZHMpDQogIH0gZWxzZXsNCiAgICBwcm9mX29hX2lkcyA8LSBjYmluZC5kYXRhLmZyYW1lKCJwcm9maWxlX2lkIiA9IG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYV9pZCIgPSBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gTkEpDQogICAgcHJvZl9vYV9tYXBwaW5nIDwtIHJiaW5kKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9pZHMpDQogIH0NCiAgcHJpbnQocGFzdGUoImRvbmUgd2l0aCIsIGksICJvdXQgb2YiLCBsZW5ndGgobmFyY2lzX2lkcykpKQ0KfQ0KDQpgYGANCg0KRm9yIHByb2Zlc3NvcnMgd2hlcmUgd2UgaGF2ZSBwdWJsaWNhdGlvbiBhbmQgT1JDSUQtYmFzZWQgT0EgSURzLCB3ZSB3aWxsIG9ubHkNCnVzZSB0aG9zZSAod2hpY2ggaXMgNTQ1MiBwcm9mZXNzb3JzKQ0KYGBge3J9DQpwcm9mX29hX21hcHBpbmdfcHViX29yY2lkIDwtIGZpbHRlcihwcm9mX29hX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgIT0gIm5hbWUiKQ0KDQpsZW5ndGgodW5pcXVlKHByb2Zfb2FfbWFwcGluZ19wdWJfb3JjaWQkcHJvZmlsZV9pZCkpDQpgYGANCkFuZCBub3csIGZvciB0aGUgcmVtYWluaW5nIHByb2Zlc3NvcnMsIGdldCB0aGVpciBuYW1lLWJhc2VkIElEcyAoMTM2NiBwcm9mZXNzb3JzKSwgYnV0IHdhdGNoIG91dCBmb3INCmFueSBvZGRpdGllcyAoZS5nLiwgYW4gZXh0cmVtZSBudW1iZXIgb2YgSURzKToNCmBgYHtyfQ0KcHJvZl9vYV9tYXBwaW5nX25hbWUgPC0gZmlsdGVyKHByb2Zfb2FfbWFwcGluZywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPT0gIm5hbWUiICYgISBwcm9maWxlX2lkICVpbiUgcHJvZl9vYV9tYXBwaW5nX3B1Yl9vcmNpZCRwcm9maWxlX2lkKQ0KDQpsZW5ndGgodW5pcXVlKHByb2Zfb2FfbWFwcGluZ19uYW1lJHByb2ZpbGVfaWQpKQ0KDQojIGNoZWNrIG1hbnVhbGx5IGZvciBvZGQgbnVtYmVycyBvZiBJRHMNCm9hX2lkX2NoZWNrIDwtIHByb2Zfb2FfbWFwcGluZ19uYW1lICU+JSANCiAgY291bnQocHJvZmlsZV9pZCwgc291cmNlLCBzb3J0ID0gVFJVRSkNCg0KIyBoZXJlIGFyZSBwcm9mZXNzb3IgSURzIHdpdGggbW9yZSB0aGFuIDEwIGRpZmZlcmVudCBJRHMgd2hlcmUgd2Ugc2VlIGluY29uc2lzdGVudCBuYW1lLWJhc2VkIHJlc3VsdHMNCnByb2JsZW1hdGljX2lkcyA8LSBjKCJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzYyMDMiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzNjIyMiIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM0MDI4IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMDMxOTAiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMDY3MyIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM0MDA3IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjU3NjYiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MDE1NiIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUwODA5IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzIyODgiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MDkwMSIsDQogICAgICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM2MTc4IiwNCiAgICAgICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDA3MTkiLA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MjYzNCIsIA0KICAgICAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMjcwMCIpDQoNCiMgZmlsdGVyIHRoZW0gb3V0DQpwcm9mX29hX21hcHBpbmdfbmFtZSA8LSBmaWx0ZXIocHJvZl9vYV9tYXBwaW5nX25hbWUsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISBwcm9maWxlX2lkICVpbiUgcHJvYmxlbWF0aWNfaWRzKQ0KYGBgDQoNCkNvbWJpbmUgdGhlIHJlbGlhYmxlIHJlc3VsdHMgdG9nZXRoZXIuIEluIHRvdGFsLCB3ZSBtaXNzIE9BIElEcyBmb3IgMjcgcHJvZmVzc29ycw0KKDAuNCUgb2YgYWxsIG9ic2VydmF0aW9ucyk6DQpgYGB7cn0NCnByb2Zfb2FfbWFwcGluZ19maXggPC0gcmJpbmQocHJvZl9vYV9tYXBwaW5nX3B1Yl9vcmNpZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9vYV9tYXBwaW5nX25hbWUpDQoNCmxlbmd0aCh1bmlxdWUocHJvZl9vYV9tYXBwaW5nX2ZpeCRwcm9maWxlX2lkKSkNCihucm93KHByb2ZzX2Z1bGwpLWxlbmd0aCh1bmlxdWUocHJvZl9vYV9tYXBwaW5nX2ZpeCRwcm9maWxlX2lkKSkpL25yb3cocHJvZnNfZnVsbCkqMTAwDQpgYGANCg0KQW5kIGRvIG5vdCBxdWVyeSBwcm9mZXNzb3JzIHdobyBoYXZlIG5hbWVzIHRoYXQgYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIHRoZQ0KZGF0YXNldCwgYW5kIHdob3NlIE9BIElEcyB3ZSBvbmx5IHF1ZXJ5IHZpYSBuYW1lOg0KYGBge3J9DQojIHdoaWNoIHByb2ZzIGZyb20gdGhlIGR1cGxpY2F0ZSBsaXN0IGhhdmUgT0EgSURzIHB1bGxlZCBmcm9tIHRoZWlyIG5hbWVzIG9ubHk/DQpwcm9mc19kdXBsaWNhdGVzX29hIDwtIGZpbHRlcihwcm9mX29hX21hcHBpbmdfZml4LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZV9pZCAlaW4lIHByb2ZzX2R1cGxpY2F0ZXMkcHJvZmlsZV9pZCkNCg0KIyBkcm9wICB0aGUgcHJvZnMgZm9yIHdob20gd2UgaGF2ZSBuYW1lLWJhc2VkIElEcyBvbmx5DQpwcm9mc19kdXBsaWNhdGVzX2Ryb3AgPC0gcHJvZnNfZHVwbGljYXRlc19vYSAlPiUgIGdyb3VwX2J5KHByb2ZpbGVfaWQpICU+JSBmaWx0ZXIoYW55KHNvdXJjZSA9PSAnbmFtZScpKQ0KDQoNCnByb2Zfb2FfbWFwcGluZ19maXggPC0gZmlsdGVyKHByb2Zfb2FfbWFwcGluZ19maXgsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISBwcm9maWxlX2lkICVpbiUgcHJvZnNfZHVwbGljYXRlc19kcm9wJHByb2ZpbGVfaWQpDQpgYGANCg0KV2hhdCBkbyB3ZSBtaXNzPyBXZSBtaXNzIElEcyBmb3IgMzEgcHJvZmVzc29yLiANCmBgYHtyfQ0KbGVuZ3RoKHVuaXF1ZShwcm9mX29hX21hcHBpbmdfZml4JHByb2ZpbGVfaWQpKQ0KKG5yb3cocHJvZnNfZnVsbCktbGVuZ3RoKHVuaXF1ZShwcm9mX29hX21hcHBpbmdfZml4JHByb2ZpbGVfaWQpKSkNCihucm93KHByb2ZzX2Z1bGwpLWxlbmd0aCh1bmlxdWUocHJvZl9vYV9tYXBwaW5nX2ZpeCRwcm9maWxlX2lkKSkpL25yb3cocHJvZnNfZnVsbCkqMTAwDQpgYGANCg0KDQpXcml0ZSB0aGUgZGF0YSBvdXQ6DQpgYGB7cn0NCmRiV3JpdGVUYWJsZShjb24sICJvYV9pZF9tYXBwaW5nIiwgcHJvZl9vYV9tYXBwaW5nX2ZpeCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQoNCiMjIE9SQ0lEcw0KDQpOb3csIGZpbmQgcHJvZmVzc29yJ3MgT1JDSURzIGJhc2VkIG9uIG91ciBOQVJDSVMgZGF0YSAoYWx3YXlzIGhhcyB0aGUgcHJlZmVyZW5jZSkNCmFuZCwgd2hlcmUgbm90IGF2YWlsYWJsZSwgb24gdGhlIE9SQ0lEcyBleHRyYWN0ZWQgYmFzZWQgb24gdGhlaXIgT0EgSURzOg0KYGBge3J9DQpvYV9pZF9saXN0IDwtIHVuaXF1ZShwcm9mX29hX21hcHBpbmdfZml4JG9hX2lkKQ0KIyBub3cgZmV0Y2ggdGhlIHByb2Zlc3NvciBpbmZvIGZyb20gT0EgYmFzZWQgb24gdGhlaXIgSUQsIHRvIHNlZWsgdGhlaXIgT1JDSURzDQpwcm9mX2luZm9fYWxsIDwtIG9hX2ZldGNoKA0KICBlbnRpdHkgPSAiYXV0aG9ycyIsIA0KICBvcGVuYWxleF9pZCA9IG9hX2lkX2xpc3QpDQoNCiMgb25seSBsZWF2ZSB0aGUgSURzIHRoYXQgaGF2ZSBPUkNJRHMNCnByb2ZfaW5mb19vcmNpZHNfMSA8LSBmaWx0ZXIocHJvZl9pbmZvX2FsbCwgIWlzLm5hKG9yY2lkKSklPiUNCiAgc2VsZWN0KGlkLCBvcmNpZCkNCiMgdGlkeSB1cCB0aGUgY29sbmFtZXMNCmNvbG5hbWVzKHByb2ZfaW5mb19vcmNpZHNfMSkgPC0gYygib2FfaWQiLCAiT1JDSUQiKQ0KIyBhbmQgbWF0Y2ggdG8gTmFyY2lzIElEcw0KcHJvZl9pbmZvX29yY2lkc18xIDwtIG1lcmdlKHByb2Zfb2FfbWFwcGluZ19maXhbMToyXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2luZm9fb3JjaWRzXzEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAib2FfaWQiKQ0KDQojIG5vdywgZ2V0IHRoZSBPUkNJRHMgd2UgYWxyZWFkeSBoYXZlIGZyb20gTmFyY2lzDQpwcm9mX2luZm9fb3JjaWRzXzIgPC0gZmlsdGVyKHByb2ZzX2Z1bGwsICFpcy5uYShPUkNJRCkpJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCBPUkNJRCkNCg0KcHJvZl9pbmZvX29yY2lkc18yIDwtIG1lcmdlKHByb2Zfb2FfbWFwcGluZ19maXhbMToyXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2luZm9fb3JjaWRzXzIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAicHJvZmlsZV9pZCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsLnkgPSBUUlVFKQ0KDQojIG9ubHkgc2VsZWN0IHByb2Zlc3NvcnMgZm9yIHdob20gd2UgZG9uJ3QgaGF2ZSBhbiBPUkNJRCBpbiBvdXIgTmFyY2lzIGRhdGEsDQojIGFzIE5hcmNpcyBkYXRhIGlzIGFsd2F5cyBvdXIgZmlyc3QgY2hvaWNlDQpwcm9mX2luZm9fb3JjaWRzXzEgPC0gZmlsdGVyKHByb2ZfaW5mb19vcmNpZHNfMSwgISBwcm9maWxlX2lkICVpbiUgcHJvZl9pbmZvX29yY2lkc18yJHByb2ZpbGVfaWQpDQoNCiMgY29tYmluZSB0aGUgdHdvIHNvdXJjZXMNCnByb2ZfaW5mb19vcmNpZHNfMiA8LSBwcm9mX2luZm9fb3JjaWRzXzJbY29sbmFtZXMocHJvZl9pbmZvX29yY2lkc18xKV0NCg0KcHJvZl9pbmZvX29yY2lkc19jb21iaSA8LSByYmluZChwcm9mX2luZm9fb3JjaWRzXzEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfaW5mb19vcmNpZHNfMikNCg0KIyBhbmQga2VlcCBvbmx5IG9uZSByb3cgd2l0aCBPUkNJRCdzIHBlciBOYXJjaXMgSUQNCnByb2ZfaW5mb19vcmNpZHNfY29tYmkgPC0gcHJvZl9pbmZvX29yY2lkc19jb21iaSAlPiUNCiAgZGlzdGluY3QoLiwgcHJvZmlsZV9pZCwgT1JDSUQsIC5rZWVwX2FsbCA9IFRSVUUpJT4lDQogIHNlbGVjdChwcm9maWxlX2lkLCBPUkNJRCkNCiAgDQojIHNvIHdlIGhhdmUgT1JDSURzIGZvciA1NDc4IHByb2Zlc3NvcnMsIG9yIHNvbWUgODAlIG9mIG91ciBkYXRhc2V0DQpucm93KHByb2ZfaW5mb19vcmNpZHNfY29tYmkpDQpucm93KHByb2ZfaW5mb19vcmNpZHNfY29tYmkpL25yb3cocHJvZnNfZnVsbCkqMTAwDQoNCmRiV3JpdGVUYWJsZShjb24sICJvcmNpZF9tYXBwaW5nIiwgcHJvZl9pbmZvX29yY2lkc19jb21iaSwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQoNCiMjIEV4dHJhY3QgcHVibGljYXRpb25zIGJhc2VkIG9uIE9BIElEcw0KDQpEZWZpbmUgdGhlIGRhdGEgcXVlcnlpbmcgZnVuY3Rpb24sIHdoaWNoIHB1bGxzIGRhdGEgZnJvbSBPQSBhcyBzaG93biBpbiB0aGUNCkRpYWdyYW0gYmVsb3c6DQohW0ZpZ3VyZSAyXShpbWFnZXMvcHJvZmVzc29yX2luZm9fcmV0cmlldmVyX2RpYWdyYW0ucG5nKQ0KDQpQdWxsIHRoZSBwcm9mZXNzb3IgZGF0YToNCmBgYHtyfQ0KIyBnZXQgdGhlIGxpc3Qgb2YgSURzDQpuYXJjaXNfaWRzIDwtIHByb2ZzX2Z1bGwkcHJvZmlsZV9pZA0KDQojIDI0MzUgaXMgdGhlIG5leHQgb25lDQojIGxvb3AgdGhyb3VnaCB0aGUgYmF0Y2hlcw0KZm9yKGkgaW4gMTpsZW5ndGgobmFyY2lzX2lkcykpew0KICBuYXJjaXNfaWQgPC0gbmFyY2lzX2lkc1tpXQ0KICANCiAgcHJvZmVzc29yX3B1Yl9pbmZvX3JldHJpZXZlcihwcm9mX29hX2lkcyA9IHByb2Zfb2FfbWFwcGluZ19maXgsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFyY2lzX2lkID0gbmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Yl9kYXRhID0gcHJvZl9wdWJzX2Z1bGwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9kYXRhID0gcHJvZnNfZnVsbCkNCiAgIyBwcmludCBzb21lIGluZm8gb3V0DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKG5hcmNpc19pZHMpKSkNCn0NCg0KYGBgDQoNCldyaXRlIG91dCB0aGUgdW5pcXVlIHB1YmxpY2F0aW9uIGxpc3Q6DQpgYGB7cn0NCm9hX3Byb2ZfcHVicyA8LSBkYlJlYWRUYWJsZShjb24sICJvYV9wcm9mX3B1YnMiKQ0KDQpvYV9wcm9mX3B1YnNfdW5pcXVlIDwtIGRpc3RpbmN0KG9hX3Byb2ZfcHVicywgaWQsIC5rZWVwX2FsbCA9IFRSVUUpDQoNCm9hX3Byb2ZfcHVic191bmlxdWUgPC0gb2FfcHJvZl9wdWJzX3VuaXF1ZSAlPiUNCiAgc2VsZWN0KC1jb3VudHNfYnlfeWVhcl95ZWFyLCAtY291bnRzX2J5X3llYXJfY2l0ZWRfYnlfY291bnQpJT4lDQogIHNlbGVjdCgtYyhhdV9pZDppbnN0aXR1dGlvbl9saW5lYWdlKSkgJT4lDQogIHNlbGVjdCgtYyhvYV9pZDpwcm9maWxlX2lkKSkNCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3Byb2ZfcHVic191bmlxdWUiLCBvYV9wcm9mX3B1YnNfdW5pcXVlKQ0KYGBgDQoNCg0KIyBQcm9mZXNzb3IgQWx0bWV0cmljIGRhdGENCg0KIyMgUHJvZmVzc29yIGF0dGVudGlvbiBkYXRhIChET0kgYmFzZWQsIGV4Y2x1ZGluZyBUd2l0dGVyKQ0KDQpHZXQgdGhlIGFsdG1ldHJpYyBhdHRlbnRpb24gZm9yIG91ciBwcm9mZXNzb3JzLCBwZXIgRE9JOg0KYGBge3J9DQojIGFwaSBrZXkgZm9yIHRoZSBEZXRhaWxzIEFQSQ0KYWx0bWV0cmljX2RldGFpbHNfYXBpX2tleSA8LSAnJw0KDQojIGdldCB0aGUgbGlzdCBvZiBwdWJsaWNhdGlvbnMgdG8gZXh0cmFjdA0Kb2FfcHVicyA8LSBkYkdldFF1ZXJ5KGNvbiwgInNlbGVjdCAqIGZyb20gb2FfcHJvZl9wdWJzOyIpDQoNCiMgZ2V0IGEgdW5pcXVlIGxpc3Qgb2YgcHVibGljYXRpb25zIHRvIGZldGNoIG1lbnRpb25zIGZvcg0KZG9pX2xpc3QgPC0gZmlsdGVyKG9hX3B1YnMsICFpcy5uYShkb2kpKSU+JQ0KICBkaXN0aW5jdChkb2ksIC5rZWVwX2FsbCA9IFRSVUUpDQoNCiMgbG9vcCB0aHJvdWdoIHRoZSBkb2lzDQpmb3IoaSBpbiAxOm5yb3coZG9pX2xpc3QpKXsNCiAgZG9pIDwtIGRvaV9saXN0W2ksXQ0KIA0KICBhbHRtZXRyaWNfbWVudGlvbl9yZXRyaWV2ZXIoYXBpX2tleSA9IGFsdG1ldHJpY19kZXRhaWxzX2FwaV9rZXksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2kgPSBkb2ksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlX3R3aXR0ZXIgPSBGQUxTRSkNCiAgDQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbnJvdyhkb2lfbGlzdCkpKQ0KfQ0KYGBgDQoNCg0KIyMgUmV0cmlldmUgVHdpdHRlciBtZW50aW9ucyAocGVyIE9SQ0lEKQ0KDQpVc2luZyBwcm9mZXNzb3IgT1JDSURzLCBwdWxsIHRoZSBhdHRlbnRpb24gVHdpdHRlciBkYXRhIGZyb20gdGhlDQpBbHRtZXRyaWMgRXhwbG9yZXIgQVBJOg0KYGBge3J9DQojIHJldHJpZXZlIHRoZSBPUkNJRCB0YWJsZQ0KcHJvZl9vcmNpZHMgPC0gZGJHZXRRdWVyeShjb25uID0gY29uLCBzdGF0ZW1lbnQgPSAic2VsZWN0ICogZnJvbSBvcmNpZF9tYXBwaW5nOyIpDQoNCiMgZ2V0IHRoZSBBbHRtZXRyaWMgRXhwbG9yZXIgQVBJIGFwaSBrZXlzIChmaWxsIGluIG93bikNCmFwaV9zZWNyZXQgPC0gJycNCmFwaV9rZXkgPC0gJycNCmBgYA0KDQpXZSBwdWxsIGFsbCBhdHRlbnRpb24gZm9yIHJvYnVzdG5lc3MgY2hlY2tzIGFnYWluc3QgdGhlIEFsdG1ldHJpYyBEZXRhaWxzIFBhZ2UNCmluZm8gd2UgZ2V0IGJ5IHNlYXJjaGluZyBhdHRlbnRpb24gdmlhIERPSS4NCg0KTG9vcCB0aHJvdWdoIHRoZSBPUkNJRHMgYW5kIGdldCBwcm9mJyBhdHRlbnRpb24gKGluY2x1ZGluZyB0d2l0dGVyKS4NCmBgYHtyfQ0KcHJvZl9hdHRlbnRpb25fbGlzdCA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSA0KSkNCmNvbG5hbWVzKHByb2ZfYXR0ZW50aW9uX2xpc3QpIDwtIGMoIm1lbnRpb25fdHlwZSIsICJ5ZWFyIiwgInllYXJseV9jb3VudCIsICJwcm9maWxlX2lkIikNCg0KDQpmb3IgKGkgaW4gMTpucm93KHByb2Zfb3JjaWRzKSl7DQogICMgbm90IHN1cmUgdGhpcyBpcyBjb3JyZWN0IQ0KICBvcmNpZCA8LSBwcm9mX29yY2lkcyRPUkNJRFtpXQ0KICBwcm9mX2F0dGVudGlvbiA8LSBOQQ0KICAjIHF1ZXJ5IHRoZSBpbmZvDQogIHRyeShwcm9mX2F0dGVudGlvbiA8LSBhbHRtZXRyaWNfYXBpX29yY2lkX2NhbGxlcihvcmNpZCA9IG9yY2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9zZWNyZXQgPSBhcGlfc2VjcmV0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXkgPSBhcGlfa2V5LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gImF0dGVudGlvbiIpKQ0KICANCiAgIyBpZiBhbnkgZGF0YSwgdW5uZXN0IHR3aWNlIHRvIHVucmF2ZWwgdGhlIGluZm8NCiAgaWYgKCFhbGwoaXMubmEocHJvZl9hdHRlbnRpb24pKSl7DQogICAgcHJvZl9hdHRlbnRpb24gPC0gcHJvZl9hdHRlbnRpb24gJT4lIGRpc3RpbmN0KGlkLCAua2VlcF9hbGwgPSBUUlVFKQ0KICAgIHByb2ZfYXR0ZW50aW9uIDwtIHVubmVzdChwcm9mX2F0dGVudGlvbiwgY29scyA9IGMoIm1ldGEiKSkNCiAgICBwcm9mX2F0dGVudGlvbiA8LSB1bm5lc3QocHJvZl9hdHRlbnRpb24sIGNvbHMgPSBjKCJkYXRlcyIpKQ0KICAgICMgbm93LCBleHRyYWN0IHRoZSB5ZWFyIGFuZCBncm91cCBtZW50aW9ucyBieSB5ZWFyDQogICAgcHJvZl9hdHRlbnRpb24keWVhciA8LSB5ZWFyKHltZChwcm9mX2F0dGVudGlvbiRkYXRlKSkNCiAgICBwcm9mX2F0dGVudGlvbl95ZWFyIDwtIHByb2ZfYXR0ZW50aW9uICU+JQ0KICAgICAgZ3JvdXBfYnkoaWQsIHllYXIpJT4lDQogICAgICBzdW1tYXJpc2UoeWVhcmx5X2NvdW50ID0gc3VtKGNvdW50KSkNCiAgICAjIHRpZHkgdXAgdGhlIGNvbHVtbiBuYW1lcw0KICAgIGNvbG5hbWVzKHByb2ZfYXR0ZW50aW9uX3llYXIpWzFdIDwtIGMoIm1lbnRpb25fdHlwZSIpDQogICAgIyBhZGQgaW4gdGhlIGNvYXV0aG9yIE9BIElEDQogICAgcHJvZl9hdHRlbnRpb25feWVhciRwcm9maWxlX2lkIDwtIHByb2Zfb3JjaWRzJHByb2ZpbGVfaWRbaV0NCiAgICANCiAgICBpZiAobnJvdyhwcm9mX2F0dGVudGlvbl95ZWFyKT4wKXsNCiAgICAgICMgZmlsdGVyIG91dCB0aGUgZHVwbGljYXRlcw0KICAgICAgcHJvZl9hdHRlbnRpb25feWVhciA8LSBmaWx0ZXIocHJvZl9hdHRlbnRpb25feWVhciwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISBwcm9maWxlX2lkICVpbiUgcHJvZl9hdHRlbnRpb25fbGlzdCRwcm9maWxlX2lkKQ0KICAgICAgDQogICAgICBwcm9mX2F0dGVudGlvbl9saXN0IDwtIHJiaW5kKHByb2ZfYXR0ZW50aW9uX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2F0dGVudGlvbl95ZWFyKQ0KICAgIH0NCiAgfQ0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIG5yb3cocHJvZl9vcmNpZHMpKSkNCn0NCg0KZGJXcml0ZVRhYmxlKGNvbiwgImFsdG1ldHJpY19wcm9mX2F0dGVudGlvbiIsIHByb2ZfYXR0ZW50aW9uX2xpc3QsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KDQojIyBSZXRyaWV2ZSBUd2l0dGVyIG1lbnRpb25zIChwZXIgcHVibGljYXRpb24pDQoNCkdldCB0d2l0dGVyIGRhdGEgdGhhdCB3YXMgaW5pdGlhbGx5IG5vdCBwdWxsZWQgdXNpbmcgQWx0bWV0cmljIGFuZCB3cml0ZSBpdCB0byBvdXINCmRhdGFiYXNlIGFzIHdlbGwuDQoNCkNvbm5lY3QgdG8gdGhlIHBvc3RncmVzIGRhdGFiYXNlIGFuZCBwdWxsIHRoZSBwdWJsaWNhdGlvbnMgdGFibGU6DQpgYGB7cn0NCiMgcHVsbCBhbGwgdGhlIHB1YmxpY2F0aW9uIGRhdGENCnF1ZXJ5IDwtIHBhc3RlMCgic2VsZWN0ICogZnJvbSBvYV9wcm9mX3B1YnM7IikNCmFsbF9vYV9wdWJzIDwtIGRiR2V0UXVlcnkoY29ubiA9IGNvbiwgc3RhdGVtZW50ID0gcXVlcnkpDQpgYGANCg0KTm93IGZldGNoIHRoZSB0d2l0dGVyIG1lbnRpb25zIGZvciBlYWNoIHB1YmxpY2F0aW9uLg0KU2luY2UgdGhlcmUgaXMgYSBsaW1pdCBmb3IgVHdlZXQgSURzIHRoYXQgY2FuIGJlIHB1bGxlZCBmcm9tIEFsdG1ldHJpYywNCndlIHJldHJpZXZlIHR3ZWV0cyBwZXIgcGFwZXIsIGFuZCBub3QgdGhlIGF1dGhvciwgdG8gYXZvaWQgZG91YmxlIEFQSSBjYWxscywgYW5kDQp3aWxsIG1hdGNoIHRoZXNlIHdpdGggYXV0aG9ycyBsYXRlciBvbjoNCmBgYHtyIHdhcm5pbmcgPSBGLCBtZXNzYWdlPSBGfQ0KIyBnZXQgYSB1bmlxdWUgbGlzdCBvZiBPQSBJRHMgdG8gcHVsbCB0aGUgZGF0YSBmb3IgYW5kIGVuc3VyZSB0aGV5IGhhdmUgYSBET0kNCnJlbGV2YW50X29hX3B1YnMgPC0gZmlsdGVyKGFsbF9vYV9wdWJzLCAhaXMubmEoZG9pKSklPiUNCiAgZGlzdGluY3QoLiwgaWQsIC5rZWVwX2FsbCA9IFRSVUUpDQoNCiMgcmVtb3ZlIHJlZHVuZGFudCBpdGVtcyBmcm9tIG1lbW9yeQ0Kcm0oYWxsX29hX3B1YnMpDQpnYygpDQoNCiMgYmF0Y2ggc2l6ZQ0KYmF0Y2hfc2l6ZSA8LSAxMDAwDQojIHZlY3RvciBvZiBpbmRpY2VzIHRvIGxvb3AgdGhyb3VnaA0KYmF0Y2hlcyA8LSBzZXEoZnJvbT0xLCB0bz1ucm93KHJlbGV2YW50X29hX3B1YnMpLCBieT1iYXRjaF9zaXplKQ0KIyB0byBiZSBhYmxlIHRvIHN1YnNldCwgYWxzbyBhZGQgdGhlIGZpbmFsIGluZGV4KzENCmJhdGNoZXMgPC0gYyhiYXRjaGVzLCBsZW5ndGgocmVsZXZhbnRfb2FfcHVicykrMSkNCg0KIyBwZXIgYmF0Y2gNCmZvciAoaSBpbiAxOmxlbmd0aChiYXRjaGVzKSl7DQogICMgZ2V0IHRoZSBsaXN0DQogIGJhdGNoX3B1YnMgPC0gcmVsZXZhbnRfb2FfcHVic1tiYXRjaGVzW2ldOihiYXRjaGVzW2krMV0tMSksXQ0KICANCiAgdHdlZXRfaW5mb19mdWxsIDwtIE5BDQogIA0KICAjIHRyeSBnZXR0aW5nIHRoZSB0d2VldCBpbmZvDQogIHRyeSh0d2VldF9pbmZvX2Z1bGwgPC0gYWx0bWV0cmljX3R3aXR0ZXJfcmV0cmlldmVyKHB1YmxpY2F0aW9uX2xpc3QgPSBiYXRjaF9wdWJzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleSA9IGFsdG1ldHJpY19hcGlfa2V5KSwNCiAgICAgIHNpbGVudCA9IFRSVUUpDQogIA0KICAjIGFuZCB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgIyBpZiBub3QgZW1wdHkNCiAgaWYgKCFhbGwoaXMubmEodHdlZXRfaW5mb19mdWxsKSkpew0KICAgICMgaWYgdGhlcmUgaXMgbm8gdGFibGUgeWV0LCB3cml0ZSBpdCBhcyBhIG5ldyB0YWJsZQ0KICAgIGlmICghIGRiRXhpc3RzVGFibGUoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfdHdpdHRlciIpKXsNCiAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICBkYldyaXRlVGFibGUoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfdHdpdHRlciIsIHR3ZWV0X2luZm9fZnVsbCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkgDQogICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgfWVsc2V7DQogICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfdHdpdHRlciIpDQogICAgICAjIGlmIG5lZWRlZCwgcGFkIHRoZSBkYXRhc2V0DQogICAgICBpZighYWxsKGZpZWxkcyAlaW4lIGNvbG5hbWVzKHR3ZWV0X2luZm9fZnVsbCkpKXsNCiAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyh0d2VldF9pbmZvX2Z1bGwpKQ0KICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXModHdlZXRfaW5mb19mdWxsKSldDQogICAgICAgIHR3ZWV0X2luZm9fZnVsbCA8LSBiaW5kX2NvbHModHdlZXRfaW5mb19mdWxsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgICB0d2VldF9pbmZvX2Z1bGwgPC0gdHdlZXRfaW5mb19mdWxsW2ZpZWxkc10NCiAgICAgIH0NCiAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiAgICAgIHR3ZWV0X2luZm9fZnVsbCA8LSAgdHdlZXRfaW5mb19mdWxsICU+JQ0KICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgImFsdG1ldHJpY19wdWJfYXR0X3R3aXR0ZXIiLCB0d2VldF9pbmZvX2Z1bGwsIHJvdy5uYW1lcz1OVUxMLCBhcHBlbmQ9VFJVRSkgDQogICAgfQ0KICB9DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKGJhdGNoZXMpLCBzZXAgPSAiICIpKQ0KfQ0KYGBgDQoNCg0KDQojIEdlbmRlciBkYXRhDQoNClNlZSBzY3JpcHQgIlByb2ZfZ2VuZGVyLlJtZCIuDQpgYGB7cn0NCnByb2ZzX2Z1bGxfZ2VuZGVyIDwtIHJlYWRSRFMoIn4vUG9zdGRvYy9Qcm9qZWN0cy9kdXRjaF9tZWRpYV9wcm9mc19yL3Byb2Nlc3NlZF9kYXRhL3Byb2ZzX2Z1bGxfZ2VuZGVyLlJEUyIpDQpkYldyaXRlVGFibGUoY29uLCAiZ2VuZGVyX3RhYmxlIiwgcHJvZnNfZnVsbF9nZW5kZXIsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KIyBHcmFudHMgTldPIGFuZCBFUkMNCg0KRmlyc3QsIGdldCB0aGUgZGF0YSBzY3JhcGVkIGZyb20gdGhlIE5XTyB1c2luZyB0aGUgcHl0aG9uIHNjcmlwdCBbcHVsbGluZy1ud28tZ3JhbnQtZGF0YS5pcHluYl0gYW5kDQpwYXJzZWQgdXNpbmcgdGhlIFtHcmFudF9wYXJzaW5nLlJtZF0gc2NyaXB0LiBUaGVuLCBhbHNvIGxvYWQgdGhlIE5XTyBncmFudCBpbmZvDQpmcm9tIE5BUkNJUzoNCmBgYHtyfQ0KIyBkYXRhIHNjcmFwZWQgZnJvbSB0aGUgTldPIHdlYnNpdGUNCm53b19ncmFudHMgPC0gcmVhZFJEUygifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcHJvY2Vzc2VkX2RhdGEvbndvX2dyYW50cy5SRFMiKQ0KDQojIGRhdGEgZnJvbSBOQVJDSVMNCmxvYWQoIn4vUG9zdGRvYy9Qcm9qZWN0cy9kdXRjaF9tZWRpYV9wcm9mc19yL3Jhd19kYXRhL21lZGlhX3Byb2ZzX3Byb2ZpbGVzLnJkYSIpDQojIGdldCB0aGUgY29sdW1ucyBvZiBpbnRlcmVzdA0KbndvX2dyYW50c19uYXJjaXMgPC0gbWV0YWRmW2MoIkdyYW50cy9wcml6ZXMiLCAibmFyY2lzX3VybCIpXQ0KIyBzcGxpdCB0aGUgdGV4dHVhbCBpbmZvDQpud29fZ3JhbnRzX25hcmNpc19saXN0IDwtIG53b19ncmFudHNfbmFyY2lzICU+JSANCiAgc2VwYXJhdGVfd2lkZXJfZGVsaW0oY29scyA9IGBHcmFudHMvcHJpemVzYCwgDQogICAgICAgICAgICAgICAgICAgICAgIGRlbGltID0gIjsiLA0KICAgICAgICAgICAgICAgICAgICAgICBuYW1lcyA9IGMoImdyYW50XzEiLCAiZ3JhbnRfMiIsICJncmFudF8zIiwgImdyYW50XzQiKSwNCiAgICAgICAgICAgICAgICAgICAgICAgdG9vX2ZldyA9ICJhbGlnbl9zdGFydCIpDQoNCiMgY29udmVydCB0byBhIGxvbmcgZGF0YWZyYW1lDQpud29fZ3JhbnRzX25hcmNpc19sb25nIDwtIGdhdGhlcihud29fZ3JhbnRzX25hcmNpc19saXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbnRfc3RyaW5nLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbnRfMTpncmFudF80KSU+JQ0KICBmaWx0ZXIoIWlzLm5hKGdyYW50X3N0cmluZykpDQoNCiMgZXh0cmFjdCB0aGUgZ3JhbnQgbmFtZXMgYW5kIHllYXJzDQpud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZ18yIDwtIGlmZWxzZShzdHJfZGV0ZWN0KG53b19ncmFudHNfbmFyY2lzX2xvbmckZ3JhbnRfc3RyaW5nLCAiU3Bpbm96YSIpID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyX3NwbGl0X2kobndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudF9zdHJpbmcsICItIiwgMiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJfc3BsaXRfaShud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZywgIiAtICIsIDIpKQ0KDQpud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZ18yIDwtIHN0cl9yZW1vdmUobndvX2dyYW50c19uYXJjaXNfbG9uZyRncmFudF9zdHJpbmdfMiwgIkF3YXJkIikNCm53b19ncmFudHNfbmFyY2lzX2xvbmckZ3JhbnRfc3RyaW5nXzIgPC0gc3RyX3NxdWlzaChud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZ18yKQ0KDQpud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50IDwtIHN0cl9zcGxpdF9pKG53b19ncmFudHNfbmFyY2lzX2xvbmckZ3JhbnRfc3RyaW5nXzIsICIgIiwgMSkNCm53b19ncmFudHNfbmFyY2lzX2xvbmckeWVhciA8LSBzdHJfc3BsaXRfaShud29fZ3JhbnRzX25hcmNpc19sb25nJGdyYW50X3N0cmluZ18yLCAiICIsIDIpDQpud29fZ3JhbnRzX25hcmNpc19sb25nJHllYXIgPC0gc3RyX3NwbGl0X2kobndvX2dyYW50c19uYXJjaXNfbG9uZyR5ZWFyLCAiLyIsIDEpDQoNCg0KIyBnZXQgdGhlIGZpbmFsIGRhdGFmcmFtZQ0KbndvX2dyYW50c19uYXJjaXMgPC0gbndvX2dyYW50c19uYXJjaXNfbG9uZ1tjKCJuYXJjaXNfdXJsIiwgImdyYW50IiwgInllYXIiKV0NCm53b19ncmFudHNfbmFyY2lzJGdyYW50IDwtIHRvbG93ZXIobndvX2dyYW50c19uYXJjaXMkZ3JhbnQpDQpjb2xuYW1lcyhud29fZ3JhbnRzX25hcmNpcylbMV0gPC0gInByb2ZpbGVfaWQiDQpgYGANCg0KQ2hlY2sgaWYgb3VyIE5BUkNJUyBkYXRhIG1pc3NlZCBvdXQgb24gYW55IHNjcmFwZWQgaW5mbzoNCmBgYHtyfQ0KIyBmaXJzdCwgZ2V0IHRoZW0gaW50byB0aGUgc2FtZSBmb3JtYXQNCm53b19ncmFudHNfbmFyY2lzIDwtIG53b19ncmFudHNfbmFyY2lzW2MoY29sbmFtZXMobndvX2dyYW50cykpXQ0KbndvX2dyYW50c19uYXJjaXMkeWVhciA8LSBhcy5udW1lcmljKG53b19ncmFudHNfbmFyY2lzJHllYXIpDQpud29fZ3JhbnRzX25hcmNpcyRwZXJzb25fZ3JhbnQgPC0gcGFzdGUobndvX2dyYW50c19uYXJjaXMkcHJvZmlsZV9pZCwgbndvX2dyYW50c19uYXJjaXMkZ3JhbnQsIHNlcCA9ICJfIikNCm53b19ncmFudHMkcGVyc29uX2dyYW50IDwtIHBhc3RlKG53b19ncmFudHMkcHJvZmlsZV9pZCwgbndvX2dyYW50cyRncmFudCwgc2VwID0gIl8iKQ0KDQojIGdldCBzb21lIGdyYW50cyB3ZSBzY3JhcGVkLCBidXQgd2VyZSBub3QgaW4gdGhlIE5BUkNJUyBkYXRhLCBtb3N0IGZyb20gMjAyMg0KbndvX2dyYW50c19jaGVjayA8LSBmaWx0ZXIobndvX2dyYW50cywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICFwZXJzb25fZ3JhbnQgJWluJSBud29fZ3JhbnRzX25hcmNpcyRwZXJzb25fZ3JhbnQpDQoNCiMgYWRkIHRoZW0gdG8gdGhlIE5BUkNJUyBkYXRhDQpud29fZ3JhbnRzX25hcmNpcyA8LSByYmluZChud29fZ3JhbnRzX25hcmNpcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIG53b19ncmFudHNfY2hlY2spDQoNCm53b19ncmFudHNfbmFyY2lzIDwtIG53b19ncmFudHNfbmFyY2lzW2MoImdyYW50IiwgInllYXIiLCAicHJvZmlsZV9pZCIpXQ0KYGBgDQoNCk92ZXJ3cml0ZSB0aGUgZGF0YToNCmBgYHtyfQ0Kc2F2ZVJEUyhud29fZ3JhbnRzX25hcmNpcywgInByb2Nlc3NlZF9kYXRhL253b19ncmFudHMuUkRTIikNCmBgYA0KDQpXcml0ZSBpbnRvIGEgZGF0YWJhc2U6DQpgYGB7cn0NCmRiV3JpdGVUYWJsZShjb24sICJuYXJjaXNfbndvX2dyYW50X2luZm8iLCBud29fZ3JhbnRzX25hcmNpcywgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkgDQpgYGANCg0KVGhpcyBtaXNzZXMgRVJDIGdyYW50cy4gTm93IGFsc28gZ2V0IHRoZSBFUkMgZ3JhbnRzIGJ5IGRvd25sb2FkaW5nIHRoZSBjc3YuIGZpbGUNCmxpc3RpbmcgYWxsIER1dGNoIGdyYW50cyBmcm9tIFtoZXJlXShodHRwczovL2VyYy5lYXNtZS13ZWIuZXU/bW9kZT03JmNvdW50cmllcz1OTCk6DQpgYGB7ciB3YXJuaW5nID0gRiwgbWVzc2FnZSA9IEZ9DQplcmNfZGF0YSA8LSByZWFkX2RlbGltKCJwcm9jZXNzZWRfZGF0YS9lcmNfZGF0YS5jc3YiLCANCiAgICBkZWxpbSA9ICI7IiwgZXNjYXBlX2RvdWJsZSA9IEZBTFNFLCB0cmltX3dzID0gVFJVRSkNCmBgYA0KDQpTZWUgaWYgd2UgY2FuIG1lcmdlIEVSQyBncmFudHMgd2l0aCBwcm9mZXNzb3IgbmFtZXMgaW4gb3VyIGRhdGE6DQpgYGB7cn0NCmVyY19kYXRhJFBJIDwtIHRvbG93ZXIoZXJjX2RhdGEkUEkpDQoNCnByb2ZzJFBJIDwtIHRvbG93ZXIocGFzdGUocHJvZnMkbGFzdCwgcHJvZnMkZmlyc3QpKQ0KDQplcmNfZGF0YV9tZXJnZSA8LSBtZXJnZShlcmNfZGF0YSwNCiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZzW2MoInByb2ZpbGVfaWQiLCAiUEkiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICBieSA9ICJQSSIpDQoNCiMgZXh0cmFjdCB0aGUgeWVhcg0KZXJjX2RhdGFfbWVyZ2UkeWVhciA8LSBwYXJzZV9udW1iZXIoZXJjX2RhdGFfbWVyZ2UkYENhbGwgSURgKQ0KZXJjX2RhdGFfbWVyZ2UkeWVhciA8LSBzdHJfcmVtb3ZlKGVyY19kYXRhX21lcmdlJHllYXIsICItIikNCg0KIyB0aWR5IHVwIHRoZSBjb2xuYW1lcw0KY29sbmFtZXMoZXJjX2RhdGFfbWVyZ2UpIDwtIHRvbG93ZXIoc3RyX3JlcGxhY2VfYWxsKGNvbG5hbWVzKGVyY19kYXRhX21lcmdlKSwgIiAiLCAiXyIpKQ0KDQojIHRpZHkgdXAgdGhlIGNpdHkgY29sdW1uDQplcmNfZGF0YV9tZXJnZSRjaXR5IDwtIHN0cl90b190aXRsZShlcmNfZGF0YV9tZXJnZSRjaXR5KQ0KYGBgDQoNCldyaXRlIGludG8gYSBkYXRhYmFzZToNCmBgYHtyfQ0KZGJXcml0ZVRhYmxlKGNvbiwgImVyY19ncmFudF9pbmZvIiwgZXJjX2RhdGFfbWVyZ2UsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpIA0KYGBgDQoNCg0KDQojIENvYXV0aG9yIGRhdGENCg0KIyMgT0EgY29hdXRob3IgcHVibGljYXRpb24gZGF0YQ0KDQpXZSBhbHNvIG5lZWQsIGZvciBlYWNoIHByb2Zlc3NvciwgdGhlIG1vcmUgZGV0YWlsZWQgZGF0YSBhYm91dCB0aGVpciBjby1hdXRob3JzLiANCg0KDQpGb3IgZWFjaCBwcm9mZXNzb3IsIHdlIHdpbGwgcXVlcnkgdGhlaXIgY29hdXRob3JzJyBkYXRhLg0KV2Ugb3V0cHV0IHRoZSBmb2xsb3dpbmc6DQoxLiBBIGZ1bGwgbGlzdCBvZiBhdXRob3IncyBPQSBkYXRhDQoyLiBBIGZ1bGwgbGlzdCBvZiBhdXRob3IncyBuYW1lcw0KMy4gQSBmdWxsIGxpc3Qgb2YgYXV0aG9yJ3MgeWVhcmx5IGF0dGVudGlvbiBmcm9tIEFsdG1ldHJpYw0KDQojIyBDb2F1dGhvciBPQSBkYXRhDQoNCkZpcnN0LCBnZXQgYWxsIHRoZSBjb2F1dGhvciB5ZWFybHkgT0Egc3Rhc3Rpc3RpY3MgYW5kIGEgZnVsbCBsaXN0IG9mIG5hbWVzOg0KYGBge3J9DQojIGdldCBhbGwgdGhlIGNvYXV0aG9yIGluZm8NCmNvYXV0aG9yX2xpc3QgPC0gZGJHZXRRdWVyeShjb25uID0gY29uLCBzdGF0ZW1lbnQgPSBwYXN0ZTAoInNlbGVjdCAqIGZyb20gb2FfY29hdXRob3JfaW5mbzsiKSkNCg0KI2dldCB0aGUgdW5pcXVlIE9BIElEcyBvZiBjb2F1dGhvcnMNCmNvYXV0aG9yX29hIDwtIGNvYXV0aG9yX2xpc3QlPiUgDQogIGRpc3RpbmN0KGF1X2lkKQ0KDQpjb2F1dGhvcl9vYSA8LSBjb2F1dGhvcl9vYSRhdV9pZA0KIyBkcm9wIHJlZHVuZGFudCBkYXRhDQpybShjb2F1dGhvcl9saXN0KQ0KZ2MoKQ0KDQojIGNvYXV0aG9yIGFmZmlsaWF0aW9uIGV0YyBsaXN0DQpjb2F1dGhvcl9pbmZvX2xpc3QgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMTQpKQ0KIyBrZWVwIGEgbGlzdCBvZiBjby1hdXRob3IgbmFtZXMgd2l0aCBpbmZlcnJlZCBnZW5kZXJzIHRoYXQgd2UgY2FuIGNvbXBsZW1lbnQgZnVydGhlciBhbmQgZnVydGhlcg0KIyBhcyB3ZSBsb29wIHRocm91Z2ggdGhlIGRhdGENCmNvYXV0aG9yX25hbWVfbGlzdCA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAzKSkNCg0KcHJvZl9iYXRjaF9zaXplIDwtIDEwMDANCiMgdmVjdG9yIG9mIGluZGljZXMgdG8gbG9vcCB0aHJvdWdoDQpiYXRjaGVzIDwtIHNlcShmcm9tPTEsIHRvPWxlbmd0aChjb2F1dGhvcl9vYSksIGJ5PXByb2ZfYmF0Y2hfc2l6ZSkNCiMgdG8gYmUgYWJsZSB0byBzdWJzZXQsIGFsc28gYWRkIHRoZSBmaW5hbCBpbmRleCsxDQpiYXRjaGVzIDwtIGMoYmF0Y2hlcywgbGVuZ3RoKGNvYXV0aG9yX29hKSsxKQ0KDQoNCiMgcXVlcnkgYWRkaXRpb25hbCBwcm9mIGluZm8NCmZvcihpIGluIDE6KGxlbmd0aChiYXRjaGVzKS0xKSl7DQogICMgZ2V0IHRoZSBuYXJjaXMgaWRzIGZyb20gdGhlIGJhdGNoDQogIHByb2ZfYmF0Y2ggPC0gY29hdXRob3Jfb2FbYmF0Y2hlc1tpXTooYmF0Y2hlc1tpKzFdLTEpXQ0KICBwcm9mX2NvYXV0aG9yX2luZm9fb2EgPC0gTkENCiAgDQogIHRyeShwcm9mX2NvYXV0aG9yX2luZm9fb2EgPC0gb2FfZmV0Y2goDQogICAgZW50aXR5ID0gImF1dGhvcnMiLCANCiAgICBvcGVuYWxleF9pZCA9IHByb2ZfYmF0Y2gpKQ0KICANCiAgaWYgKCFhbGwoaXMubmEocHJvZl9jb2F1dGhvcl9pbmZvX29hKSkpew0KICAgIA0KICAgICMgdW5uZXN0IHRoZSBkYXRhIA0KICAgIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QgPC0gdW5uZXN0KHByb2ZfY29hdXRob3JfaW5mb19vYSwgY29scyA9IGMoY291bnRzX2J5X3llYXIpLCBuYW1lc19zZXAgPSAiXyIpJT4lDQogICAgICBzZWxlY3QoLXhfY29uY2VwdHMpDQogICAgDQogICAgIyBnZXQgdGhlaXIgbmFtZXMNCiAgICAjIGZpcnN0LCBnZXQgYWxsIHRoZSBuYW1lIGFsdGVybmF0aXZlcyBhcyB3ZWxsDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zIDwtIHByb2ZfY29hdXRob3JfaW5mb19vYSAlPiUNCiAgICAgIHNlbGVjdChpZCwgZGlzcGxheV9uYW1lLCBkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzKSU+JQ0KICAgICAgdW5uZXN0KC4sIGNvbHMgPSBjKGRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMpKQ0KICAgICMgd2lkZSB0byBsb25nLCB3aXRoIGFsbCB2YXJpYXRpb25zDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zIDwtIGdhdGhlcihjb2F1dGhvcl9uYW1lX3ZhcmlhdGlvbnMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxfbmFtZSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6ZGlzcGxheV9uYW1lX2FsdGVybmF0aXZlcywgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3Jfa2V5PUZBTFNFKQ0KICAgIA0KICAgICMgbm93LCBpZGVudGlmeSB3aGljaCBvbmVzIGFyZSBhY3R1YWx5IG5hbWVzLCBhbmQgbm90IGp1c3QgaW5pdGlhbHMNCiAgICAjIGdldCB0aGUgZmlyc3Qgd29yZCwgYW5kIGRldGVjdCBpZiBsb25nZXIgdGhhbiAxIGNoYXJhY3RlciBhbmQvb3IgZG9lcyBub3QgY29udGFpbiBhbnkgZnVsbCBzdG9wcw0KICAgIGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRmaXJzdCA8LSB3b3JkKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRmdWxsX25hbWUsIDEpDQogICAgY29hdXRob3JfbmFtZV92YXJpYXRpb25zJHZhbGlkX25hbWUgPC0gaWZlbHNlKHN0cl9kZXRlY3QoY29hdXRob3JfbmFtZV92YXJpYXRpb25zJGZpcnN0LCAiXFwuIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJGQUxTRSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJUUlVFIikNCiAgICAjIGdldCB0aGUgbmFtZSB2YXJpYXRpb24gbGVuZ3Rocw0KICAgIGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRsZW5ndGhfZmlyc3QgPC0gIG5jaGFyKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucyRmaXJzdCkgDQogICAgY29hdXRob3JfbmFtZXMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQogICAgIyBsZWF2ZSBvbmx5IHRoZSBvbmVzIHdoZXJlIHdlIHNlZW0gdG8gaGF2ZSBhIHNob3J0ZXN0IG5hbWUgbG9uZ2VyIHRoYW4gMiBjaGFyYWN0ZXJzDQogICAgY29hdXRob3JfbmFtZXMgPC0gZmlsdGVyKGNvYXV0aG9yX25hbWVfdmFyaWF0aW9ucywgdmFsaWRfbmFtZSA9PSBUUlVFKSU+JQ0KICAgICAgZ3JvdXBfYnkoaWQpJT4lDQogICAgICBzbGljZSh3aGljaC5tYXgobGVuZ3RoX2ZpcnN0KSklPiUNCiAgICAgIGZpbHRlciguLCBsZW5ndGhfZmlyc3QgPiAyKSU+JQ0KICAgICAgc2VsZWN0KC12YWxpZF9uYW1lLCAtbGVuZ3RoX2ZpcnN0LCAtdHlwZSkNCiAgICANCiAgICAjIGFwcGVuZCB0aGUgbmV3IG5hbWVzIHRvIHRoZSBuYW1lcyBkYXRhZnJhbWUNCiAgICBpZiAoIWFsbChpcy5uYShjb2F1dGhvcl9uYW1lcykpKXsNCiAgICAgIG5ld19uYW1lcyA8LSBmaWx0ZXIoY29hdXRob3JfbmFtZXMsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAhIGlkICVpbiUgY29hdXRob3JfbmFtZV9saXN0JGlkKQ0KICAgICAgY29hdXRob3JfbmFtZV9saXN0IDwtIHJiaW5kKGNvYXV0aG9yX25hbWVfbGlzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfbmFtZXMpDQogICAgfQ0KICAgIA0KICAgICMgc2VsZWN0IHByb2YgaW5mbw0KICAgIGNvYXV0aG9yX2luZm8gPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMTQpKQ0KICAgIGNvbHVtbnMgPC0gYygiaWQiLCAiZGlzcGxheV9uYW1lIiwgIm9yY2lkIiwgIndvcmtzX2NvdW50IiwNCiAgICAgICAgICAgICAgICAgImNpdGVkX2J5X2NvdW50IiwgImNvdW50c19ieV95ZWFyX3llYXIiLCAiY291bnRzX2J5X3llYXJfd29ya3NfY291bnQiLCANCiAgICAgICAgICAgICAgICAgImNvdW50c19ieV95ZWFyX2NpdGVkX2J5X2NvdW50IiwgImFmZmlsaWF0aW9uX2Rpc3BsYXlfbmFtZSIsIA0KICAgICAgICAgICAgICAgICAiYWZmaWxpYXRpb25faWQiLCAiYWZmaWxpYXRpb25fcm9yIiwgImFmZmlsaWF0aW9uX2NvdW50cnlfY29kZSIsDQogICAgICAgICAgICAgICAgICJhZmZpbGlhdGlvbl90eXBlIiwgIndvcmtzX2FwaV91cmwiKQ0KICAgICMgcGFkZGluZyBpbiBjYXNlIHNvbWUgY29sdW1ucyBhcmUgbWlzc2luZw0KICAgIGlmKCFhbGwoY29sdW1ucyAlaW4lIGNvbG5hbWVzKHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QpKSl7DQogICAgICBuX21pc3NpbmcgPC0gd2hpY2goIWNvbHVtbnMgJWluJSBjb2xuYW1lcyhwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0KSkNCiAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGNvbHVtbnNbd2hpY2goIWNvbHVtbnMgJWluJSBjb2xuYW1lcyhwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0KSldDQogICAgICBwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0IDwtIGJpbmRfY29scyhwcm9mX2NvYXV0aG9yX2luZm9fb2FfdW5uZXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QgPC0gcHJvZl9jb2F1dGhvcl9pbmZvX29hX3VubmVzdFtjb2x1bW5zXQ0KICAgIH0NCiAgICANCiAgICBjb2F1dGhvcl9pbmZvIDwtIHByb2ZfY29hdXRob3JfaW5mb19vYV91bm5lc3QlPiUNCiAgICAgIHNlbGVjdChpZCwgZGlzcGxheV9uYW1lLCBvcmNpZCwgd29ya3NfY291bnQsDQogICAgICAgICAgICAgY2l0ZWRfYnlfY291bnQsIGNvdW50c19ieV95ZWFyX3llYXIsIGNvdW50c19ieV95ZWFyX3dvcmtzX2NvdW50LCANCiAgICAgICAgICAgICBjb3VudHNfYnlfeWVhcl9jaXRlZF9ieV9jb3VudCwgYWZmaWxpYXRpb25fZGlzcGxheV9uYW1lLCANCiAgICAgICAgICAgICBhZmZpbGlhdGlvbl9pZCwgYWZmaWxpYXRpb25fcm9yLCBhZmZpbGlhdGlvbl9jb3VudHJ5X2NvZGUsDQogICAgICAgICAgICAgYWZmaWxpYXRpb25fdHlwZSwgd29ya3NfYXBpX3VybCkNCiAgICANCiAgICAjIGFwcGVuZCB0aGUgbmV3IGluZm8gdG8gdGhlIGluZm8gZGF0YWZyYW1lDQogICAgaWYgKCFhbGwoaXMubmEoY29hdXRob3JfaW5mbykpKXsNCiAgICAgIG5ld19pbmZvIDwtIGZpbHRlcihjb2F1dGhvcl9pbmZvLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAhIGlkICVpbiUgY29hdXRob3JfaW5mb19saXN0JGlkKQ0KICAgICAgDQogICAgICBjb2F1dGhvcl9pbmZvX2xpc3QgPC0gcmJpbmQoY29hdXRob3JfaW5mb19saXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19pbmZvKQ0KICAgIH0NCiAgfQ0KICANCiAgcHJpbnQocGFzdGUoImRvbmUgd2l0aCIsIGksICJvdXQgb2YiLCBsZW5ndGgoYmF0Y2hlcykpKQ0KfQ0KDQpkYldyaXRlVGFibGUoY29uLCAib2FfY29hdXRob3JfaW5mb19mdWxsIiwgY29hdXRob3JfaW5mb19saXN0LCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KDQpkYldyaXRlVGFibGUoY29uLCAib2FfY29hdXRob3JfbmFtZV9saXN0IiwgY29hdXRob3JfbmFtZV9saXN0LCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KYGBgDQoNCldlIGhhdmUgMSAzNzEgODEwIHVuaXF1ZSBjb2F1dGhvcnMgd2UgZmV0Y2hlZCB0aGUgZGF0YSBmb3IsIGFuZCAxNzcgODIzIHVuaXF1ZSBmaXJzdCBuYW1lcy4gDQoNCldyaXRlIG91dCB1bmlxdWUgY29tYmluYXRpb25zIG9mIHBhcGVycywgY29hdXRob3JzLCBhbmQgcHJvZmVzc29yczoNCmBgYHtyfQ0Kb2FfY29hdXRob3JfbWF0Y2hpbmcgPC0gY29hdXRob3JfaW5mb19saXN0ICU+JSBkaXN0aW5jdChpZCwgb2FfaWQsIHByb2ZpbGVfaWQsIC5rZWVwX2FsbCA9IFRSVUUpDQoNCmRiV3JpdGVUYWJsZShjb24sICJvYV9jb2F1dGhvcl9tYXRjaGluZyIsIG9hX2NvYXV0aG9yX21hdGNoaW5nLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KYGBgDQoNCg0KIyMgQ29hdXRob3IgQWx0bWV0cmljIGF0dGVudGlvbiAocGVyIE9SQ0lEKQ0KDQpVc2UgdGhlIHNhbWUgY29hdXRob3IgbGlzdCwgYnV0IG5vdyB0byBwdWxsIHRoZSBhdHRlbnRpb24gZGF0YSBmcm9tIEFsdG1ldHJpYy4NCk9ubHkgcHVsbCB0aGUgZGF0YSBmb3IgdGhvc2UgY29hdXRob3JzIHdobw0KYGBge3J9DQojIGdldCB0aGUgY29hdXRob3JzaGlwIGxpc3QNCmNvYXV0aG9yX2xpc3QgPC0gZGJSZWFkVGFibGUoY29uLCAib2FfY29hdXRob3JfaW5mbyIpDQoNCiMgdW5pcXVlIElEcw0KY29hdXRob3JfYWx0bWV0cmljX2xpc3QgPC0gZGlzdGluY3QoY29hdXRob3JfbGlzdCwgYXVfaWQsIC5rZWVwX2FsbCA9IFRSVUUpDQojIHdlIGhhdmUgMSAzNDQgNTA4IG9mIHRoZXNlDQpsZW5ndGgodW5pcXVlKGNvYXV0aG9yX2FsdG1ldHJpY19saXN0JGF1X2lkKSkNCg0KIyBsZWF2ZSBvbmx5IHRob3NlIHdpdGggT1JDSUQgSURzDQpjb2F1dGhvcl9hbHRtZXRyaWNfbGlzdCA8LSBmaWx0ZXIoY29hdXRob3JfYWx0bWV0cmljX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzLm5hKGF1X29yY2lkKSkNCg0KIyB0aGlzIGxlYXZlcyB1cyB3aXRoIG9ubHkgNDU3IDIwMCBJRHMNCmxlbmd0aCh1bmlxdWUoY29hdXRob3JfYWx0bWV0cmljX2xpc3QkYXVfb3JjaWQpKQ0KDQojIGRyb3AgcmVkdW5kYW50IGRhdGENCnJtKGNvYXV0aG9yX2xpc3QpDQpnYygpDQpgYGANCg0KTG9vcCB0aHJvdWdoIHRoZSBPUkNJRHMgYW5kIGdldCBhdXRob3JzJyBhdHRlbnRpb246DQpgYGB7ciB3YXJuaW5nID0gRiwgbWVzc2FnZSA9IEZ9DQpjb2F1dGhvcl9hdHRlbnRpb25fbGlzdCA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSA0KSkNCmNvbG5hbWVzKGNvYXV0aG9yX2F0dGVudGlvbl9saXN0KSA8LSBjKCJtZW50aW9uX3R5cGUiLCAieWVhciIsICJ5ZWFybHlfY291bnQiLCAiaWQiKQ0KDQpmb3IgKGkgaW4gMTpucm93KGNvYXV0aG9yX2FsdG1ldHJpY19saXN0KSl7DQogICMgbm90IHN1cmUgdGhpcyBpcyBjb3JyZWN0IQ0KICBvcmNpZCA8LSBjb2F1dGhvcl9hbHRtZXRyaWNfbGlzdCRhdV9vcmNpZFtpXQ0KICBjb2F1dGhvcl9hdHRlbnRpb24gPC0gTkENCiAgIyBxdWVyeSB0aGUgaW5mbw0KICB0cnkoY29hdXRob3JfYXR0ZW50aW9uIDwtIGFsdG1ldHJpY19hcGlfb3JjaWRfY2FsbGVyKG9yY2lkID0gb3JjaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpX3NlY3JldCA9IGFwaV9zZWNyZXQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleSA9IGFwaV9rZXksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQgPSAiYXR0ZW50aW9uIikpDQogIA0KICAjIGlmIGFueSBkYXRhLCB1bm5lc3QgdHdpY2UgdG8gdW5yYXZlbCB0aGUgaW5mbw0KICBpZiAoIWFsbChpcy5uYShjb2F1dGhvcl9hdHRlbnRpb24pKSl7DQogICAgI2RlZHVwbGljYXRlDQogICAgY29hdXRob3JfYXR0ZW50aW9uIDwtIGNvYXV0aG9yX2F0dGVudGlvbiAlPiUgZGlzdGluY3QoaWQsIC5rZWVwX2FsbCA9ICBUUlVFKQ0KICAgIGNvYXV0aG9yX2F0dGVudGlvbiA8LSB1bm5lc3QoY29hdXRob3JfYXR0ZW50aW9uLCBjb2xzID0gYygibWV0YSIpKQ0KICAgIGNvYXV0aG9yX2F0dGVudGlvbiA8LSB1bm5lc3QoY29hdXRob3JfYXR0ZW50aW9uLCBjb2xzID0gYygiZGF0ZXMiKSkNCiAgICAjIG5vdywgZXh0cmFjdCB0aGUgeWVhciBhbmQgZ3JvdXAgbWVudGlvbnMgYnkgeWVhcg0KICAgIGNvYXV0aG9yX2F0dGVudGlvbiR5ZWFyIDwtIHllYXIoeW1kKGNvYXV0aG9yX2F0dGVudGlvbiRkYXRlKSkNCiAgICBjb2F1dGhvcl9hdHRlbnRpb25feWVhciA8LSBjb2F1dGhvcl9hdHRlbnRpb24gJT4lDQogICAgICBncm91cF9ieShpZCwgeWVhciklPiUNCiAgICAgIHN1bW1hcmlzZSh5ZWFybHlfY291bnQgPSBzdW0oY291bnQpKQ0KICAgICMgdGlkeSB1cCB0aGUgY29sdW1uIG5hbWVzDQogICAgY29sbmFtZXMoY29hdXRob3JfYXR0ZW50aW9uX3llYXIpWzFdIDwtIGMoIm1lbnRpb25fdHlwZSIpDQogICAgIyBhZGQgaW4gdGhlIGNvYXV0aG9yIE9BIElEDQogICAgY29hdXRob3JfYXR0ZW50aW9uX3llYXIkaWQgPC0gY29hdXRob3JfYWx0bWV0cmljX2xpc3QkYXVfaWRbaV0NCiAgICANCiAgICBpZiAobnJvdyhjb2F1dGhvcl9hdHRlbnRpb25feWVhcik+MCl7DQogICAgICAjIGZpbHRlciBvdXQgdGhlIGR1cGxpY2F0ZXMNCiAgICAgIGNvYXV0aG9yX2F0dGVudGlvbl95ZWFyIDwtIGZpbHRlcihjb2F1dGhvcl9hdHRlbnRpb25feWVhciwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISBpZCAlaW4lIGNvYXV0aG9yX2F0dGVudGlvbl9saXN0JGlkKQ0KICAgICAgDQogICAgICBjb2F1dGhvcl9hdHRlbnRpb25fbGlzdCA8LSByYmluZChjb2F1dGhvcl9hdHRlbnRpb25fbGlzdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvYXV0aG9yX2F0dGVudGlvbl95ZWFyKQ0KICAgIH0NCiAgfQ0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIG5yb3coY29hdXRob3JfYWx0bWV0cmljX2xpc3QpKSkNCn0NCg0KZGJXcml0ZVRhYmxlKGNvbiwgImFsdG1ldHJpY19jb2F1dGhvcl9hdHRlbnRpb24iLCBjb2F1dGhvcl9hdHRlbnRpb25fbGlzdCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQoNCiMjIFRvcGljcyBmb3IgZWFjaCBwcm9mZXNzb3INCg0KRmlyc3QsIGdldCBhIGRpc3RpbmN0IHB1YmxpY2F0aW9uIGxpc3Q6DQpgYGB7cn0NCm9hX3Byb2ZfcHVicyA8LSBkYlJlYWRUYWJsZShjb24sICJvYV9wcm9mX3B1YnMiKQ0KDQpvYV9kaXN0aW5jdF9wdWJzIDwtIG9hX3Byb2ZfcHVicyU+JQ0KICBkaXN0aW5jdCguLCBpZCwgLmtlZXBfYWxsID0gVFJVRSklPiUNCiAgICBzZWxlY3QoaWQ6ZGlzcGxheV9uYW1lLCBhYjppc19yZXRyYWN0ZWQpDQoNCm9hX3Byb2ZfcHViX21hdGNoIDwtIG9hX3Byb2ZfcHVicyAlPiUNCiAgZGlzdGluY3QoLiwgaWQsIHByb2ZpbGVfaWQsIC5rZWVwX2FsbCA9IFRSVUUpJT4lDQogICAgc2VsZWN0KGlkLCBhdV9pZCwgYXVfZGlzcGxheV9uYW1lLCBvYV9pZCwgcHJvZmlsZV9pZCkNCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX2Rpc3RpbmN0X3B1YnMiLCBvYV9kaXN0aW5jdF9wdWJzKQ0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3Byb2ZfcHViX21hdGNoIiwgb2FfcHJvZl9wdWJfbWF0Y2gpDQpgYGANCg0KR2V0IHRoZSB0b3BpY3MgZm9yIGVhY2ggcHVibGljYXRpb246DQpgYGB7cn0NCiMgYmF0Y2ggc2l6ZQ0KYmF0Y2hfc2l6ZSA8LSAxMDANCiMgdmVjdG9yIG9mIGluZGljZXMgdG8gbG9vcCB0aHJvdWdoDQpiYXRjaGVzIDwtIHNlcShmcm9tPTEsIHRvPWxlbmd0aChvYV9kaXN0aW5jdF9wdWJzJGlkKSwgYnk9YmF0Y2hfc2l6ZSkNCiMgdG8gYmUgYWJsZSB0byBzdWJzZXQsIGFsc28gYWRkIHRoZSBmaW5hbCBpbmRleCsxDQpiYXRjaGVzIDwtIGMoYmF0Y2hlcywgbGVuZ3RoKG9hX2Rpc3RpbmN0X3B1YnMkaWQpKzEpDQoNCiMgcGVyIGJhdGNoDQpmb3IgKGkgaW4gMTpsZW5ndGgoYmF0Y2hlcykpew0KICAjIGdldCB0aGUgbGlzdA0KICBiYXRjaF9pZHMgPC0gb2FfZGlzdGluY3RfcHVicyRpZFtiYXRjaGVzW2ldOihiYXRjaGVzW2krMV0tMSldDQogIGJhdGNoX2lkcyA8LSBzdHJfcmVtb3ZlKGJhdGNoX2lkcywgImh0dHBzXFw6XFwvXFwvb3BlbmFsZXgub3JnXFwvIikNCiAgIyBjb2xsYXBzZSB0aGVtIHNvIHRoYXQgd2UgY2FuIGZldGNoIGFsbCBvZiB0aGVtIGF0IG9uY2UgZnJvbSB0aGUgQVBJDQogIGJhdGNoX2lkcyA8LSBwYXN0ZShiYXRjaF9pZHMsIGNvbGxhcHNlID0gInwiKQ0KICBnZXRfYXBpIDwtIGZyb21KU09OKHBhc3RlMCgiaHR0cHM6Ly9hcGkub3BlbmFsZXgub3JnL3dvcmtzP2ZpbHRlcj1pZHMub3BlbmFsZXg6IiwgYmF0Y2hfaWRzLCAiJnBlci1wYWdlPTEwMCIpKQ0KICBpZiAoJ3RvcGljcycgJWluJSBuYW1lcyhnZXRfYXBpW1sicmVzdWx0cyJdXSkpew0KICAgIHJlc3VsdF9pZHMgPC0gZ2V0X2FwaVtbInJlc3VsdHMiXV1bWyJpZCJdXQ0KICAgIHRvcGljcyA8LSBnZXRfYXBpW1sicmVzdWx0cyJdXVtbInRvcGljcyJdXQ0KICAgIGlmIChsZW5ndGgodG9waWNzKSA+IDApew0KICAgICAgdG9waWNzX2RmIDwtIGJpbmRfcm93cyh0b3BpY3MsIC5pZCA9ICJjb2x1bW5fbGFiZWwiKQ0KICAgICAgdG9waWNzX2RmIDwtIHVubmVzdCh0b3BpY3NfZGYsIGNvbHMgPSBjKHN1YmZpZWxkLCBmaWVsZCwgZG9tYWluKSwgbmFtZXNfc2VwID0gIl8iKQ0KICAgICAgY29sbmFtZXModG9waWNzX2RmKVsyXSA8LSAidG9waWNfaWQiDQogICAgICBvYV9pZF9tYXRjaGluZyA8LSBjYmluZC5kYXRhLmZyYW1lKGNvbHVtbl9sYWJlbCA9IGMoMToxMDApLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGdldF9hcGlbWyJyZXN1bHRzIl1dW1siaWQiXV0pDQogICAgICANCiAgICAgIHRvcGljc19kZiA8LSBtZXJnZSh0b3BpY3NfZGYsDQogICAgICAgICAgICAgICAgICAgICAgICAgb2FfaWRfbWF0Y2hpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAiY29sdW1uX2xhYmVsIikNCiAgICAgIA0KICAgICAgDQogICAgICBpZiAoZGJFeGlzdHNUYWJsZShjb24sICJvYV9wdWJzX3RvcGljcyIpKXsNCiAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAib2FfcHVic190b3BpY3MiKQ0KICAgICAgICAjIGlmIG5vdCBhbGwgZmllbGRzIHRoZXJlDQogICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXModG9waWNzX2RmKSkpew0KICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXModG9waWNzX2RmKSkNCiAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gZmllbGRzW3doaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyh0b3BpY3NfZGYpKV0NCiAgICAgICAgICB0b3BpY3NfZGYgPC0gYmluZF9jb2xzKHRvcGljc19kZiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICAgICAgdG9waWNzX2RmIDwtIHRvcGljc19kZltmaWVsZHNdDQogICAgICAgIH0NCiAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICB0b3BpY3NfZGYgPC0gIHRvcGljc19kZiAlPiUNCiAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgIA0KICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgIm9hX3B1YnNfdG9waWNzIiwgdG9waWNzX2RmLCByb3cubmFtZXM9TlVMTCwgYXBwZW5kPVRSVUUpDQogICAgICB9ZWxzZXsNCiAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3B1YnNfdG9waWNzIiwgdG9waWNzX2RmLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KICAgICAgfQ0KICAgIH0NCiAgfQ0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChiYXRjaGVzKSkpDQp9DQoNCiMgDQojIGZvciAob2FfaWQgaW4gb2FfZGlzdGluY3RfcHVicyRpZCl7DQojICAgIyBmZXRjaCBmcm9tIHRoZSBvZmZpY2lhbCBBUEkNCiMgICBnZXRfYXBpMiA8LSBmcm9tSlNPTihwYXN0ZSgiaHR0cHM6Ly9hcGkub3BlbmFsZXgub3JnLyIsIHN0cl9yZW1vdmUob2FfaWQsICJodHRwc1xcOlxcL1xcL29wZW5hbGV4Lm9yZ1xcLyIpLCAiJnBlci1wYWdlPTEwMCIsIHNlcCA9ICIiKSkNCiMgICBpZiAoJ3RvcGljcycgJWluJSBuYW1lcyhnZXRfYXBpKSl7DQojICAgICB0b3BpY3MgPC0gZ2V0X2FwaVtbJ3RvcGljcyddXQ0KIyAgICAgaWYgKGxlbmd0aCh0b3BpY3MpID4gMCl7DQojICAgICAgIHRvcGljcyA8LSB1bm5lc3QodG9waWNzLCBjb2xzID0gYyhzdWJmaWVsZCwgZmllbGQsIGRvbWFpbiksIG5hbWVzX3NlcCA9ICJfIikNCiMgICAgICAgY29sbmFtZXModG9waWNzKVsxXSA8LSAidG9waWNfaWQiDQojICAgICAgIHRvcGljcyRpZCA8LSBvYV9pZA0KIyAgICAgICANCiMgICAgICAgaWYgKGRiRXhpc3RzVGFibGUoY29uLCAib2FfcHVic190b3BpY3MiKSl7DQojICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQojICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJvYV9wdWJzX3RvcGljcyIpDQojICAgICAgICAgIyBpZiBub3QgYWxsIGZpZWxkcyB0aGVyZQ0KIyAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXModG9waWNzKSkpew0KIyAgICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyh0b3BpY3MpKQ0KIyAgICAgICAgICAgcGFkZGluZyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IGxlbmd0aChuX21pc3NpbmcpLCBucm93PTEpKQ0KIyAgICAgICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gZmllbGRzW3doaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyh0b3BpY3MpKV0NCiMgICAgICAgICAgIHRvcGljcyA8LSBiaW5kX2NvbHModG9waWNzLA0KIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KIyAgICAgICAgICAgdG9waWNzIDwtIHRvcGljc1tmaWVsZHNdDQojICAgICAgICAgfQ0KIyAgICAgICAgICMgb25seSBsZWF2ZSB0aGVzZSBmaWVsZHMgaW4NCiMgICAgICAgICB0b3BpY3MgPC0gIHRvcGljcyAlPiUNCiMgICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiMgICAgICAgICANCiMgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgIm9hX3B1YnNfdG9waWNzIiwgdG9waWNzLCByb3cubmFtZXM9TlVMTCwgYXBwZW5kPVRSVUUpDQojICAgICAgIH1lbHNlew0KIyAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJvYV9wdWJzX3RvcGljcyIsIHRvcGljcywgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCiMgICAgICAgfQ0KIyAgICAgICBwcmludCh3aGljaChvYV9kaXN0aW5jdF9wdWJzJGlkID09IG9hX2lkKSkNCiMgICAgIH0NCiMgICB9DQojIH0NCmBgYA0KDQoNCg0KIyMgSW5zdGl0dXRpb25hbCBhZmZpbGlhdGlvbnMNCg0KTG9hZCBwcm9mZXNzb3IgcHVibGljYXRpb25zOg0KYGBge3J9DQpvYV9wdWJzX3VuaXF1ZSA8LSBkYlJlYWRUYWJsZShjb24sICJvYV9wcm9mX3B1YnNfdW5pcXVlIikNCm9hX3Byb2ZfcHViX21hdGNoaW5nIDwtIGRiUmVhZFRhYmxlKGNvbiwgIm9hX3Byb2ZfcHViX21hdGNoIikNCg0Kb2FfaWRzIDwtIGRiUmVhZFRhYmxlKGNvbiwgIm9hX2lkX21hcHBpbmciKQ0KYGBgDQoNCkZvciBlYWNoIHByb2Zlc3NvciwgY29uc3RydWN0IGEgbGlzdCBvZiBhZmZpbGlhdGlvbnMgdGhleSd2ZSBoYWQ6DQpgYGB7cn0NCmxpc3RfcHJvZnMgPC0gdW5pcXVlKG9hX2lkcyRvYV9pZCkNCmFsbF9yZXN1bHRzIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNywgbnJvdyA9IDApKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgobGlzdF9wcm9mcykpew0KICAjIGdldCB0aGUgbGlzdA0KICBwcm9mIDwtIGxpc3RfcHJvZnNbaV0NCiAgZ2V0X2FwaSA8LSBmcm9tSlNPTihwYXN0ZTAoImh0dHBzOi8vYXBpLm9wZW5hbGV4Lm9yZy9hdXRob3JzP2ZpbHRlcj1pZHMub3BlbmFsZXg6IiwgcHJvZikpDQogIA0KICBpZiAoJ2FmZmlsaWF0aW9ucycgJWluJSBuYW1lcyhnZXRfYXBpW1sicmVzdWx0cyJdXSkpew0KICAgIHJlc3VsdF9pbnN0aXR1dGlvbnMgPC0gZ2V0X2FwaVtbInJlc3VsdHMiXV1bWyJhZmZpbGlhdGlvbnMiXV1bWzFdXVtbImluc3RpdHV0aW9uIl1dDQogICAgaWYgKCFhbGwoaXMubmEocmVzdWx0X2luc3RpdHV0aW9ucykpKXsNCiAgICAgIHJlc3VsdF9pbnN0aXR1dGlvbnMkYXVfaWQgPC0gcHJvZg0KICAgICAgYWxsX3Jlc3VsdHMgPC0gcmJpbmQuZGF0YS5mcmFtZShhbGxfcmVzdWx0cywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0X2luc3RpdHV0aW9ucykNCiAgICB9DQogIH0NCiAgcHJpbnQoaSkNCn0NCg0KDQphbGxfcmVzdWx0c19zZWwgPC0gYWxsX3Jlc3VsdHMgJT4lDQogIHNlbGVjdCgtbGluZWFnZSkNCg0KIyB3cml0ZSBvdXQgYSB0YWJsZQ0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3Byb2ZfYWZmaWxpYXRpb25zIiwgYWxsX3Jlc3VsdHNfc2VsKQ0KYGBgDQoNCkZvciBlYWNoIHVuaXF1ZSBpbnN0aXR1dGlvbiwgYWxzbyBnZXQgYWx0ZXJuYXRpdmUgbmFtZXM6DQpgYGB7cn0NCnVuaXF1ZV9pbnN0aXR1dGlvbnMgPC0gdW5pcXVlKGFsbF9yZXN1bHRzX3NlbCRpZCkNCmFsbF9pbnN0aXR1dGlvbl9uYW1lcyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IDIsIG5yb3cgPSAwKSkNCg0KZm9yIChpbnN0IGluIHVuaXF1ZV9pbnN0aXR1dGlvbnMpew0KICBnZXRfYXBpIDwtIGZyb21KU09OKHBhc3RlMCgiaHR0cHM6Ly9hcGkub3BlbmFsZXgub3JnL2luc3RpdHV0aW9ucz9maWx0ZXI9aWRzLm9wZW5hbGV4OiIsIGluc3QpKQ0KICBpZiAoJ2Rpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMnICVpbiUgbmFtZXMoZ2V0X2FwaVtbInJlc3VsdHMiXV0pKXsNCiAgICBhbHRfbmFtZXMgPC0gZ2V0X2FwaVtbInJlc3VsdHMiXV1bWyJkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzIl1dW1sxXV0NCiAgICBuYW1lIDwtIGdldF9hcGlbWyJyZXN1bHRzIl1dW1siZGlzcGxheV9uYW1lIl1dDQogICAgaW5zdGl0dXRpb25fbmFtZV9saXN0IDwtIHBhc3RlKGMobmFtZSxhbHRfbmFtZXMpLCBjb2xsYXBzZSA9ICIsICIpDQogICAgIyBnZXQgYSBsaXN0IGZvciBzdHJpbmcgbWF0Y2hpbmcNCiAgICBpbnN0aXR1dGlvbl9uYW1lX2xpc3Rfc3RyX21hdGNoIDwtIGMobmFtZSwgYWx0X25hbWVzKQ0KICAgIGluc3RpdHV0aW9uX25hbWVfbGlzdF9zdHJfbWF0Y2ggPC0gcGFzdGUwKHBhc3RlMCgiXFxiIiwgaW5zdGl0dXRpb25fbmFtZV9saXN0X3N0cl9tYXRjaCksICJcXGIiKQ0KICAgIGluc3RpdHV0aW9uX25hbWVfbGlzdF9zdHJfbWF0Y2ggPC0gcGFzdGUoaW5zdGl0dXRpb25fbmFtZV9saXN0X3N0cl9tYXRjaCwgY29sbGFwc2UgPSAifCIpDQogICAgDQogICAgaW5zdGl0dXRpb25fb3V0cHV0IDwtIGNiaW5kLmRhdGEuZnJhbWUoaWQgPSBpbnN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZXMgPSBpbnN0aXR1dGlvbl9uYW1lX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nX21hdGNoX25hbWVzID0gaW5zdGl0dXRpb25fbmFtZV9saXN0X3N0cl9tYXRjaCkNCiAgICANCiAgICBhbGxfaW5zdGl0dXRpb25fbmFtZXMgPC0gcmJpbmQuZGF0YS5mcmFtZShhbGxfaW5zdGl0dXRpb25fbmFtZXMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGl0dXRpb25fb3V0cHV0KQ0KICB9DQogIA0KICBwcmludCh3aGljaCh1bmlxdWVfaW5zdGl0dXRpb25zID09IGluc3QpKQ0KICANCn0NCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX2FmZmlsaWF0aW9uX2Rpc3BsYXlfbmFtZXMiLCBhbGxfaW5zdGl0dXRpb25fbmFtZXMpDQpgYGANCg0KRm9yIGVhY2ggcHJvZmVzc29yLCBjb21waWxlIGFsbCBpbnN0aXR1dGlvbnMgdGhleSBhcmUgYWZmaWxpYXRlZCB3aXRoIGludG8gYSBzaW5nbGUNCmZpZWxkOg0KYGBge3J9DQpsaXN0X3Byb2ZzIDwtIHVuaXF1ZShwcm9mc19mdWxsJHByb2ZpbGVfaWQpDQphbGxfcHJvZl9pbnN0X3NlYXJjaCA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IDIsIG5yb3cgPSAwKSkNCg0KZm9yIChpIGluIDE6bGVuZ3RoKGxpc3RfcHJvZnMpKXsNCiAgIyBnZXQgdGhlIGxpc3QNCiAgcHJvZiA8LSBsaXN0X3Byb2ZzW2ldDQogIA0KICBwcm9mX29hX2lkcyA8LSBmaWx0ZXIob2FfaWRzLCANCiAgICAgICAgICAgICAgICAgICBwcm9maWxlX2lkID09IHByb2YpDQogIA0KICByZWxfaW5zdCA8LSBmaWx0ZXIoYWxsX3Jlc3VsdHNfc2VsLA0KICAgICAgICAgICAgICAgICAgICAgYXVfaWQgJWluJSBwcm9mX29hX2lkcyRvYV9pZCklPiUNCiAgICBkaXN0aW5jdChpZCwgLmtlZXBfYWxsID0gVFJVRSkNCiAgDQogIGluc3RpdHV0aW9uX25hbWVzIDwtIGZpbHRlcihhbGxfaW5zdGl0dXRpb25fbmFtZXMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAlaW4lIHJlbF9pbnN0JGlkKQ0KICANCiAgaW5zdGl0dXRpb25fbmFtZXNfcHJvZiA8LSBwYXN0ZShpbnN0aXR1dGlvbl9uYW1lcyRzdHJpbmdfbWF0Y2hfbmFtZXMsIGNvbGxhcHNlID0gInwiKQ0KICANCiAgcHJvZl9pbnN0X3NlYXJjaCA8LSBjYmluZC5kYXRhLmZyYW1lKGF1X2lkID0gcHJvZiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdfbWF0Y2hfbmFtZXMgPSBpbnN0aXR1dGlvbl9uYW1lc19wcm9mKQ0KICANCiAgYWxsX3Byb2ZfaW5zdF9zZWFyY2ggPC0gcmJpbmQuZGF0YS5mcmFtZShhbGxfcHJvZl9pbnN0X3NlYXJjaCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2luc3Rfc2VhcmNoKQ0KICANCiAgcHJpbnQoaSkNCn0NCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX2FmZmlsaWF0aW9uX3N0cmluZ19zZWFyY2giLCBhbGxfcHJvZl9pbnN0X3NlYXJjaCkNCg0KYGBgDQo=</div>
>>>>>>> parent of 00d84a7 (code update)


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("OpenAlex_Altmetric_data_download.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
