<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ana Macanovic" />

<meta name="date" content="2024-01-06" />

<title>OpenAlex_Altmetric_data_download</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a>
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="index.html">Code homepage</a>
</li>
<li>
  <a href="OpenAlex_Altmetric_data_download.html">Open Alex and Altmetric data download</a>
</li>
<li>
  <a href="SQL_tutorial.html">SQL database manual</a>
</li>
<li>
  <a href="Prof_gender.html">Professor gender inference</a>
</li>
<li>
  <a href="Grant_parsing.html">Grant parsing</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/amacanovic/dutch_media_profs">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">OpenAlex_Altmetric_data_download</h1>
<h4 class="author">Ana Macanovic</h4>
<h4 class="date">2024-01-06</h4>

</div>


<p>This script uses OpenAlex database to download data on the professors
in our sample</p>
<p>Load the packages:</p>
<pre class="r"><code>library(groundhog)
packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;openalexR&quot;,
                      &quot;ggplot2&quot;, &quot;stringr&quot;, &quot;tidyr&quot;,
                      &quot;jsonlite&quot;, &quot;xml2&quot;, &quot;tidyverse&quot;,
                      &quot;RPostgres&quot;,
                      &quot;DBI&quot;, &quot;RODBC&quot;, &quot;odbc&quot;)
groundhog.library(packages_to_load, date = &quot;2023-12-01&quot;)

# we&#39;ve also added our email to the &quot;polite pool&quot; of OpenAlex by
# adding a line in the .Rprofile</code></pre>
<div id="tidy-up-professor-data-from-narcis" class="section level1"
number="1">
<h1><span class="header-section-number">1</span> Tidy up professor data
from NARCIS</h1>
<p>Load the professor profiles:</p>
<pre class="r"><code>load(&quot;raw_data/media_profs_profiles.rda&quot;)
profs &lt;- read_csv(&quot;raw_data/dutch_profs_urls.csv&quot;)

# merge the profs with their ORCIDs
colnames(profs)[c(1,7)] &lt;- c(&quot;id&quot;, &quot;profile_id&quot;)

profs_full &lt;- merge(profs,
                    metadf[, c(1:4, 361)],
                    by = &quot;profile_id&quot;)</code></pre>
</div>
<div id="tidy-up-the-publication-data-from-narcis"
class="section level1" number="2">
<h1><span class="header-section-number">2</span> Tidy up the publication
data from NARCIS</h1>
<p>Load the publication data:</p>
<pre class="r"><code># fetch the papers
load(&quot;~/Postdoc/Projects/dutch_media_profs_r/raw_data/media_profs_pubs.rda&quot;)
# match the publication data to authorships
load(&quot;~/Postdoc/Projects/dutch_media_profs_r/raw_data/media_profs_pub_to_profile_ids.rda&quot;)
colnames(pub_to_profile_id)[1] &lt;- &quot;narcis_url&quot;

prof_pubs_full &lt;- merge(pubs_metadf[, c(1:23)],
                        pub_to_profile_id,
                        by = &quot;narcis_url&quot;)
# strip the last / from the profile ids here
prof_pubs_full$profile_id &lt;- str_sub(prof_pubs_full$profile_id, end = -2)

# tidy up some misbehaving DOIs
prof_pubs_full$n_words &lt;- str_count(prof_pubs_full$DOI, &quot; &quot;)

# let&#39;s manually fix them since there are so few problematic ones
pubs_doi_words &lt;- filter(prof_pubs_full, n_words &gt; 0)
# these are just the DOIs where we have manually removed the spaces or redundant text
pubs_doi_words$DOI &lt;- c(&quot;10.1016/j.jhydrol.2011.03.047&quot;, &quot;10.1111/j.1365-3091.2012.01365.x&quot;,   
                         &quot;10.1120/jacmp.v17i4.6117&quot;, &quot;10.22203/ecm.v032a11&quot;,  
                         &quot;10.22203/ecm.v032a11&quot;, &quot;10.1167/iovs.16-20799&quot;,  
                         &quot;10.1136/bmjsem-2018-000427&quot;, &quot;10.1111/hae.12353&quot;,
                         &quot;10.1128/iai.64.10.4220-4225.1996&quot;, &quot;10.1039/b302097e&quot;,       
                         &quot;10.1039/b302097e&quot;, &quot;10.1016/s0016-5085(19)38052-7&quot;,
                         &quot;10.1039/b209378b&quot;, &quot;10.3850/978-981-07-2615-7-290&quot;,      
                         &quot;10.3850/978-981-07-2615-7 289&quot;, &quot;10.1016/s0040-6090(96)09248-6&quot;,    
                         &quot;10.1061(asce)mt.1943-5533.0002169&quot;, &quot;10.1371/journal.pone.0059600&quot;,     
                         &quot;10.1371/journal.pone.0059600&quot;, &quot;10.1371/journal.pone.0059600&quot;,     
                         &quot;10.1109/isbi.2016.7493532&quot;, &quot;10.1109/isbi.2016.7493532&quot;,         
                         &quot;10.1109/isbi.2016.7493532&quot;, &quot;10.1109/isbi.2016.7493532&quot;,         
                         &quot;10.1109/isbi.2016.7493532&quot;, &quot;10.1080/03797720120082651&quot;,         
                         &quot;10.3850/978-981-11-2724-3_0641-cd&quot;, &quot;10.3850/978-981-11-2724-3_0641-cd&quot;, 
                         &quot;10.3850/978-981-11-2724-3_0596-cd&quot;, &quot;10.1136/bmjopen-2017-016077&quot;,       
                         &quot;10.1103/physrevlett.115.159901&quot;, &quot;10.1515/lingvan-2016-0048&quot;,         
                         &quot;10.1108/jfrc-07-2018-0103&quot;, &quot;10.1097/01.brs.0000206381.15224.0&quot;,
                         &quot;10.1080/21507740.2016.1251990&quot;, &quot;10.1021/ie0492449 s0888-5885(04)09244-9&quot;,  
                         &quot;10.1021/ie0492449 s0888-5885(04)09244-9&quot;, &quot;10.2478/v10304-012-0011-y&quot;,   
                         &quot;10.1007/s10853-011-5682-6&quot;, &quot;10.1021/ja0455650s0002-7863(04)05565-9&quot;,   
                         &quot;10.1021/jo0401220-s0022-3263(04)00122-7&quot;,&quot;10.1007/s10103-008-0626-3&quot;,  
                         &quot;10.1371/journal.pone.0216743&quot;, &quot;10.1177/0021886316672724&quot;,         
                         &quot;10.5194/se-10-517-2019&quot;, &quot;10.18690/978-961-286-061-5.3&quot;,      
                         &quot;10.18690/978-961-286-061-5.3&quot;, &quot;10.3850/978-981-11-2724-3_0441-cd&quot;, 
                         &quot;10.3850/978-981-11-2725-0-is3-5-cd&quot;, &quot;10.3390/atmos12121633&quot;,  
                         &quot;10.3850/978-981-14-8593-0-4139-cd&quot;, &quot;10.3850/978-981-11-2724-3_0248-cd&quot;) 
# fix the pub list
# filter out the problematic dois
prof_pubs_full_fix &lt;- filter(prof_pubs_full, (is.na(n_words)|n_words == 0))
# and then put them back
prof_pubs_full &lt;- rbind(prof_pubs_full_fix,
                        pubs_doi_words)


# drop large files from the memory as we don&#39;t need them anymore
rm(pubs_metadf)
rm(metadf)
rm(pub_to_profile_id)
gc()</code></pre>
</div>
<div id="define-the-data-querying-functions" class="section level1"
number="3">
<h1><span class="header-section-number">3</span> Define the data
querying functions</h1>
<div id="seek-professor-identifiers-in-openalex" class="section level2"
number="3.1">
<h2><span class="header-section-number">3.1</span> Seek professor
identifiers in OpenAlex</h2>
<p>Define the function that helps us seek identifiers from: 1.
Professor’s Narcis publication list (based on DOI) 2. Professor’s ORCID
as in Narcis 3. Professor’s name + NL as the country of their last known
institution</p>
<p>This diagram describes how we do it: <img
src="images/professor_identifier_retriever_diagram.png"
alt="Figure 1" /></p>
<pre class="r"><code>professor_identifier_retriever &lt;- function(narcis_id,
                                           pub_data,
                                           prof_data){
  
  # set all the identifiers to NA
  oa_ids_pubs &lt;- NA
  oa_ids_names &lt;- NA
  oa_ids_orcid &lt;- NA
  prof_orcid &lt;- NA
  prof_name &lt;- NA
  prof_name_w_initials &lt;- NA
  prof_name_w_initials_space &lt;- NA
  prof_initials_wo_first_name &lt;- NA
  prof_initials_wo_first_name_space &lt;- NA
  prof_name_first_initials &lt;- NA
  prof_name_first_initials_space &lt;- NA
  prof_alternative_full_name &lt;- NA
  
  # get the professor&#39;s narcis id anad get their publications based on this
  prof_pubs &lt;- filter(pub_data, profile_id == narcis_id)
  
  # get their name
  prof_name_details &lt;- filter(prof_data, profile_id == narcis_id)
  prof_orcid &lt;- prof_name_details$ORCID
  prof_name &lt;- paste(prof_name_details$first, 
                     prof_name_details$last)
  
  # get the name, initials, etc combinations
  # convert the special characters
  prof_name_details[, 4:11] &lt;- iconv(prof_name_details[, 4:11], to=&#39;ASCII//TRANSLIT&#39;)
  
  # get first/last name
  prof_name &lt;- paste(
    prof_name_details$first, 
    prof_name_details$last)
  prof_name &lt;- paste0(&quot;^&quot;,
                      prof_name,
                      &quot;$&quot;)
  # get their initials, drop their name in the brackets
  prof_initials &lt;- str_squish(str_split_i(prof_name_details$initialen, &quot;\\(&quot;, 1))
  # but some profs might have a roepnaam which is not the name they use
  # to sign their papers (the brackets will contain the roepnaam, but the
  # initials will be containing the actual first name)
  # get an additional option w/o the first name at all
  prof_initials_wo_first_name &lt;- paste(str_split(prof_initials, &quot;\\.&quot;)[[1]], collapse = &quot;.&quot;)
  # and space them out
  prof_initials_wo_first_name_space &lt;- paste(str_split(prof_initials, &quot;\\.&quot;)[[1]], collapse = &quot;. &quot;)
  
  # get the initials
  prof_initials &lt;- str_split(prof_initials, &quot;\\.&quot;)[[1]][-c(1, length(str_split(prof_initials, &quot;\\.&quot;)[[1]]))]
  prof_initials_no_space &lt;- paste0(paste(prof_initials, collapse = &quot;.&quot;), &quot;.&quot;)
  prof_initials_space &lt;- paste0(paste(prof_initials, collapse = &quot;. &quot;), &quot;.&quot;)
  # professor first name, initials, last name
  prof_name_w_initials &lt;-  tolower(paste(prof_name_details$first, 
                                         prof_initials_no_space,
                                         prof_name_details$last))
  # tidy up
  prof_name_w_initials &lt;- paste0(&quot;^&quot;, 
                                 str_replace(str_replace(prof_name_w_initials, &quot; \\. &quot;, &quot; &quot;), &quot;\\.\\.&quot;, &quot; &quot;),
                                 &quot;$&quot;)
  
  # professor first name, initials, last name, with spaces between the initials
  prof_name_w_initials_space &lt;-  tolower(paste(
    prof_name_details$first, 
    prof_initials_space,
    prof_name_details$last))
  
  # tidy up
  prof_name_w_initials_space &lt;- paste0(&quot;^&quot;, 
                                       str_replace(str_replace(prof_name_w_initials_space, &quot; \\. &quot;, &quot; &quot;), &quot;\\.\\.&quot;, &quot; &quot;),
                                       &quot;$&quot;)
  
  # just the first letter of the name + initials
  # with spacing
  first_initials_space &lt;- paste(paste0(substring(prof_name_details$first, 1, 1), &quot;.&quot;),
                                prof_initials_space)
  
  prof_name_first_initials_space &lt;- tolower(paste(first_initials_space, 
                                                  prof_name_details$last))
  # tidy up
  prof_name_first_initials_space &lt;- paste0(&quot;^&quot;, 
                                           str_replace(str_replace(prof_name_first_initials_space, &quot; \\. &quot;, &quot; &quot;), &quot;\\.\\.&quot;, &quot;.&quot;),
                                           &quot;$&quot;)
  
  # w/o spacing
  first_initials &lt;- str_remove_all(paste(paste0(substring(prof_name_details$first, 1, 1), 
                                                &quot;.&quot;),
                                         prof_initials_space), &quot; &quot;)
  
  prof_name_first_initials &lt;- tolower(paste(first_initials, 
                                            prof_name_details$last))
  
  # tidy up
  prof_name_first_initials &lt;- paste0(&quot;^&quot;, 
                                     str_replace(str_replace(prof_name_first_initials, &quot; \\. &quot;, &quot; &quot;), &quot;\\.\\.&quot;, &quot; &quot;),
                                     &quot;$&quot;)
  
  # for some professors, we manually find their actual name vs their roepnaam in NARCIS
  if (narcis_id == &quot;https://www.narcis.nl/person/RecordID/PRS1239190&quot;){
    prof_alternative_full_name &lt;- tolower(&quot;\\bAlbert M. Brouwer\\b&quot;)
  }
  if (narcis_id == &quot;https://www.narcis.nl/person/RecordID/PRS1238045&quot;){
    prof_alternative_full_name &lt;- tolower(&quot;\\bJean-Bernard Martens\\b&quot;)
  }
  
  
  # get the DOI list without the NAs
  doi_list &lt;- prof_pubs$DOI[!is.na(prof_pubs$DOI)]
  prof_alternative_full_name &lt;- NA
  
  # try to get the IDs
  if (all(is.na(oa_ids_pubs))){
    # if any DOIs in our list:
    if (length(doi_list)&gt;0){
      
      # call OpenAlex to get their works based on the DOIs
      # do it in batches (currently 25)
      batch_size &lt;- 25
      batches &lt;- ceiling(length(doi_list)/batch_size)
      prof_works_oa &lt;- data.frame(matrix(NA, ncol = 16, nrow = 0))
      begin_batch &lt;- 1
      end_batch &lt;- batch_size
      # initialize an empty data frame
      prof_works_oa_batch &lt;- data.frame(matrix(NA, ncol = 16, nrow = 0))
      # loop through the batches
      for(i in 1:batches){
        # get the first batch
        # try, if error, just stop
        try(
          prof_works_oa_batch &lt;- oa_fetch(
            entity = &quot;works&quot;,
            doi = doi_list[begin_batch:end_batch]), 
          silent = TRUE
        )
        # when binding, some columns might not be there
        # so to address that, check the columns
        # if the new batch has less (but only after the first batch was processed, thus i &gt; 1)
        if (i &gt; 1 &amp; length(which(!colnames(prof_works_oa) %in% colnames(prof_works_oa_batch))) &gt; 0){
          # add the missing columns filled with NAs
          prof_works_oa_batch[colnames(prof_works_oa)[which(! colnames(prof_works_oa) %in% colnames(prof_works_oa_batch))]] &lt;- NA
          # rearrange the columns
          prof_works_oa_batch &lt;- prof_works_oa_batch[colnames(prof_works_oa)]
        }
        # if the new batch has more (but only after the first batch was processed, thus i &gt; 1)
        if (i &gt; 1 &amp; length(which(! colnames(prof_works_oa_batch) %in% colnames(prof_works_oa))) &gt; 0){
          # add the missing columns filled with NAs
          prof_works_oa[colnames(prof_works_oa_batch)[which(! colnames(prof_works_oa_batch) %in% colnames(prof_works_oa))]] &lt;- NA
          # rearrange the columns
          prof_works_oa &lt;- prof_works_oa[colnames(prof_works_oa_batch)]
        }
        
        # bind to the rest
        prof_works_oa &lt;- rbind(prof_works_oa,
                               prof_works_oa_batch)
        
        # get the remaining batch size, and go to the end if less than batch size, 
        # and go for another round if more than batch size
        if (length(doi_list)-end_batch &lt;= batch_size){
          end_batch &lt;- end_batch + length(doi_list)-end_batch
        }else{
          end_batch &lt;- end_batch + batch_size
        }
        # set the beginning to the beginning + batch size
        begin_batch &lt;- begin_batch + batch_size
      }
      
      # and now loop through the authors of these papers in OpenAlex to get info
      # on the author ids OpenAlex has on them
      prof_oaid_info &lt;- data.frame(matrix(NA, nrow = 0, ncol = 13))
      # loop through the papers we retrieved, get the DOIs and author lists and try to match the
      # author to those we miss
      if (nrow(prof_works_oa) &gt; 0 &amp; !all(is.na(prof_works_oa))){
        for (i in 1:nrow(prof_works_oa)){
          author_info &lt;- c()
          info &lt;- prof_works_oa[i, c(&quot;id&quot;,&quot;display_name&quot;, &quot;doi&quot;)]
          doi_in_question &lt;- str_remove(info$doi, &quot;https://doi.org/&quot;)
          # if found and one person
          authors &lt;- prof_works_oa[i, &quot;author&quot;][[1]][[1]]
          if (class(authors) != &quot;logical&quot;){

            # remove special characters
            authors$au_display_name &lt;- iconv(authors$au_display_name, to=&#39;ASCII//TRANSLIT&#39;)
    
            # find the author with a matching name
            authors$match &lt;- grepl(prof_name, tolower(authors$au_display_name))
            # check with initials as well
            authors$match &lt;- ifelse(authors$match == FALSE,
                                    grepl(prof_name_w_initials, tolower(authors$au_display_name)),
                                    authors$match)
            # and spaced out initials
            authors$match &lt;- ifelse(authors$match == FALSE,
                                    grepl(prof_name_w_initials_space, tolower(authors$au_display_name)),
                                    authors$match)
            # and no first name, but only initials and also only spaced out initials
            authors$match &lt;- ifelse(authors$match == FALSE,
                                    grepl(prof_name_first_initials, tolower(authors$au_display_name)),
                                    authors$match)
            
            authors$match &lt;- ifelse(authors$match == FALSE,
                                    grepl(prof_name_first_initials_space, tolower(authors$au_display_name)),
                                    authors$match)
            
            # if nothing still, initials without the first name
            authors$match &lt;- ifelse(authors$match == FALSE,
                                    grepl(prof_initials_wo_first_name, tolower(authors$au_display_name)),
                                    authors$match)
            
            authors$match &lt;- ifelse(authors$match == FALSE,
                                    grepl(prof_initials_wo_first_name_space, tolower(authors$au_display_name)),
                                    authors$match)   
            # and their alternative first name we manually correct for
            authors$match &lt;- ifelse(authors$match == FALSE,
                                    grepl(prof_alternative_full_name, tolower(authors$au_display_name)),
                                    authors$match)   
            
            # fetch the author, if there is a match
            author &lt;- filter(authors, match == TRUE)
            
            if (nrow(author) == 1){
              # remove the &quot;match&quot; column
              author_info &lt;- author[, -12]
              # bind with the narcis ID for later
              author_info$profile_id &lt;- narcis_id
            }
          }
          
          prof_oaid_info &lt;- rbind(prof_oaid_info,
                                  author_info)
        }
        
        # make sure the empty oa_id did not make it in here, because then we get stuck
        # in an endless loop (or fetch things we do not want to, burdening the API)
        if (nrow(prof_oaid_info) &gt; 0){
          prof_oaid_info &lt;- filter(prof_oaid_info, au_id != &quot;https://openalex.org/A9999999999&quot;)
          # get all oa ids of the author
          oa_ids_pubs &lt;- as.character(unique(prof_oaid_info$au_id))
        }
      }
    }
  }
  
  # if no ID found:
  if (all(is.na(oa_ids_orcid))){
    # if no DOIs in our list, check if there is an ORCID we can use
    prof_orcid &lt;- prof_name_details$ORCID
    # if there&#39;s an orcid
    if (!is.na(prof_orcid)){
      # fetch professor info from ORCIDs
      prof_info &lt;- oa_fetch(
        entity = &quot;authors&quot;, 
        orcid = prof_orcid)
      
      if (!is.null(prof_info)){
        # make sure the no name ID is not in here
        prof_info &lt;- filter(prof_info, 
                            id != &quot;https://openalex.org/A9999999999&quot;)
        # now retrieve OA IDs from this
        oa_ids_orcid &lt;- as.character(unique(prof_info$id))
      }
    }
  }
  
  # if oa_ids still NA
  oa_ids_by_name &lt;- as.data.frame(matrix(NA, nrow = 0, ncol = 17))
  if (all(is.na(oa_ids_names))){
    # search by name
    oa_au_result &lt;- oa_fetch(&quot;author&quot;,
                             search = paste(prof_name_details$first, 
                                            prof_name_details$achternaam),
                             last_known_institution.country_code = &quot;NL&quot;)
    
    # if no results, try an alternative name if present
    if(!is.null(nrow(oa_au_result)) &amp; !is.na(prof_alternative_full_name)){
      oa_au_result &lt;- oa_fetch(&quot;author&quot;,
                               search = prof_alternative_full_name,
                               last_known_institution.country_code = &quot;NL&quot;)
    }
    # if still no results, try with extensive additional name displays:

# if any results, see which names are an exact match
    if(!is.null(nrow(oa_au_result))){
      
      oa_au_result$display_name &lt;- iconv(oa_au_result$display_name , to=&#39;ASCII//TRANSLIT&#39;)
      
      # find the author with a matching name
      oa_au_result$match &lt;- grepl(prof_name, tolower(oa_au_result$display_name))
      # check with initials as well
      oa_au_result$match &lt;- ifelse(oa_au_result$match == FALSE,
                                        grepl(prof_name_w_initials, tolower(oa_au_result$display_name)),
                                        oa_au_result$match)
      # and spaced out initials
      oa_au_result$match &lt;- ifelse(oa_au_result$match == FALSE,
                                        grepl(prof_name_w_initials_space, tolower(oa_au_result$display_name)),
                                        oa_au_result$match)
      # and no first name, but only initials and also only spaced out initials
      oa_au_result$match &lt;- ifelse(oa_au_result$match == FALSE,
                                        grepl(prof_name_first_initials, tolower(oa_au_result$display_name)),
                                        oa_au_result$match)
      
      oa_au_result$match &lt;- ifelse(oa_au_result$match == FALSE,
                                        grepl(prof_name_first_initials_space, tolower(oa_au_result$display_name)),
                                        oa_au_result$match)
      
      # if nothing still, initials without the first name
      oa_au_result$match &lt;- ifelse(oa_au_result$match == FALSE,
                                        grepl(prof_initials_wo_first_name, tolower(oa_au_result$display_name)),
                                        oa_au_result$match)
      
      oa_au_result$match &lt;- ifelse(oa_au_result$match == FALSE,
                                        grepl(prof_initials_wo_first_name_space, tolower(oa_au_result$display_name)),
                                        oa_au_result$match)   
      # and their alternative first name we manually correct for
      oa_au_result$match &lt;- ifelse(oa_au_result$match == FALSE,
                                        grepl(prof_alternative_full_name, tolower(oa_au_result$display_name)),
                                        oa_au_result$match)   
      
      oa_au_result &lt;- filter(oa_au_result, 
                             ids != &quot;https://openalex.org/A9999999999&quot;)
      # fetch the OA IDs if there is a match
      prof_oa_ids &lt;- filter(oa_au_result, match == TRUE)
      id_list &lt;- c()
      
      if (nrow(prof_oa_ids)&gt;0){
        oa_ids_names &lt;- prof_oa_ids$ids
        # if a list, only retain the OA IDs:
        if(class(oa_ids_names) == &quot;list&quot;){
          oa_ids_names &lt;- c()
          for (j in 1:nrow(prof_oa_ids)){
            id &lt;- prof_oa_ids$ids[[j]][&#39;openalex&#39;]
            oa_ids_names &lt;- c(oa_ids_names, id)
          }
          oa_ids_names &lt;- unname(oa_ids_names)
        }
      }
    }
  }
  # if still nothing
  if (all(is.na(oa_ids_names))){
     # try to find OA ID matches by looking at alternative OA name spellings as well
        prof_name_details &lt;- filter(profs_full, profile_id == narcis_id)
        
        oa_au_result &lt;- oa_fetch(&quot;author&quot;,
                             search = paste(prof_name_details$first, 
                                            prof_name_details$achternaam))
        
        # unlist the results
        if (!all(is.na(oa_au_result))){
          display_name_ids &lt;- data.frame(matrix(NA, nrow = 0, ncol = 2))
          for (j in 1:nrow(oa_au_result)){
            display_names &lt;- unlist(oa_au_result$display_name_alternatives[j])
            ids &lt;- unlist(oa_au_result$ids[j])[&#39;openalex&#39;]
            row &lt;- cbind.data.frame(&quot;display_name&quot; = display_names,
                                    &quot;oa_id&quot; = ids)
            rownames(row) &lt;- c()
            display_name_ids &lt;- rbind(display_name_ids,
                                      row, row.names = NULL)
          }
          
          display_name_ids$display_name &lt;- iconv(display_name_ids$display_name , to=&#39;ASCII//TRANSLIT&#39;)
      
          # find the author with a matching name
          display_name_ids$match &lt;- grepl(prof_name, tolower(display_name_ids$display_name))
          # check with initials as well
          display_name_ids$match &lt;- ifelse(display_name_ids$match == FALSE,
                                       grepl(prof_name_w_initials, tolower(display_name_ids$display_name)),
                                       display_name_ids$match)
          # and spaced out initials
          display_name_ids$match &lt;- ifelse(display_name_ids$match == FALSE,
                                       grepl(prof_name_w_initials_space, tolower(display_name_ids$display_name)),
                                       display_name_ids$match)
          # and no first name, but only initials and also only spaced out initials
          display_name_ids$match &lt;- ifelse(display_name_ids$match == FALSE,
                                       grepl(prof_name_first_initials, tolower(display_name_ids$display_name)),
                                       display_name_ids$match)
          
          display_name_ids$match &lt;- ifelse(display_name_ids$match == FALSE,
                                       grepl(prof_name_first_initials_space, tolower(display_name_ids$display_name)),
                                       display_name_ids$match)
          
          # if nothing still, initials without the first name
          display_name_ids$match &lt;- ifelse(display_name_ids$match == FALSE,
                                       grepl(prof_initials_wo_first_name, tolower(display_name_ids$display_name)),
                                       display_name_ids$match)
          
          display_name_ids$match &lt;- ifelse(display_name_ids$match == FALSE,
                                       grepl(prof_initials_wo_first_name_space, tolower(display_name_ids$display_name)),
                                       display_name_ids$match)   
          # and their alternative first name we manually correct for
          display_name_ids$match &lt;- ifelse(display_name_ids$match == FALSE,
                                       grepl(prof_alternative_full_name, tolower(display_name_ids$display_name)),
                                       display_name_ids$match) 
          
          # get the matches
          display_name_ids &lt;- filter(display_name_ids,
                                     match == TRUE)
          
          # extract
          oa_ids_names &lt;- display_name_ids$oa_id
        }
        }
  # bind into a list
  prof_search_output &lt;- list()
  prof_search_output[&#39;narcis_id&#39;] &lt;- narcis_id
  prof_search_output[&#39;oa_ids_pubs&#39;] &lt;- list(oa_ids_pubs)  
  prof_search_output[&#39;oa_ids_orcid&#39;] &lt;- list(oa_ids_orcid)
  prof_search_output[&#39;oa_ids_names&#39;] &lt;- list(oa_ids_names)
  return(prof_search_output)
}</code></pre>
<p>Loop through professors and find their identifiers:</p>
<pre class="r"><code>narcis_ids &lt;- profs_full$profile_id
prof_identifier_list &lt;- list()

for (i in 1:length(narcis_ids)){
  narcis_id &lt;- narcis_ids[i]
  
  prof_ids &lt;- NA
  
  try(prof_ids &lt;- professor_identifier_retriever(narcis_id,
                                                 pub_data = prof_pubs_full,
                                                 prof_data = profs_full)
  )
  
  prof_identifier_list[[i]] &lt;- prof_ids
  names(prof_identifier_list)[[i]] &lt;- narcis_id
  
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
  
}</code></pre>
<p>We fail to find any OA ids for some professors. Find their OA IDs
manually:</p>
<pre class="r"><code># manually get the correct search terms for the missing professors:
missing_ids &lt;- c(&quot;https://www.narcis.nl/person/RecordID/PRS1236634&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1236869&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1236960&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1237850&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238045&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238542&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238880&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1238898&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1239122&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1239606&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1239841&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1240194&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241218&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241266&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241562&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1241837&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1242035&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1242243&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1243109&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1247112&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1251650&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1253801&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1255909&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1263017&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1265503&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1273858&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1276448&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1281844&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1281845&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1281875&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1283984&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1286354&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1288340&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1288550&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1289299&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1291051&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1291919&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1291938&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1295469&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1295569&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1296313&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1297223&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1297929&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1300768&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1303552&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1304651&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1313781&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1314178&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1316068&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1317806&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1319241&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1319812&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1320174&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1321103&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1324160&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1325120&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1329166&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1331360&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1331452&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1333614&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1333801&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1334043&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1335654&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1335659&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1336365&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1336549&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1340887&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1340978&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1341557&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1342181&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1342195&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1342275&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1347897&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1348241&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1348353&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1349732&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1350328&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1350937&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351306&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351308&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351364&quot;,
                 &quot;https://www.narcis.nl/person/RecordID/PRS1351481&quot;)

missing_search_terms &lt;- c(&quot;W.H.M. Reehuis&quot;,
                          &quot;Philip H. J. G. van Huizen&quot;,
                          &quot;J.C.E. van Kollenburg&quot;,
                          &quot;A.I.M. van Mierlo&quot;,
                          &quot;Jean-Bernard Martens&quot;,
                          &quot;R.P.J.L. Tjittes&quot;,
                          &quot;J.W. Duyvendak&quot;,
                          &quot;Jean-Pierre Wils&quot;,
                          &quot;W.G. Huijgen&quot;,
                          &quot;Jan A. Bruijn&quot;,
                          &quot;Anne-Marie Korte&quot;,
                          &quot;G.W.J.M. Kampschöer&quot;,
                          NA,
                          NA,
                          &quot;m.h. corbey&quot;,
                          &quot;A.M. Lubotsky&quot;,
                          &quot;https://openalex.org/A5041930157&quot;,
                          &quot;E.F. Steennis&quot;,
                          &quot;Venugopal Venkataraman&quot;,
                          &quot;hoefte rosemarijn&quot;,
                          &quot;B.P.M. van Ravels&quot;,
                          &quot;korsten f.w.a.&quot;,
                          &quot;Alberdina Houtman&quot;,
                          &quot;Marco P Nieuwe Weme&quot;,
                          &quot;Jan-Diederik van Wees&quot;,
                          NA,
                          &quot;C.D.J. Bulten&quot;,
                          &quot;A.M.B. DeWaegenaere&quot;,
                          &quot;Willem‐Jan van den Heuvel&quot;,
                          &quot;E.C.C. Punselie&quot;,
                          NA,
                          NA,
                          &quot;G. van Rijssen&quot;,
                          NA,
                          &quot;M.A. Verbrugh&quot;,
                          &quot;Huibert Diederik van Romburgh&quot;,
                          NA,
                          &quot;Katarzyna J. Cwiertka&quot;,
                          &quot;J.W. Foppen&quot;,
                          &quot;Peter van Gool&quot;,
                          &quot;H.J.M. Havekes&quot;,
                          NA,
                          &quot;i.a.m. saloul&quot;,
                          &quot;e.j.j. beulen&quot;,
                          &quot;Olexander Yarovyi&quot;,
                          &quot;R.P. Botha&quot;,
                          &quot;A. M. Baryshev&quot;,
                          &quot;sylvia burg-vermeulen&quot;,
                          &quot;J.S.L.A.W.B. Roes&quot;,
                          &quot;Jan Hein Furnée&quot;,
                          &quot;Annette Freyberg‐Inan&quot;,
                          &quot;Gert Jan van der Sman&quot;,
                          NA,
                          &quot;C. Goukens-Mertens&quot;,
                          NA,
                          &quot;G.R.B.E. Römer&quot;,
                          &quot;p.h.l.m. kuypers&quot;,
                          &quot;Genserik Reniers&quot;,
                          &quot;Stephan Wensveen&quot;,
                          &quot;Onno Kranenburg&quot;,
                          &quot;Schwartz-Landsman&quot;,
                          &quot;G.J.C. Rensen&quot;,
                          &quot;K.W.H. Broekhuizen&quot;,
                          &quot;S.H.M.A. Dumoulin&quot;,
                          &quot;S. Jong Kon Chin&quot;,
                          &quot;S.P.J. van Alphen&quot;,
                          &quot;Chun‐Keung Hoi&quot;,
                          &quot;Sergey Nejentsev&quot;,
                          &quot;ludovico alcorta&quot;,
                          &quot;p.a.m.g. de kock&quot;,
                          &quot;haersolte-van hof jacomijn&quot;,
                          &quot;Eugenia Houvenaghel&quot;,
                          &quot;m.a. van willigen&quot;,
                          &quot;arthur ten cate&quot;,
                          &quot;Peter Koudijs&quot;,
                          &quot;Fulvio Reggiori&quot;,
                          NA,
                          NA,
                          &quot;Antonis Papapantoleon&quot;,
                          &quot;a.c. boerstra&quot;,
                          &quot;Leonie Heres&quot;,
                          &quot;Thomas P. Moliterno&quot;)

length(which(is.na(missing_search_terms)))</code></pre>
<p>We cannot find a reliable OA ID for 12 professors in our dataset.</p>
<p>Loop through the identifier list to fill the IDs in:</p>
<pre class="r"><code>for (i in 1:length(missing_ids)){
  narcis_id &lt;- missing_ids[i]
  
  search_term &lt;- missing_search_terms[i]
  
  prof_list_item &lt;- prof_identifier_list[[narcis_id]]
  
  if (!is.na(search_term)){
    
    if(search_term == &quot;https://openalex.org/A5041930157&quot;){
      prof_oa_ids &lt;- oa_fetch(
        entity = &quot;author&quot;, &#39;A5041930157&#39;)
    }else{
      prof_oa_ids &lt;- oa_fetch(&quot;author&quot;,
                              search = search_term)
    }
    
    if (nrow(prof_oa_ids)&gt;0){
      oa_ids_names &lt;- prof_oa_ids$ids
      # if a list, only retain the OA IDs:
      if(class(oa_ids_names) == &quot;list&quot;){
        oa_ids_names &lt;- c()
        for (j in 1:nrow(prof_oa_ids)){
          id &lt;- prof_oa_ids$ids[[j]][&#39;openalex&#39;]
          oa_ids_names &lt;- c(oa_ids_names, id)
        }
        oa_ids_names &lt;- unname(oa_ids_names)
      }
      
      prof_list_item[&quot;oa_ids_names&quot;] &lt;- list(oa_ids_names)
    }
  }
  
  prof_identifier_list[[narcis_id]] &lt;- prof_list_item
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(missing_ids)))
  
}</code></pre>
<p>Write it out:</p>
<pre class="r"><code>saveRDS(prof_identifier_list, &quot;processed_data/prof_oa_identifier_list.RDS&quot;)</code></pre>
<p>Extract professor IDs and sources for each professor:</p>
<pre class="r"><code>prof_oa_mapping &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))

for (i in 1:length(prof_identifier_list)){
  # initiate a dataframe to store this professor&#39;s data
  prof_oa_ids &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))
  # retrieve this professor&#39;s list of identifiers
  prof_identifiers &lt;- prof_identifier_list[[i]]
  # get their Narcis ID and all the retrieved OA IDs
  narcis_id &lt;- prof_identifier_list[[i]][[&quot;narcis_id&quot;]]
  
  pub_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_pubs&quot;]]
  
  orcid_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_orcid&quot;]]
  
  name_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_names&quot;]]
  
  # add any IDs retrieved from the publication list
  if (!all(is.na(pub_ids))){
  
  pub_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = pub_ids,
                              &quot;source&quot; = &quot;publications&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       pub_ids)
  }
  # add any IDs associated with prof&#39;s ORCID
  if (!all(is.na(orcid_ids))){
  orcid_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = orcid_ids,
                              &quot;source&quot; = &quot;orcid&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       orcid_ids)
  }
  # add any IDs from name search + NL country
  if (!all(is.na(name_ids))){
  name_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = name_ids,
                              &quot;source&quot; = &quot;name&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       name_ids)
  }
  
  # if any rows
  if (nrow(prof_oa_ids) &gt; 0){
    
    # deduplicate
    prof_oa_ids$duplicate &lt;- duplicated(prof_oa_ids[c(&quot;profile_id&quot;, &quot;oa_id&quot;)])
    prof_oa_ids &lt;- filter(prof_oa_ids,
                          duplicate == FALSE)
    prof_oa_ids &lt;- prof_oa_ids[, -4]
    
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  } else{
    prof_oa_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                                    &quot;oa_id&quot; = NA,
                                    &quot;source&quot; = NA)
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  }
  print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
}</code></pre>
</div>
<div id="extract-publications-based-on-oa-ids" class="section level2"
number="3.2">
<h2><span class="header-section-number">3.2</span> Extract publications
based on OA IDs</h2>
<p>Define the data querying function, which pulls data from OA as shown
in the Diagram below: <img
src="images/professor_info_retriever_diagram.png" alt="Figure 2" /></p>
<pre class="r"><code>professor_info_retriever &lt;- function(prof_oa_ids,
                                     narcis_id,
                                     pub_data,
                                     prof_data,
                                     api_key,
                                     # recommend to set to FALSE unless all works well,
                                     # to avoid using up our twitter query limits
                                     include_twitter = FALSE){
  
  # get the professor&#39;s narcis id and get their publications based on this
  prof_pubs &lt;- filter(pub_data, profile_id == narcis_id)
  
  # get the professor&#39;s OA IDs list
  oa_ids &lt;- filter(prof_oa_ids,
                   profile_id == narcis_id)$oa_id
  
  # pull all the data related to these OA ids
  # if ID found:
  if (length(oa_ids)&gt;0){
    # get all papers from OA using these ids:
    prof_all_works_oa &lt;- oa_fetch(
      entity = &quot;works&quot;, 
      author.id = oa_ids)
    
    # deduplicate based on IDs
    prof_all_works_oa$duplicate &lt;- duplicated(prof_all_works_oa[, c(&quot;id&quot;)])
    prof_all_works_oa &lt;- filter(prof_all_works_oa,
                                duplicate == FALSE)
    
    # if there are still duplicates, deduplicate by lowercased title
    prof_all_works_oa$display_name_lower &lt;- tolower(prof_all_works_oa$display_name)
    prof_all_works_oa$duplicate &lt;- duplicated(prof_all_works_oa[, c(&quot;display_name_lower&quot;)])
    prof_all_works_oa &lt;- filter(prof_all_works_oa,
                                duplicate == FALSE)
    
    # paste the OA ID and the Narcis ID
    prof_all_works_oa$oa_id &lt;- paste(oa_ids, collapse = &quot;, &quot;)
    prof_all_works_oa$profile_id &lt;- narcis_id
    
    # get their co-authors in a given year
    # but also their affiliations, and the autoship positino in every pub, 
    # since we are already looping...
    # pleceholder for authoship position
    prof_pub_position &lt;- rep(NA, nrow(prof_all_works_oa))
    # placeholders for authors and affiliations
    prof_coauthors_oa &lt;- NA
    prof_pub_info_ia &lt;- NA
    
    for (i in 1:nrow(prof_all_works_oa)){
      # fetch the authors nested within the &quot;author&quot; field returned by OA
      all_authors &lt;- prof_all_works_oa[i, &quot;author&quot;][[1]][[1]]
      # get the professor info and their affiliations that year
      if (!is.null(nrow(all_authors))){
        prof_author_info &lt;- filter(all_authors,  au_id %in% oa_ids)
        # if author&#39;s ID not found here (e.g., a slightly different name), it will be set to NA
        prof_pub_position[i] &lt;- NA
        # otherwise, replace with the actual value
        if (nrow(prof_author_info)&gt;0){
          # paste the prof&#39;s authorship here (first row, as some professors some get 
          # duplicate mentions in a paper)
          prof_pub_position[i] &lt;- prof_author_info[1, &#39;author_position&#39;]
        }
        # exclude this author themselves from the co-authors
        coauthors &lt;- filter(all_authors, ! au_id %in% oa_ids)
        # if not a single-author paper, get coauthor info
        if (nrow(coauthors) &gt; 0){
          # get the publication year
          year &lt;- as.numeric(prof_all_works_oa[i, &quot;publication_year&quot;])
          # paste the year alongside the coauthors
          coauthors$year &lt;- year
          prof_coauthors_oa &lt;- rbind(prof_coauthors_oa,
                                     coauthors)
        }
        # for the prof themselves, get their affiliation info etc
        if (nrow(prof_author_info) &gt; 0){
          # get the publication year
          year &lt;- as.numeric(prof_all_works_oa[i, &quot;publication_year&quot;])
          # paste the year alongside the coauthors
          prof_author_info$year &lt;- year
          prof_pub_info_ia &lt;- rbind(prof_pub_info_ia,
                                    prof_author_info)
        }
      }
    }
    # tidy up the dataframe on coauthors, if any info is there
    if (!is.null(nrow(prof_coauthors_oa))){
      if (nrow(prof_coauthors_oa) &gt; 0){
        
        # and deduplicate coauthorships in the same year
        prof_coauthors_oa$duplicate &lt;- duplicated(prof_coauthors_oa[, c(&quot;au_id&quot;, &quot;year&quot;)])
        prof_coauthors_oa &lt;- filter(prof_coauthors_oa,
                                    duplicate == FALSE)
        # remove the duplicate column
        prof_coauthors_oa &lt;- prof_coauthors_oa[, -ncol(prof_coauthors_oa)]
        
        # remove the row with NAs
        prof_coauthors_oa &lt;- prof_coauthors_oa[rowSums(is.na(prof_coauthors_oa)) != ncol(prof_coauthors_oa), ]
        
        # add the author id info just in case
        prof_coauthors_oa$oa_id &lt;- paste(oa_ids, collapse = &quot;, &quot;)
        prof_coauthors_oa$profile_id &lt;- narcis_id
      }
    }
    
    # tidy up the info on author affiliations, if any is there
    if (!is.null(nrow(prof_pub_info_ia))){
      # once again, if any is there...
      if (nrow(prof_pub_info_ia) &gt; 0 ){
        prof_pub_info_ia &lt;- filter(prof_pub_info_ia, !is.na(institution_id))
        # check that filtering did not remove everything; if so, replace back with NA
        if (nrow(prof_pub_info_ia) == 0){
          prof_pub_info_ia &lt;- NA
        }else{
          # and deduplicate affiliations in the same year
          prof_pub_info_ia$duplicate &lt;- duplicated(prof_pub_info_ia[, c(&quot;institution_id&quot;, &quot;year&quot;)])
          prof_pub_info_ia &lt;- filter(prof_pub_info_ia,
                                     duplicate == FALSE)
          # remove the duplicate column
          prof_pub_info_ia &lt;- prof_pub_info_ia[, -ncol(prof_pub_info_ia)]
          
          # drop author position since this is paper related
          prof_pub_info_ia &lt;- prof_pub_info_ia[ , -which(names(prof_pub_info_ia) %in% c(&quot;author_position&quot;))]
          # add the author id info just in case
          prof_pub_info_ia$oa_id &lt;- paste(oa_ids, collapse = &quot;, &quot;)
          prof_pub_info_ia$profile_id &lt;- narcis_id
        }
      }
    }
    
    # add the authorship info to the publications
    prof_all_works_oa$author_position &lt;- prof_pub_position
    
    # initialize an empty object for grant info
    prof_grants_oa &lt;- NA
    
    # if there is a grant column, fetch their grant numbers
    if (&quot;grants&quot; %in% colnames(prof_all_works_oa)){
      # get the grant list
      prof_grant_list &lt;- prof_all_works_oa$grants
      # get the years from the publications
      year_list &lt;- prof_all_works_oa$publication_year
      # empty dataframe
      #prof_grants_oa &lt;- data.frame(matrix(NA, nrow = 0, ncol = 5))
      # for each grant item in the list
      for (i in 1:length(prof_grant_list)){
        grant &lt;- prof_grant_list[[i]]
        # if not NA, get the data
        if (! anyNA(grant)){
          # get all funder IDs and names and put them into a dataframe
          # NB: not all of these are author&#39;s own grants, but they are
          # co-authorship grants
          funder_ids &lt;- grant[names(grant)==&quot;funder&quot;]
          funder_names &lt;- grant[names(grant) == &quot;funder_display_name&quot;]
          year &lt;- as.numeric(year_list[i])
          oa_id &lt;- paste(oa_ids, collapse = &quot;, &quot;)
          profile_id &lt;- narcis_id
          fund_df &lt;- cbind.data.frame(funder_id = funder_ids,
                                      funder_names = funder_names)
          # add some more info
          fund_df$year &lt;- year
          fund_df$oa_id &lt;- paste(oa_ids, collapse = &quot;, &quot;)
          fund_df$profile_id &lt;- narcis_id
          prof_grants_oa &lt;- rbind(prof_grants_oa,
                                  fund_df)
        }
      }
      # if not NA, tidy up the dataframe
      if (!is.null(nrow(prof_grants_oa))){
        # tidy up the row names
        rownames(prof_grants_oa) &lt;- 1:nrow(prof_grants_oa)
        # deduplicate same grants across years
        prof_grants_oa$duplicate &lt;- duplicated(prof_grants_oa[, c(&quot;funder_id&quot;, &quot;year&quot;)])
        prof_grants_oa &lt;- filter(prof_grants_oa,
                                 duplicate == FALSE)
        # remove the duplicate column
        prof_grants_oa &lt;- prof_grants_oa[, -(ncol(prof_grants_oa))]
        # remove the row with NAs
        prof_grants_oa &lt;- prof_grants_oa[rowSums(is.na(prof_grants_oa)) != ncol(prof_grants_oa), ]
      }
    }
    
    # get the info on this author
    prof_info &lt;- oa_fetch(
      entity = &quot;authors&quot;, 
      identifier = oa_ids)
    
    # now, query the Altmetric API to get mentions info on the author
    prof_all_works_oa_mentions &lt;- altmetric_mention_retriever(api_key = api_key,
                                                              publication_list = prof_all_works_oa,
                                                              include_twitter = include_twitter)
    
    
    # output a list populated with all the details
    prof_output &lt;- list()
    prof_output[&quot;profile_id&quot;] &lt;- narcis_id
    prof_output[&quot;oa_ids&quot;] &lt;- list(oa_ids)
    prof_output[&quot;orcid&quot;] &lt;- prof_info$orcid
    prof_output[&quot;prof_info&quot;] &lt;- list(prof_info)
    prof_output[&quot;narcis_pubs&quot;] &lt;- list(prof_pubs)
    prof_output[&quot;oa_pubs&quot;] &lt;- list(prof_all_works_oa_mentions)
    prof_output[&quot;grant_info&quot;] &lt;- list(prof_grants_oa)
    prof_output[&quot;coauthor_info&quot;] &lt;- list(prof_coauthors_oa)
    prof_output[&quot;affiliation_info&quot;] &lt;- list(prof_pub_info_ia)
  }else{
    if (! all(is.na(oa_ids_pubs))){
    prof_output &lt;- list()
    prof_output[&quot;profile_id&quot;] &lt;- narcis_id
    prof_output[&quot;oa_ids&quot;] &lt;- NA
    prof_output[&quot;orcid&quot;] &lt;- prof_info$orcid
    prof_output[&quot;prof_info&quot;] &lt;- NA
    prof_output[&quot;narcis_pubs&quot;] &lt;- NA
    prof_output[&quot;oa_pubs&quot;] &lt;- NA
    prof_output[&quot;grant_info&quot;] &lt;- NA
    prof_output[&quot;coauthor_info&quot;] &lt;- NA
    prof_output[&quot;affiliation_info&quot;] &lt;- NA
    }else{
      prof_output &lt;- list()
      prof_output[&quot;profile_id&quot;] &lt;- narcis_id
      prof_output[&quot;oa_ids&quot;] &lt;- NA
      prof_output[&quot;orcid&quot;] &lt;- prof_info$orcid
      prof_output[&quot;prof_info&quot;] &lt;- NA
      prof_output[&quot;narcis_pubs&quot;] &lt;- prof_pubs
      prof_output[&quot;oa_pubs&quot;] &lt;- NA
      prof_output[&quot;grant_info&quot;] &lt;- NA
      prof_output[&quot;coauthor_info&quot;] &lt;- NA
      prof_output[&quot;affiliation_info&quot;] &lt;- NA
    }
  }
    
  return(prof_output)
}</code></pre>
<p>Define the Altmetric querying function:</p>
<pre class="r"><code>altmetric_mention_retriever &lt;- function(api_key,
                                        publication_list,
                                        include_twitter = FALSE){
  
  # elements to make a url that calls the API to get mention data
  doi_call_url &lt;- &quot;https://api.altmetric.com/v1/fetch/doi/&quot;
  api_key_url &lt;- paste0(&quot;?key=&quot;, api_key)
  exclude_twitter_url &lt;- &quot;&amp;exclude_sources=twitter&quot;
  
  # get the publication list
  oa_pubs &lt;- publication_list
  # if not empty:
  if (!is.null(nrow(oa_pubs))){
    # loop, for each doi, and:
    for (i in 1:nrow(oa_pubs)){
      # get the doi without the url part
      doi_url &lt;- str_remove(oa_pubs$doi[i], &quot;https://doi.org/&quot;)
      # if there is a doi:
      if (!is.na(doi_url)){
        # make the url for the api call
        api_call &lt;- paste(doi_call_url, doi_url, api_key_url, sep = &quot;&quot;)
        
        # exclude twitter? if so, add:
        if (include_twitter == FALSE){
          api_call &lt;- paste(api_call, exclude_twitter_url, sep = &quot;&quot;)
        }
        # empty DOI output object, in case try fails
        doi_output &lt;- NA
        # and call the api
        try(doi_output &lt;- fromJSON(txt=api_call), silent = TRUE)
        # now, check if this doi has any mentions in the media
        if (&quot;posts&quot; %in% names(doi_output)){
          mentions &lt;- doi_output[[&quot;posts&quot;]]
          # since different papers have different mentions, let&#39;s loop again
          # addding columns for relevant mentions
          for (mention_type in names(mentions)){
            # check if column already there in oa_pubs
            if(mention_type %in% colnames(oa_pubs)){
              # if there, just add the mentions into the cell (nested)
              oa_pubs[[which(colnames(oa_pubs)==mention_type)]][i] &lt;- list(mentions[[mention_type]])
            }else{
              # if column not there, first add it and populate with NAs
              oa_pubs[mention_type] &lt;- NA
              # and then, for this pub, paste the mention data into the cell (it will be a nested dataframe)
              oa_pubs[[which(colnames(oa_pubs)==mention_type)]][i] &lt;- list(mentions[[mention_type]])
            }
          }
        }
      }
    }
  }
  # return the list of publications dataframe with new columns
  return(oa_pubs)
}</code></pre>
<p>Pull the professor data:</p>
<pre class="r"><code># api key (fill in own)
altmetric_api_key &lt;- &#39;&#39;

# get the list of IDs
narcis_ids &lt;- profs_full$profile_id

# query in batches
# batch size
prof_batch_size &lt;- 500
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(narcis_ids), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(narcis_ids)+1)

# loop through the batches
for(i in 1:(length(batches)-1)){
  # initialize an empty list for the batch
  batch_prof_outcomes &lt;- list()
  # initialize a list for empty ouputs - profs that threw an error
  batch_errors &lt;- list()
  
  # get the narcis ids from the batch
  prof_batch &lt;- narcis_ids[batches[i]:(batches[i+1]-1)]
  
  # loop through professors in this batch
  for (narcis_id in prof_batch){
    # set outcome to NA as a placeholder
    outcome &lt;- NA
    
    # try to query all the data
    try(outcome &lt;- professor_info_retriever(prof_oa_ids = prof_oa_mapping,
                                            narcis_id = narcis_id,
                                            pub_data = prof_pubs_full,
                                            prof_data = profs_full,
                                            api_key = altmetric_api_key,
                                            # recommend to set to FALSE unless all works well,
                                            # to avoid using up our twitter query limits
                                            include_twitter = FALSE)) #, silent = TRUE)
    # append to the batch data
    batch_prof_outcomes[[narcis_id]] &lt;- outcome
    # print some info out
    print(paste(&quot;done with&quot;, which(narcis_id == prof_batch), &quot;out of&quot;, length(prof_batch)))
  }
  
  # save the batch RDS
  save_string &lt;- paste0(&quot;processed_data/open_alex_prof_data/&quot;, paste(&quot;prof_data_batch&quot;, i, sep = &quot;_&quot;), &quot;.RDS&quot;)
  saveRDS(batch_prof_outcomes, save_string)
}</code></pre>
<p>Check which IDs lack the relevant information, and try to retrieve it
again (sometimes the API request times out etc, so it’s worth giving it
another try):</p>
<pre class="r"><code># loop through the batches
for(i in 1:(length(batches)-1)){
  # load the batch
  read_string &lt;- paste0(&quot;processed_data/open_alex_prof_data/&quot;, paste(&quot;prof_data_batch&quot;, i, sep = &quot;_&quot;), &quot;.RDS&quot;)
  batch_prof_outcomes &lt;- readRDS(read_string)
  
  # get the narcis ids from the batch
  prof_batch &lt;- narcis_ids[batches[i]:(batches[i+1]-1)]
  
  # loop through professors in this batch
  for (narcis_id in prof_batch){
    # check if NA, and if so, try to fill it in...
    outcome &lt;- batch_prof_outcomes[[narcis_id]]
    
    # if the outcome is NA or everything OA related is NA, and skip one problematic narcis ID
    if (all(is.na(outcome))|all(is.na(outcome[c(4, 6, 7, 8, 9)]))){
      if(narcis_id != &quot;https://www.narcis.nl/person/RecordID/PRS1336203&quot;){
      # check if there is an OA ID mapped to them
      oa &lt;- filter(prof_oa_mapping, profile_id == narcis_id)
      # if there is, give it another go at retrieving the info
      if (!all(is.na(oa[c(&#39;oa_id&#39;, &#39;source&#39;)]))){
        try(outcome &lt;- professor_info_retriever(prof_oa_ids = prof_oa_mapping,
                                                narcis_id = narcis_id,
                                                pub_data = prof_pubs_full,
                                                prof_data = profs_full,
                                                api_key = altmetric_api_key,
                                                # recommend to set to FALSE unless all works well,
                                                # to avoid using up our twitter query limits
                                                include_twitter = FALSE)) #, silent = TRUE)
      }else{
        prof_pubs &lt;- filter(prof_pubs_full, profile_id == narcis_id)
        if(!all(is.na(prof_pubs))){
          outcome &lt;- list()
          outcome[&quot;profile_id&quot;] &lt;- narcis_id
          outcome[&quot;oa_ids&quot;] &lt;- NA
          outcome[&quot;orcid&quot;] &lt;- NA
          outcome[&quot;prof_info&quot;] &lt;- NA
          outcome[&quot;narcis_pubs&quot;] &lt;- prof_pubs
          outcome[&quot;oa_pubs&quot;] &lt;- NA
          outcome[&quot;grant_info&quot;] &lt;- NA
          outcome[&quot;coauthor_info&quot;] &lt;- NA
          outcome[&quot;affiliation_info&quot;] &lt;- NA
          }else{
            outcome &lt;- list()
            outcome[&quot;profile_id&quot;] &lt;- narcis_id
            outcome[&quot;oa_ids&quot;] &lt;- NA
            outcome[&quot;orcid&quot;] &lt;- NA
            outcome[&quot;prof_info&quot;] &lt;- NA
            outcome[&quot;narcis_pubs&quot;] &lt;- NA
            outcome[&quot;oa_pubs&quot;] &lt;- NA
            outcome[&quot;grant_info&quot;] &lt;- NA
            outcome[&quot;coauthor_info&quot;] &lt;- NA
            outcome[&quot;affiliation_info&quot;] &lt;- NA
          }
      }
      # append to the batch data
      batch_prof_outcomes[[narcis_id]] &lt;- outcome
    }
    # print some info out
    print(paste(&quot;done with&quot;, which(narcis_id == prof_batch), &quot;out of&quot;, length(prof_batch)))
  }}
  # save the batch RDS
  save_string &lt;- paste0(&quot;processed_data/open_alex_prof_data/&quot;, paste(&quot;prof_data_batch&quot;, i, sep = &quot;_&quot;), &quot;.RDS&quot;)
  saveRDS(batch_prof_outcomes, save_string)
}</code></pre>
</div>
</div>
<div id="populate-an-sql-database-with-the-data" class="section level1"
number="4">
<h1><span class="header-section-number">4</span> Populate an SQL
database with the data</h1>
<p>Connect to the postgres database. Use own credentials.</p>
<pre class="r"><code>dsn_port &lt;- 
dsn_uid &lt;- &quot;&quot;
dsn_pwd &lt;- &quot;&quot;

con &lt;- RPostgres::dbConnect(RPostgres::Postgres(),
                 dbname= dsn_uid,
                 port = dsn_port,
                 user = dsn_uid, 
                 password = dsn_pwd)

con # Checks connection is working</code></pre>
<div id="identifier-list" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Identifier list</h2>
<p>Write out the identifier list to a table in the SQL database:</p>
<pre class="r"><code>prof_identifier_list &lt;- readRDS(&quot;~/Postdoc/Projects/dutch_media_profs_r/processed_data/prof_oa_identifier_list.RDS&quot;)

prof_oa_mapping &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))

for (i in 1:length(prof_identifier_list)){
  # initiate a dataframe to store this professor&#39;s data
  prof_oa_ids &lt;- data.frame(matrix(NA, nrow = 0, ncol = 3))
  # retrieve this professor&#39;s list of identifiers
  prof_identifiers &lt;- prof_identifier_list[[i]]
  # get their Narcis ID and all the retrieved OA IDs
  narcis_id &lt;- prof_identifier_list[[i]][[&quot;narcis_id&quot;]]
  
  pub_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_pubs&quot;]]
  
  orcid_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_orcid&quot;]]
  
  name_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_names&quot;]]
  
  # add any IDs retrieved from the publication list
  if (!all(is.na(pub_ids))){
  
  pub_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = pub_ids,
                              &quot;source&quot; = &quot;publications&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       pub_ids)
  }
  # add any IDs associated with prof&#39;s ORCID
  if (!all(is.na(orcid_ids))){
  orcid_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = orcid_ids,
                              &quot;source&quot; = &quot;orcid&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       orcid_ids)
  }
  # add any IDs from name search + NL country
  if (!all(is.na(name_ids))){
  name_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;oa_id&quot; = name_ids,
                              &quot;source&quot; = &quot;name&quot;)
  
  prof_oa_ids &lt;- rbind(prof_oa_ids,
                       name_ids)
  }
  
  # if any rows
  if (nrow(prof_oa_ids) &gt; 0){
    
    # deduplicate
    prof_oa_ids$duplicate &lt;- duplicated(prof_oa_ids[c(&quot;profile_id&quot;, &quot;oa_id&quot;)])
    prof_oa_ids &lt;- filter(prof_oa_ids,
                          duplicate == FALSE)
    prof_oa_ids &lt;- prof_oa_ids[, -4]
    
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  } else{
    prof_oa_ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                                    &quot;oa_id&quot; = NA,
                                    &quot;source&quot; = NA)
    prof_oa_mapping &lt;- rbind(prof_oa_mapping,
                             prof_oa_ids)
  }
  #print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
}


dbWriteTable(con, &quot;oa_identifier_table&quot;, prof_oa_mapping, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="gender-data" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Gender data</h2>
<pre class="r"><code>profs_full_gender &lt;- readRDS(&quot;~/Postdoc/Projects/dutch_media_profs_r/processed_data/profs_full_gender.RDS&quot;)
dbWriteTable(con, &quot;gender_table&quot;, profs_full_gender, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="orcids" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> ORCIDs</h2>
<pre class="r"><code>prof_orcid_mapping &lt;- data.frame(matrix(NA, nrow = 0, ncol = 1))

for (i in 1:length(prof_identifier_list)){
  # retrieve this professor&#39;s list of identifiers
  prof_identifiers &lt;- prof_identifier_list[[i]]
  # get their Narcis ID and all the retrieved OA IDs
  narcis_id &lt;- prof_identifier_list[[i]][[&quot;narcis_id&quot;]]
  
  orcid_ids &lt;- prof_identifier_list[[i]][[&quot;oa_ids_orcid&quot;]]

  
  ids &lt;- cbind.data.frame(&quot;profile_id&quot; = narcis_id,
                              &quot;orcid&quot; = orcid_ids)
  
  prof_orcid_mapping &lt;- rbind(prof_orcid_mapping,
                          ids)
  #print(paste(&quot;done with&quot;, i, &quot;out of&quot;, length(narcis_ids)))
}

dbWriteTable(con, &quot;orcid_table&quot;, prof_orcid_mapping, row.names=FALSE, append=TRUE)</code></pre>
</div>
<div id="extract-info-from-professor-lists" class="section level2"
number="4.4">
<h2><span class="header-section-number">4.4</span> Extract info from
professor lists</h2>
<pre class="r"><code># dbRemoveTable(con, &quot;prof_info&quot;)
# dbRemoveTable(con, &quot;affiliation_info&quot;)
# dbRemoveTable(con, &quot;grant_info&quot;)
# dbRemoveTable(con, &quot;coauthor_info&quot;)
# dbRemoveTable(con, &quot;news_mentions&quot;)
# dbRemoveTable(con, &quot;wiki_mentions&quot;)
# dbRemoveTable(con, &quot;reddit_mentions&quot;)
# dbRemoveTable(con, &quot;narcis_pubs&quot;)
# dbRemoveTable(con, &quot;oa_pubs&quot;)
# dbRemoveTable(con, &quot;oa_concepts&quot;)

# helper elements for mention padding
# mention_cols &lt;- c(&quot;wikipedia&quot;, &quot;news&quot;, &quot;patent&quot;, &quot;blogs&quot;, &quot;googleplus&quot;, 
#                   &quot;facebook&quot;, &quot;reddit&quot;, &quot;f1000&quot;, &quot;policy&quot;, &quot;peer_reviews&quot;,
#                   &quot;video&quot;, &quot;q&amp;a&quot;, &quot;misc&quot;, &quot;weibo&quot;, &quot;pinterest&quot;, &quot;syllabi&quot;,
#                   &quot;linkedin&quot;, &quot;book_reviews&quot;)

# get the list of IDs
narcis_ids &lt;- profs_full$profile_id
# query in batches
# batch size
prof_batch_size &lt;- 500
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(narcis_ids), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(narcis_ids)+1)

# loop through the batches
for(i in 1:(length(batches)-1)){
 # load the batch
  read_string &lt;- paste0(&quot;processed_data/open_alex_prof_data/&quot;, paste(&quot;prof_data_batch&quot;, i, sep = &quot;_&quot;), &quot;.RDS&quot;)
  batch_prof_outcomes &lt;- readRDS(read_string)
  
  # get the narcis ids from the batch
  prof_batch &lt;- narcis_ids[batches[i]:(batches[i+1]-1)]


  for (j in 1:length(prof_batch)){
    prof &lt;- batch_prof_outcomes[[j]]
    prof_id &lt;- names(batch_prof_outcomes[j])
    # if some data in the prof list
    if (length(prof)&gt;1){
      ## get the professor info
      prof_info &lt;- prof[[&quot;prof_info&quot;]]
      # if not empty
      if (!all(is.na(prof_info))){
        # remove columns we do not need
        if(any(c(&quot;x_concepts&quot;,&quot;display_name_alternatives&quot;, &quot;ids&quot;, &quot;affiliation_lineage&quot;) %in% colnames(prof_info))){
          prof_info &lt;- prof_info %&gt;%
            select(!any_of(c(&quot;x_concepts&quot;, &quot;display_name_alternatives&quot;, &quot;ids&quot;, &quot;affiliation_lineage&quot;)))
        }
        # now unnest the data
        prof_info_unnest &lt;- unnest(prof_info, cols = c(counts_by_year), names_sep = &quot;_year_&quot;)
        # append the prof id
        prof_info_unnest &lt;- bind_cols(&quot;profile_id&quot; = prof_id,
                                      prof_info_unnest)
        if ((i == 1) &amp; (j == 1)){
        # and write to the database
        dbWriteTable(con, &quot;prof_info&quot;, prof_info_unnest, row.names=FALSE, append=TRUE)
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;prof_info&quot;)
          # if not all fields there
          if(!all(fields %in% colnames(prof_info_unnest))){
            n_missing &lt;- which(!fields %in% colnames(prof_info_unnest))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(prof_info_unnest))]
            prof_info_unnest &lt;- bind_cols(prof_info_unnest,
                                          padding)
            prof_info_unnest &lt;- prof_info_unnest[fields]
          }
          # only leave these fields in
          prof_info_unnest &lt;-  prof_info_unnest %&gt;%
            select(all_of(fields))
          
          dbAppendTable(con, &quot;prof_info&quot;, prof_info_unnest, row.names=NULL, append=TRUE)
        }
      }
      
      ## get the NARCIS publications
      narcis_pubs &lt;- prof[[&quot;narcis_pubs&quot;]]
      # if not empty
      if (!all(is.na(narcis_pubs)) &amp; class(narcis_pubs) != &quot;character&quot;){
        # if first round, create a table
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;narcis_pubs&quot;, narcis_pubs, row.names=FALSE, append=TRUE)
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;narcis_pubs&quot;)
          # only leave these fields in
          narcis_pubs &lt;-  narcis_pubs %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;narcis_pubs&quot;, narcis_pubs, row.names=NULL, append=TRUE)
        }
      }
      
      ## get the OA publications
      oa_pubs &lt;- prof[[&quot;oa_pubs&quot;]]
      
      # if not empty
      if (!all(is.na(oa_pubs))){
        # first, get the mention data
        mention_data &lt;- oa_pubs %&gt;%
          select(id, profile_id, author_position:last_col(), -author_position)
        
        # if not empty
        if (!all(is.na(mention_data))){
          
          # if there&#39;s wiki data
          if (&#39;wikipedia&#39; %in% colnames(mention_data)){
            wiki_mention_data_unnest &lt;- mention_data%&gt;%
              select(id, profile_id, wikipedia) %&gt;%
              unnest(., cols = &#39;wikipedia&#39;)%&gt;%
              select(!citation_ids)%&gt;%
              unnest(., cols = author, names_sep = &quot;_au_&quot;)
            
            # if first round, create a table
            if ((i == 1) &amp; (j == 1)){
              # write to the database
              dbWriteTable(con, &quot;wiki_mentions&quot;, wiki_mention_data_unnest, row.names=FALSE, append=TRUE)
              # otherwise, append
            }else{
              # check fields in the existing table
              fields &lt;- dbListFields(con, &quot;wiki_mentions&quot;)
              # if not all fields there
              if(!all(fields %in% colnames(wiki_mention_data_unnest))){
                n_missing &lt;- which(!fields %in% colnames(wiki_mention_data_unnest))
                padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
                colnames(padding) &lt;- fields[which(!fields %in% colnames(wiki_mention_data_unnest))]
                wiki_mention_data_unnest &lt;- bind_cols(wiki_mention_data_unnest,
                                              padding)
                wiki_mention_data_unnest &lt;- wiki_mention_data_unnest[fields]
              }
              # only leave these fields in
              wiki_mention_data_unnest &lt;-  wiki_mention_data_unnest %&gt;%
                select(all_of(fields))
              dbAppendTable(con, &quot;wiki_mentions&quot;, wiki_mention_data_unnest, row.names=NULL, append=TRUE)
            }
          }
          # if there&#39;s news data
          if (&#39;news&#39; %in% colnames(mention_data)){
            news_mention_data_unnest &lt;- mention_data%&gt;%
              select(id, profile_id, news) %&gt;%
              unnest(., cols = &#39;news&#39;)%&gt;%
              select(!citation_ids)%&gt;%
              unnest(., cols = author, names_sep = &quot;_au_&quot;)
            
            # if first round, create a table
            if ((i == 1) &amp; (j == 1)){
              # write to the database
              dbWriteTable(con, &quot;news_mentions&quot;, news_mention_data_unnest, row.names=FALSE, append=TRUE) 
              # otherwise, append
            }else{
              # check fields in the existing table
              fields &lt;- dbListFields(con, &quot;news_mentions&quot;)
              # if not all fields there
              if(!all(fields %in% colnames(news_mention_data_unnest))){
                n_missing &lt;- which(!fields %in% colnames(news_mention_data_unnest))
                padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
                colnames(padding) &lt;- fields[which(!fields %in% colnames(news_mention_data_unnest))]
                news_mention_data_unnest &lt;- bind_cols(news_mention_data_unnest,
                                                      padding)
                news_mention_data_unnest &lt;- news_mention_data_unnest[fields]
              }
              
              # only leave these fields in
              news_mention_data_unnest &lt;-  news_mention_data_unnest %&gt;%
                select(all_of(fields))
              dbAppendTable(con, &quot;news_mentions&quot;, news_mention_data_unnest, row.names=NULL, append=TRUE) 
            }
          }
          
          # # if there&#39;s FB data, but this doesn&#39;t work 
          # if (&#39;facebook&#39; %in% colnames(mention_data)){
          #   fb_mention_data_unnest &lt;- mention_data%&gt;%
          #     select(id, profile_id, facebook) %&gt;%
          #     unnest(., cols = &#39;facebook&#39;)%&gt;%
          #     select(!citation_ids)
          # 
          # }
          
          # if there&#39;s reddit data
          if (&#39;reddit&#39; %in% colnames(mention_data)){
            reddit_mention_data_unnest &lt;- mention_data%&gt;%
              select(id, profile_id, reddit) %&gt;%
              unnest(., cols = &#39;reddit&#39;)%&gt;%
              select(!citation_ids)%&gt;%
              unnest(., cols = author, names_sep = &quot;_au_&quot;)
            
            if ((i == 1) &amp; (j == 1)){
              # write to the database
              dbWriteTable(con, &quot;reddit_mentions&quot;, reddit_mention_data_unnest, row.names=FALSE, append=TRUE) 
              # otherwise, append
            }else{
              # check fields in the existing table
              fields &lt;- dbListFields(con, &quot;reddit_mentions&quot;)
              if(!all(fields %in% colnames(reddit_mention_data_unnest))){
                n_missing &lt;- which(!fields %in% colnames(reddit_mention_data_unnest))
                padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
                colnames(padding) &lt;- fields[which(!fields %in% colnames(reddit_mention_data_unnest))]
                reddit_mention_data_unnest &lt;- bind_cols(reddit_mention_data_unnest,
                                                      padding)
                reddit_mention_data_unnest &lt;- reddit_mention_data_unnest[fields]
              }
              # only leave these fields in
              reddit_mention_data_unnest &lt;-  reddit_mention_data_unnest %&gt;%
                select(all_of(fields))
              dbAppendTable(con, &quot;reddit_mentions&quot;, reddit_mention_data_unnest, row.names=NULL, append=TRUE) 
            }
          }
        }
        
        # now, get the publication data
        # select relevant columns
        select_cols &lt;- c(&quot;id&quot;, &quot;profile_id&quot;, &quot;display_name&quot;, &quot;ab&quot;, &quot;publication_year&quot;,
                         &quot;so&quot;, &quot;so_id&quot;, &quot;host_organization&quot;, &quot;issn_l&quot;, 
                         &quot;url&quot;, &quot;pdf_url&quot;, &quot;volume&quot;, &quot;issue&quot;, &quot;first_page&quot;, 
                         &quot;last_page&quot;, &quot; is_ia&quot;, &quot;language&quot;,
                         &quot;cited_by_count&quot;, &quot;counts_by_year&quot;, &quot;cited_by_api_url&quot;,
                         &quot;doi&quot;, &quot;type&quot;, 
                         &quot;is_retracted&quot;, &quot;ia_id&quot;, 
                         &quot;author_position&quot;)
        pub_data &lt;- oa_pubs %&gt;%
          select(any_of(select_cols))
        
        # get the referenced works
        referenced_works &lt;- oa_pubs %&gt;%
          select(id, profile_id, referenced_works)%&gt;%
          unnest(., cols = &quot;referenced_works&quot;)
        
        # get the counts by year
        pub_by_year &lt;- pub_data %&gt;%
          unnest(., cols = &quot;counts_by_year&quot;, names_sep = &quot;_year_&quot;)
        
        # write this out
        # if not empty
        if (!all(is.na(oa_pubs))){
          if ((i == 1) &amp; (j == 1)){
            # write to the database
            dbWriteTable(con, &quot;oa_pubs&quot;, pub_by_year, row.names=FALSE, append=TRUE)
            # otherwise, append
          }else{
            # check fields in the existing table
            fields &lt;- dbListFields(con, &quot;oa_pubs&quot;)
            # if some missing, pad the dataset
            if(!all(fields %in% colnames(pub_by_year))){
              n_missing &lt;- which(!fields %in% colnames(pub_by_year))
              padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
              colnames(padding) &lt;- fields[which(!fields %in% colnames(pub_by_year))]
              pub_by_year &lt;- bind_cols(pub_by_year,
                                                      padding)
              pub_by_year &lt;- pub_by_year[fields]
            }
            # only leave these fields in
            pub_by_year &lt;-  pub_by_year %&gt;%
              select(all_of(fields))
            dbAppendTable(con, &quot;oa_pubs&quot;, pub_by_year, row.names=NULL, append=TRUE)
          }
        }
        
        # unnest the concepts, but also leave only those on levels 0 and 1 and with prob
        # above 0.5
        oa_concepts &lt;- oa_pubs %&gt;%
          select(id, profile_id, concepts)%&gt;%
          unnest(., cols = &quot;concepts&quot;, names_sep = &quot;_conc_&quot;)%&gt;%
          filter(concepts_conc_level %in% c(0,1) &amp; concepts_conc_score &gt;= 0.5)
        
        # write this out
        # if not empty
        if (!all(is.na(oa_concepts))){
          if ((i == 1) &amp; (j == 1)){
            # write to the database
            dbWriteTable(con, &quot;oa_concepts&quot;, oa_concepts, row.names=FALSE, append=TRUE) 
            # otherwise, append
          }else{
            # check fields in the existing table
            fields &lt;- dbListFields(con, &quot;oa_concepts&quot;)
            # if some fields missing, pad the dataset
            if(!all(fields %in% colnames(oa_concepts))){
              n_missing &lt;- which(!fields %in% colnames(oa_concepts))
              padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
              colnames(padding) &lt;- fields[which(!fields %in% colnames(oa_concepts))]
              oa_concepts &lt;- bind_cols(oa_concepts,
                                       padding)
              oa_concepts &lt;- oa_concepts[fields]
            }
            # only leave these fields in
            oa_concepts &lt;-  oa_concepts %&gt;%
              select(all_of(fields))
            dbAppendTable(con, &quot;oa_concepts&quot;, oa_concepts, row.names=NULL, append=TRUE)
          }
        }
      }
      
      ## get the grant info
      grant_info &lt;- prof[[&quot;grant_info&quot;]]
      # and write to the database
      # if not empty
      if (!all(is.na(grant_info))){
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;grant_info&quot;, grant_info, row.names=FALSE, append=TRUE)
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;grant_info&quot;)
          if(!all(fields %in% colnames(grant_info))){
            n_missing &lt;- which(!fields %in% colnames(grant_info))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(grant_info))]
            grant_info &lt;- bind_cols(grant_info,
                                     padding)
            grant_info &lt;- grant_info[fields]
          }
          # only leave these fields in
          grant_info &lt;-  grant_info %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;grant_info&quot;, grant_info, row.names=NULL, append=TRUE)
        }
      
      }
      
      ## get the coauthor info
      coauthor_info &lt;- prof[[&quot;coauthor_info&quot;]]
      # and write to the database
      # if not empty
      if (!all(is.na(coauthor_info))){
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;coauthor_info&quot;, coauthor_info, row.names=FALSE, append=TRUE) 
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;coauthor_info&quot;)
          # if needed, pad the dataset
          if(!all(fields %in% colnames(coauthor_info))){
            n_missing &lt;- which(!fields %in% colnames(coauthor_info))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(coauthor_info))]
            coauthor_info &lt;- bind_cols(coauthor_info,
                                    padding)
            coauthor_info &lt;- coauthor_info[fields]
          }
          # only leave these fields in
          coauthor_info &lt;-  coauthor_info %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;coauthor_info&quot;, coauthor_info, row.names=NULL, append=TRUE) 
        }
      }
      
      ## get the affiliation info
      affiliation_info &lt;- prof[[&quot;affiliation_info&quot;]]
      # if not empty
      if (!all(is.na(affiliation_info))){
        # and write to the database
        if ((i == 1) &amp; (j == 1)){
          # write to the database
          dbWriteTable(con, &quot;affiliation_info&quot;, affiliation_info, row.names=FALSE, append=TRUE) 
          # otherwise, append
        }else{
          # check fields in the existing table
          fields &lt;- dbListFields(con, &quot;affiliation_info&quot;)
          # if needed, pad the dataset
          if(!all(fields %in% colnames(affiliation_info))){
            n_missing &lt;- which(!fields %in% colnames(affiliation_info))
            padding &lt;- data.frame(matrix(NA, ncol = length(n_missing), nrow=1))
            colnames(padding) &lt;- fields[which(!fields %in% colnames(affiliation_info))]
            affiliation_info &lt;- bind_cols(affiliation_info,
                                       padding)
            affiliation_info &lt;- affiliation_info[fields]
          }
          
          # only leave these fields in
          affiliation_info &lt;-  affiliation_info %&gt;%
            select(all_of(fields))
          dbAppendTable(con, &quot;affiliation_info&quot;, affiliation_info, row.names=NULL, append=TRUE)  
        }
      }
    }
    
    print(paste(&quot;done with&quot;, j, &quot;out of&quot;, length(prof_batch)))
    
  }
}</code></pre>
</div>
</div>
<div id="data-insights" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Data insights</h1>
<p>Check the overlaps between NARCIS and OA data for profs in each
batch. Also, extract the IDs of professors for whom we did not collect
any data:</p>
<pre class="r"><code># query in batches
narcis_ids &lt;- profs_full$profile_id
# batch size
prof_batch_size &lt;- 500
# vector of indices to loop through
batches &lt;- seq(from=1, to=length(narcis_ids), by=prof_batch_size)
# to be able to subset, also add the final index+1
batches &lt;- c(batches, length(narcis_ids)+1)

# list of profs w/o info
professor_coverage &lt;- data.frame(matrix(NA, ncol = 5, nrow = 0))

# loop through the batches
for(i in 1:(length(batches)-1)){
  # read in the first batch
  prof_batch &lt;- readRDS(paste0(&quot;processed_data/open_alex_prof_data/&quot;, paste(&quot;prof_data_batch&quot;, i, sep = &quot;_&quot;), &quot;.RDS&quot;))
  
  # loop through profs in the list
  for (j in 1:length(prof_batch)){
    prof &lt;- prof_batch[[j]]
    # if there is some info on the prof
    if (length(prof) &gt; 1 ){
      narcis_pubs &lt;- prof[[&quot;narcis_pubs&quot;]]
      oa_pubs &lt;- prof[[&quot;oa_pubs&quot;]]
      if ((!is.null(nrow(prof[[&quot;oa_pubs&quot;]]))&amp;!is.null(nrow(prof[[&quot;narcis_pubs&quot;]])))){
        # remove the html parts of the doi from both
        narcis_pubs$doi_match &lt;- str_remove(narcis_pubs$DOI, &quot;https://doi.org/&quot;)
        oa_pubs$doi_match &lt;- str_remove(oa_pubs$doi, &quot;https://doi.org/&quot;)
        
        # clean the titles of both
        narcis_pubs$title_match &lt;- str_squish(tolower(str_remove_all(narcis_pubs$Title, &quot;[^[:alnum:] ]&quot;)))
        oa_pubs$title_match &lt;- str_squish(tolower(str_remove_all(oa_pubs$display_name, &quot;[^[:alnum:] ]&quot;)))
        
        # find which NARCIS pubs also in OA and vice versa
        narcis_pubs$in_oa &lt;- ifelse(narcis_pubs$doi_match %in% oa_pubs$doi_match|narcis_pubs$title_match %in% oa_pubs$title_match,
                                    TRUE,
                                    FALSE)
        
        oa_pubs$in_narcis &lt;- ifelse(oa_pubs$doi_match %in% narcis_pubs$doi_match| oa_pubs$title_match %in% narcis_pubs$title_match,
                                    TRUE,
                                    FALSE)
        
        # append the professor ID and the coverage overlap into a dataframe
        profile_id &lt;- prof[[&#39;profile_id&#39;]]
        narcis_vs_oa &lt;- round(prop.table(table(narcis_pubs$in_oa))[&#39;TRUE&#39;], 2)
        oa_vs_narcis &lt;- round(prop.table(table(oa_pubs$in_narcis))[&#39;TRUE&#39;], 2)
        narcis_pubs &lt;- NA
        oa_pubs &lt;- NA
        if (!is.null(nrow(prof[[&quot;oa_pubs&quot;]]))){
          oa_pubs &lt;- nrow(prof[[&quot;oa_pubs&quot;]])
        }
        if (!is.null(nrow(prof[[&quot;narcis_pubs&quot;]]))){
          narcis_pubs &lt;- nrow(prof[[&quot;narcis_pubs&quot;]])
        }
        
        row &lt;- cbind(profile_id, 
                     narcis_pubs,
                     oa_pubs,
                     narcis_vs_oa,
                     oa_vs_narcis)
      }else{
        profile_id &lt;- prof[[&#39;profile_id&#39;]]
        narcis_pubs &lt;- NA
        oa_pubs &lt;- NA
        if (!is.null(nrow(prof[[&quot;oa_pubs&quot;]]))){
          oa_pubs &lt;- nrow(prof[[&quot;oa_pubs&quot;]])
        }
        if (!is.null(nrow(prof[[&quot;narcis_pubs&quot;]]))){
          narcis_pubs &lt;- nrow(prof[[&quot;narcis_pubs&quot;]])
        }
        narcis_vs_oa &lt;- NA
        oa_vs_narcis &lt;- NA
        row &lt;- cbind(profile_id, 
                     narcis_pubs,
                     oa_pubs,
                     narcis_vs_oa,
                     oa_vs_narcis) 
      }
    } else{
      profile_id &lt;- names(prof_batch)[j]
      narcis_pubs &lt;- NA
      oa_pubs &lt;- NA
      narcis_vs_oa &lt;- NA
      oa_vs_narcis &lt;- NA
        row &lt;- cbind(profile_id, 
                     narcis_pubs,
                     oa_pubs,
                     narcis_vs_oa,
                     oa_vs_narcis)
    }
    professor_coverage &lt;- rbind(professor_coverage,
                                row)
  }
  print(paste(&quot;done with batch&quot;, i))
}

professor_coverage &lt;- filter(professor_coverage, !is.na(profile_id))</code></pre>
<p>Write this out:</p>
<pre class="r"><code>saveRDS(professor_coverage, &quot;processed_data/professor_coverage.RDS&quot;)</code></pre>
<pre class="r"><code>professor_coverage$narcis_vs_oa &lt;- as.numeric(professor_coverage$narcis_vs_oa)
professor_coverage$oa_vs_narcis &lt;- as.numeric(professor_coverage$oa_vs_narcis)

professor_coverage %&gt;% 
  filter(., !is.na(narcis_vs_oa))%&gt;% 
  summarise(narcis_vs_oa = mean(narcis_vs_oa),
            oa_vs_narcis = mean(oa_vs_narcis))</code></pre>
<pre><code>##   narcis_vs_oa oa_vs_narcis
## 1    0.9443134    0.5267865</code></pre>
<p>So, 94% of the Narcis publications are in our OA data. And 53% of the
OA publications are in our NARCIS data.</p>
<p>Finally, we only miss publication data for 0.25% of the professors
(17).</p>
<pre class="r"><code>length(which(is.na(professor_coverage$narcis_pubs)))</code></pre>
<pre><code>## [1] 17</code></pre>
<pre class="r"><code>length(which(is.na(professor_coverage$narcis_pubs)))/nrow(professor_coverage)*100</code></pre>
<pre><code>## [1] 0.2489019</code></pre>
<pre class="r"><code>length(which(is.na(professor_coverage$oa_pubs)))</code></pre>
<pre><code>## [1] 17</code></pre>
<pre class="r"><code>length(which(is.na(professor_coverage$oa_pubs)))/nrow(professor_coverage)*100</code></pre>
<pre><code>## [1] 0.2489019</code></pre>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIk9wZW5BbGV4X0FsdG1ldHJpY19kYXRhX2Rvd25sb2FkIg0KYXV0aG9yOiAiQW5hIE1hY2Fub3ZpYyINCmRhdGU6ICIyMDI0LTAxLTA2Ig0KLS0tDQoNClRoaXMgc2NyaXB0IHVzZXMgT3BlbkFsZXggZGF0YWJhc2UgdG8gZG93bmxvYWQgZGF0YSBvbiB0aGUgcHJvZmVzc29ycyBpbiBvdXIgc2FtcGxlDQoNCmBgYHtyIGluY2x1ZGU9RkFMU0V9DQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpDQprbml0cjo6b3B0c19jaHVuayRzZXQoZXZhbCA9IEZBTFNFKQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KHdhcm5pbmcgPSBGQUxTRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChtZXNzYWdlID0gRkFMU0UpDQpgYGANCg0KTG9hZCB0aGUgcGFja2FnZXM6DQpgYGB7ciBtZXNzYWdlPSAgRiwgd2FybmluZyA9IEYsIGV2YWwgPSBUfQ0KbGlicmFyeShncm91bmRob2cpDQpwYWNrYWdlc190b19sb2FkIDwtIGMoInJlYWRyIiwgImRwbHlyIiwgIm9wZW5hbGV4UiIsDQogICAgICAgICAgICAgICAgICAgICAgImdncGxvdDIiLCAic3RyaW5nciIsICJ0aWR5ciIsDQogICAgICAgICAgICAgICAgICAgICAgImpzb25saXRlIiwgInhtbDIiLCAidGlkeXZlcnNlIiwNCiAgICAgICAgICAgICAgICAgICAgICAiUlBvc3RncmVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAiREJJIiwgIlJPREJDIiwgIm9kYmMiKQ0KZ3JvdW5kaG9nLmxpYnJhcnkocGFja2FnZXNfdG9fbG9hZCwgZGF0ZSA9ICIyMDIzLTEyLTAxIikNCg0KIyB3ZSd2ZSBhbHNvIGFkZGVkIG91ciBlbWFpbCB0byB0aGUgInBvbGl0ZSBwb29sIiBvZiBPcGVuQWxleCBieQ0KIyBhZGRpbmcgYSBsaW5lIGluIHRoZSAuUnByb2ZpbGUNCmBgYA0KDQojIFRpZHkgdXAgcHJvZmVzc29yIGRhdGEgZnJvbSBOQVJDSVMNCg0KTG9hZCB0aGUgcHJvZmVzc29yIHByb2ZpbGVzOg0KYGBge3IgbWVzc2FnZSA9IEYsIHdhcm5pbmcgPSBGfQ0KbG9hZCgicmF3X2RhdGEvbWVkaWFfcHJvZnNfcHJvZmlsZXMucmRhIikNCnByb2ZzIDwtIHJlYWRfY3N2KCJyYXdfZGF0YS9kdXRjaF9wcm9mc191cmxzLmNzdiIpDQoNCiMgbWVyZ2UgdGhlIHByb2ZzIHdpdGggdGhlaXIgT1JDSURzDQpjb2xuYW1lcyhwcm9mcylbYygxLDcpXSA8LSBjKCJpZCIsICJwcm9maWxlX2lkIikNCg0KcHJvZnNfZnVsbCA8LSBtZXJnZShwcm9mcywNCiAgICAgICAgICAgICAgICAgICAgbWV0YWRmWywgYygxOjQsIDM2MSldLA0KICAgICAgICAgICAgICAgICAgICBieSA9ICJwcm9maWxlX2lkIikNCmBgYA0KDQojIFRpZHkgdXAgdGhlIHB1YmxpY2F0aW9uIGRhdGEgZnJvbSBOQVJDSVMNCkxvYWQgdGhlIHB1YmxpY2F0aW9uIGRhdGE6DQpgYGB7cn0NCiMgZmV0Y2ggdGhlIHBhcGVycw0KbG9hZCgifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcmF3X2RhdGEvbWVkaWFfcHJvZnNfcHVicy5yZGEiKQ0KIyBtYXRjaCB0aGUgcHVibGljYXRpb24gZGF0YSB0byBhdXRob3JzaGlwcw0KbG9hZCgifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcmF3X2RhdGEvbWVkaWFfcHJvZnNfcHViX3RvX3Byb2ZpbGVfaWRzLnJkYSIpDQpjb2xuYW1lcyhwdWJfdG9fcHJvZmlsZV9pZClbMV0gPC0gIm5hcmNpc191cmwiDQoNCnByb2ZfcHVic19mdWxsIDwtIG1lcmdlKHB1YnNfbWV0YWRmWywgYygxOjIzKV0sDQogICAgICAgICAgICAgICAgICAgICAgICBwdWJfdG9fcHJvZmlsZV9pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gIm5hcmNpc191cmwiKQ0KIyBzdHJpcCB0aGUgbGFzdCAvIGZyb20gdGhlIHByb2ZpbGUgaWRzIGhlcmUNCnByb2ZfcHVic19mdWxsJHByb2ZpbGVfaWQgPC0gc3RyX3N1Yihwcm9mX3B1YnNfZnVsbCRwcm9maWxlX2lkLCBlbmQgPSAtMikNCg0KIyB0aWR5IHVwIHNvbWUgbWlzYmVoYXZpbmcgRE9Jcw0KcHJvZl9wdWJzX2Z1bGwkbl93b3JkcyA8LSBzdHJfY291bnQocHJvZl9wdWJzX2Z1bGwkRE9JLCAiICIpDQoNCiMgbGV0J3MgbWFudWFsbHkgZml4IHRoZW0gc2luY2UgdGhlcmUgYXJlIHNvIGZldyBwcm9ibGVtYXRpYyBvbmVzDQpwdWJzX2RvaV93b3JkcyA8LSBmaWx0ZXIocHJvZl9wdWJzX2Z1bGwsIG5fd29yZHMgPiAwKQ0KIyB0aGVzZSBhcmUganVzdCB0aGUgRE9JcyB3aGVyZSB3ZSBoYXZlIG1hbnVhbGx5IHJlbW92ZWQgdGhlIHNwYWNlcyBvciByZWR1bmRhbnQgdGV4dA0KcHVic19kb2lfd29yZHMkRE9JIDwtIGMoIjEwLjEwMTYvai5qaHlkcm9sLjIwMTEuMDMuMDQ3IiwgIjEwLjExMTEvai4xMzY1LTMwOTEuMjAxMi4wMTM2NS54IiwgICANCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTEyMC9qYWNtcC52MTdpNC42MTE3IiwgIjEwLjIyMjAzL2VjbS52MDMyYTExIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4yMjIwMy9lY20udjAzMmExMSIsICIxMC4xMTY3L2lvdnMuMTYtMjA3OTkiLCAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMzYvYm1qc2VtLTIwMTgtMDAwNDI3IiwgIjEwLjExMTEvaGFlLjEyMzUzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTEyOC9pYWkuNjQuMTAuNDIyMC00MjI1LjE5OTYiLCAiMTAuMTAzOS9iMzAyMDk3ZSIsICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDM5L2IzMDIwOTdlIiwgIjEwLjEwMTYvczAwMTYtNTA4NSgxOSkzODA1Mi03IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTAzOS9iMjA5Mzc4YiIsICIxMC4zODUwLzk3OC05ODEtMDctMjYxNS03LTI5MCIsICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0wNy0yNjE1LTcgMjg5IiwgIjEwLjEwMTYvczAwNDAtNjA5MCg5NikwOTI0OC02IiwgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjEwNjEoYXNjZSltdC4xOTQzLTU1MzMuMDAwMjE2OSIsICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMDU5NjAwIiwgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMDU5NjAwIiwgIjEwLjEzNzEvam91cm5hbC5wb25lLjAwNTk2MDAiLCAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTEwOS9pc2JpLjIwMTYuNzQ5MzUzMiIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTEwOS9pc2JpLjIwMTYuNzQ5MzUzMiIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDkvaXNiaS4yMDE2Ljc0OTM1MzIiLCAiMTAuMTA4MC8wMzc5NzcyMDEyMDA4MjY1MSIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0xMS0yNzI0LTNfMDY0MS1jZCIsICIxMC4zODUwLzk3OC05ODEtMTEtMjcyNC0zXzA2NDEtY2QiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wNTk2LWNkIiwgIjEwLjExMzYvYm1qb3Blbi0yMDE3LTAxNjA3NyIsICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMTAzL3BoeXNyZXZsZXR0LjExNS4xNTk5MDEiLCAiMTAuMTUxNS9saW5ndmFuLTIwMTYtMDA0OCIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjExMDgvamZyYy0wNy0yMDE4LTAxMDMiLCAiMTAuMTA5Ny8wMS5icnMuMDAwMDIwNjM4MS4xNTIyNC4wIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAiMTAuMTA4MC8yMTUwNzc0MC4yMDE2LjEyNTE5OTAiLCAiMTAuMTAyMS9pZTA0OTI0NDkgczA4ODgtNTg4NSgwNCkwOTI0NC05IiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDIxL2llMDQ5MjQ0OSBzMDg4OC01ODg1KDA0KTA5MjQ0LTkiLCAiMTAuMjQ3OC92MTAzMDQtMDEyLTAwMTEteSIsICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjEwMDcvczEwODUzLTAxMS01NjgyLTYiLCAiMTAuMTAyMS9qYTA0NTU2NTBzMDAwMi03ODYzKDA0KTA1NTY1LTkiLCAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMDIxL2pvMDQwMTIyMC1zMDAyMi0zMjYzKDA0KTAwMTIyLTciLCIxMC4xMDA3L3MxMDEwMy0wMDgtMDYyNi0zIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4xMzcxL2pvdXJuYWwucG9uZS4wMjE2NzQzIiwgIjEwLjExNzcvMDAyMTg4NjMxNjY3MjcyNCIsICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjUxOTQvc2UtMTAtNTE3LTIwMTkiLCAiMTAuMTg2OTAvOTc4LTk2MS0yODYtMDYxLTUuMyIsICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjE4NjkwLzk3OC05NjEtMjg2LTA2MS01LjMiLCAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wNDQxLWNkIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgIjEwLjM4NTAvOTc4LTk4MS0xMS0yNzI1LTAtaXMzLTUtY2QiLCAiMTAuMzM5MC9hdG1vczEyMTIxNjMzIiwgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICIxMC4zODUwLzk3OC05ODEtMTQtODU5My0wLTQxMzktY2QiLCAiMTAuMzg1MC85NzgtOTgxLTExLTI3MjQtM18wMjQ4LWNkIikgDQojIGZpeCB0aGUgcHViIGxpc3QNCiMgZmlsdGVyIG91dCB0aGUgcHJvYmxlbWF0aWMgZG9pcw0KcHJvZl9wdWJzX2Z1bGxfZml4IDwtIGZpbHRlcihwcm9mX3B1YnNfZnVsbCwgKGlzLm5hKG5fd29yZHMpfG5fd29yZHMgPT0gMCkpDQojIGFuZCB0aGVuIHB1dCB0aGVtIGJhY2sNCnByb2ZfcHVic19mdWxsIDwtIHJiaW5kKHByb2ZfcHVic19mdWxsX2ZpeCwNCiAgICAgICAgICAgICAgICAgICAgICAgIHB1YnNfZG9pX3dvcmRzKQ0KDQoNCiMgZHJvcCBsYXJnZSBmaWxlcyBmcm9tIHRoZSBtZW1vcnkgYXMgd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmUNCnJtKHB1YnNfbWV0YWRmKQ0Kcm0obWV0YWRmKQ0Kcm0ocHViX3RvX3Byb2ZpbGVfaWQpDQpnYygpDQpgYGANCg0KDQojIERlZmluZSB0aGUgZGF0YSBxdWVyeWluZyBmdW5jdGlvbnMNCg0KIyMgU2VlayBwcm9mZXNzb3IgaWRlbnRpZmllcnMgaW4gT3BlbkFsZXgNCg0KRGVmaW5lIHRoZSBmdW5jdGlvbiB0aGF0IGhlbHBzIHVzIHNlZWsgaWRlbnRpZmllcnMgZnJvbToNCjEuIFByb2Zlc3NvcidzIE5hcmNpcyBwdWJsaWNhdGlvbiBsaXN0IChiYXNlZCBvbiBET0kpDQoyLiBQcm9mZXNzb3IncyBPUkNJRCBhcyBpbiBOYXJjaXMNCjMuIFByb2Zlc3NvcidzIG5hbWUgKyBOTCBhcyB0aGUgY291bnRyeSBvZiB0aGVpciBsYXN0IGtub3duIGluc3RpdHV0aW9uDQoNClRoaXMgZGlhZ3JhbSBkZXNjcmliZXMgaG93IHdlIGRvIGl0Og0KIVtGaWd1cmUgMV0oaW1hZ2VzL3Byb2Zlc3Nvcl9pZGVudGlmaWVyX3JldHJpZXZlcl9kaWFncmFtLnBuZykNCg0KYGBge3J9DQpwcm9mZXNzb3JfaWRlbnRpZmllcl9yZXRyaWV2ZXIgPC0gZnVuY3Rpb24obmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Yl9kYXRhLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfZGF0YSl7DQogIA0KICAjIHNldCBhbGwgdGhlIGlkZW50aWZpZXJzIHRvIE5BDQogIG9hX2lkc19wdWJzIDwtIE5BDQogIG9hX2lkc19uYW1lcyA8LSBOQQ0KICBvYV9pZHNfb3JjaWQgPC0gTkENCiAgcHJvZl9vcmNpZCA8LSBOQQ0KICBwcm9mX25hbWUgPC0gTkENCiAgcHJvZl9uYW1lX3dfaW5pdGlhbHMgPC0gTkENCiAgcHJvZl9uYW1lX3dfaW5pdGlhbHNfc3BhY2UgPC0gTkENCiAgcHJvZl9pbml0aWFsc193b19maXJzdF9uYW1lIDwtIE5BDQogIHByb2ZfaW5pdGlhbHNfd29fZmlyc3RfbmFtZV9zcGFjZSA8LSBOQQ0KICBwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHMgPC0gTkENCiAgcHJvZl9uYW1lX2ZpcnN0X2luaXRpYWxzX3NwYWNlIDwtIE5BDQogIHByb2ZfYWx0ZXJuYXRpdmVfZnVsbF9uYW1lIDwtIE5BDQogIA0KICAjIGdldCB0aGUgcHJvZmVzc29yJ3MgbmFyY2lzIGlkIGFuYWQgZ2V0IHRoZWlyIHB1YmxpY2F0aW9ucyBiYXNlZCBvbiB0aGlzDQogIHByb2ZfcHVicyA8LSBmaWx0ZXIocHViX2RhdGEsIHByb2ZpbGVfaWQgPT0gbmFyY2lzX2lkKQ0KICANCiAgIyBnZXQgdGhlaXIgbmFtZQ0KICBwcm9mX25hbWVfZGV0YWlscyA8LSBmaWx0ZXIocHJvZl9kYXRhLCBwcm9maWxlX2lkID09IG5hcmNpc19pZCkNCiAgcHJvZl9vcmNpZCA8LSBwcm9mX25hbWVfZGV0YWlscyRPUkNJRA0KICBwcm9mX25hbWUgPC0gcGFzdGUocHJvZl9uYW1lX2RldGFpbHMkZmlyc3QsIA0KICAgICAgICAgICAgICAgICAgICAgcHJvZl9uYW1lX2RldGFpbHMkbGFzdCkNCiAgDQogICMgZ2V0IHRoZSBuYW1lLCBpbml0aWFscywgZXRjIGNvbWJpbmF0aW9ucw0KICAjIGNvbnZlcnQgdGhlIHNwZWNpYWwgY2hhcmFjdGVycw0KICBwcm9mX25hbWVfZGV0YWlsc1ssIDQ6MTFdIDwtIGljb252KHByb2ZfbmFtZV9kZXRhaWxzWywgNDoxMV0sIHRvPSdBU0NJSS8vVFJBTlNMSVQnKQ0KICANCiAgIyBnZXQgZmlyc3QvbGFzdCBuYW1lDQogIHByb2ZfbmFtZSA8LSBwYXN0ZSgNCiAgICBwcm9mX25hbWVfZGV0YWlscyRmaXJzdCwgDQogICAgcHJvZl9uYW1lX2RldGFpbHMkbGFzdCkNCiAgcHJvZl9uYW1lIDwtIHBhc3RlMCgiXiIsDQogICAgICAgICAgICAgICAgICAgICAgcHJvZl9uYW1lLA0KICAgICAgICAgICAgICAgICAgICAgICIkIikNCiAgIyBnZXQgdGhlaXIgaW5pdGlhbHMsIGRyb3AgdGhlaXIgbmFtZSBpbiB0aGUgYnJhY2tldHMNCiAgcHJvZl9pbml0aWFscyA8LSBzdHJfc3F1aXNoKHN0cl9zcGxpdF9pKHByb2ZfbmFtZV9kZXRhaWxzJGluaXRpYWxlbiwgIlxcKCIsIDEpKQ0KICAjIGJ1dCBzb21lIHByb2ZzIG1pZ2h0IGhhdmUgYSByb2VwbmFhbSB3aGljaCBpcyBub3QgdGhlIG5hbWUgdGhleSB1c2UNCiAgIyB0byBzaWduIHRoZWlyIHBhcGVycyAodGhlIGJyYWNrZXRzIHdpbGwgY29udGFpbiB0aGUgcm9lcG5hYW0sIGJ1dCB0aGUNCiAgIyBpbml0aWFscyB3aWxsIGJlIGNvbnRhaW5pbmcgdGhlIGFjdHVhbCBmaXJzdCBuYW1lKQ0KICAjIGdldCBhbiBhZGRpdGlvbmFsIG9wdGlvbiB3L28gdGhlIGZpcnN0IG5hbWUgYXQgYWxsDQogIHByb2ZfaW5pdGlhbHNfd29fZmlyc3RfbmFtZSA8LSBwYXN0ZShzdHJfc3BsaXQocHJvZl9pbml0aWFscywgIlxcLiIpW1sxXV0sIGNvbGxhcHNlID0gIi4iKQ0KICAjIGFuZCBzcGFjZSB0aGVtIG91dA0KICBwcm9mX2luaXRpYWxzX3dvX2ZpcnN0X25hbWVfc3BhY2UgPC0gcGFzdGUoc3RyX3NwbGl0KHByb2ZfaW5pdGlhbHMsICJcXC4iKVtbMV1dLCBjb2xsYXBzZSA9ICIuICIpDQogIA0KICAjIGdldCB0aGUgaW5pdGlhbHMNCiAgcHJvZl9pbml0aWFscyA8LSBzdHJfc3BsaXQocHJvZl9pbml0aWFscywgIlxcLiIpW1sxXV1bLWMoMSwgbGVuZ3RoKHN0cl9zcGxpdChwcm9mX2luaXRpYWxzLCAiXFwuIilbWzFdXSkpXQ0KICBwcm9mX2luaXRpYWxzX25vX3NwYWNlIDwtIHBhc3RlMChwYXN0ZShwcm9mX2luaXRpYWxzLCBjb2xsYXBzZSA9ICIuIiksICIuIikNCiAgcHJvZl9pbml0aWFsc19zcGFjZSA8LSBwYXN0ZTAocGFzdGUocHJvZl9pbml0aWFscywgY29sbGFwc2UgPSAiLiAiKSwgIi4iKQ0KICAjIHByb2Zlc3NvciBmaXJzdCBuYW1lLCBpbml0aWFscywgbGFzdCBuYW1lDQogIHByb2ZfbmFtZV93X2luaXRpYWxzIDwtICB0b2xvd2VyKHBhc3RlKHByb2ZfbmFtZV9kZXRhaWxzJGZpcnN0LCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9pbml0aWFsc19ub19zcGFjZSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9uYW1lX2RldGFpbHMkbGFzdCkpDQogICMgdGlkeSB1cA0KICBwcm9mX25hbWVfd19pbml0aWFscyA8LSBwYXN0ZTAoIl4iLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cl9yZXBsYWNlKHN0cl9yZXBsYWNlKHByb2ZfbmFtZV93X2luaXRpYWxzLCAiIFxcLiAiLCAiICIpLCAiXFwuXFwuIiwgIiAiKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIkIikNCiAgDQogICMgcHJvZmVzc29yIGZpcnN0IG5hbWUsIGluaXRpYWxzLCBsYXN0IG5hbWUsIHdpdGggc3BhY2VzIGJldHdlZW4gdGhlIGluaXRpYWxzDQogIHByb2ZfbmFtZV93X2luaXRpYWxzX3NwYWNlIDwtICB0b2xvd2VyKHBhc3RlKA0KICAgIHByb2ZfbmFtZV9kZXRhaWxzJGZpcnN0LCANCiAgICBwcm9mX2luaXRpYWxzX3NwYWNlLA0KICAgIHByb2ZfbmFtZV9kZXRhaWxzJGxhc3QpKQ0KICANCiAgIyB0aWR5IHVwDQogIHByb2ZfbmFtZV93X2luaXRpYWxzX3NwYWNlIDwtIHBhc3RlMCgiXiIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyX3JlcGxhY2Uoc3RyX3JlcGxhY2UocHJvZl9uYW1lX3dfaW5pdGlhbHNfc3BhY2UsICIgXFwuICIsICIgIiksICJcXC5cXC4iLCAiICIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIiQiKQ0KICANCiAgIyBqdXN0IHRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIG5hbWUgKyBpbml0aWFscw0KICAjIHdpdGggc3BhY2luZw0KICBmaXJzdF9pbml0aWFsc19zcGFjZSA8LSBwYXN0ZShwYXN0ZTAoc3Vic3RyaW5nKHByb2ZfbmFtZV9kZXRhaWxzJGZpcnN0LCAxLCAxKSwgIi4iKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9pbml0aWFsc19zcGFjZSkNCiAgDQogIHByb2ZfbmFtZV9maXJzdF9pbml0aWFsc19zcGFjZSA8LSB0b2xvd2VyKHBhc3RlKGZpcnN0X2luaXRpYWxzX3NwYWNlLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9uYW1lX2RldGFpbHMkbGFzdCkpDQogICMgdGlkeSB1cA0KICBwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHNfc3BhY2UgPC0gcGFzdGUwKCJeIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyX3JlcGxhY2Uoc3RyX3JlcGxhY2UocHJvZl9uYW1lX2ZpcnN0X2luaXRpYWxzX3NwYWNlLCAiIFxcLiAiLCAiICIpLCAiXFwuXFwuIiwgIi4iKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiJCIpDQogIA0KICAjIHcvbyBzcGFjaW5nDQogIGZpcnN0X2luaXRpYWxzIDwtIHN0cl9yZW1vdmVfYWxsKHBhc3RlKHBhc3RlMChzdWJzdHJpbmcocHJvZl9uYW1lX2RldGFpbHMkZmlyc3QsIDEsIDEpLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIuIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfaW5pdGlhbHNfc3BhY2UpLCAiICIpDQogIA0KICBwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHMgPC0gdG9sb3dlcihwYXN0ZShmaXJzdF9pbml0aWFscywgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfbmFtZV9kZXRhaWxzJGxhc3QpKQ0KICANCiAgIyB0aWR5IHVwDQogIHByb2ZfbmFtZV9maXJzdF9pbml0aWFscyA8LSBwYXN0ZTAoIl4iLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJfcmVwbGFjZShzdHJfcmVwbGFjZShwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHMsICIgXFwuICIsICIgIiksICJcXC5cXC4iLCAiICIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIkIikNCiAgDQogICMgZm9yIHNvbWUgcHJvZmVzc29ycywgd2UgbWFudWFsbHkgZmluZCB0aGVpciBhY3R1YWwgbmFtZSB2cyB0aGVpciByb2VwbmFhbSBpbiBOQVJDSVMNCiAgaWYgKG5hcmNpc19pZCA9PSAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM5MTkwIil7DQogICAgcHJvZl9hbHRlcm5hdGl2ZV9mdWxsX25hbWUgPC0gdG9sb3dlcigiXFxiQWxiZXJ0IE0uIEJyb3V3ZXJcXGIiKQ0KICB9DQogIGlmIChuYXJjaXNfaWQgPT0gImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzODA0NSIpew0KICAgIHByb2ZfYWx0ZXJuYXRpdmVfZnVsbF9uYW1lIDwtIHRvbG93ZXIoIlxcYkplYW4tQmVybmFyZCBNYXJ0ZW5zXFxiIikNCiAgfQ0KICANCiAgDQogICMgZ2V0IHRoZSBET0kgbGlzdCB3aXRob3V0IHRoZSBOQXMNCiAgZG9pX2xpc3QgPC0gcHJvZl9wdWJzJERPSVshaXMubmEocHJvZl9wdWJzJERPSSldDQogIHByb2ZfYWx0ZXJuYXRpdmVfZnVsbF9uYW1lIDwtIE5BDQogIA0KICAjIHRyeSB0byBnZXQgdGhlIElEcw0KICBpZiAoYWxsKGlzLm5hKG9hX2lkc19wdWJzKSkpew0KICAgICMgaWYgYW55IERPSXMgaW4gb3VyIGxpc3Q6DQogICAgaWYgKGxlbmd0aChkb2lfbGlzdCk+MCl7DQogICAgICANCiAgICAgICMgY2FsbCBPcGVuQWxleCB0byBnZXQgdGhlaXIgd29ya3MgYmFzZWQgb24gdGhlIERPSXMNCiAgICAgICMgZG8gaXQgaW4gYmF0Y2hlcyAoY3VycmVudGx5IDI1KQ0KICAgICAgYmF0Y2hfc2l6ZSA8LSAyNQ0KICAgICAgYmF0Y2hlcyA8LSBjZWlsaW5nKGxlbmd0aChkb2lfbGlzdCkvYmF0Y2hfc2l6ZSkNCiAgICAgIHByb2Zfd29ya3Nfb2EgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSAxNiwgbnJvdyA9IDApKQ0KICAgICAgYmVnaW5fYmF0Y2ggPC0gMQ0KICAgICAgZW5kX2JhdGNoIDwtIGJhdGNoX3NpemUNCiAgICAgICMgaW5pdGlhbGl6ZSBhbiBlbXB0eSBkYXRhIGZyYW1lDQogICAgICBwcm9mX3dvcmtzX29hX2JhdGNoIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gMTYsIG5yb3cgPSAwKSkNCiAgICAgICMgbG9vcCB0aHJvdWdoIHRoZSBiYXRjaGVzDQogICAgICBmb3IoaSBpbiAxOmJhdGNoZXMpew0KICAgICAgICAjIGdldCB0aGUgZmlyc3QgYmF0Y2gNCiAgICAgICAgIyB0cnksIGlmIGVycm9yLCBqdXN0IHN0b3ANCiAgICAgICAgdHJ5KA0KICAgICAgICAgIHByb2Zfd29ya3Nfb2FfYmF0Y2ggPC0gb2FfZmV0Y2goDQogICAgICAgICAgICBlbnRpdHkgPSAid29ya3MiLA0KICAgICAgICAgICAgZG9pID0gZG9pX2xpc3RbYmVnaW5fYmF0Y2g6ZW5kX2JhdGNoXSksIA0KICAgICAgICAgIHNpbGVudCA9IFRSVUUNCiAgICAgICAgKQ0KICAgICAgICAjIHdoZW4gYmluZGluZywgc29tZSBjb2x1bW5zIG1pZ2h0IG5vdCBiZSB0aGVyZQ0KICAgICAgICAjIHNvIHRvIGFkZHJlc3MgdGhhdCwgY2hlY2sgdGhlIGNvbHVtbnMNCiAgICAgICAgIyBpZiB0aGUgbmV3IGJhdGNoIGhhcyBsZXNzIChidXQgb25seSBhZnRlciB0aGUgZmlyc3QgYmF0Y2ggd2FzIHByb2Nlc3NlZCwgdGh1cyBpID4gMSkNCiAgICAgICAgaWYgKGkgPiAxICYgbGVuZ3RoKHdoaWNoKCFjb2xuYW1lcyhwcm9mX3dvcmtzX29hKSAlaW4lIGNvbG5hbWVzKHByb2Zfd29ya3Nfb2FfYmF0Y2gpKSkgPiAwKXsNCiAgICAgICAgICAjIGFkZCB0aGUgbWlzc2luZyBjb2x1bW5zIGZpbGxlZCB3aXRoIE5Bcw0KICAgICAgICAgIHByb2Zfd29ya3Nfb2FfYmF0Y2hbY29sbmFtZXMocHJvZl93b3Jrc19vYSlbd2hpY2goISBjb2xuYW1lcyhwcm9mX3dvcmtzX29hKSAlaW4lIGNvbG5hbWVzKHByb2Zfd29ya3Nfb2FfYmF0Y2gpKV1dIDwtIE5BDQogICAgICAgICAgIyByZWFycmFuZ2UgdGhlIGNvbHVtbnMNCiAgICAgICAgICBwcm9mX3dvcmtzX29hX2JhdGNoIDwtIHByb2Zfd29ya3Nfb2FfYmF0Y2hbY29sbmFtZXMocHJvZl93b3Jrc19vYSldDQogICAgICAgIH0NCiAgICAgICAgIyBpZiB0aGUgbmV3IGJhdGNoIGhhcyBtb3JlIChidXQgb25seSBhZnRlciB0aGUgZmlyc3QgYmF0Y2ggd2FzIHByb2Nlc3NlZCwgdGh1cyBpID4gMSkNCiAgICAgICAgaWYgKGkgPiAxICYgbGVuZ3RoKHdoaWNoKCEgY29sbmFtZXMocHJvZl93b3Jrc19vYV9iYXRjaCkgJWluJSBjb2xuYW1lcyhwcm9mX3dvcmtzX29hKSkpID4gMCl7DQogICAgICAgICAgIyBhZGQgdGhlIG1pc3NpbmcgY29sdW1ucyBmaWxsZWQgd2l0aCBOQXMNCiAgICAgICAgICBwcm9mX3dvcmtzX29hW2NvbG5hbWVzKHByb2Zfd29ya3Nfb2FfYmF0Y2gpW3doaWNoKCEgY29sbmFtZXMocHJvZl93b3Jrc19vYV9iYXRjaCkgJWluJSBjb2xuYW1lcyhwcm9mX3dvcmtzX29hKSldXSA8LSBOQQ0KICAgICAgICAgICMgcmVhcnJhbmdlIHRoZSBjb2x1bW5zDQogICAgICAgICAgcHJvZl93b3Jrc19vYSA8LSBwcm9mX3dvcmtzX29hW2NvbG5hbWVzKHByb2Zfd29ya3Nfb2FfYmF0Y2gpXQ0KICAgICAgICB9DQogICAgICAgIA0KICAgICAgICAjIGJpbmQgdG8gdGhlIHJlc3QNCiAgICAgICAgcHJvZl93b3Jrc19vYSA8LSByYmluZChwcm9mX3dvcmtzX29hLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Zfd29ya3Nfb2FfYmF0Y2gpDQogICAgICAgIA0KICAgICAgICAjIGdldCB0aGUgcmVtYWluaW5nIGJhdGNoIHNpemUsIGFuZCBnbyB0byB0aGUgZW5kIGlmIGxlc3MgdGhhbiBiYXRjaCBzaXplLCANCiAgICAgICAgIyBhbmQgZ28gZm9yIGFub3RoZXIgcm91bmQgaWYgbW9yZSB0aGFuIGJhdGNoIHNpemUNCiAgICAgICAgaWYgKGxlbmd0aChkb2lfbGlzdCktZW5kX2JhdGNoIDw9IGJhdGNoX3NpemUpew0KICAgICAgICAgIGVuZF9iYXRjaCA8LSBlbmRfYmF0Y2ggKyBsZW5ndGgoZG9pX2xpc3QpLWVuZF9iYXRjaA0KICAgICAgICB9ZWxzZXsNCiAgICAgICAgICBlbmRfYmF0Y2ggPC0gZW5kX2JhdGNoICsgYmF0Y2hfc2l6ZQ0KICAgICAgICB9DQogICAgICAgICMgc2V0IHRoZSBiZWdpbm5pbmcgdG8gdGhlIGJlZ2lubmluZyArIGJhdGNoIHNpemUNCiAgICAgICAgYmVnaW5fYmF0Y2ggPC0gYmVnaW5fYmF0Y2ggKyBiYXRjaF9zaXplDQogICAgICB9DQogICAgICANCiAgICAgICMgYW5kIG5vdyBsb29wIHRocm91Z2ggdGhlIGF1dGhvcnMgb2YgdGhlc2UgcGFwZXJzIGluIE9wZW5BbGV4IHRvIGdldCBpbmZvDQogICAgICAjIG9uIHRoZSBhdXRob3IgaWRzIE9wZW5BbGV4IGhhcyBvbiB0aGVtDQogICAgICBwcm9mX29haWRfaW5mbyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAxMykpDQogICAgICAjIGxvb3AgdGhyb3VnaCB0aGUgcGFwZXJzIHdlIHJldHJpZXZlZCwgZ2V0IHRoZSBET0lzIGFuZCBhdXRob3IgbGlzdHMgYW5kIHRyeSB0byBtYXRjaCB0aGUNCiAgICAgICMgYXV0aG9yIHRvIHRob3NlIHdlIG1pc3MNCiAgICAgIGlmIChucm93KHByb2Zfd29ya3Nfb2EpID4gMCAmICFhbGwoaXMubmEocHJvZl93b3Jrc19vYSkpKXsNCiAgICAgICAgZm9yIChpIGluIDE6bnJvdyhwcm9mX3dvcmtzX29hKSl7DQogICAgICAgICAgYXV0aG9yX2luZm8gPC0gYygpDQogICAgICAgICAgaW5mbyA8LSBwcm9mX3dvcmtzX29hW2ksIGMoImlkIiwiZGlzcGxheV9uYW1lIiwgImRvaSIpXQ0KICAgICAgICAgIGRvaV9pbl9xdWVzdGlvbiA8LSBzdHJfcmVtb3ZlKGluZm8kZG9pLCAiaHR0cHM6Ly9kb2kub3JnLyIpDQogICAgICAgICAgIyBpZiBmb3VuZCBhbmQgb25lIHBlcnNvbg0KICAgICAgICAgIGF1dGhvcnMgPC0gcHJvZl93b3Jrc19vYVtpLCAiYXV0aG9yIl1bWzFdXVtbMV1dDQogICAgICAgICAgaWYgKGNsYXNzKGF1dGhvcnMpICE9ICJsb2dpY2FsIil7DQoNCiAgICAgICAgICAgICMgcmVtb3ZlIHNwZWNpYWwgY2hhcmFjdGVycw0KICAgICAgICAgICAgYXV0aG9ycyRhdV9kaXNwbGF5X25hbWUgPC0gaWNvbnYoYXV0aG9ycyRhdV9kaXNwbGF5X25hbWUsIHRvPSdBU0NJSS8vVFJBTlNMSVQnKQ0KICAgIA0KICAgICAgICAgICAgIyBmaW5kIHRoZSBhdXRob3Igd2l0aCBhIG1hdGNoaW5nIG5hbWUNCiAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2ggPC0gZ3JlcGwocHJvZl9uYW1lLCB0b2xvd2VyKGF1dGhvcnMkYXVfZGlzcGxheV9uYW1lKSkNCiAgICAgICAgICAgICMgY2hlY2sgd2l0aCBpbml0aWFscyBhcyB3ZWxsDQogICAgICAgICAgICBhdXRob3JzJG1hdGNoIDwtIGlmZWxzZShhdXRob3JzJG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9uYW1lX3dfaW5pdGlhbHMsIHRvbG93ZXIoYXV0aG9ycyRhdV9kaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2gpDQogICAgICAgICAgICAjIGFuZCBzcGFjZWQgb3V0IGluaXRpYWxzDQogICAgICAgICAgICBhdXRob3JzJG1hdGNoIDwtIGlmZWxzZShhdXRob3JzJG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9uYW1lX3dfaW5pdGlhbHNfc3BhY2UsIHRvbG93ZXIoYXV0aG9ycyRhdV9kaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2gpDQogICAgICAgICAgICAjIGFuZCBubyBmaXJzdCBuYW1lLCBidXQgb25seSBpbml0aWFscyBhbmQgYWxzbyBvbmx5IHNwYWNlZCBvdXQgaW5pdGlhbHMNCiAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2ggPC0gaWZlbHNlKGF1dGhvcnMkbWF0Y2ggPT0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHMsIHRvbG93ZXIoYXV0aG9ycyRhdV9kaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2gpDQogICAgICAgICAgICANCiAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2ggPC0gaWZlbHNlKGF1dGhvcnMkbWF0Y2ggPT0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHNfc3BhY2UsIHRvbG93ZXIoYXV0aG9ycyRhdV9kaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2gpDQogICAgICAgICAgICANCiAgICAgICAgICAgICMgaWYgbm90aGluZyBzdGlsbCwgaW5pdGlhbHMgd2l0aG91dCB0aGUgZmlyc3QgbmFtZQ0KICAgICAgICAgICAgYXV0aG9ycyRtYXRjaCA8LSBpZmVsc2UoYXV0aG9ycyRtYXRjaCA9PSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyZXBsKHByb2ZfaW5pdGlhbHNfd29fZmlyc3RfbmFtZSwgdG9sb3dlcihhdXRob3JzJGF1X2Rpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9ycyRtYXRjaCkNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgYXV0aG9ycyRtYXRjaCA8LSBpZmVsc2UoYXV0aG9ycyRtYXRjaCA9PSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyZXBsKHByb2ZfaW5pdGlhbHNfd29fZmlyc3RfbmFtZV9zcGFjZSwgdG9sb3dlcihhdXRob3JzJGF1X2Rpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9ycyRtYXRjaCkgICANCiAgICAgICAgICAgICMgYW5kIHRoZWlyIGFsdGVybmF0aXZlIGZpcnN0IG5hbWUgd2UgbWFudWFsbHkgY29ycmVjdCBmb3INCiAgICAgICAgICAgIGF1dGhvcnMkbWF0Y2ggPC0gaWZlbHNlKGF1dGhvcnMkbWF0Y2ggPT0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX2FsdGVybmF0aXZlX2Z1bGxfbmFtZSwgdG9sb3dlcihhdXRob3JzJGF1X2Rpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9ycyRtYXRjaCkgICANCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBmZXRjaCB0aGUgYXV0aG9yLCBpZiB0aGVyZSBpcyBhIG1hdGNoDQogICAgICAgICAgICBhdXRob3IgPC0gZmlsdGVyKGF1dGhvcnMsIG1hdGNoID09IFRSVUUpDQogICAgICAgICAgICANCiAgICAgICAgICAgIGlmIChucm93KGF1dGhvcikgPT0gMSl7DQogICAgICAgICAgICAgICMgcmVtb3ZlIHRoZSAibWF0Y2giIGNvbHVtbg0KICAgICAgICAgICAgICBhdXRob3JfaW5mbyA8LSBhdXRob3JbLCAtMTJdDQogICAgICAgICAgICAgICMgYmluZCB3aXRoIHRoZSBuYXJjaXMgSUQgZm9yIGxhdGVyDQogICAgICAgICAgICAgIGF1dGhvcl9pbmZvJHByb2ZpbGVfaWQgPC0gbmFyY2lzX2lkDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIA0KICAgICAgICAgIHByb2Zfb2FpZF9pbmZvIDwtIHJiaW5kKHByb2Zfb2FpZF9pbmZvLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcl9pbmZvKQ0KICAgICAgICB9DQogICAgICAgIA0KICAgICAgICAjIG1ha2Ugc3VyZSB0aGUgZW1wdHkgb2FfaWQgZGlkIG5vdCBtYWtlIGl0IGluIGhlcmUsIGJlY2F1c2UgdGhlbiB3ZSBnZXQgc3R1Y2sNCiAgICAgICAgIyBpbiBhbiBlbmRsZXNzIGxvb3AgKG9yIGZldGNoIHRoaW5ncyB3ZSBkbyBub3Qgd2FudCB0bywgYnVyZGVuaW5nIHRoZSBBUEkpDQogICAgICAgIGlmIChucm93KHByb2Zfb2FpZF9pbmZvKSA+IDApew0KICAgICAgICAgIHByb2Zfb2FpZF9pbmZvIDwtIGZpbHRlcihwcm9mX29haWRfaW5mbywgYXVfaWQgIT0gImh0dHBzOi8vb3BlbmFsZXgub3JnL0E5OTk5OTk5OTk5IikNCiAgICAgICAgICAjIGdldCBhbGwgb2EgaWRzIG9mIHRoZSBhdXRob3INCiAgICAgICAgICBvYV9pZHNfcHVicyA8LSBhcy5jaGFyYWN0ZXIodW5pcXVlKHByb2Zfb2FpZF9pbmZvJGF1X2lkKSkNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0NCiAgfQ0KICANCiAgIyBpZiBubyBJRCBmb3VuZDoNCiAgaWYgKGFsbChpcy5uYShvYV9pZHNfb3JjaWQpKSl7DQogICAgIyBpZiBubyBET0lzIGluIG91ciBsaXN0LCBjaGVjayBpZiB0aGVyZSBpcyBhbiBPUkNJRCB3ZSBjYW4gdXNlDQogICAgcHJvZl9vcmNpZCA8LSBwcm9mX25hbWVfZGV0YWlscyRPUkNJRA0KICAgICMgaWYgdGhlcmUncyBhbiBvcmNpZA0KICAgIGlmICghaXMubmEocHJvZl9vcmNpZCkpew0KICAgICAgIyBmZXRjaCBwcm9mZXNzb3IgaW5mbyBmcm9tIE9SQ0lEcw0KICAgICAgcHJvZl9pbmZvIDwtIG9hX2ZldGNoKA0KICAgICAgICBlbnRpdHkgPSAiYXV0aG9ycyIsIA0KICAgICAgICBvcmNpZCA9IHByb2Zfb3JjaWQpDQogICAgICANCiAgICAgIGlmICghaXMubnVsbChwcm9mX2luZm8pKXsNCiAgICAgICAgIyBtYWtlIHN1cmUgdGhlIG5vIG5hbWUgSUQgaXMgbm90IGluIGhlcmUNCiAgICAgICAgcHJvZl9pbmZvIDwtIGZpbHRlcihwcm9mX2luZm8sIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICE9ICJodHRwczovL29wZW5hbGV4Lm9yZy9BOTk5OTk5OTk5OSIpDQogICAgICAgICMgbm93IHJldHJpZXZlIE9BIElEcyBmcm9tIHRoaXMNCiAgICAgICAgb2FfaWRzX29yY2lkIDwtIGFzLmNoYXJhY3Rlcih1bmlxdWUocHJvZl9pbmZvJGlkKSkNCiAgICAgIH0NCiAgICB9DQogIH0NCiAgDQogICMgaWYgb2FfaWRzIHN0aWxsIE5BDQogIG9hX2lkc19ieV9uYW1lIDwtIGFzLmRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDE3KSkNCiAgaWYgKGFsbChpcy5uYShvYV9pZHNfbmFtZXMpKSl7DQogICAgIyBzZWFyY2ggYnkgbmFtZQ0KICAgIG9hX2F1X3Jlc3VsdCA8LSBvYV9mZXRjaCgiYXV0aG9yIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoID0gcGFzdGUocHJvZl9uYW1lX2RldGFpbHMkZmlyc3QsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX25hbWVfZGV0YWlscyRhY2h0ZXJuYWFtKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9rbm93bl9pbnN0aXR1dGlvbi5jb3VudHJ5X2NvZGUgPSAiTkwiKQ0KICAgIA0KICAgICMgaWYgbm8gcmVzdWx0cywgdHJ5IGFuIGFsdGVybmF0aXZlIG5hbWUgaWYgcHJlc2VudA0KICAgIGlmKCFpcy5udWxsKG5yb3cob2FfYXVfcmVzdWx0KSkgJiAhaXMubmEocHJvZl9hbHRlcm5hdGl2ZV9mdWxsX25hbWUpKXsNCiAgICAgIG9hX2F1X3Jlc3VsdCA8LSBvYV9mZXRjaCgiYXV0aG9yIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2ggPSBwcm9mX2FsdGVybmF0aXZlX2Z1bGxfbmFtZSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2tub3duX2luc3RpdHV0aW9uLmNvdW50cnlfY29kZSA9ICJOTCIpDQogICAgfQ0KICAgICMgaWYgc3RpbGwgbm8gcmVzdWx0cywgdHJ5IHdpdGggZXh0ZW5zaXZlIGFkZGl0aW9uYWwgbmFtZSBkaXNwbGF5czoNCg0KIyBpZiBhbnkgcmVzdWx0cywgc2VlIHdoaWNoIG5hbWVzIGFyZSBhbiBleGFjdCBtYXRjaA0KICAgIGlmKCFpcy5udWxsKG5yb3cob2FfYXVfcmVzdWx0KSkpew0KICAgICAgDQogICAgICBvYV9hdV9yZXN1bHQkZGlzcGxheV9uYW1lIDwtIGljb252KG9hX2F1X3Jlc3VsdCRkaXNwbGF5X25hbWUgLCB0bz0nQVNDSUkvL1RSQU5TTElUJykNCiAgICAgIA0KICAgICAgIyBmaW5kIHRoZSBhdXRob3Igd2l0aCBhIG1hdGNoaW5nIG5hbWUNCiAgICAgIG9hX2F1X3Jlc3VsdCRtYXRjaCA8LSBncmVwbChwcm9mX25hbWUsIHRvbG93ZXIob2FfYXVfcmVzdWx0JGRpc3BsYXlfbmFtZSkpDQogICAgICAjIGNoZWNrIHdpdGggaW5pdGlhbHMgYXMgd2VsbA0KICAgICAgb2FfYXVfcmVzdWx0JG1hdGNoIDwtIGlmZWxzZShvYV9hdV9yZXN1bHQkbWF0Y2ggPT0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9uYW1lX3dfaW5pdGlhbHMsIHRvbG93ZXIob2FfYXVfcmVzdWx0JGRpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9hX2F1X3Jlc3VsdCRtYXRjaCkNCiAgICAgICMgYW5kIHNwYWNlZCBvdXQgaW5pdGlhbHMNCiAgICAgIG9hX2F1X3Jlc3VsdCRtYXRjaCA8LSBpZmVsc2Uob2FfYXVfcmVzdWx0JG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyZXBsKHByb2ZfbmFtZV93X2luaXRpYWxzX3NwYWNlLCB0b2xvd2VyKG9hX2F1X3Jlc3VsdCRkaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYV9hdV9yZXN1bHQkbWF0Y2gpDQogICAgICAjIGFuZCBubyBmaXJzdCBuYW1lLCBidXQgb25seSBpbml0aWFscyBhbmQgYWxzbyBvbmx5IHNwYWNlZCBvdXQgaW5pdGlhbHMNCiAgICAgIG9hX2F1X3Jlc3VsdCRtYXRjaCA8LSBpZmVsc2Uob2FfYXVfcmVzdWx0JG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyZXBsKHByb2ZfbmFtZV9maXJzdF9pbml0aWFscywgdG9sb3dlcihvYV9hdV9yZXN1bHQkZGlzcGxheV9uYW1lKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2FfYXVfcmVzdWx0JG1hdGNoKQ0KICAgICAgDQogICAgICBvYV9hdV9yZXN1bHQkbWF0Y2ggPC0gaWZlbHNlKG9hX2F1X3Jlc3VsdCRtYXRjaCA9PSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHNfc3BhY2UsIHRvbG93ZXIob2FfYXVfcmVzdWx0JGRpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9hX2F1X3Jlc3VsdCRtYXRjaCkNCiAgICAgIA0KICAgICAgIyBpZiBub3RoaW5nIHN0aWxsLCBpbml0aWFscyB3aXRob3V0IHRoZSBmaXJzdCBuYW1lDQogICAgICBvYV9hdV9yZXN1bHQkbWF0Y2ggPC0gaWZlbHNlKG9hX2F1X3Jlc3VsdCRtYXRjaCA9PSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX2luaXRpYWxzX3dvX2ZpcnN0X25hbWUsIHRvbG93ZXIob2FfYXVfcmVzdWx0JGRpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9hX2F1X3Jlc3VsdCRtYXRjaCkNCiAgICAgIA0KICAgICAgb2FfYXVfcmVzdWx0JG1hdGNoIDwtIGlmZWxzZShvYV9hdV9yZXN1bHQkbWF0Y2ggPT0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9pbml0aWFsc193b19maXJzdF9uYW1lX3NwYWNlLCB0b2xvd2VyKG9hX2F1X3Jlc3VsdCRkaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYV9hdV9yZXN1bHQkbWF0Y2gpICAgDQogICAgICAjIGFuZCB0aGVpciBhbHRlcm5hdGl2ZSBmaXJzdCBuYW1lIHdlIG1hbnVhbGx5IGNvcnJlY3QgZm9yDQogICAgICBvYV9hdV9yZXN1bHQkbWF0Y2ggPC0gaWZlbHNlKG9hX2F1X3Jlc3VsdCRtYXRjaCA9PSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX2FsdGVybmF0aXZlX2Z1bGxfbmFtZSwgdG9sb3dlcihvYV9hdV9yZXN1bHQkZGlzcGxheV9uYW1lKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2FfYXVfcmVzdWx0JG1hdGNoKSAgIA0KICAgICAgDQogICAgICBvYV9hdV9yZXN1bHQgPC0gZmlsdGVyKG9hX2F1X3Jlc3VsdCwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkcyAhPSAiaHR0cHM6Ly9vcGVuYWxleC5vcmcvQTk5OTk5OTk5OTkiKQ0KICAgICAgIyBmZXRjaCB0aGUgT0EgSURzIGlmIHRoZXJlIGlzIGEgbWF0Y2gNCiAgICAgIHByb2Zfb2FfaWRzIDwtIGZpbHRlcihvYV9hdV9yZXN1bHQsIG1hdGNoID09IFRSVUUpDQogICAgICBpZF9saXN0IDwtIGMoKQ0KICAgICAgDQogICAgICBpZiAobnJvdyhwcm9mX29hX2lkcyk+MCl7DQogICAgICAgIG9hX2lkc19uYW1lcyA8LSBwcm9mX29hX2lkcyRpZHMNCiAgICAgICAgIyBpZiBhIGxpc3QsIG9ubHkgcmV0YWluIHRoZSBPQSBJRHM6DQogICAgICAgIGlmKGNsYXNzKG9hX2lkc19uYW1lcykgPT0gImxpc3QiKXsNCiAgICAgICAgICBvYV9pZHNfbmFtZXMgPC0gYygpDQogICAgICAgICAgZm9yIChqIGluIDE6bnJvdyhwcm9mX29hX2lkcykpew0KICAgICAgICAgICAgaWQgPC0gcHJvZl9vYV9pZHMkaWRzW1tqXV1bJ29wZW5hbGV4J10NCiAgICAgICAgICAgIG9hX2lkc19uYW1lcyA8LSBjKG9hX2lkc19uYW1lcywgaWQpDQogICAgICAgICAgfQ0KICAgICAgICAgIG9hX2lkc19uYW1lcyA8LSB1bm5hbWUob2FfaWRzX25hbWVzKQ0KICAgICAgICB9DQogICAgICB9DQogICAgfQ0KICB9DQogICMgaWYgc3RpbGwgbm90aGluZw0KICBpZiAoYWxsKGlzLm5hKG9hX2lkc19uYW1lcykpKXsNCiAgICAgIyB0cnkgdG8gZmluZCBPQSBJRCBtYXRjaGVzIGJ5IGxvb2tpbmcgYXQgYWx0ZXJuYXRpdmUgT0EgbmFtZSBzcGVsbGluZ3MgYXMgd2VsbA0KICAgICAgICBwcm9mX25hbWVfZGV0YWlscyA8LSBmaWx0ZXIocHJvZnNfZnVsbCwgcHJvZmlsZV9pZCA9PSBuYXJjaXNfaWQpDQogICAgICAgIA0KICAgICAgICBvYV9hdV9yZXN1bHQgPC0gb2FfZmV0Y2goImF1dGhvciIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaCA9IHBhc3RlKHByb2ZfbmFtZV9kZXRhaWxzJGZpcnN0LCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9uYW1lX2RldGFpbHMkYWNodGVybmFhbSkpDQogICAgICAgIA0KICAgICAgICAjIHVubGlzdCB0aGUgcmVzdWx0cw0KICAgICAgICBpZiAoIWFsbChpcy5uYShvYV9hdV9yZXN1bHQpKSl7DQogICAgICAgICAgZGlzcGxheV9uYW1lX2lkcyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbnJvdyA9IDAsIG5jb2wgPSAyKSkNCiAgICAgICAgICBmb3IgKGogaW4gMTpucm93KG9hX2F1X3Jlc3VsdCkpew0KICAgICAgICAgICAgZGlzcGxheV9uYW1lcyA8LSB1bmxpc3Qob2FfYXVfcmVzdWx0JGRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXNbal0pDQogICAgICAgICAgICBpZHMgPC0gdW5saXN0KG9hX2F1X3Jlc3VsdCRpZHNbal0pWydvcGVuYWxleCddDQogICAgICAgICAgICByb3cgPC0gY2JpbmQuZGF0YS5mcmFtZSgiZGlzcGxheV9uYW1lIiA9IGRpc3BsYXlfbmFtZXMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gaWRzKQ0KICAgICAgICAgICAgcm93bmFtZXMocm93KSA8LSBjKCkNCiAgICAgICAgICAgIGRpc3BsYXlfbmFtZV9pZHMgPC0gcmJpbmQoZGlzcGxheV9uYW1lX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LCByb3cubmFtZXMgPSBOVUxMKQ0KICAgICAgICAgIH0NCiAgICAgICAgICANCiAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJGRpc3BsYXlfbmFtZSA8LSBpY29udihkaXNwbGF5X25hbWVfaWRzJGRpc3BsYXlfbmFtZSAsIHRvPSdBU0NJSS8vVFJBTlNMSVQnKQ0KICAgICAgDQogICAgICAgICAgIyBmaW5kIHRoZSBhdXRob3Igd2l0aCBhIG1hdGNoaW5nIG5hbWUNCiAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJG1hdGNoIDwtIGdyZXBsKHByb2ZfbmFtZSwgdG9sb3dlcihkaXNwbGF5X25hbWVfaWRzJGRpc3BsYXlfbmFtZSkpDQogICAgICAgICAgIyBjaGVjayB3aXRoIGluaXRpYWxzIGFzIHdlbGwNCiAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJG1hdGNoIDwtIGlmZWxzZShkaXNwbGF5X25hbWVfaWRzJG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9uYW1lX3dfaW5pdGlhbHMsIHRvbG93ZXIoZGlzcGxheV9uYW1lX2lkcyRkaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZV9pZHMkbWF0Y2gpDQogICAgICAgICAgIyBhbmQgc3BhY2VkIG91dCBpbml0aWFscw0KICAgICAgICAgIGRpc3BsYXlfbmFtZV9pZHMkbWF0Y2ggPC0gaWZlbHNlKGRpc3BsYXlfbmFtZV9pZHMkbWF0Y2ggPT0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX25hbWVfd19pbml0aWFsc19zcGFjZSwgdG9sb3dlcihkaXNwbGF5X25hbWVfaWRzJGRpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lX2lkcyRtYXRjaCkNCiAgICAgICAgICAjIGFuZCBubyBmaXJzdCBuYW1lLCBidXQgb25seSBpbml0aWFscyBhbmQgYWxzbyBvbmx5IHNwYWNlZCBvdXQgaW5pdGlhbHMNCiAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJG1hdGNoIDwtIGlmZWxzZShkaXNwbGF5X25hbWVfaWRzJG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9uYW1lX2ZpcnN0X2luaXRpYWxzLCB0b2xvd2VyKGRpc3BsYXlfbmFtZV9pZHMkZGlzcGxheV9uYW1lKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJG1hdGNoKQ0KICAgICAgICAgIA0KICAgICAgICAgIGRpc3BsYXlfbmFtZV9pZHMkbWF0Y2ggPC0gaWZlbHNlKGRpc3BsYXlfbmFtZV9pZHMkbWF0Y2ggPT0gRkFMU0UsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmVwbChwcm9mX25hbWVfZmlyc3RfaW5pdGlhbHNfc3BhY2UsIHRvbG93ZXIoZGlzcGxheV9uYW1lX2lkcyRkaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZV9pZHMkbWF0Y2gpDQogICAgICAgICAgDQogICAgICAgICAgIyBpZiBub3RoaW5nIHN0aWxsLCBpbml0aWFscyB3aXRob3V0IHRoZSBmaXJzdCBuYW1lDQogICAgICAgICAgZGlzcGxheV9uYW1lX2lkcyRtYXRjaCA8LSBpZmVsc2UoZGlzcGxheV9uYW1lX2lkcyRtYXRjaCA9PSBGQUxTRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyZXBsKHByb2ZfaW5pdGlhbHNfd29fZmlyc3RfbmFtZSwgdG9sb3dlcihkaXNwbGF5X25hbWVfaWRzJGRpc3BsYXlfbmFtZSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lX2lkcyRtYXRjaCkNCiAgICAgICAgICANCiAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJG1hdGNoIDwtIGlmZWxzZShkaXNwbGF5X25hbWVfaWRzJG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9pbml0aWFsc193b19maXJzdF9uYW1lX3NwYWNlLCB0b2xvd2VyKGRpc3BsYXlfbmFtZV9pZHMkZGlzcGxheV9uYW1lKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJG1hdGNoKSAgIA0KICAgICAgICAgICMgYW5kIHRoZWlyIGFsdGVybmF0aXZlIGZpcnN0IG5hbWUgd2UgbWFudWFsbHkgY29ycmVjdCBmb3INCiAgICAgICAgICBkaXNwbGF5X25hbWVfaWRzJG1hdGNoIDwtIGlmZWxzZShkaXNwbGF5X25hbWVfaWRzJG1hdGNoID09IEZBTFNFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JlcGwocHJvZl9hbHRlcm5hdGl2ZV9mdWxsX25hbWUsIHRvbG93ZXIoZGlzcGxheV9uYW1lX2lkcyRkaXNwbGF5X25hbWUpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZV9pZHMkbWF0Y2gpIA0KICAgICAgICAgIA0KICAgICAgICAgICMgZ2V0IHRoZSBtYXRjaGVzDQogICAgICAgICAgZGlzcGxheV9uYW1lX2lkcyA8LSBmaWx0ZXIoZGlzcGxheV9uYW1lX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9PSBUUlVFKQ0KICAgICAgICAgIA0KICAgICAgICAgICMgZXh0cmFjdA0KICAgICAgICAgIG9hX2lkc19uYW1lcyA8LSBkaXNwbGF5X25hbWVfaWRzJG9hX2lkDQogICAgICAgIH0NCiAgICAgICAgfQ0KICAjIGJpbmQgaW50byBhIGxpc3QNCiAgcHJvZl9zZWFyY2hfb3V0cHV0IDwtIGxpc3QoKQ0KICBwcm9mX3NlYXJjaF9vdXRwdXRbJ25hcmNpc19pZCddIDwtIG5hcmNpc19pZA0KICBwcm9mX3NlYXJjaF9vdXRwdXRbJ29hX2lkc19wdWJzJ10gPC0gbGlzdChvYV9pZHNfcHVicykgIA0KICBwcm9mX3NlYXJjaF9vdXRwdXRbJ29hX2lkc19vcmNpZCddIDwtIGxpc3Qob2FfaWRzX29yY2lkKQ0KICBwcm9mX3NlYXJjaF9vdXRwdXRbJ29hX2lkc19uYW1lcyddIDwtIGxpc3Qob2FfaWRzX25hbWVzKQ0KICByZXR1cm4ocHJvZl9zZWFyY2hfb3V0cHV0KQ0KfQ0KYGBgDQoNCg0KTG9vcCB0aHJvdWdoIHByb2Zlc3NvcnMgYW5kIGZpbmQgdGhlaXIgaWRlbnRpZmllcnM6DQpgYGB7cn0NCm5hcmNpc19pZHMgPC0gcHJvZnNfZnVsbCRwcm9maWxlX2lkDQpwcm9mX2lkZW50aWZpZXJfbGlzdCA8LSBsaXN0KCkNCg0KZm9yIChpIGluIDE6bGVuZ3RoKG5hcmNpc19pZHMpKXsNCiAgbmFyY2lzX2lkIDwtIG5hcmNpc19pZHNbaV0NCiAgDQogIHByb2ZfaWRzIDwtIE5BDQogIA0KICB0cnkocHJvZl9pZHMgPC0gcHJvZmVzc29yX2lkZW50aWZpZXJfcmV0cmlldmVyKG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJfZGF0YSA9IHByb2ZfcHVic19mdWxsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfZGF0YSA9IHByb2ZzX2Z1bGwpDQogICkNCiAgDQogIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV0gPC0gcHJvZl9pZHMNCiAgbmFtZXMocHJvZl9pZGVudGlmaWVyX2xpc3QpW1tpXV0gPC0gbmFyY2lzX2lkDQogIA0KICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChuYXJjaXNfaWRzKSkpDQogIA0KfQ0KYGBgDQoNCldlIGZhaWwgdG8gZmluZCBhbnkgT0EgaWRzIGZvciBzb21lIHByb2Zlc3NvcnMuDQpGaW5kIHRoZWlyIE9BIElEcyBtYW51YWxseToNCmBgYHtyfQ0KIyBtYW51YWxseSBnZXQgdGhlIGNvcnJlY3Qgc2VhcmNoIHRlcm1zIGZvciB0aGUgbWlzc2luZyBwcm9mZXNzb3JzOg0KbWlzc2luZ19pZHMgPC0gYygiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM2NjM0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzNjg2OSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzY5NjAiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM3ODUwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzODA0NSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzg1NDIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM4ODgwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzODg5OCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyMzkxMjIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjM5NjA2IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTIzOTg0MSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDAxOTQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQxMjE4IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MTI2NiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDE1NjIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQxODM3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0MjAzNSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNDIyNDMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjQzMTA5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI0NzExMiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNTE2NTAiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjUzODAxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI1NTkwOSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNjMwMTciLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjY1NTAzIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI3Mzg1OCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyNzY0NDgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjgxODQ0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4MTg0NSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODE4NzUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjgzOTg0IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4NjM1NCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyODgzNDAiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjg4NTUwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI4OTI5OSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyOTEwNTEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjkxOTE5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5MTkzOCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyOTU0NjkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjk1NTY5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTI5NjMxMyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEyOTcyMjMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMjk3OTI5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMwMDc2OCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMDM1NTIiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzA0NjUxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMxMzc4MSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMTQxNzgiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzE2MDY4IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMxNzgwNiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMTkyNDEiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzE5ODEyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMyMDE3NCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjExMDMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzI0MTYwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMyNTEyMCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMjkxNjYiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzMxMzYwIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzMTQ1MiIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzM2MTQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzMzODAxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzNDA0MyIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzU2NTQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzM1NjU5IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzNjM2NSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzMzY1NDkiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQwODg3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MDk3OCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDE1NTciLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQyMTgxIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0MjE5NSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDIyNzUiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQ3ODk3IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM0ODI0MSIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNDgzNTMiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzQ5NzMyIiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM1MDMyOCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNTA5MzciLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUxMzA2IiwNCiAgICAgICAgICAgICAgICAgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTM1MTMwOCIsDQogICAgICAgICAgICAgICAgICJodHRwczovL3d3dy5uYXJjaXMubmwvcGVyc29uL1JlY29yZElEL1BSUzEzNTEzNjQiLA0KICAgICAgICAgICAgICAgICAiaHR0cHM6Ly93d3cubmFyY2lzLm5sL3BlcnNvbi9SZWNvcmRJRC9QUlMxMzUxNDgxIikNCg0KbWlzc2luZ19zZWFyY2hfdGVybXMgPC0gYygiVy5ILk0uIFJlZWh1aXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiUGhpbGlwIEguIEouIEcuIHZhbiBIdWl6ZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSi5DLkUuIHZhbiBLb2xsZW5idXJnIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkEuSS5NLiB2YW4gTWllcmxvIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkplYW4tQmVybmFyZCBNYXJ0ZW5zIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlIuUC5KLkwuIFRqaXR0ZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSi5XLiBEdXl2ZW5kYWsiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSmVhbi1QaWVycmUgV2lscyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJXLkcuIEh1aWpnZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSmFuIEEuIEJydWlqbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJBbm5lLU1hcmllIEtvcnRlIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkcuVy5KLk0uIEthbXBzY2jDtmVyIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAibS5oLiBjb3JiZXkiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQS5NLiBMdWJvdHNreSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJodHRwczovL29wZW5hbGV4Lm9yZy9BNTA0MTkzMDE1NyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJFLkYuIFN0ZWVubmlzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlZlbnVnb3BhbCBWZW5rYXRhcmFtYW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiaG9lZnRlIHJvc2VtYXJpam4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQi5QLk0uIHZhbiBSYXZlbHMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAia29yc3RlbiBmLncuYS4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQWxiZXJkaW5hIEhvdXRtYW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiTWFyY28gUCBOaWV1d2UgV2VtZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKYW4tRGllZGVyaWsgdmFuIFdlZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkMuRC5KLiBCdWx0ZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQS5NLkIuIERlV2FlZ2VuYWVyZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJXaWxsZW3igJBKYW4gdmFuIGRlbiBIZXV2ZWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiRS5DLkMuIFB1bnNlbGllIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiRy4gdmFuIFJpanNzZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIk0uQS4gVmVyYnJ1Z2giLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiSHVpYmVydCBEaWVkZXJpayB2YW4gUm9tYnVyZ2giLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkthdGFyenluYSBKLiBDd2llcnRrYSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJKLlcuIEZvcHBlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJQZXRlciB2YW4gR29vbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJILkouTS4gSGF2ZWtlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiaS5hLm0uIHNhbG91bCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJlLmouai4gYmV1bGVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIk9sZXhhbmRlciBZYXJvdnlpIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlIuUC4gQm90aGEiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQS4gTS4gQmFyeXNoZXYiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAic3lsdmlhIGJ1cmctdmVybWV1bGVuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkouUy5MLkEuVy5CLiBSb2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkphbiBIZWluIEZ1cm7DqWUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQW5uZXR0ZSBGcmV5YmVyZ+KAkEluYW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiR2VydCBKYW4gdmFuIGRlciBTbWFuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJDLiBHb3VrZW5zLU1lcnRlbnMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBOQSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkcuUi5CLkUuIFLDtm1lciIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJwLmgubC5tLiBrdXlwZXJzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkdlbnNlcmlrIFJlbmllcnMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiU3RlcGhhbiBXZW5zdmVlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJPbm5vIEtyYW5lbmJ1cmciLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiU2Nod2FydHotTGFuZHNtYW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiRy5KLkMuIFJlbnNlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJLLlcuSC4gQnJvZWtodWl6ZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiUy5ILk0uQS4gRHVtb3VsaW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiUy4gSm9uZyBLb24gQ2hpbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJTLlAuSi4gdmFuIEFscGhlbiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJDaHVu4oCQS2V1bmcgSG9pIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlNlcmdleSBOZWplbnRzZXYiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAibHVkb3ZpY28gYWxjb3J0YSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJwLmEubS5nLiBkZSBrb2NrIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImhhZXJzb2x0ZS12YW4gaG9mIGphY29taWpuIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIkV1Z2VuaWEgSG91dmVuYWdoZWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAibS5hLiB2YW4gd2lsbGlnZW4iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiYXJ0aHVyIHRlbiBjYXRlIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlBldGVyIEtvdWRpanMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiRnVsdmlvIFJlZ2dpb3JpIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgIE5BLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiQW50b25pcyBQYXBhcGFudG9sZW9uIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgImEuYy4gYm9lcnN0cmEiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAiTGVvbmllIEhlcmVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIlRob21hcyBQLiBNb2xpdGVybm8iKQ0KDQpsZW5ndGgod2hpY2goaXMubmEobWlzc2luZ19zZWFyY2hfdGVybXMpKSkNCmBgYA0KV2UgY2Fubm90IGZpbmQgYSByZWxpYWJsZSBPQSBJRCBmb3IgMTIgcHJvZmVzc29ycyBpbiBvdXIgZGF0YXNldC4gDQoNCkxvb3AgdGhyb3VnaCB0aGUgaWRlbnRpZmllciBsaXN0IHRvIGZpbGwgdGhlIElEcyBpbjoNCmBgYHtyfQ0KZm9yIChpIGluIDE6bGVuZ3RoKG1pc3NpbmdfaWRzKSl7DQogIG5hcmNpc19pZCA8LSBtaXNzaW5nX2lkc1tpXQ0KICANCiAgc2VhcmNoX3Rlcm0gPC0gbWlzc2luZ19zZWFyY2hfdGVybXNbaV0NCiAgDQogIHByb2ZfbGlzdF9pdGVtIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tuYXJjaXNfaWRdXQ0KICANCiAgaWYgKCFpcy5uYShzZWFyY2hfdGVybSkpew0KICAgIA0KICAgIGlmKHNlYXJjaF90ZXJtID09ICJodHRwczovL29wZW5hbGV4Lm9yZy9BNTA0MTkzMDE1NyIpew0KICAgICAgcHJvZl9vYV9pZHMgPC0gb2FfZmV0Y2goDQogICAgICAgIGVudGl0eSA9ICJhdXRob3IiLCAnQTUwNDE5MzAxNTcnKQ0KICAgIH1lbHNlew0KICAgICAgcHJvZl9vYV9pZHMgPC0gb2FfZmV0Y2goImF1dGhvciIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2hfdGVybSkNCiAgICB9DQogICAgDQogICAgaWYgKG5yb3cocHJvZl9vYV9pZHMpPjApew0KICAgICAgb2FfaWRzX25hbWVzIDwtIHByb2Zfb2FfaWRzJGlkcw0KICAgICAgIyBpZiBhIGxpc3QsIG9ubHkgcmV0YWluIHRoZSBPQSBJRHM6DQogICAgICBpZihjbGFzcyhvYV9pZHNfbmFtZXMpID09ICJsaXN0Iil7DQogICAgICAgIG9hX2lkc19uYW1lcyA8LSBjKCkNCiAgICAgICAgZm9yIChqIGluIDE6bnJvdyhwcm9mX29hX2lkcykpew0KICAgICAgICAgIGlkIDwtIHByb2Zfb2FfaWRzJGlkc1tbal1dWydvcGVuYWxleCddDQogICAgICAgICAgb2FfaWRzX25hbWVzIDwtIGMob2FfaWRzX25hbWVzLCBpZCkNCiAgICAgICAgfQ0KICAgICAgICBvYV9pZHNfbmFtZXMgPC0gdW5uYW1lKG9hX2lkc19uYW1lcykNCiAgICAgIH0NCiAgICAgIA0KICAgICAgcHJvZl9saXN0X2l0ZW1bIm9hX2lkc19uYW1lcyJdIDwtIGxpc3Qob2FfaWRzX25hbWVzKQ0KICAgIH0NCiAgfQ0KICANCiAgcHJvZl9pZGVudGlmaWVyX2xpc3RbW25hcmNpc19pZF1dIDwtIHByb2ZfbGlzdF9pdGVtDQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKG1pc3NpbmdfaWRzKSkpDQogIA0KfQ0KYGBgDQoNCg0KV3JpdGUgaXQgb3V0Og0KYGBge3J9DQpzYXZlUkRTKHByb2ZfaWRlbnRpZmllcl9saXN0LCAicHJvY2Vzc2VkX2RhdGEvcHJvZl9vYV9pZGVudGlmaWVyX2xpc3QuUkRTIikNCmBgYA0KDQpgYGB7ciBlY2hvID0gRn0NCnByb2ZfaWRlbnRpZmllcl9saXN0IDwtIHJlYWRSRFMoInByb2Nlc3NlZF9kYXRhL3Byb2Zfb2FfaWRlbnRpZmllcl9saXN0LlJEUyIpDQpgYGANCg0KRXh0cmFjdCBwcm9mZXNzb3IgSURzIGFuZCBzb3VyY2VzIGZvciBlYWNoIHByb2Zlc3NvcjoNCmBgYHtyfQ0KcHJvZl9vYV9tYXBwaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDMpKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgocHJvZl9pZGVudGlmaWVyX2xpc3QpKXsNCiAgIyBpbml0aWF0ZSBhIGRhdGFmcmFtZSB0byBzdG9yZSB0aGlzIHByb2Zlc3NvcidzIGRhdGENCiAgcHJvZl9vYV9pZHMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQogICMgcmV0cmlldmUgdGhpcyBwcm9mZXNzb3IncyBsaXN0IG9mIGlkZW50aWZpZXJzDQogIHByb2ZfaWRlbnRpZmllcnMgPC0gcHJvZl9pZGVudGlmaWVyX2xpc3RbW2ldXQ0KICAjIGdldCB0aGVpciBOYXJjaXMgSUQgYW5kIGFsbCB0aGUgcmV0cmlldmVkIE9BIElEcw0KICBuYXJjaXNfaWQgPC0gcHJvZl9pZGVudGlmaWVyX2xpc3RbW2ldXVtbIm5hcmNpc19pZCJdXQ0KICANCiAgcHViX2lkcyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sib2FfaWRzX3B1YnMiXV0NCiAgDQogIG9yY2lkX2lkcyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sib2FfaWRzX29yY2lkIl1dDQogIA0KICBuYW1lX2lkcyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sib2FfaWRzX25hbWVzIl1dDQogIA0KICAjIGFkZCBhbnkgSURzIHJldHJpZXZlZCBmcm9tIHRoZSBwdWJsaWNhdGlvbiBsaXN0DQogIGlmICghYWxsKGlzLm5hKHB1Yl9pZHMpKSl7DQogIA0KICBwdWJfaWRzIDwtIGNiaW5kLmRhdGEuZnJhbWUoInByb2ZpbGVfaWQiID0gbmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9hX2lkIiA9IHB1Yl9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlIiA9ICJwdWJsaWNhdGlvbnMiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIHB1Yl9pZHMpDQogIH0NCiAgIyBhZGQgYW55IElEcyBhc3NvY2lhdGVkIHdpdGggcHJvZidzIE9SQ0lEDQogIGlmICghYWxsKGlzLm5hKG9yY2lkX2lkcykpKXsNCiAgb3JjaWRfaWRzIDwtIGNiaW5kLmRhdGEuZnJhbWUoInByb2ZpbGVfaWQiID0gbmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9hX2lkIiA9IG9yY2lkX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gIm9yY2lkIikNCiAgDQogIHByb2Zfb2FfaWRzIDwtIHJiaW5kKHByb2Zfb2FfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICBvcmNpZF9pZHMpDQogIH0NCiAgIyBhZGQgYW55IElEcyBmcm9tIG5hbWUgc2VhcmNoICsgTkwgY291bnRyeQ0KICBpZiAoIWFsbChpcy5uYShuYW1lX2lkcykpKXsNCiAgbmFtZV9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gbmFtZV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlIiA9ICJuYW1lIikNCiAgDQogIHByb2Zfb2FfaWRzIDwtIHJiaW5kKHByb2Zfb2FfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICBuYW1lX2lkcykNCiAgfQ0KICANCiAgIyBpZiBhbnkgcm93cw0KICBpZiAobnJvdyhwcm9mX29hX2lkcykgPiAwKXsNCiAgICANCiAgICAjIGRlZHVwbGljYXRlDQogICAgcHJvZl9vYV9pZHMkZHVwbGljYXRlIDwtIGR1cGxpY2F0ZWQocHJvZl9vYV9pZHNbYygicHJvZmlsZV9pZCIsICJvYV9pZCIpXSkNCiAgICBwcm9mX29hX2lkcyA8LSBmaWx0ZXIocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9PSBGQUxTRSkNCiAgICBwcm9mX29hX2lkcyA8LSBwcm9mX29hX2lkc1ssIC00XQ0KICAgIA0KICAgIHByb2Zfb2FfbWFwcGluZyA8LSByYmluZChwcm9mX29hX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Zfb2FfaWRzKQ0KICB9IGVsc2V7DQogICAgcHJvZl9vYV9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlIiA9IE5BKQ0KICAgIHByb2Zfb2FfbWFwcGluZyA8LSByYmluZChwcm9mX29hX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Zfb2FfaWRzKQ0KICB9DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCBpLCAib3V0IG9mIiwgbGVuZ3RoKG5hcmNpc19pZHMpKSkNCn0NCg0KYGBgDQoNCg0KIyMgRXh0cmFjdCBwdWJsaWNhdGlvbnMgYmFzZWQgb24gT0EgSURzDQoNCkRlZmluZSB0aGUgZGF0YSBxdWVyeWluZyBmdW5jdGlvbiwgd2hpY2ggcHVsbHMgZGF0YSBmcm9tIE9BIGFzIHNob3duIGluIHRoZQ0KRGlhZ3JhbSBiZWxvdzoNCiFbRmlndXJlIDJdKGltYWdlcy9wcm9mZXNzb3JfaW5mb19yZXRyaWV2ZXJfZGlhZ3JhbS5wbmcpDQoNCmBgYHtyfQ0KcHJvZmVzc29yX2luZm9fcmV0cmlldmVyIDwtIGZ1bmN0aW9uKHByb2Zfb2FfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJfZGF0YSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2RhdGEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIHJlY29tbWVuZCB0byBzZXQgdG8gRkFMU0UgdW5sZXNzIGFsbCB3b3JrcyB3ZWxsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgdG8gYXZvaWQgdXNpbmcgdXAgb3VyIHR3aXR0ZXIgcXVlcnkgbGltaXRzDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZV90d2l0dGVyID0gRkFMU0Upew0KICANCiAgIyBnZXQgdGhlIHByb2Zlc3NvcidzIG5hcmNpcyBpZCBhbmQgZ2V0IHRoZWlyIHB1YmxpY2F0aW9ucyBiYXNlZCBvbiB0aGlzDQogIHByb2ZfcHVicyA8LSBmaWx0ZXIocHViX2RhdGEsIHByb2ZpbGVfaWQgPT0gbmFyY2lzX2lkKQ0KICANCiAgIyBnZXQgdGhlIHByb2Zlc3NvcidzIE9BIElEcyBsaXN0DQogIG9hX2lkcyA8LSBmaWx0ZXIocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgcHJvZmlsZV9pZCA9PSBuYXJjaXNfaWQpJG9hX2lkDQogIA0KICAjIHB1bGwgYWxsIHRoZSBkYXRhIHJlbGF0ZWQgdG8gdGhlc2UgT0EgaWRzDQogICMgaWYgSUQgZm91bmQ6DQogIGlmIChsZW5ndGgob2FfaWRzKT4wKXsNCiAgICAjIGdldCBhbGwgcGFwZXJzIGZyb20gT0EgdXNpbmcgdGhlc2UgaWRzOg0KICAgIHByb2ZfYWxsX3dvcmtzX29hIDwtIG9hX2ZldGNoKA0KICAgICAgZW50aXR5ID0gIndvcmtzIiwgDQogICAgICBhdXRob3IuaWQgPSBvYV9pZHMpDQogICAgDQogICAgIyBkZWR1cGxpY2F0ZSBiYXNlZCBvbiBJRHMNCiAgICBwcm9mX2FsbF93b3Jrc19vYSRkdXBsaWNhdGUgPC0gZHVwbGljYXRlZChwcm9mX2FsbF93b3Jrc19vYVssIGMoImlkIildKQ0KICAgIHByb2ZfYWxsX3dvcmtzX29hIDwtIGZpbHRlcihwcm9mX2FsbF93b3Jrc19vYSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID09IEZBTFNFKQ0KICAgIA0KICAgICMgaWYgdGhlcmUgYXJlIHN0aWxsIGR1cGxpY2F0ZXMsIGRlZHVwbGljYXRlIGJ5IGxvd2VyY2FzZWQgdGl0bGUNCiAgICBwcm9mX2FsbF93b3Jrc19vYSRkaXNwbGF5X25hbWVfbG93ZXIgPC0gdG9sb3dlcihwcm9mX2FsbF93b3Jrc19vYSRkaXNwbGF5X25hbWUpDQogICAgcHJvZl9hbGxfd29ya3Nfb2EkZHVwbGljYXRlIDwtIGR1cGxpY2F0ZWQocHJvZl9hbGxfd29ya3Nfb2FbLCBjKCJkaXNwbGF5X25hbWVfbG93ZXIiKV0pDQogICAgcHJvZl9hbGxfd29ya3Nfb2EgPC0gZmlsdGVyKHByb2ZfYWxsX3dvcmtzX29hLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPT0gRkFMU0UpDQogICAgDQogICAgIyBwYXN0ZSB0aGUgT0EgSUQgYW5kIHRoZSBOYXJjaXMgSUQNCiAgICBwcm9mX2FsbF93b3Jrc19vYSRvYV9pZCA8LSBwYXN0ZShvYV9pZHMsIGNvbGxhcHNlID0gIiwgIikNCiAgICBwcm9mX2FsbF93b3Jrc19vYSRwcm9maWxlX2lkIDwtIG5hcmNpc19pZA0KICAgIA0KICAgICMgZ2V0IHRoZWlyIGNvLWF1dGhvcnMgaW4gYSBnaXZlbiB5ZWFyDQogICAgIyBidXQgYWxzbyB0aGVpciBhZmZpbGlhdGlvbnMsIGFuZCB0aGUgYXV0b3NoaXAgcG9zaXRpbm8gaW4gZXZlcnkgcHViLCANCiAgICAjIHNpbmNlIHdlIGFyZSBhbHJlYWR5IGxvb3BpbmcuLi4NCiAgICAjIHBsZWNlaG9sZGVyIGZvciBhdXRob3NoaXAgcG9zaXRpb24NCiAgICBwcm9mX3B1Yl9wb3NpdGlvbiA8LSByZXAoTkEsIG5yb3cocHJvZl9hbGxfd29ya3Nfb2EpKQ0KICAgICMgcGxhY2Vob2xkZXJzIGZvciBhdXRob3JzIGFuZCBhZmZpbGlhdGlvbnMNCiAgICBwcm9mX2NvYXV0aG9yc19vYSA8LSBOQQ0KICAgIHByb2ZfcHViX2luZm9faWEgPC0gTkENCiAgICANCiAgICBmb3IgKGkgaW4gMTpucm93KHByb2ZfYWxsX3dvcmtzX29hKSl7DQogICAgICAjIGZldGNoIHRoZSBhdXRob3JzIG5lc3RlZCB3aXRoaW4gdGhlICJhdXRob3IiIGZpZWxkIHJldHVybmVkIGJ5IE9BDQogICAgICBhbGxfYXV0aG9ycyA8LSBwcm9mX2FsbF93b3Jrc19vYVtpLCAiYXV0aG9yIl1bWzFdXVtbMV1dDQogICAgICAjIGdldCB0aGUgcHJvZmVzc29yIGluZm8gYW5kIHRoZWlyIGFmZmlsaWF0aW9ucyB0aGF0IHllYXINCiAgICAgIGlmICghaXMubnVsbChucm93KGFsbF9hdXRob3JzKSkpew0KICAgICAgICBwcm9mX2F1dGhvcl9pbmZvIDwtIGZpbHRlcihhbGxfYXV0aG9ycywgIGF1X2lkICVpbiUgb2FfaWRzKQ0KICAgICAgICAjIGlmIGF1dGhvcidzIElEIG5vdCBmb3VuZCBoZXJlIChlLmcuLCBhIHNsaWdodGx5IGRpZmZlcmVudCBuYW1lKSwgaXQgd2lsbCBiZSBzZXQgdG8gTkENCiAgICAgICAgcHJvZl9wdWJfcG9zaXRpb25baV0gPC0gTkENCiAgICAgICAgIyBvdGhlcndpc2UsIHJlcGxhY2Ugd2l0aCB0aGUgYWN0dWFsIHZhbHVlDQogICAgICAgIGlmIChucm93KHByb2ZfYXV0aG9yX2luZm8pPjApew0KICAgICAgICAgICMgcGFzdGUgdGhlIHByb2YncyBhdXRob3JzaGlwIGhlcmUgKGZpcnN0IHJvdywgYXMgc29tZSBwcm9mZXNzb3JzIHNvbWUgZ2V0IA0KICAgICAgICAgICMgZHVwbGljYXRlIG1lbnRpb25zIGluIGEgcGFwZXIpDQogICAgICAgICAgcHJvZl9wdWJfcG9zaXRpb25baV0gPC0gcHJvZl9hdXRob3JfaW5mb1sxLCAnYXV0aG9yX3Bvc2l0aW9uJ10NCiAgICAgICAgfQ0KICAgICAgICAjIGV4Y2x1ZGUgdGhpcyBhdXRob3IgdGhlbXNlbHZlcyBmcm9tIHRoZSBjby1hdXRob3JzDQogICAgICAgIGNvYXV0aG9ycyA8LSBmaWx0ZXIoYWxsX2F1dGhvcnMsICEgYXVfaWQgJWluJSBvYV9pZHMpDQogICAgICAgICMgaWYgbm90IGEgc2luZ2xlLWF1dGhvciBwYXBlciwgZ2V0IGNvYXV0aG9yIGluZm8NCiAgICAgICAgaWYgKG5yb3coY29hdXRob3JzKSA+IDApew0KICAgICAgICAgICMgZ2V0IHRoZSBwdWJsaWNhdGlvbiB5ZWFyDQogICAgICAgICAgeWVhciA8LSBhcy5udW1lcmljKHByb2ZfYWxsX3dvcmtzX29hW2ksICJwdWJsaWNhdGlvbl95ZWFyIl0pDQogICAgICAgICAgIyBwYXN0ZSB0aGUgeWVhciBhbG9uZ3NpZGUgdGhlIGNvYXV0aG9ycw0KICAgICAgICAgIGNvYXV0aG9ycyR5ZWFyIDwtIHllYXINCiAgICAgICAgICBwcm9mX2NvYXV0aG9yc19vYSA8LSByYmluZChwcm9mX2NvYXV0aG9yc19vYSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2F1dGhvcnMpDQogICAgICAgIH0NCiAgICAgICAgIyBmb3IgdGhlIHByb2YgdGhlbXNlbHZlcywgZ2V0IHRoZWlyIGFmZmlsaWF0aW9uIGluZm8gZXRjDQogICAgICAgIGlmIChucm93KHByb2ZfYXV0aG9yX2luZm8pID4gMCl7DQogICAgICAgICAgIyBnZXQgdGhlIHB1YmxpY2F0aW9uIHllYXINCiAgICAgICAgICB5ZWFyIDwtIGFzLm51bWVyaWMocHJvZl9hbGxfd29ya3Nfb2FbaSwgInB1YmxpY2F0aW9uX3llYXIiXSkNCiAgICAgICAgICAjIHBhc3RlIHRoZSB5ZWFyIGFsb25nc2lkZSB0aGUgY29hdXRob3JzDQogICAgICAgICAgcHJvZl9hdXRob3JfaW5mbyR5ZWFyIDwtIHllYXINCiAgICAgICAgICBwcm9mX3B1Yl9pbmZvX2lhIDwtIHJiaW5kKHByb2ZfcHViX2luZm9faWEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2F1dGhvcl9pbmZvKQ0KICAgICAgICB9DQogICAgICB9DQogICAgfQ0KICAgICMgdGlkeSB1cCB0aGUgZGF0YWZyYW1lIG9uIGNvYXV0aG9ycywgaWYgYW55IGluZm8gaXMgdGhlcmUNCiAgICBpZiAoIWlzLm51bGwobnJvdyhwcm9mX2NvYXV0aG9yc19vYSkpKXsNCiAgICAgIGlmIChucm93KHByb2ZfY29hdXRob3JzX29hKSA+IDApew0KICAgICAgICANCiAgICAgICAgIyBhbmQgZGVkdXBsaWNhdGUgY29hdXRob3JzaGlwcyBpbiB0aGUgc2FtZSB5ZWFyDQogICAgICAgIHByb2ZfY29hdXRob3JzX29hJGR1cGxpY2F0ZSA8LSBkdXBsaWNhdGVkKHByb2ZfY29hdXRob3JzX29hWywgYygiYXVfaWQiLCAieWVhciIpXSkNCiAgICAgICAgcHJvZl9jb2F1dGhvcnNfb2EgPC0gZmlsdGVyKHByb2ZfY29hdXRob3JzX29hLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID09IEZBTFNFKQ0KICAgICAgICAjIHJlbW92ZSB0aGUgZHVwbGljYXRlIGNvbHVtbg0KICAgICAgICBwcm9mX2NvYXV0aG9yc19vYSA8LSBwcm9mX2NvYXV0aG9yc19vYVssIC1uY29sKHByb2ZfY29hdXRob3JzX29hKV0NCiAgICAgICAgDQogICAgICAgICMgcmVtb3ZlIHRoZSByb3cgd2l0aCBOQXMNCiAgICAgICAgcHJvZl9jb2F1dGhvcnNfb2EgPC0gcHJvZl9jb2F1dGhvcnNfb2Fbcm93U3Vtcyhpcy5uYShwcm9mX2NvYXV0aG9yc19vYSkpICE9IG5jb2wocHJvZl9jb2F1dGhvcnNfb2EpLCBdDQogICAgICAgIA0KICAgICAgICAjIGFkZCB0aGUgYXV0aG9yIGlkIGluZm8ganVzdCBpbiBjYXNlDQogICAgICAgIHByb2ZfY29hdXRob3JzX29hJG9hX2lkIDwtIHBhc3RlKG9hX2lkcywgY29sbGFwc2UgPSAiLCAiKQ0KICAgICAgICBwcm9mX2NvYXV0aG9yc19vYSRwcm9maWxlX2lkIDwtIG5hcmNpc19pZA0KICAgICAgfQ0KICAgIH0NCiAgICANCiAgICAjIHRpZHkgdXAgdGhlIGluZm8gb24gYXV0aG9yIGFmZmlsaWF0aW9ucywgaWYgYW55IGlzIHRoZXJlDQogICAgaWYgKCFpcy5udWxsKG5yb3cocHJvZl9wdWJfaW5mb19pYSkpKXsNCiAgICAgICMgb25jZSBhZ2FpbiwgaWYgYW55IGlzIHRoZXJlLi4uDQogICAgICBpZiAobnJvdyhwcm9mX3B1Yl9pbmZvX2lhKSA+IDAgKXsNCiAgICAgICAgcHJvZl9wdWJfaW5mb19pYSA8LSBmaWx0ZXIocHJvZl9wdWJfaW5mb19pYSwgIWlzLm5hKGluc3RpdHV0aW9uX2lkKSkNCiAgICAgICAgIyBjaGVjayB0aGF0IGZpbHRlcmluZyBkaWQgbm90IHJlbW92ZSBldmVyeXRoaW5nOyBpZiBzbywgcmVwbGFjZSBiYWNrIHdpdGggTkENCiAgICAgICAgaWYgKG5yb3cocHJvZl9wdWJfaW5mb19pYSkgPT0gMCl7DQogICAgICAgICAgcHJvZl9wdWJfaW5mb19pYSA8LSBOQQ0KICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAjIGFuZCBkZWR1cGxpY2F0ZSBhZmZpbGlhdGlvbnMgaW4gdGhlIHNhbWUgeWVhcg0KICAgICAgICAgIHByb2ZfcHViX2luZm9faWEkZHVwbGljYXRlIDwtIGR1cGxpY2F0ZWQocHJvZl9wdWJfaW5mb19pYVssIGMoImluc3RpdHV0aW9uX2lkIiwgInllYXIiKV0pDQogICAgICAgICAgcHJvZl9wdWJfaW5mb19pYSA8LSBmaWx0ZXIocHJvZl9wdWJfaW5mb19pYSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPT0gRkFMU0UpDQogICAgICAgICAgIyByZW1vdmUgdGhlIGR1cGxpY2F0ZSBjb2x1bW4NCiAgICAgICAgICBwcm9mX3B1Yl9pbmZvX2lhIDwtIHByb2ZfcHViX2luZm9faWFbLCAtbmNvbChwcm9mX3B1Yl9pbmZvX2lhKV0NCiAgICAgICAgICANCiAgICAgICAgICAjIGRyb3AgYXV0aG9yIHBvc2l0aW9uIHNpbmNlIHRoaXMgaXMgcGFwZXIgcmVsYXRlZA0KICAgICAgICAgIHByb2ZfcHViX2luZm9faWEgPC0gcHJvZl9wdWJfaW5mb19pYVsgLCAtd2hpY2gobmFtZXMocHJvZl9wdWJfaW5mb19pYSkgJWluJSBjKCJhdXRob3JfcG9zaXRpb24iKSldDQogICAgICAgICAgIyBhZGQgdGhlIGF1dGhvciBpZCBpbmZvIGp1c3QgaW4gY2FzZQ0KICAgICAgICAgIHByb2ZfcHViX2luZm9faWEkb2FfaWQgPC0gcGFzdGUob2FfaWRzLCBjb2xsYXBzZSA9ICIsICIpDQogICAgICAgICAgcHJvZl9wdWJfaW5mb19pYSRwcm9maWxlX2lkIDwtIG5hcmNpc19pZA0KICAgICAgICB9DQogICAgICB9DQogICAgfQ0KICAgIA0KICAgICMgYWRkIHRoZSBhdXRob3JzaGlwIGluZm8gdG8gdGhlIHB1YmxpY2F0aW9ucw0KICAgIHByb2ZfYWxsX3dvcmtzX29hJGF1dGhvcl9wb3NpdGlvbiA8LSBwcm9mX3B1Yl9wb3NpdGlvbg0KICAgIA0KICAgICMgaW5pdGlhbGl6ZSBhbiBlbXB0eSBvYmplY3QgZm9yIGdyYW50IGluZm8NCiAgICBwcm9mX2dyYW50c19vYSA8LSBOQQ0KICAgIA0KICAgICMgaWYgdGhlcmUgaXMgYSBncmFudCBjb2x1bW4sIGZldGNoIHRoZWlyIGdyYW50IG51bWJlcnMNCiAgICBpZiAoImdyYW50cyIgJWluJSBjb2xuYW1lcyhwcm9mX2FsbF93b3Jrc19vYSkpew0KICAgICAgIyBnZXQgdGhlIGdyYW50IGxpc3QNCiAgICAgIHByb2ZfZ3JhbnRfbGlzdCA8LSBwcm9mX2FsbF93b3Jrc19vYSRncmFudHMNCiAgICAgICMgZ2V0IHRoZSB5ZWFycyBmcm9tIHRoZSBwdWJsaWNhdGlvbnMNCiAgICAgIHllYXJfbGlzdCA8LSBwcm9mX2FsbF93b3Jrc19vYSRwdWJsaWNhdGlvbl95ZWFyDQogICAgICAjIGVtcHR5IGRhdGFmcmFtZQ0KICAgICAgI3Byb2ZfZ3JhbnRzX29hIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDUpKQ0KICAgICAgIyBmb3IgZWFjaCBncmFudCBpdGVtIGluIHRoZSBsaXN0DQogICAgICBmb3IgKGkgaW4gMTpsZW5ndGgocHJvZl9ncmFudF9saXN0KSl7DQogICAgICAgIGdyYW50IDwtIHByb2ZfZ3JhbnRfbGlzdFtbaV1dDQogICAgICAgICMgaWYgbm90IE5BLCBnZXQgdGhlIGRhdGENCiAgICAgICAgaWYgKCEgYW55TkEoZ3JhbnQpKXsNCiAgICAgICAgICAjIGdldCBhbGwgZnVuZGVyIElEcyBhbmQgbmFtZXMgYW5kIHB1dCB0aGVtIGludG8gYSBkYXRhZnJhbWUNCiAgICAgICAgICAjIE5COiBub3QgYWxsIG9mIHRoZXNlIGFyZSBhdXRob3IncyBvd24gZ3JhbnRzLCBidXQgdGhleSBhcmUNCiAgICAgICAgICAjIGNvLWF1dGhvcnNoaXAgZ3JhbnRzDQogICAgICAgICAgZnVuZGVyX2lkcyA8LSBncmFudFtuYW1lcyhncmFudCk9PSJmdW5kZXIiXQ0KICAgICAgICAgIGZ1bmRlcl9uYW1lcyA8LSBncmFudFtuYW1lcyhncmFudCkgPT0gImZ1bmRlcl9kaXNwbGF5X25hbWUiXQ0KICAgICAgICAgIHllYXIgPC0gYXMubnVtZXJpYyh5ZWFyX2xpc3RbaV0pDQogICAgICAgICAgb2FfaWQgPC0gcGFzdGUob2FfaWRzLCBjb2xsYXBzZSA9ICIsICIpDQogICAgICAgICAgcHJvZmlsZV9pZCA8LSBuYXJjaXNfaWQNCiAgICAgICAgICBmdW5kX2RmIDwtIGNiaW5kLmRhdGEuZnJhbWUoZnVuZGVyX2lkID0gZnVuZGVyX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuZGVyX25hbWVzID0gZnVuZGVyX25hbWVzKQ0KICAgICAgICAgICMgYWRkIHNvbWUgbW9yZSBpbmZvDQogICAgICAgICAgZnVuZF9kZiR5ZWFyIDwtIHllYXINCiAgICAgICAgICBmdW5kX2RmJG9hX2lkIDwtIHBhc3RlKG9hX2lkcywgY29sbGFwc2UgPSAiLCAiKQ0KICAgICAgICAgIGZ1bmRfZGYkcHJvZmlsZV9pZCA8LSBuYXJjaXNfaWQNCiAgICAgICAgICBwcm9mX2dyYW50c19vYSA8LSByYmluZChwcm9mX2dyYW50c19vYSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5kX2RmKQ0KICAgICAgICB9DQogICAgICB9DQogICAgICAjIGlmIG5vdCBOQSwgdGlkeSB1cCB0aGUgZGF0YWZyYW1lDQogICAgICBpZiAoIWlzLm51bGwobnJvdyhwcm9mX2dyYW50c19vYSkpKXsNCiAgICAgICAgIyB0aWR5IHVwIHRoZSByb3cgbmFtZXMNCiAgICAgICAgcm93bmFtZXMocHJvZl9ncmFudHNfb2EpIDwtIDE6bnJvdyhwcm9mX2dyYW50c19vYSkNCiAgICAgICAgIyBkZWR1cGxpY2F0ZSBzYW1lIGdyYW50cyBhY3Jvc3MgeWVhcnMNCiAgICAgICAgcHJvZl9ncmFudHNfb2EkZHVwbGljYXRlIDwtIGR1cGxpY2F0ZWQocHJvZl9ncmFudHNfb2FbLCBjKCJmdW5kZXJfaWQiLCAieWVhciIpXSkNCiAgICAgICAgcHJvZl9ncmFudHNfb2EgPC0gZmlsdGVyKHByb2ZfZ3JhbnRzX29hLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID09IEZBTFNFKQ0KICAgICAgICAjIHJlbW92ZSB0aGUgZHVwbGljYXRlIGNvbHVtbg0KICAgICAgICBwcm9mX2dyYW50c19vYSA8LSBwcm9mX2dyYW50c19vYVssIC0obmNvbChwcm9mX2dyYW50c19vYSkpXQ0KICAgICAgICAjIHJlbW92ZSB0aGUgcm93IHdpdGggTkFzDQogICAgICAgIHByb2ZfZ3JhbnRzX29hIDwtIHByb2ZfZ3JhbnRzX29hW3Jvd1N1bXMoaXMubmEocHJvZl9ncmFudHNfb2EpKSAhPSBuY29sKHByb2ZfZ3JhbnRzX29hKSwgXQ0KICAgICAgfQ0KICAgIH0NCiAgICANCiAgICAjIGdldCB0aGUgaW5mbyBvbiB0aGlzIGF1dGhvcg0KICAgIHByb2ZfaW5mbyA8LSBvYV9mZXRjaCgNCiAgICAgIGVudGl0eSA9ICJhdXRob3JzIiwgDQogICAgICBpZGVudGlmaWVyID0gb2FfaWRzKQ0KICAgIA0KICAgICMgbm93LCBxdWVyeSB0aGUgQWx0bWV0cmljIEFQSSB0byBnZXQgbWVudGlvbnMgaW5mbyBvbiB0aGUgYXV0aG9yDQogICAgcHJvZl9hbGxfd29ya3Nfb2FfbWVudGlvbnMgPC0gYWx0bWV0cmljX21lbnRpb25fcmV0cmlldmVyKGFwaV9rZXkgPSBhcGlfa2V5LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNhdGlvbl9saXN0ID0gcHJvZl9hbGxfd29ya3Nfb2EsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVfdHdpdHRlciA9IGluY2x1ZGVfdHdpdHRlcikNCiAgICANCiAgICANCiAgICAjIG91dHB1dCBhIGxpc3QgcG9wdWxhdGVkIHdpdGggYWxsIHRoZSBkZXRhaWxzDQogICAgcHJvZl9vdXRwdXQgPC0gbGlzdCgpDQogICAgcHJvZl9vdXRwdXRbInByb2ZpbGVfaWQiXSA8LSBuYXJjaXNfaWQNCiAgICBwcm9mX291dHB1dFsib2FfaWRzIl0gPC0gbGlzdChvYV9pZHMpDQogICAgcHJvZl9vdXRwdXRbIm9yY2lkIl0gPC0gcHJvZl9pbmZvJG9yY2lkDQogICAgcHJvZl9vdXRwdXRbInByb2ZfaW5mbyJdIDwtIGxpc3QocHJvZl9pbmZvKQ0KICAgIHByb2Zfb3V0cHV0WyJuYXJjaXNfcHVicyJdIDwtIGxpc3QocHJvZl9wdWJzKQ0KICAgIHByb2Zfb3V0cHV0WyJvYV9wdWJzIl0gPC0gbGlzdChwcm9mX2FsbF93b3Jrc19vYV9tZW50aW9ucykNCiAgICBwcm9mX291dHB1dFsiZ3JhbnRfaW5mbyJdIDwtIGxpc3QocHJvZl9ncmFudHNfb2EpDQogICAgcHJvZl9vdXRwdXRbImNvYXV0aG9yX2luZm8iXSA8LSBsaXN0KHByb2ZfY29hdXRob3JzX29hKQ0KICAgIHByb2Zfb3V0cHV0WyJhZmZpbGlhdGlvbl9pbmZvIl0gPC0gbGlzdChwcm9mX3B1Yl9pbmZvX2lhKQ0KICB9ZWxzZXsNCiAgICBpZiAoISBhbGwoaXMubmEob2FfaWRzX3B1YnMpKSl7DQogICAgcHJvZl9vdXRwdXQgPC0gbGlzdCgpDQogICAgcHJvZl9vdXRwdXRbInByb2ZpbGVfaWQiXSA8LSBuYXJjaXNfaWQNCiAgICBwcm9mX291dHB1dFsib2FfaWRzIl0gPC0gTkENCiAgICBwcm9mX291dHB1dFsib3JjaWQiXSA8LSBwcm9mX2luZm8kb3JjaWQNCiAgICBwcm9mX291dHB1dFsicHJvZl9pbmZvIl0gPC0gTkENCiAgICBwcm9mX291dHB1dFsibmFyY2lzX3B1YnMiXSA8LSBOQQ0KICAgIHByb2Zfb3V0cHV0WyJvYV9wdWJzIl0gPC0gTkENCiAgICBwcm9mX291dHB1dFsiZ3JhbnRfaW5mbyJdIDwtIE5BDQogICAgcHJvZl9vdXRwdXRbImNvYXV0aG9yX2luZm8iXSA8LSBOQQ0KICAgIHByb2Zfb3V0cHV0WyJhZmZpbGlhdGlvbl9pbmZvIl0gPC0gTkENCiAgICB9ZWxzZXsNCiAgICAgIHByb2Zfb3V0cHV0IDwtIGxpc3QoKQ0KICAgICAgcHJvZl9vdXRwdXRbInByb2ZpbGVfaWQiXSA8LSBuYXJjaXNfaWQNCiAgICAgIHByb2Zfb3V0cHV0WyJvYV9pZHMiXSA8LSBOQQ0KICAgICAgcHJvZl9vdXRwdXRbIm9yY2lkIl0gPC0gcHJvZl9pbmZvJG9yY2lkDQogICAgICBwcm9mX291dHB1dFsicHJvZl9pbmZvIl0gPC0gTkENCiAgICAgIHByb2Zfb3V0cHV0WyJuYXJjaXNfcHVicyJdIDwtIHByb2ZfcHVicw0KICAgICAgcHJvZl9vdXRwdXRbIm9hX3B1YnMiXSA8LSBOQQ0KICAgICAgcHJvZl9vdXRwdXRbImdyYW50X2luZm8iXSA8LSBOQQ0KICAgICAgcHJvZl9vdXRwdXRbImNvYXV0aG9yX2luZm8iXSA8LSBOQQ0KICAgICAgcHJvZl9vdXRwdXRbImFmZmlsaWF0aW9uX2luZm8iXSA8LSBOQQ0KICAgIH0NCiAgfQ0KICAgIA0KICByZXR1cm4ocHJvZl9vdXRwdXQpDQp9DQpgYGANCg0KRGVmaW5lIHRoZSBBbHRtZXRyaWMgcXVlcnlpbmcgZnVuY3Rpb246DQpgYGB7cn0NCmFsdG1ldHJpY19tZW50aW9uX3JldHJpZXZlciA8LSBmdW5jdGlvbihhcGlfa2V5LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uX2xpc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZV90d2l0dGVyID0gRkFMU0Upew0KICANCiAgIyBlbGVtZW50cyB0byBtYWtlIGEgdXJsIHRoYXQgY2FsbHMgdGhlIEFQSSB0byBnZXQgbWVudGlvbiBkYXRhDQogIGRvaV9jYWxsX3VybCA8LSAiaHR0cHM6Ly9hcGkuYWx0bWV0cmljLmNvbS92MS9mZXRjaC9kb2kvIg0KICBhcGlfa2V5X3VybCA8LSBwYXN0ZTAoIj9rZXk9IiwgYXBpX2tleSkNCiAgZXhjbHVkZV90d2l0dGVyX3VybCA8LSAiJmV4Y2x1ZGVfc291cmNlcz10d2l0dGVyIg0KICANCiAgIyBnZXQgdGhlIHB1YmxpY2F0aW9uIGxpc3QNCiAgb2FfcHVicyA8LSBwdWJsaWNhdGlvbl9saXN0DQogICMgaWYgbm90IGVtcHR5Og0KICBpZiAoIWlzLm51bGwobnJvdyhvYV9wdWJzKSkpew0KICAgICMgbG9vcCwgZm9yIGVhY2ggZG9pLCBhbmQ6DQogICAgZm9yIChpIGluIDE6bnJvdyhvYV9wdWJzKSl7DQogICAgICAjIGdldCB0aGUgZG9pIHdpdGhvdXQgdGhlIHVybCBwYXJ0DQogICAgICBkb2lfdXJsIDwtIHN0cl9yZW1vdmUob2FfcHVicyRkb2lbaV0sICJodHRwczovL2RvaS5vcmcvIikNCiAgICAgICMgaWYgdGhlcmUgaXMgYSBkb2k6DQogICAgICBpZiAoIWlzLm5hKGRvaV91cmwpKXsNCiAgICAgICAgIyBtYWtlIHRoZSB1cmwgZm9yIHRoZSBhcGkgY2FsbA0KICAgICAgICBhcGlfY2FsbCA8LSBwYXN0ZShkb2lfY2FsbF91cmwsIGRvaV91cmwsIGFwaV9rZXlfdXJsLCBzZXAgPSAiIikNCiAgICAgICAgDQogICAgICAgICMgZXhjbHVkZSB0d2l0dGVyPyBpZiBzbywgYWRkOg0KICAgICAgICBpZiAoaW5jbHVkZV90d2l0dGVyID09IEZBTFNFKXsNCiAgICAgICAgICBhcGlfY2FsbCA8LSBwYXN0ZShhcGlfY2FsbCwgZXhjbHVkZV90d2l0dGVyX3VybCwgc2VwID0gIiIpDQogICAgICAgIH0NCiAgICAgICAgIyBlbXB0eSBET0kgb3V0cHV0IG9iamVjdCwgaW4gY2FzZSB0cnkgZmFpbHMNCiAgICAgICAgZG9pX291dHB1dCA8LSBOQQ0KICAgICAgICAjIGFuZCBjYWxsIHRoZSBhcGkNCiAgICAgICAgdHJ5KGRvaV9vdXRwdXQgPC0gZnJvbUpTT04odHh0PWFwaV9jYWxsKSwgc2lsZW50ID0gVFJVRSkNCiAgICAgICAgIyBub3csIGNoZWNrIGlmIHRoaXMgZG9pIGhhcyBhbnkgbWVudGlvbnMgaW4gdGhlIG1lZGlhDQogICAgICAgIGlmICgicG9zdHMiICVpbiUgbmFtZXMoZG9pX291dHB1dCkpew0KICAgICAgICAgIG1lbnRpb25zIDwtIGRvaV9vdXRwdXRbWyJwb3N0cyJdXQ0KICAgICAgICAgICMgc2luY2UgZGlmZmVyZW50IHBhcGVycyBoYXZlIGRpZmZlcmVudCBtZW50aW9ucywgbGV0J3MgbG9vcCBhZ2Fpbg0KICAgICAgICAgICMgYWRkZGluZyBjb2x1bW5zIGZvciByZWxldmFudCBtZW50aW9ucw0KICAgICAgICAgIGZvciAobWVudGlvbl90eXBlIGluIG5hbWVzKG1lbnRpb25zKSl7DQogICAgICAgICAgICAjIGNoZWNrIGlmIGNvbHVtbiBhbHJlYWR5IHRoZXJlIGluIG9hX3B1YnMNCiAgICAgICAgICAgIGlmKG1lbnRpb25fdHlwZSAlaW4lIGNvbG5hbWVzKG9hX3B1YnMpKXsNCiAgICAgICAgICAgICAgIyBpZiB0aGVyZSwganVzdCBhZGQgdGhlIG1lbnRpb25zIGludG8gdGhlIGNlbGwgKG5lc3RlZCkNCiAgICAgICAgICAgICAgb2FfcHVic1tbd2hpY2goY29sbmFtZXMob2FfcHVicyk9PW1lbnRpb25fdHlwZSldXVtpXSA8LSBsaXN0KG1lbnRpb25zW1ttZW50aW9uX3R5cGVdXSkNCiAgICAgICAgICAgIH1lbHNlew0KICAgICAgICAgICAgICAjIGlmIGNvbHVtbiBub3QgdGhlcmUsIGZpcnN0IGFkZCBpdCBhbmQgcG9wdWxhdGUgd2l0aCBOQXMNCiAgICAgICAgICAgICAgb2FfcHVic1ttZW50aW9uX3R5cGVdIDwtIE5BDQogICAgICAgICAgICAgICMgYW5kIHRoZW4sIGZvciB0aGlzIHB1YiwgcGFzdGUgdGhlIG1lbnRpb24gZGF0YSBpbnRvIHRoZSBjZWxsIChpdCB3aWxsIGJlIGEgbmVzdGVkIGRhdGFmcmFtZSkNCiAgICAgICAgICAgICAgb2FfcHVic1tbd2hpY2goY29sbmFtZXMob2FfcHVicyk9PW1lbnRpb25fdHlwZSldXVtpXSA8LSBsaXN0KG1lbnRpb25zW1ttZW50aW9uX3R5cGVdXSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9DQogIH0NCiAgIyByZXR1cm4gdGhlIGxpc3Qgb2YgcHVibGljYXRpb25zIGRhdGFmcmFtZSB3aXRoIG5ldyBjb2x1bW5zDQogIHJldHVybihvYV9wdWJzKQ0KfQ0KYGBgDQoNCg0KUHVsbCB0aGUgcHJvZmVzc29yIGRhdGE6DQpgYGB7cn0NCiMgYXBpIGtleSAoZmlsbCBpbiBvd24pDQphbHRtZXRyaWNfYXBpX2tleSA8LSAnJw0KDQojIGdldCB0aGUgbGlzdCBvZiBJRHMNCm5hcmNpc19pZHMgPC0gcHJvZnNfZnVsbCRwcm9maWxlX2lkDQoNCiMgcXVlcnkgaW4gYmF0Y2hlcw0KIyBiYXRjaCBzaXplDQpwcm9mX2JhdGNoX3NpemUgPC0gNTAwDQojIHZlY3RvciBvZiBpbmRpY2VzIHRvIGxvb3AgdGhyb3VnaA0KYmF0Y2hlcyA8LSBzZXEoZnJvbT0xLCB0bz1sZW5ndGgobmFyY2lzX2lkcyksIGJ5PXByb2ZfYmF0Y2hfc2l6ZSkNCiMgdG8gYmUgYWJsZSB0byBzdWJzZXQsIGFsc28gYWRkIHRoZSBmaW5hbCBpbmRleCsxDQpiYXRjaGVzIDwtIGMoYmF0Y2hlcywgbGVuZ3RoKG5hcmNpc19pZHMpKzEpDQoNCiMgbG9vcCB0aHJvdWdoIHRoZSBiYXRjaGVzDQpmb3IoaSBpbiAxOihsZW5ndGgoYmF0Y2hlcyktMSkpew0KICAjIGluaXRpYWxpemUgYW4gZW1wdHkgbGlzdCBmb3IgdGhlIGJhdGNoDQogIGJhdGNoX3Byb2Zfb3V0Y29tZXMgPC0gbGlzdCgpDQogICMgaW5pdGlhbGl6ZSBhIGxpc3QgZm9yIGVtcHR5IG91cHV0cyAtIHByb2ZzIHRoYXQgdGhyZXcgYW4gZXJyb3INCiAgYmF0Y2hfZXJyb3JzIDwtIGxpc3QoKQ0KICANCiAgIyBnZXQgdGhlIG5hcmNpcyBpZHMgZnJvbSB0aGUgYmF0Y2gNCiAgcHJvZl9iYXRjaCA8LSBuYXJjaXNfaWRzW2JhdGNoZXNbaV06KGJhdGNoZXNbaSsxXS0xKV0NCiAgDQogICMgbG9vcCB0aHJvdWdoIHByb2Zlc3NvcnMgaW4gdGhpcyBiYXRjaA0KICBmb3IgKG5hcmNpc19pZCBpbiBwcm9mX2JhdGNoKXsNCiAgICAjIHNldCBvdXRjb21lIHRvIE5BIGFzIGEgcGxhY2Vob2xkZXINCiAgICBvdXRjb21lIDwtIE5BDQogICAgDQogICAgIyB0cnkgdG8gcXVlcnkgYWxsIHRoZSBkYXRhDQogICAgdHJ5KG91dGNvbWUgPC0gcHJvZmVzc29yX2luZm9fcmV0cmlldmVyKHByb2Zfb2FfaWRzID0gcHJvZl9vYV9tYXBwaW5nLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXJjaXNfaWQgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Yl9kYXRhID0gcHJvZl9wdWJzX2Z1bGwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfZGF0YSA9IHByb2ZzX2Z1bGwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXkgPSBhbHRtZXRyaWNfYXBpX2tleSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyByZWNvbW1lbmQgdG8gc2V0IHRvIEZBTFNFIHVubGVzcyBhbGwgd29ya3Mgd2VsbCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyB0byBhdm9pZCB1c2luZyB1cCBvdXIgdHdpdHRlciBxdWVyeSBsaW1pdHMNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZV90d2l0dGVyID0gRkFMU0UpKSAjLCBzaWxlbnQgPSBUUlVFKQ0KICAgICMgYXBwZW5kIHRvIHRoZSBiYXRjaCBkYXRhDQogICAgYmF0Y2hfcHJvZl9vdXRjb21lc1tbbmFyY2lzX2lkXV0gPC0gb3V0Y29tZQ0KICAgICMgcHJpbnQgc29tZSBpbmZvIG91dA0KICAgIHByaW50KHBhc3RlKCJkb25lIHdpdGgiLCB3aGljaChuYXJjaXNfaWQgPT0gcHJvZl9iYXRjaCksICJvdXQgb2YiLCBsZW5ndGgocHJvZl9iYXRjaCkpKQ0KICB9DQogIA0KICAjIHNhdmUgdGhlIGJhdGNoIFJEUw0KICBzYXZlX3N0cmluZyA8LSBwYXN0ZTAoInByb2Nlc3NlZF9kYXRhL29wZW5fYWxleF9wcm9mX2RhdGEvIiwgcGFzdGUoInByb2ZfZGF0YV9iYXRjaCIsIGksIHNlcCA9ICJfIiksICIuUkRTIikNCiAgc2F2ZVJEUyhiYXRjaF9wcm9mX291dGNvbWVzLCBzYXZlX3N0cmluZykNCn0NCmBgYA0KDQoNCkNoZWNrIHdoaWNoIElEcyBsYWNrIHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiwgYW5kIHRyeSB0byByZXRyaWV2ZSBpdCBhZ2Fpbg0KKHNvbWV0aW1lcyB0aGUgQVBJIHJlcXVlc3QgdGltZXMgb3V0IGV0Yywgc28gaXQncyB3b3J0aCBnaXZpbmcgaXQgYW5vdGhlciB0cnkpOg0KYGBge3J9DQojIGxvb3AgdGhyb3VnaCB0aGUgYmF0Y2hlcw0KZm9yKGkgaW4gMToobGVuZ3RoKGJhdGNoZXMpLTEpKXsNCiAgIyBsb2FkIHRoZSBiYXRjaA0KICByZWFkX3N0cmluZyA8LSBwYXN0ZTAoInByb2Nlc3NlZF9kYXRhL29wZW5fYWxleF9wcm9mX2RhdGEvIiwgcGFzdGUoInByb2ZfZGF0YV9iYXRjaCIsIGksIHNlcCA9ICJfIiksICIuUkRTIikNCiAgYmF0Y2hfcHJvZl9vdXRjb21lcyA8LSByZWFkUkRTKHJlYWRfc3RyaW5nKQ0KICANCiAgIyBnZXQgdGhlIG5hcmNpcyBpZHMgZnJvbSB0aGUgYmF0Y2gNCiAgcHJvZl9iYXRjaCA8LSBuYXJjaXNfaWRzW2JhdGNoZXNbaV06KGJhdGNoZXNbaSsxXS0xKV0NCiAgDQogICMgbG9vcCB0aHJvdWdoIHByb2Zlc3NvcnMgaW4gdGhpcyBiYXRjaA0KICBmb3IgKG5hcmNpc19pZCBpbiBwcm9mX2JhdGNoKXsNCiAgICAjIGNoZWNrIGlmIE5BLCBhbmQgaWYgc28sIHRyeSB0byBmaWxsIGl0IGluLi4uDQogICAgb3V0Y29tZSA8LSBiYXRjaF9wcm9mX291dGNvbWVzW1tuYXJjaXNfaWRdXQ0KICAgIA0KICAgICMgaWYgdGhlIG91dGNvbWUgaXMgTkEgb3IgZXZlcnl0aGluZyBPQSByZWxhdGVkIGlzIE5BLCBhbmQgc2tpcCBvbmUgcHJvYmxlbWF0aWMgbmFyY2lzIElEDQogICAgaWYgKGFsbChpcy5uYShvdXRjb21lKSl8YWxsKGlzLm5hKG91dGNvbWVbYyg0LCA2LCA3LCA4LCA5KV0pKSl7DQogICAgICBpZihuYXJjaXNfaWQgIT0gImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvUFJTMTMzNjIwMyIpew0KICAgICAgIyBjaGVjayBpZiB0aGVyZSBpcyBhbiBPQSBJRCBtYXBwZWQgdG8gdGhlbQ0KICAgICAgb2EgPC0gZmlsdGVyKHByb2Zfb2FfbWFwcGluZywgcHJvZmlsZV9pZCA9PSBuYXJjaXNfaWQpDQogICAgICAjIGlmIHRoZXJlIGlzLCBnaXZlIGl0IGFub3RoZXIgZ28gYXQgcmV0cmlldmluZyB0aGUgaW5mbw0KICAgICAgaWYgKCFhbGwoaXMubmEob2FbYygnb2FfaWQnLCAnc291cmNlJyldKSkpew0KICAgICAgICB0cnkob3V0Y29tZSA8LSBwcm9mZXNzb3JfaW5mb19yZXRyaWV2ZXIocHJvZl9vYV9pZHMgPSBwcm9mX29hX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXJjaXNfaWQgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJfZGF0YSA9IHByb2ZfcHVic19mdWxsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9kYXRhID0gcHJvZnNfZnVsbCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXkgPSBhbHRtZXRyaWNfYXBpX2tleSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgcmVjb21tZW5kIHRvIHNldCB0byBGQUxTRSB1bmxlc3MgYWxsIHdvcmtzIHdlbGwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIHRvIGF2b2lkIHVzaW5nIHVwIG91ciB0d2l0dGVyIHF1ZXJ5IGxpbWl0cw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZV90d2l0dGVyID0gRkFMU0UpKSAjLCBzaWxlbnQgPSBUUlVFKQ0KICAgICAgfWVsc2V7DQogICAgICAgIHByb2ZfcHVicyA8LSBmaWx0ZXIocHJvZl9wdWJzX2Z1bGwsIHByb2ZpbGVfaWQgPT0gbmFyY2lzX2lkKQ0KICAgICAgICBpZighYWxsKGlzLm5hKHByb2ZfcHVicykpKXsNCiAgICAgICAgICBvdXRjb21lIDwtIGxpc3QoKQ0KICAgICAgICAgIG91dGNvbWVbInByb2ZpbGVfaWQiXSA8LSBuYXJjaXNfaWQNCiAgICAgICAgICBvdXRjb21lWyJvYV9pZHMiXSA8LSBOQQ0KICAgICAgICAgIG91dGNvbWVbIm9yY2lkIl0gPC0gTkENCiAgICAgICAgICBvdXRjb21lWyJwcm9mX2luZm8iXSA8LSBOQQ0KICAgICAgICAgIG91dGNvbWVbIm5hcmNpc19wdWJzIl0gPC0gcHJvZl9wdWJzDQogICAgICAgICAgb3V0Y29tZVsib2FfcHVicyJdIDwtIE5BDQogICAgICAgICAgb3V0Y29tZVsiZ3JhbnRfaW5mbyJdIDwtIE5BDQogICAgICAgICAgb3V0Y29tZVsiY29hdXRob3JfaW5mbyJdIDwtIE5BDQogICAgICAgICAgb3V0Y29tZVsiYWZmaWxpYXRpb25faW5mbyJdIDwtIE5BDQogICAgICAgICAgfWVsc2V7DQogICAgICAgICAgICBvdXRjb21lIDwtIGxpc3QoKQ0KICAgICAgICAgICAgb3V0Y29tZVsicHJvZmlsZV9pZCJdIDwtIG5hcmNpc19pZA0KICAgICAgICAgICAgb3V0Y29tZVsib2FfaWRzIl0gPC0gTkENCiAgICAgICAgICAgIG91dGNvbWVbIm9yY2lkIl0gPC0gTkENCiAgICAgICAgICAgIG91dGNvbWVbInByb2ZfaW5mbyJdIDwtIE5BDQogICAgICAgICAgICBvdXRjb21lWyJuYXJjaXNfcHVicyJdIDwtIE5BDQogICAgICAgICAgICBvdXRjb21lWyJvYV9wdWJzIl0gPC0gTkENCiAgICAgICAgICAgIG91dGNvbWVbImdyYW50X2luZm8iXSA8LSBOQQ0KICAgICAgICAgICAgb3V0Y29tZVsiY29hdXRob3JfaW5mbyJdIDwtIE5BDQogICAgICAgICAgICBvdXRjb21lWyJhZmZpbGlhdGlvbl9pbmZvIl0gPC0gTkENCiAgICAgICAgICB9DQogICAgICB9DQogICAgICAjIGFwcGVuZCB0byB0aGUgYmF0Y2ggZGF0YQ0KICAgICAgYmF0Y2hfcHJvZl9vdXRjb21lc1tbbmFyY2lzX2lkXV0gPC0gb3V0Y29tZQ0KICAgIH0NCiAgICAjIHByaW50IHNvbWUgaW5mbyBvdXQNCiAgICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgd2hpY2gobmFyY2lzX2lkID09IHByb2ZfYmF0Y2gpLCAib3V0IG9mIiwgbGVuZ3RoKHByb2ZfYmF0Y2gpKSkNCiAgfX0NCiAgIyBzYXZlIHRoZSBiYXRjaCBSRFMNCiAgc2F2ZV9zdHJpbmcgPC0gcGFzdGUwKCJwcm9jZXNzZWRfZGF0YS9vcGVuX2FsZXhfcHJvZl9kYXRhLyIsIHBhc3RlKCJwcm9mX2RhdGFfYmF0Y2giLCBpLCBzZXAgPSAiXyIpLCAiLlJEUyIpDQogIHNhdmVSRFMoYmF0Y2hfcHJvZl9vdXRjb21lcywgc2F2ZV9zdHJpbmcpDQp9DQpgYGANCg0KDQoNCg0KIyBQb3B1bGF0ZSBhbiBTUUwgZGF0YWJhc2Ugd2l0aCB0aGUgZGF0YQ0KDQpDb25uZWN0IHRvIHRoZSBwb3N0Z3JlcyBkYXRhYmFzZS4NClVzZSBvd24gY3JlZGVudGlhbHMuDQpgYGB7cn0NCmRzbl9wb3J0IDwtIA0KZHNuX3VpZCA8LSAiIg0KZHNuX3B3ZCA8LSAiIg0KDQpjb24gPC0gUlBvc3RncmVzOjpkYkNvbm5lY3QoUlBvc3RncmVzOjpQb3N0Z3JlcygpLA0KICAgICAgICAgICAgICAgICBkYm5hbWU9IGRzbl91aWQsDQogICAgICAgICAgICAgICAgIHBvcnQgPSBkc25fcG9ydCwNCiAgICAgICAgICAgICAgICAgdXNlciA9IGRzbl91aWQsIA0KICAgICAgICAgICAgICAgICBwYXNzd29yZCA9IGRzbl9wd2QpDQoNCmNvbiAjIENoZWNrcyBjb25uZWN0aW9uIGlzIHdvcmtpbmcNCmBgYA0KDQojIyBJZGVudGlmaWVyIGxpc3QNCldyaXRlIG91dCB0aGUgaWRlbnRpZmllciBsaXN0IHRvIGEgdGFibGUgaW4gdGhlIFNRTCBkYXRhYmFzZToNCmBgYHtyfQ0KcHJvZl9pZGVudGlmaWVyX2xpc3QgPC0gcmVhZFJEUygifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcHJvY2Vzc2VkX2RhdGEvcHJvZl9vYV9pZGVudGlmaWVyX2xpc3QuUkRTIikNCg0KcHJvZl9vYV9tYXBwaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBucm93ID0gMCwgbmNvbCA9IDMpKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgocHJvZl9pZGVudGlmaWVyX2xpc3QpKXsNCiAgIyBpbml0aWF0ZSBhIGRhdGFmcmFtZSB0byBzdG9yZSB0aGlzIHByb2Zlc3NvcidzIGRhdGENCiAgcHJvZl9vYV9pZHMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMykpDQogICMgcmV0cmlldmUgdGhpcyBwcm9mZXNzb3IncyBsaXN0IG9mIGlkZW50aWZpZXJzDQogIHByb2ZfaWRlbnRpZmllcnMgPC0gcHJvZl9pZGVudGlmaWVyX2xpc3RbW2ldXQ0KICAjIGdldCB0aGVpciBOYXJjaXMgSUQgYW5kIGFsbCB0aGUgcmV0cmlldmVkIE9BIElEcw0KICBuYXJjaXNfaWQgPC0gcHJvZl9pZGVudGlmaWVyX2xpc3RbW2ldXVtbIm5hcmNpc19pZCJdXQ0KICANCiAgcHViX2lkcyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sib2FfaWRzX3B1YnMiXV0NCiAgDQogIG9yY2lkX2lkcyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sib2FfaWRzX29yY2lkIl1dDQogIA0KICBuYW1lX2lkcyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sib2FfaWRzX25hbWVzIl1dDQogIA0KICAjIGFkZCBhbnkgSURzIHJldHJpZXZlZCBmcm9tIHRoZSBwdWJsaWNhdGlvbiBsaXN0DQogIGlmICghYWxsKGlzLm5hKHB1Yl9pZHMpKSl7DQogIA0KICBwdWJfaWRzIDwtIGNiaW5kLmRhdGEuZnJhbWUoInByb2ZpbGVfaWQiID0gbmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9hX2lkIiA9IHB1Yl9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlIiA9ICJwdWJsaWNhdGlvbnMiKQ0KICANCiAgcHJvZl9vYV9pZHMgPC0gcmJpbmQocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgIHB1Yl9pZHMpDQogIH0NCiAgIyBhZGQgYW55IElEcyBhc3NvY2lhdGVkIHdpdGggcHJvZidzIE9SQ0lEDQogIGlmICghYWxsKGlzLm5hKG9yY2lkX2lkcykpKXsNCiAgb3JjaWRfaWRzIDwtIGNiaW5kLmRhdGEuZnJhbWUoInByb2ZpbGVfaWQiID0gbmFyY2lzX2lkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9hX2lkIiA9IG9yY2lkX2lkcywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2UiID0gIm9yY2lkIikNCiAgDQogIHByb2Zfb2FfaWRzIDwtIHJiaW5kKHByb2Zfb2FfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICBvcmNpZF9pZHMpDQogIH0NCiAgIyBhZGQgYW55IElEcyBmcm9tIG5hbWUgc2VhcmNoICsgTkwgY291bnRyeQ0KICBpZiAoIWFsbChpcy5uYShuYW1lX2lkcykpKXsNCiAgbmFtZV9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gbmFtZV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlIiA9ICJuYW1lIikNCiAgDQogIHByb2Zfb2FfaWRzIDwtIHJiaW5kKHByb2Zfb2FfaWRzLA0KICAgICAgICAgICAgICAgICAgICAgICBuYW1lX2lkcykNCiAgfQ0KICANCiAgIyBpZiBhbnkgcm93cw0KICBpZiAobnJvdyhwcm9mX29hX2lkcykgPiAwKXsNCiAgICANCiAgICAjIGRlZHVwbGljYXRlDQogICAgcHJvZl9vYV9pZHMkZHVwbGljYXRlIDwtIGR1cGxpY2F0ZWQocHJvZl9vYV9pZHNbYygicHJvZmlsZV9pZCIsICJvYV9pZCIpXSkNCiAgICBwcm9mX29hX2lkcyA8LSBmaWx0ZXIocHJvZl9vYV9pZHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9PSBGQUxTRSkNCiAgICBwcm9mX29hX2lkcyA8LSBwcm9mX29hX2lkc1ssIC00XQ0KICAgIA0KICAgIHByb2Zfb2FfbWFwcGluZyA8LSByYmluZChwcm9mX29hX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Zfb2FfaWRzKQ0KICB9IGVsc2V7DQogICAgcHJvZl9vYV9pZHMgPC0gY2JpbmQuZGF0YS5mcmFtZSgicHJvZmlsZV9pZCIgPSBuYXJjaXNfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2FfaWQiID0gTkEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlIiA9IE5BKQ0KICAgIHByb2Zfb2FfbWFwcGluZyA8LSByYmluZChwcm9mX29hX21hcHBpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Zfb2FfaWRzKQ0KICB9DQogICNwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChuYXJjaXNfaWRzKSkpDQp9DQoNCg0KZGJXcml0ZVRhYmxlKGNvbiwgIm9hX2lkZW50aWZpZXJfdGFibGUiLCBwcm9mX29hX21hcHBpbmcsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQpgYGANCg0KIyMgR2VuZGVyIGRhdGENCmBgYHtyfQ0KcHJvZnNfZnVsbF9nZW5kZXIgPC0gcmVhZFJEUygifi9Qb3N0ZG9jL1Byb2plY3RzL2R1dGNoX21lZGlhX3Byb2ZzX3IvcHJvY2Vzc2VkX2RhdGEvcHJvZnNfZnVsbF9nZW5kZXIuUkRTIikNCmRiV3JpdGVUYWJsZShjb24sICJnZW5kZXJfdGFibGUiLCBwcm9mc19mdWxsX2dlbmRlciwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQojIyBPUkNJRHMNCg0KYGBge3J9DQpwcm9mX29yY2lkX21hcHBpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5yb3cgPSAwLCBuY29sID0gMSkpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChwcm9mX2lkZW50aWZpZXJfbGlzdCkpew0KICAjIHJldHJpZXZlIHRoaXMgcHJvZmVzc29yJ3MgbGlzdCBvZiBpZGVudGlmaWVycw0KICBwcm9mX2lkZW50aWZpZXJzIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV0NCiAgIyBnZXQgdGhlaXIgTmFyY2lzIElEIGFuZCBhbGwgdGhlIHJldHJpZXZlZCBPQSBJRHMNCiAgbmFyY2lzX2lkIDwtIHByb2ZfaWRlbnRpZmllcl9saXN0W1tpXV1bWyJuYXJjaXNfaWQiXV0NCiAgDQogIG9yY2lkX2lkcyA8LSBwcm9mX2lkZW50aWZpZXJfbGlzdFtbaV1dW1sib2FfaWRzX29yY2lkIl1dDQoNCiAgDQogIGlkcyA8LSBjYmluZC5kYXRhLmZyYW1lKCJwcm9maWxlX2lkIiA9IG5hcmNpc19pZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvcmNpZCIgPSBvcmNpZF9pZHMpDQogIA0KICBwcm9mX29yY2lkX21hcHBpbmcgPC0gcmJpbmQocHJvZl9vcmNpZF9tYXBwaW5nLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZHMpDQogICNwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaSwgIm91dCBvZiIsIGxlbmd0aChuYXJjaXNfaWRzKSkpDQp9DQoNCmRiV3JpdGVUYWJsZShjb24sICJvcmNpZF90YWJsZSIsIHByb2Zfb3JjaWRfbWFwcGluZywgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCmBgYA0KDQojIyBFeHRyYWN0IGluZm8gZnJvbSBwcm9mZXNzb3IgbGlzdHMNCmBgYHtyfQ0KIyBkYlJlbW92ZVRhYmxlKGNvbiwgInByb2ZfaW5mbyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAiYWZmaWxpYXRpb25faW5mbyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAiZ3JhbnRfaW5mbyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAiY29hdXRob3JfaW5mbyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAibmV3c19tZW50aW9ucyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAid2lraV9tZW50aW9ucyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAicmVkZGl0X21lbnRpb25zIikNCiMgZGJSZW1vdmVUYWJsZShjb24sICJuYXJjaXNfcHVicyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAib2FfcHVicyIpDQojIGRiUmVtb3ZlVGFibGUoY29uLCAib2FfY29uY2VwdHMiKQ0KDQojIGhlbHBlciBlbGVtZW50cyBmb3IgbWVudGlvbiBwYWRkaW5nDQojIG1lbnRpb25fY29scyA8LSBjKCJ3aWtpcGVkaWEiLCAibmV3cyIsICJwYXRlbnQiLCAiYmxvZ3MiLCAiZ29vZ2xlcGx1cyIsIA0KIyAgICAgICAgICAgICAgICAgICAiZmFjZWJvb2siLCAicmVkZGl0IiwgImYxMDAwIiwgInBvbGljeSIsICJwZWVyX3Jldmlld3MiLA0KIyAgICAgICAgICAgICAgICAgICAidmlkZW8iLCAicSZhIiwgIm1pc2MiLCAid2VpYm8iLCAicGludGVyZXN0IiwgInN5bGxhYmkiLA0KIyAgICAgICAgICAgICAgICAgICAibGlua2VkaW4iLCAiYm9va19yZXZpZXdzIikNCg0KIyBnZXQgdGhlIGxpc3Qgb2YgSURzDQpuYXJjaXNfaWRzIDwtIHByb2ZzX2Z1bGwkcHJvZmlsZV9pZA0KIyBxdWVyeSBpbiBiYXRjaGVzDQojIGJhdGNoIHNpemUNCnByb2ZfYmF0Y2hfc2l6ZSA8LSA1MDANCiMgdmVjdG9yIG9mIGluZGljZXMgdG8gbG9vcCB0aHJvdWdoDQpiYXRjaGVzIDwtIHNlcShmcm9tPTEsIHRvPWxlbmd0aChuYXJjaXNfaWRzKSwgYnk9cHJvZl9iYXRjaF9zaXplKQ0KIyB0byBiZSBhYmxlIHRvIHN1YnNldCwgYWxzbyBhZGQgdGhlIGZpbmFsIGluZGV4KzENCmJhdGNoZXMgPC0gYyhiYXRjaGVzLCBsZW5ndGgobmFyY2lzX2lkcykrMSkNCg0KIyBsb29wIHRocm91Z2ggdGhlIGJhdGNoZXMNCmZvcihpIGluIDE6KGxlbmd0aChiYXRjaGVzKS0xKSl7DQogIyBsb2FkIHRoZSBiYXRjaA0KICByZWFkX3N0cmluZyA8LSBwYXN0ZTAoInByb2Nlc3NlZF9kYXRhL29wZW5fYWxleF9wcm9mX2RhdGEvIiwgcGFzdGUoInByb2ZfZGF0YV9iYXRjaCIsIGksIHNlcCA9ICJfIiksICIuUkRTIikNCiAgYmF0Y2hfcHJvZl9vdXRjb21lcyA8LSByZWFkUkRTKHJlYWRfc3RyaW5nKQ0KICANCiAgIyBnZXQgdGhlIG5hcmNpcyBpZHMgZnJvbSB0aGUgYmF0Y2gNCiAgcHJvZl9iYXRjaCA8LSBuYXJjaXNfaWRzW2JhdGNoZXNbaV06KGJhdGNoZXNbaSsxXS0xKV0NCg0KDQogIGZvciAoaiBpbiAxOmxlbmd0aChwcm9mX2JhdGNoKSl7DQogICAgcHJvZiA8LSBiYXRjaF9wcm9mX291dGNvbWVzW1tqXV0NCiAgICBwcm9mX2lkIDwtIG5hbWVzKGJhdGNoX3Byb2Zfb3V0Y29tZXNbal0pDQogICAgIyBpZiBzb21lIGRhdGEgaW4gdGhlIHByb2YgbGlzdA0KICAgIGlmIChsZW5ndGgocHJvZik+MSl7DQogICAgICAjIyBnZXQgdGhlIHByb2Zlc3NvciBpbmZvDQogICAgICBwcm9mX2luZm8gPC0gcHJvZltbInByb2ZfaW5mbyJdXQ0KICAgICAgIyBpZiBub3QgZW1wdHkNCiAgICAgIGlmICghYWxsKGlzLm5hKHByb2ZfaW5mbykpKXsNCiAgICAgICAgIyByZW1vdmUgY29sdW1ucyB3ZSBkbyBub3QgbmVlZA0KICAgICAgICBpZihhbnkoYygieF9jb25jZXB0cyIsImRpc3BsYXlfbmFtZV9hbHRlcm5hdGl2ZXMiLCAiaWRzIiwgImFmZmlsaWF0aW9uX2xpbmVhZ2UiKSAlaW4lIGNvbG5hbWVzKHByb2ZfaW5mbykpKXsNCiAgICAgICAgICBwcm9mX2luZm8gPC0gcHJvZl9pbmZvICU+JQ0KICAgICAgICAgICAgc2VsZWN0KCFhbnlfb2YoYygieF9jb25jZXB0cyIsICJkaXNwbGF5X25hbWVfYWx0ZXJuYXRpdmVzIiwgImlkcyIsICJhZmZpbGlhdGlvbl9saW5lYWdlIikpKQ0KICAgICAgICB9DQogICAgICAgICMgbm93IHVubmVzdCB0aGUgZGF0YQ0KICAgICAgICBwcm9mX2luZm9fdW5uZXN0IDwtIHVubmVzdChwcm9mX2luZm8sIGNvbHMgPSBjKGNvdW50c19ieV95ZWFyKSwgbmFtZXNfc2VwID0gIl95ZWFyXyIpDQogICAgICAgICMgYXBwZW5kIHRoZSBwcm9mIGlkDQogICAgICAgIHByb2ZfaW5mb191bm5lc3QgPC0gYmluZF9jb2xzKCJwcm9maWxlX2lkIiA9IHByb2ZfaWQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfaW5mb191bm5lc3QpDQogICAgICAgIGlmICgoaSA9PSAxKSAmIChqID09IDEpKXsNCiAgICAgICAgIyBhbmQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJwcm9mX2luZm8iLCBwcm9mX2luZm9fdW5uZXN0LCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKQ0KICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgICBmaWVsZHMgPC0gZGJMaXN0RmllbGRzKGNvbiwgInByb2ZfaW5mbyIpDQogICAgICAgICAgIyBpZiBub3QgYWxsIGZpZWxkcyB0aGVyZQ0KICAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXMocHJvZl9pbmZvX3VubmVzdCkpKXsNCiAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMocHJvZl9pbmZvX3VubmVzdCkpDQogICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHByb2ZfaW5mb191bm5lc3QpKV0NCiAgICAgICAgICAgIHByb2ZfaW5mb191bm5lc3QgPC0gYmluZF9jb2xzKHByb2ZfaW5mb191bm5lc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgICAgICAgcHJvZl9pbmZvX3VubmVzdCA8LSBwcm9mX2luZm9fdW5uZXN0W2ZpZWxkc10NCiAgICAgICAgICB9DQogICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgIHByb2ZfaW5mb191bm5lc3QgPC0gIHByb2ZfaW5mb191bm5lc3QgJT4lDQogICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgDQogICAgICAgICAgZGJBcHBlbmRUYWJsZShjb24sICJwcm9mX2luZm8iLCBwcm9mX2luZm9fdW5uZXN0LCByb3cubmFtZXM9TlVMTCwgYXBwZW5kPVRSVUUpDQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIA0KICAgICAgIyMgZ2V0IHRoZSBOQVJDSVMgcHVibGljYXRpb25zDQogICAgICBuYXJjaXNfcHVicyA8LSBwcm9mW1sibmFyY2lzX3B1YnMiXV0NCiAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICBpZiAoIWFsbChpcy5uYShuYXJjaXNfcHVicykpICYgY2xhc3MobmFyY2lzX3B1YnMpICE9ICJjaGFyYWN0ZXIiKXsNCiAgICAgICAgIyBpZiBmaXJzdCByb3VuZCwgY3JlYXRlIGEgdGFibGUNCiAgICAgICAgaWYgKChpID09IDEpICYgKGogPT0gMSkpew0KICAgICAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgIm5hcmNpc19wdWJzIiwgbmFyY2lzX3B1YnMsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQogICAgICAgICAgIyBvdGhlcndpc2UsIGFwcGVuZA0KICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgICBmaWVsZHMgPC0gZGJMaXN0RmllbGRzKGNvbiwgIm5hcmNpc19wdWJzIikNCiAgICAgICAgICAjIG9ubHkgbGVhdmUgdGhlc2UgZmllbGRzIGluDQogICAgICAgICAgbmFyY2lzX3B1YnMgPC0gIG5hcmNpc19wdWJzICU+JQ0KICAgICAgICAgICAgc2VsZWN0KGFsbF9vZihmaWVsZHMpKQ0KICAgICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAibmFyY2lzX3B1YnMiLCBuYXJjaXNfcHVicywgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKQ0KICAgICAgICB9DQogICAgICB9DQogICAgICANCiAgICAgICMjIGdldCB0aGUgT0EgcHVibGljYXRpb25zDQogICAgICBvYV9wdWJzIDwtIHByb2ZbWyJvYV9wdWJzIl1dDQogICAgICANCiAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICBpZiAoIWFsbChpcy5uYShvYV9wdWJzKSkpew0KICAgICAgICAjIGZpcnN0LCBnZXQgdGhlIG1lbnRpb24gZGF0YQ0KICAgICAgICBtZW50aW9uX2RhdGEgPC0gb2FfcHVicyAlPiUNCiAgICAgICAgICBzZWxlY3QoaWQsIHByb2ZpbGVfaWQsIGF1dGhvcl9wb3NpdGlvbjpsYXN0X2NvbCgpLCAtYXV0aG9yX3Bvc2l0aW9uKQ0KICAgICAgICANCiAgICAgICAgIyBpZiBub3QgZW1wdHkNCiAgICAgICAgaWYgKCFhbGwoaXMubmEobWVudGlvbl9kYXRhKSkpew0KICAgICAgICAgIA0KICAgICAgICAgICMgaWYgdGhlcmUncyB3aWtpIGRhdGENCiAgICAgICAgICBpZiAoJ3dpa2lwZWRpYScgJWluJSBjb2xuYW1lcyhtZW50aW9uX2RhdGEpKXsNCiAgICAgICAgICAgIHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCA8LSBtZW50aW9uX2RhdGElPiUNCiAgICAgICAgICAgICAgc2VsZWN0KGlkLCBwcm9maWxlX2lkLCB3aWtpcGVkaWEpICU+JQ0KICAgICAgICAgICAgICB1bm5lc3QoLiwgY29scyA9ICd3aWtpcGVkaWEnKSU+JQ0KICAgICAgICAgICAgICBzZWxlY3QoIWNpdGF0aW9uX2lkcyklPiUNCiAgICAgICAgICAgICAgdW5uZXN0KC4sIGNvbHMgPSBhdXRob3IsIG5hbWVzX3NlcCA9ICJfYXVfIikNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBpZiBmaXJzdCByb3VuZCwgY3JlYXRlIGEgdGFibGUNCiAgICAgICAgICAgIGlmICgoaSA9PSAxKSAmIChqID09IDEpKXsNCiAgICAgICAgICAgICAgIyB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgIndpa2lfbWVudGlvbnMiLCB3aWtpX21lbnRpb25fZGF0YV91bm5lc3QsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpDQogICAgICAgICAgICAgICMgb3RoZXJ3aXNlLCBhcHBlbmQNCiAgICAgICAgICAgIH1lbHNlew0KICAgICAgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJ3aWtpX21lbnRpb25zIikNCiAgICAgICAgICAgICAgIyBpZiBub3QgYWxsIGZpZWxkcyB0aGVyZQ0KICAgICAgICAgICAgICBpZighYWxsKGZpZWxkcyAlaW4lIGNvbG5hbWVzKHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCkpKXsNCiAgICAgICAgICAgICAgICBuX21pc3NpbmcgPC0gd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCkpDQogICAgICAgICAgICAgICAgcGFkZGluZyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IGxlbmd0aChuX21pc3NpbmcpLCBucm93PTEpKQ0KICAgICAgICAgICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMod2lraV9tZW50aW9uX2RhdGFfdW5uZXN0KSldDQogICAgICAgICAgICAgICAgd2lraV9tZW50aW9uX2RhdGFfdW5uZXN0IDwtIGJpbmRfY29scyh3aWtpX21lbnRpb25fZGF0YV91bm5lc3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICAgICAgICB3aWtpX21lbnRpb25fZGF0YV91bm5lc3QgPC0gd2lraV9tZW50aW9uX2RhdGFfdW5uZXN0W2ZpZWxkc10NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAjIG9ubHkgbGVhdmUgdGhlc2UgZmllbGRzIGluDQogICAgICAgICAgICAgIHdpa2lfbWVudGlvbl9kYXRhX3VubmVzdCA8LSAgd2lraV9tZW50aW9uX2RhdGFfdW5uZXN0ICU+JQ0KICAgICAgICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiAgICAgICAgICAgICAgZGJBcHBlbmRUYWJsZShjb24sICJ3aWtpX21lbnRpb25zIiwgd2lraV9tZW50aW9uX2RhdGFfdW5uZXN0LCByb3cubmFtZXM9TlVMTCwgYXBwZW5kPVRSVUUpDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgICMgaWYgdGhlcmUncyBuZXdzIGRhdGENCiAgICAgICAgICBpZiAoJ25ld3MnICVpbiUgY29sbmFtZXMobWVudGlvbl9kYXRhKSl7DQogICAgICAgICAgICBuZXdzX21lbnRpb25fZGF0YV91bm5lc3QgPC0gbWVudGlvbl9kYXRhJT4lDQogICAgICAgICAgICAgIHNlbGVjdChpZCwgcHJvZmlsZV9pZCwgbmV3cykgJT4lDQogICAgICAgICAgICAgIHVubmVzdCguLCBjb2xzID0gJ25ld3MnKSU+JQ0KICAgICAgICAgICAgICBzZWxlY3QoIWNpdGF0aW9uX2lkcyklPiUNCiAgICAgICAgICAgICAgdW5uZXN0KC4sIGNvbHMgPSBhdXRob3IsIG5hbWVzX3NlcCA9ICJfYXVfIikNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBpZiBmaXJzdCByb3VuZCwgY3JlYXRlIGEgdGFibGUNCiAgICAgICAgICAgIGlmICgoaSA9PSAxKSAmIChqID09IDEpKXsNCiAgICAgICAgICAgICAgIyB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgIm5ld3NfbWVudGlvbnMiLCBuZXdzX21lbnRpb25fZGF0YV91bm5lc3QsIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpIA0KICAgICAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAibmV3c19tZW50aW9ucyIpDQogICAgICAgICAgICAgICMgaWYgbm90IGFsbCBmaWVsZHMgdGhlcmUNCiAgICAgICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyhuZXdzX21lbnRpb25fZGF0YV91bm5lc3QpKSl7DQogICAgICAgICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhuZXdzX21lbnRpb25fZGF0YV91bm5lc3QpKQ0KICAgICAgICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKG5ld3NfbWVudGlvbl9kYXRhX3VubmVzdCkpXQ0KICAgICAgICAgICAgICAgIG5ld3NfbWVudGlvbl9kYXRhX3VubmVzdCA8LSBiaW5kX2NvbHMobmV3c19tZW50aW9uX2RhdGFfdW5uZXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICAgICAgICBuZXdzX21lbnRpb25fZGF0YV91bm5lc3QgPC0gbmV3c19tZW50aW9uX2RhdGFfdW5uZXN0W2ZpZWxkc10NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgICAgICBuZXdzX21lbnRpb25fZGF0YV91bm5lc3QgPC0gIG5ld3NfbWVudGlvbl9kYXRhX3VubmVzdCAlPiUNCiAgICAgICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAibmV3c19tZW50aW9ucyIsIG5ld3NfbWVudGlvbl9kYXRhX3VubmVzdCwgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKSANCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgDQogICAgICAgICAgIyAjIGlmIHRoZXJlJ3MgRkIgZGF0YSwgYnV0IHRoaXMgZG9lc24ndCB3b3JrIA0KICAgICAgICAgICMgaWYgKCdmYWNlYm9vaycgJWluJSBjb2xuYW1lcyhtZW50aW9uX2RhdGEpKXsNCiAgICAgICAgICAjICAgZmJfbWVudGlvbl9kYXRhX3VubmVzdCA8LSBtZW50aW9uX2RhdGElPiUNCiAgICAgICAgICAjICAgICBzZWxlY3QoaWQsIHByb2ZpbGVfaWQsIGZhY2Vib29rKSAlPiUNCiAgICAgICAgICAjICAgICB1bm5lc3QoLiwgY29scyA9ICdmYWNlYm9vaycpJT4lDQogICAgICAgICAgIyAgICAgc2VsZWN0KCFjaXRhdGlvbl9pZHMpDQogICAgICAgICAgIyANCiAgICAgICAgICAjIH0NCiAgICAgICAgICANCiAgICAgICAgICAjIGlmIHRoZXJlJ3MgcmVkZGl0IGRhdGENCiAgICAgICAgICBpZiAoJ3JlZGRpdCcgJWluJSBjb2xuYW1lcyhtZW50aW9uX2RhdGEpKXsNCiAgICAgICAgICAgIHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0IDwtIG1lbnRpb25fZGF0YSU+JQ0KICAgICAgICAgICAgICBzZWxlY3QoaWQsIHByb2ZpbGVfaWQsIHJlZGRpdCkgJT4lDQogICAgICAgICAgICAgIHVubmVzdCguLCBjb2xzID0gJ3JlZGRpdCcpJT4lDQogICAgICAgICAgICAgIHNlbGVjdCghY2l0YXRpb25faWRzKSU+JQ0KICAgICAgICAgICAgICB1bm5lc3QoLiwgY29scyA9IGF1dGhvciwgbmFtZXNfc2VwID0gIl9hdV8iKQ0KICAgICAgICAgICAgDQogICAgICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICAgICAgICMgd3JpdGUgdG8gdGhlIGRhdGFiYXNlDQogICAgICAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJyZWRkaXRfbWVudGlvbnMiLCByZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkgDQogICAgICAgICAgICAgICMgb3RoZXJ3aXNlLCBhcHBlbmQNCiAgICAgICAgICAgIH1lbHNlew0KICAgICAgICAgICAgICAjIGNoZWNrIGZpZWxkcyBpbiB0aGUgZXhpc3RpbmcgdGFibGUNCiAgICAgICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJyZWRkaXRfbWVudGlvbnMiKQ0KICAgICAgICAgICAgICBpZighYWxsKGZpZWxkcyAlaW4lIGNvbG5hbWVzKHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0KSkpew0KICAgICAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMocmVkZGl0X21lbnRpb25fZGF0YV91bm5lc3QpKQ0KICAgICAgICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICAgICAgICBjb2xuYW1lcyhwYWRkaW5nKSA8LSBmaWVsZHNbd2hpY2goIWZpZWxkcyAlaW4lIGNvbG5hbWVzKHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0KSldDQogICAgICAgICAgICAgICAgcmVkZGl0X21lbnRpb25fZGF0YV91bm5lc3QgPC0gYmluZF9jb2xzKHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICAgICAgICByZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCA8LSByZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdFtmaWVsZHNdDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgICAgICByZWRkaXRfbWVudGlvbl9kYXRhX3VubmVzdCA8LSAgcmVkZGl0X21lbnRpb25fZGF0YV91bm5lc3QgJT4lDQogICAgICAgICAgICAgICAgc2VsZWN0KGFsbF9vZihmaWVsZHMpKQ0KICAgICAgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgInJlZGRpdF9tZW50aW9ucyIsIHJlZGRpdF9tZW50aW9uX2RhdGFfdW5uZXN0LCByb3cubmFtZXM9TlVMTCwgYXBwZW5kPVRSVUUpIA0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICANCiAgICAgICAgIyBub3csIGdldCB0aGUgcHVibGljYXRpb24gZGF0YQ0KICAgICAgICAjIHNlbGVjdCByZWxldmFudCBjb2x1bW5zDQogICAgICAgIHNlbGVjdF9jb2xzIDwtIGMoImlkIiwgInByb2ZpbGVfaWQiLCAiZGlzcGxheV9uYW1lIiwgImFiIiwgInB1YmxpY2F0aW9uX3llYXIiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJzbyIsICJzb19pZCIsICJob3N0X29yZ2FuaXphdGlvbiIsICJpc3NuX2wiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAidXJsIiwgInBkZl91cmwiLCAidm9sdW1lIiwgImlzc3VlIiwgImZpcnN0X3BhZ2UiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAibGFzdF9wYWdlIiwgIiBpc19pYSIsICJsYW5ndWFnZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgImNpdGVkX2J5X2NvdW50IiwgImNvdW50c19ieV95ZWFyIiwgImNpdGVkX2J5X2FwaV91cmwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICJkb2kiLCAidHlwZSIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICJpc19yZXRyYWN0ZWQiLCAiaWFfaWQiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAiYXV0aG9yX3Bvc2l0aW9uIikNCiAgICAgICAgcHViX2RhdGEgPC0gb2FfcHVicyAlPiUNCiAgICAgICAgICBzZWxlY3QoYW55X29mKHNlbGVjdF9jb2xzKSkNCiAgICAgICAgDQogICAgICAgICMgZ2V0IHRoZSByZWZlcmVuY2VkIHdvcmtzDQogICAgICAgIHJlZmVyZW5jZWRfd29ya3MgPC0gb2FfcHVicyAlPiUNCiAgICAgICAgICBzZWxlY3QoaWQsIHByb2ZpbGVfaWQsIHJlZmVyZW5jZWRfd29ya3MpJT4lDQogICAgICAgICAgdW5uZXN0KC4sIGNvbHMgPSAicmVmZXJlbmNlZF93b3JrcyIpDQogICAgICAgIA0KICAgICAgICAjIGdldCB0aGUgY291bnRzIGJ5IHllYXINCiAgICAgICAgcHViX2J5X3llYXIgPC0gcHViX2RhdGEgJT4lDQogICAgICAgICAgdW5uZXN0KC4sIGNvbHMgPSAiY291bnRzX2J5X3llYXIiLCBuYW1lc19zZXAgPSAiX3llYXJfIikNCiAgICAgICAgDQogICAgICAgICMgd3JpdGUgdGhpcyBvdXQNCiAgICAgICAgIyBpZiBub3QgZW1wdHkNCiAgICAgICAgaWYgKCFhbGwoaXMubmEob2FfcHVicykpKXsNCiAgICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICAgICAjIHdyaXRlIHRvIHRoZSBkYXRhYmFzZQ0KICAgICAgICAgICAgZGJXcml0ZVRhYmxlKGNvbiwgIm9hX3B1YnMiLCBwdWJfYnlfeWVhciwgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCiAgICAgICAgICAgICMgb3RoZXJ3aXNlLCBhcHBlbmQNCiAgICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgICMgY2hlY2sgZmllbGRzIGluIHRoZSBleGlzdGluZyB0YWJsZQ0KICAgICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJvYV9wdWJzIikNCiAgICAgICAgICAgICMgaWYgc29tZSBtaXNzaW5nLCBwYWQgdGhlIGRhdGFzZXQNCiAgICAgICAgICAgIGlmKCFhbGwoZmllbGRzICVpbiUgY29sbmFtZXMocHViX2J5X3llYXIpKSl7DQogICAgICAgICAgICAgIG5fbWlzc2luZyA8LSB3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMocHViX2J5X3llYXIpKQ0KICAgICAgICAgICAgICBwYWRkaW5nIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gbGVuZ3RoKG5fbWlzc2luZyksIG5yb3c9MSkpDQogICAgICAgICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMocHViX2J5X3llYXIpKV0NCiAgICAgICAgICAgICAgcHViX2J5X3llYXIgPC0gYmluZF9jb2xzKHB1Yl9ieV95ZWFyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZykNCiAgICAgICAgICAgICAgcHViX2J5X3llYXIgPC0gcHViX2J5X3llYXJbZmllbGRzXQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgICAgcHViX2J5X3llYXIgPC0gIHB1Yl9ieV95ZWFyICU+JQ0KICAgICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgIm9hX3B1YnMiLCBwdWJfYnlfeWVhciwgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICANCiAgICAgICAgIyB1bm5lc3QgdGhlIGNvbmNlcHRzLCBidXQgYWxzbyBsZWF2ZSBvbmx5IHRob3NlIG9uIGxldmVscyAwIGFuZCAxIGFuZCB3aXRoIHByb2INCiAgICAgICAgIyBhYm92ZSAwLjUNCiAgICAgICAgb2FfY29uY2VwdHMgPC0gb2FfcHVicyAlPiUNCiAgICAgICAgICBzZWxlY3QoaWQsIHByb2ZpbGVfaWQsIGNvbmNlcHRzKSU+JQ0KICAgICAgICAgIHVubmVzdCguLCBjb2xzID0gImNvbmNlcHRzIiwgbmFtZXNfc2VwID0gIl9jb25jXyIpJT4lDQogICAgICAgICAgZmlsdGVyKGNvbmNlcHRzX2NvbmNfbGV2ZWwgJWluJSBjKDAsMSkgJiBjb25jZXB0c19jb25jX3Njb3JlID49IDAuNSkNCiAgICAgICAgDQogICAgICAgICMgd3JpdGUgdGhpcyBvdXQNCiAgICAgICAgIyBpZiBub3QgZW1wdHkNCiAgICAgICAgaWYgKCFhbGwoaXMubmEob2FfY29uY2VwdHMpKSl7DQogICAgICAgICAgaWYgKChpID09IDEpICYgKGogPT0gMSkpew0KICAgICAgICAgICAgIyB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJvYV9jb25jZXB0cyIsIG9hX2NvbmNlcHRzLCByb3cubmFtZXM9RkFMU0UsIGFwcGVuZD1UUlVFKSANCiAgICAgICAgICAgICMgb3RoZXJ3aXNlLCBhcHBlbmQNCiAgICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgICMgY2hlY2sgZmllbGRzIGluIHRoZSBleGlzdGluZyB0YWJsZQ0KICAgICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJvYV9jb25jZXB0cyIpDQogICAgICAgICAgICAjIGlmIHNvbWUgZmllbGRzIG1pc3NpbmcsIHBhZCB0aGUgZGF0YXNldA0KICAgICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyhvYV9jb25jZXB0cykpKXsNCiAgICAgICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhvYV9jb25jZXB0cykpDQogICAgICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICAgICAgY29sbmFtZXMocGFkZGluZykgPC0gZmllbGRzW3doaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhvYV9jb25jZXB0cykpXQ0KICAgICAgICAgICAgICBvYV9jb25jZXB0cyA8LSBiaW5kX2NvbHMob2FfY29uY2VwdHMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgICAgICAgICBvYV9jb25jZXB0cyA8LSBvYV9jb25jZXB0c1tmaWVsZHNdDQogICAgICAgICAgICB9DQogICAgICAgICAgICAjIG9ubHkgbGVhdmUgdGhlc2UgZmllbGRzIGluDQogICAgICAgICAgICBvYV9jb25jZXB0cyA8LSAgb2FfY29uY2VwdHMgJT4lDQogICAgICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiAgICAgICAgICAgIGRiQXBwZW5kVGFibGUoY29uLCAib2FfY29uY2VwdHMiLCBvYV9jb25jZXB0cywgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgDQogICAgICAjIyBnZXQgdGhlIGdyYW50IGluZm8NCiAgICAgIGdyYW50X2luZm8gPC0gcHJvZltbImdyYW50X2luZm8iXV0NCiAgICAgICMgYW5kIHdyaXRlIHRvIHRoZSBkYXRhYmFzZQ0KICAgICAgIyBpZiBub3QgZW1wdHkNCiAgICAgIGlmICghYWxsKGlzLm5hKGdyYW50X2luZm8pKSl7DQogICAgICAgIGlmICgoaSA9PSAxKSAmIChqID09IDEpKXsNCiAgICAgICAgICAjIHdyaXRlIHRvIHRoZSBkYXRhYmFzZQ0KICAgICAgICAgIGRiV3JpdGVUYWJsZShjb24sICJncmFudF9pbmZvIiwgZ3JhbnRfaW5mbywgcm93Lm5hbWVzPUZBTFNFLCBhcHBlbmQ9VFJVRSkNCiAgICAgICAgICAjIG90aGVyd2lzZSwgYXBwZW5kDQogICAgICAgIH1lbHNlew0KICAgICAgICAgICMgY2hlY2sgZmllbGRzIGluIHRoZSBleGlzdGluZyB0YWJsZQ0KICAgICAgICAgIGZpZWxkcyA8LSBkYkxpc3RGaWVsZHMoY29uLCAiZ3JhbnRfaW5mbyIpDQogICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyhncmFudF9pbmZvKSkpew0KICAgICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhncmFudF9pbmZvKSkNCiAgICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMoZ3JhbnRfaW5mbykpXQ0KICAgICAgICAgICAgZ3JhbnRfaW5mbyA8LSBiaW5kX2NvbHMoZ3JhbnRfaW5mbywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKQ0KICAgICAgICAgICAgZ3JhbnRfaW5mbyA8LSBncmFudF9pbmZvW2ZpZWxkc10NCiAgICAgICAgICB9DQogICAgICAgICAgIyBvbmx5IGxlYXZlIHRoZXNlIGZpZWxkcyBpbg0KICAgICAgICAgIGdyYW50X2luZm8gPC0gIGdyYW50X2luZm8gJT4lDQogICAgICAgICAgICBzZWxlY3QoYWxsX29mKGZpZWxkcykpDQogICAgICAgICAgZGJBcHBlbmRUYWJsZShjb24sICJncmFudF9pbmZvIiwgZ3JhbnRfaW5mbywgcm93Lm5hbWVzPU5VTEwsIGFwcGVuZD1UUlVFKQ0KICAgICAgICB9DQogICAgICANCiAgICAgIH0NCiAgICAgIA0KICAgICAgIyMgZ2V0IHRoZSBjb2F1dGhvciBpbmZvDQogICAgICBjb2F1dGhvcl9pbmZvIDwtIHByb2ZbWyJjb2F1dGhvcl9pbmZvIl1dDQogICAgICAjIGFuZCB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICMgaWYgbm90IGVtcHR5DQogICAgICBpZiAoIWFsbChpcy5uYShjb2F1dGhvcl9pbmZvKSkpew0KICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICAgIyB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgICBkYldyaXRlVGFibGUoY29uLCAiY29hdXRob3JfaW5mbyIsIGNvYXV0aG9yX2luZm8sIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpIA0KICAgICAgICAgICMgb3RoZXJ3aXNlLCBhcHBlbmQNCiAgICAgICAgfWVsc2V7DQogICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJjb2F1dGhvcl9pbmZvIikNCiAgICAgICAgICAjIGlmIG5lZWRlZCwgcGFkIHRoZSBkYXRhc2V0DQogICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyhjb2F1dGhvcl9pbmZvKSkpew0KICAgICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhjb2F1dGhvcl9pbmZvKSkNCiAgICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMoY29hdXRob3JfaW5mbykpXQ0KICAgICAgICAgICAgY29hdXRob3JfaW5mbyA8LSBiaW5kX2NvbHMoY29hdXRob3JfaW5mbywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICAgICAgICBjb2F1dGhvcl9pbmZvIDwtIGNvYXV0aG9yX2luZm9bZmllbGRzXQ0KICAgICAgICAgIH0NCiAgICAgICAgICAjIG9ubHkgbGVhdmUgdGhlc2UgZmllbGRzIGluDQogICAgICAgICAgY29hdXRob3JfaW5mbyA8LSAgY29hdXRob3JfaW5mbyAlPiUNCiAgICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiAgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgImNvYXV0aG9yX2luZm8iLCBjb2F1dGhvcl9pbmZvLCByb3cubmFtZXM9TlVMTCwgYXBwZW5kPVRSVUUpIA0KICAgICAgICB9DQogICAgICB9DQogICAgICANCiAgICAgICMjIGdldCB0aGUgYWZmaWxpYXRpb24gaW5mbw0KICAgICAgYWZmaWxpYXRpb25faW5mbyA8LSBwcm9mW1siYWZmaWxpYXRpb25faW5mbyJdXQ0KICAgICAgIyBpZiBub3QgZW1wdHkNCiAgICAgIGlmICghYWxsKGlzLm5hKGFmZmlsaWF0aW9uX2luZm8pKSl7DQogICAgICAgICMgYW5kIHdyaXRlIHRvIHRoZSBkYXRhYmFzZQ0KICAgICAgICBpZiAoKGkgPT0gMSkgJiAoaiA9PSAxKSl7DQogICAgICAgICAgIyB3cml0ZSB0byB0aGUgZGF0YWJhc2UNCiAgICAgICAgICBkYldyaXRlVGFibGUoY29uLCAiYWZmaWxpYXRpb25faW5mbyIsIGFmZmlsaWF0aW9uX2luZm8sIHJvdy5uYW1lcz1GQUxTRSwgYXBwZW5kPVRSVUUpIA0KICAgICAgICAgICMgb3RoZXJ3aXNlLCBhcHBlbmQNCiAgICAgICAgfWVsc2V7DQogICAgICAgICAgIyBjaGVjayBmaWVsZHMgaW4gdGhlIGV4aXN0aW5nIHRhYmxlDQogICAgICAgICAgZmllbGRzIDwtIGRiTGlzdEZpZWxkcyhjb24sICJhZmZpbGlhdGlvbl9pbmZvIikNCiAgICAgICAgICAjIGlmIG5lZWRlZCwgcGFkIHRoZSBkYXRhc2V0DQogICAgICAgICAgaWYoIWFsbChmaWVsZHMgJWluJSBjb2xuYW1lcyhhZmZpbGlhdGlvbl9pbmZvKSkpew0KICAgICAgICAgICAgbl9taXNzaW5nIDwtIHdoaWNoKCFmaWVsZHMgJWluJSBjb2xuYW1lcyhhZmZpbGlhdGlvbl9pbmZvKSkNCiAgICAgICAgICAgIHBhZGRpbmcgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSBsZW5ndGgobl9taXNzaW5nKSwgbnJvdz0xKSkNCiAgICAgICAgICAgIGNvbG5hbWVzKHBhZGRpbmcpIDwtIGZpZWxkc1t3aGljaCghZmllbGRzICVpbiUgY29sbmFtZXMoYWZmaWxpYXRpb25faW5mbykpXQ0KICAgICAgICAgICAgYWZmaWxpYXRpb25faW5mbyA8LSBiaW5kX2NvbHMoYWZmaWxpYXRpb25faW5mbywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcpDQogICAgICAgICAgICBhZmZpbGlhdGlvbl9pbmZvIDwtIGFmZmlsaWF0aW9uX2luZm9bZmllbGRzXQ0KICAgICAgICAgIH0NCiAgICAgICAgICANCiAgICAgICAgICAjIG9ubHkgbGVhdmUgdGhlc2UgZmllbGRzIGluDQogICAgICAgICAgYWZmaWxpYXRpb25faW5mbyA8LSAgYWZmaWxpYXRpb25faW5mbyAlPiUNCiAgICAgICAgICAgIHNlbGVjdChhbGxfb2YoZmllbGRzKSkNCiAgICAgICAgICBkYkFwcGVuZFRhYmxlKGNvbiwgImFmZmlsaWF0aW9uX2luZm8iLCBhZmZpbGlhdGlvbl9pbmZvLCByb3cubmFtZXM9TlVMTCwgYXBwZW5kPVRSVUUpICANCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0NCiAgICANCiAgICBwcmludChwYXN0ZSgiZG9uZSB3aXRoIiwgaiwgIm91dCBvZiIsIGxlbmd0aChwcm9mX2JhdGNoKSkpDQogICAgDQogIH0NCn0NCmBgYA0KDQoNCg0KDQojIERhdGEgaW5zaWdodHMNCg0KQ2hlY2sgdGhlIG92ZXJsYXBzIGJldHdlZW4gTkFSQ0lTIGFuZCBPQSBkYXRhIGZvciBwcm9mcyBpbiBlYWNoIGJhdGNoLg0KQWxzbywgZXh0cmFjdCB0aGUgSURzIG9mIHByb2Zlc3NvcnMgZm9yIHdob20gd2UgZGlkIG5vdCBjb2xsZWN0IGFueSBkYXRhOg0KYGBge3IsIGV2YWwgPSBGfQ0KIyBxdWVyeSBpbiBiYXRjaGVzDQpuYXJjaXNfaWRzIDwtIHByb2ZzX2Z1bGwkcHJvZmlsZV9pZA0KIyBiYXRjaCBzaXplDQpwcm9mX2JhdGNoX3NpemUgPC0gNTAwDQojIHZlY3RvciBvZiBpbmRpY2VzIHRvIGxvb3AgdGhyb3VnaA0KYmF0Y2hlcyA8LSBzZXEoZnJvbT0xLCB0bz1sZW5ndGgobmFyY2lzX2lkcyksIGJ5PXByb2ZfYmF0Y2hfc2l6ZSkNCiMgdG8gYmUgYWJsZSB0byBzdWJzZXQsIGFsc28gYWRkIHRoZSBmaW5hbCBpbmRleCsxDQpiYXRjaGVzIDwtIGMoYmF0Y2hlcywgbGVuZ3RoKG5hcmNpc19pZHMpKzEpDQoNCiMgbGlzdCBvZiBwcm9mcyB3L28gaW5mbw0KcHJvZmVzc29yX2NvdmVyYWdlIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNSwgbnJvdyA9IDApKQ0KDQojIGxvb3AgdGhyb3VnaCB0aGUgYmF0Y2hlcw0KZm9yKGkgaW4gMToobGVuZ3RoKGJhdGNoZXMpLTEpKXsNCiAgIyByZWFkIGluIHRoZSBmaXJzdCBiYXRjaA0KICBwcm9mX2JhdGNoIDwtIHJlYWRSRFMocGFzdGUwKCJwcm9jZXNzZWRfZGF0YS9vcGVuX2FsZXhfcHJvZl9kYXRhLyIsIHBhc3RlKCJwcm9mX2RhdGFfYmF0Y2giLCBpLCBzZXAgPSAiXyIpLCAiLlJEUyIpKQ0KICANCiAgIyBsb29wIHRocm91Z2ggcHJvZnMgaW4gdGhlIGxpc3QNCiAgZm9yIChqIGluIDE6bGVuZ3RoKHByb2ZfYmF0Y2gpKXsNCiAgICBwcm9mIDwtIHByb2ZfYmF0Y2hbW2pdXQ0KICAgICMgaWYgdGhlcmUgaXMgc29tZSBpbmZvIG9uIHRoZSBwcm9mDQogICAgaWYgKGxlbmd0aChwcm9mKSA+IDEgKXsNCiAgICAgIG5hcmNpc19wdWJzIDwtIHByb2ZbWyJuYXJjaXNfcHVicyJdXQ0KICAgICAgb2FfcHVicyA8LSBwcm9mW1sib2FfcHVicyJdXQ0KICAgICAgaWYgKCghaXMubnVsbChucm93KHByb2ZbWyJvYV9wdWJzIl1dKSkmIWlzLm51bGwobnJvdyhwcm9mW1sibmFyY2lzX3B1YnMiXV0pKSkpew0KICAgICAgICAjIHJlbW92ZSB0aGUgaHRtbCBwYXJ0cyBvZiB0aGUgZG9pIGZyb20gYm90aA0KICAgICAgICBuYXJjaXNfcHVicyRkb2lfbWF0Y2ggPC0gc3RyX3JlbW92ZShuYXJjaXNfcHVicyRET0ksICJodHRwczovL2RvaS5vcmcvIikNCiAgICAgICAgb2FfcHVicyRkb2lfbWF0Y2ggPC0gc3RyX3JlbW92ZShvYV9wdWJzJGRvaSwgImh0dHBzOi8vZG9pLm9yZy8iKQ0KICAgICAgICANCiAgICAgICAgIyBjbGVhbiB0aGUgdGl0bGVzIG9mIGJvdGgNCiAgICAgICAgbmFyY2lzX3B1YnMkdGl0bGVfbWF0Y2ggPC0gc3RyX3NxdWlzaCh0b2xvd2VyKHN0cl9yZW1vdmVfYWxsKG5hcmNpc19wdWJzJFRpdGxlLCAiW15bOmFsbnVtOl0gXSIpKSkNCiAgICAgICAgb2FfcHVicyR0aXRsZV9tYXRjaCA8LSBzdHJfc3F1aXNoKHRvbG93ZXIoc3RyX3JlbW92ZV9hbGwob2FfcHVicyRkaXNwbGF5X25hbWUsICJbXls6YWxudW06XSBdIikpKQ0KICAgICAgICANCiAgICAgICAgIyBmaW5kIHdoaWNoIE5BUkNJUyBwdWJzIGFsc28gaW4gT0EgYW5kIHZpY2UgdmVyc2ENCiAgICAgICAgbmFyY2lzX3B1YnMkaW5fb2EgPC0gaWZlbHNlKG5hcmNpc19wdWJzJGRvaV9tYXRjaCAlaW4lIG9hX3B1YnMkZG9pX21hdGNofG5hcmNpc19wdWJzJHRpdGxlX21hdGNoICVpbiUgb2FfcHVicyR0aXRsZV9tYXRjaCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRSVUUsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGQUxTRSkNCiAgICAgICAgDQogICAgICAgIG9hX3B1YnMkaW5fbmFyY2lzIDwtIGlmZWxzZShvYV9wdWJzJGRvaV9tYXRjaCAlaW4lIG5hcmNpc19wdWJzJGRvaV9tYXRjaHwgb2FfcHVicyR0aXRsZV9tYXRjaCAlaW4lIG5hcmNpc19wdWJzJHRpdGxlX21hdGNoLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVFJVRSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZBTFNFKQ0KICAgICAgICANCiAgICAgICAgIyBhcHBlbmQgdGhlIHByb2Zlc3NvciBJRCBhbmQgdGhlIGNvdmVyYWdlIG92ZXJsYXAgaW50byBhIGRhdGFmcmFtZQ0KICAgICAgICBwcm9maWxlX2lkIDwtIHByb2ZbWydwcm9maWxlX2lkJ11dDQogICAgICAgIG5hcmNpc192c19vYSA8LSByb3VuZChwcm9wLnRhYmxlKHRhYmxlKG5hcmNpc19wdWJzJGluX29hKSlbJ1RSVUUnXSwgMikNCiAgICAgICAgb2FfdnNfbmFyY2lzIDwtIHJvdW5kKHByb3AudGFibGUodGFibGUob2FfcHVicyRpbl9uYXJjaXMpKVsnVFJVRSddLCAyKQ0KICAgICAgICBuYXJjaXNfcHVicyA8LSBOQQ0KICAgICAgICBvYV9wdWJzIDwtIE5BDQogICAgICAgIGlmICghaXMubnVsbChucm93KHByb2ZbWyJvYV9wdWJzIl1dKSkpew0KICAgICAgICAgIG9hX3B1YnMgPC0gbnJvdyhwcm9mW1sib2FfcHVicyJdXSkNCiAgICAgICAgfQ0KICAgICAgICBpZiAoIWlzLm51bGwobnJvdyhwcm9mW1sibmFyY2lzX3B1YnMiXV0pKSl7DQogICAgICAgICAgbmFyY2lzX3B1YnMgPC0gbnJvdyhwcm9mW1sibmFyY2lzX3B1YnMiXV0pDQogICAgICAgIH0NCiAgICAgICAgDQogICAgICAgIHJvdyA8LSBjYmluZChwcm9maWxlX2lkLCANCiAgICAgICAgICAgICAgICAgICAgIG5hcmNpc19wdWJzLA0KICAgICAgICAgICAgICAgICAgICAgb2FfcHVicywNCiAgICAgICAgICAgICAgICAgICAgIG5hcmNpc192c19vYSwNCiAgICAgICAgICAgICAgICAgICAgIG9hX3ZzX25hcmNpcykNCiAgICAgIH1lbHNlew0KICAgICAgICBwcm9maWxlX2lkIDwtIHByb2ZbWydwcm9maWxlX2lkJ11dDQogICAgICAgIG5hcmNpc19wdWJzIDwtIE5BDQogICAgICAgIG9hX3B1YnMgPC0gTkENCiAgICAgICAgaWYgKCFpcy5udWxsKG5yb3cocHJvZltbIm9hX3B1YnMiXV0pKSl7DQogICAgICAgICAgb2FfcHVicyA8LSBucm93KHByb2ZbWyJvYV9wdWJzIl1dKQ0KICAgICAgICB9DQogICAgICAgIGlmICghaXMubnVsbChucm93KHByb2ZbWyJuYXJjaXNfcHVicyJdXSkpKXsNCiAgICAgICAgICBuYXJjaXNfcHVicyA8LSBucm93KHByb2ZbWyJuYXJjaXNfcHVicyJdXSkNCiAgICAgICAgfQ0KICAgICAgICBuYXJjaXNfdnNfb2EgPC0gTkENCiAgICAgICAgb2FfdnNfbmFyY2lzIDwtIE5BDQogICAgICAgIHJvdyA8LSBjYmluZChwcm9maWxlX2lkLCANCiAgICAgICAgICAgICAgICAgICAgIG5hcmNpc19wdWJzLA0KICAgICAgICAgICAgICAgICAgICAgb2FfcHVicywNCiAgICAgICAgICAgICAgICAgICAgIG5hcmNpc192c19vYSwNCiAgICAgICAgICAgICAgICAgICAgIG9hX3ZzX25hcmNpcykgDQogICAgICB9DQogICAgfSBlbHNlew0KICAgICAgcHJvZmlsZV9pZCA8LSBuYW1lcyhwcm9mX2JhdGNoKVtqXQ0KICAgICAgbmFyY2lzX3B1YnMgPC0gTkENCiAgICAgIG9hX3B1YnMgPC0gTkENCiAgICAgIG5hcmNpc192c19vYSA8LSBOQQ0KICAgICAgb2FfdnNfbmFyY2lzIDwtIE5BDQogICAgICAgIHJvdyA8LSBjYmluZChwcm9maWxlX2lkLCANCiAgICAgICAgICAgICAgICAgICAgIG5hcmNpc19wdWJzLA0KICAgICAgICAgICAgICAgICAgICAgb2FfcHVicywNCiAgICAgICAgICAgICAgICAgICAgIG5hcmNpc192c19vYSwNCiAgICAgICAgICAgICAgICAgICAgIG9hX3ZzX25hcmNpcykNCiAgICB9DQogICAgcHJvZmVzc29yX2NvdmVyYWdlIDwtIHJiaW5kKHByb2Zlc3Nvcl9jb3ZlcmFnZSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93KQ0KICB9DQogIHByaW50KHBhc3RlKCJkb25lIHdpdGggYmF0Y2giLCBpKSkNCn0NCg0KcHJvZmVzc29yX2NvdmVyYWdlIDwtIGZpbHRlcihwcm9mZXNzb3JfY292ZXJhZ2UsICFpcy5uYShwcm9maWxlX2lkKSkNCmBgYA0KDQpXcml0ZSB0aGlzIG91dDoNCmBgYHtyfQ0Kc2F2ZVJEUyhwcm9mZXNzb3JfY292ZXJhZ2UsICJwcm9jZXNzZWRfZGF0YS9wcm9mZXNzb3JfY292ZXJhZ2UuUkRTIikNCmBgYA0KDQpgYGB7ciBlY2hvID0gRiwgZXZhbCA9IFR9DQpwcm9mZXNzb3JfY292ZXJhZ2UgPC0gcmVhZFJEUygicHJvY2Vzc2VkX2RhdGEvcHJvZmVzc29yX2NvdmVyYWdlLlJEUyIpDQpgYGANCg0KDQpgYGB7ciBldmFsID0gVH0NCnByb2Zlc3Nvcl9jb3ZlcmFnZSRuYXJjaXNfdnNfb2EgPC0gYXMubnVtZXJpYyhwcm9mZXNzb3JfY292ZXJhZ2UkbmFyY2lzX3ZzX29hKQ0KcHJvZmVzc29yX2NvdmVyYWdlJG9hX3ZzX25hcmNpcyA8LSBhcy5udW1lcmljKHByb2Zlc3Nvcl9jb3ZlcmFnZSRvYV92c19uYXJjaXMpDQoNCnByb2Zlc3Nvcl9jb3ZlcmFnZSAlPiUgDQogIGZpbHRlciguLCAhaXMubmEobmFyY2lzX3ZzX29hKSklPiUgDQogIHN1bW1hcmlzZShuYXJjaXNfdnNfb2EgPSBtZWFuKG5hcmNpc192c19vYSksDQogICAgICAgICAgICBvYV92c19uYXJjaXMgPSBtZWFuKG9hX3ZzX25hcmNpcykpDQpgYGANClNvLCA5NCUgb2YgdGhlIE5hcmNpcyBwdWJsaWNhdGlvbnMgYXJlIGluIG91ciBPQSBkYXRhLg0KQW5kIDUzJSBvZiB0aGUgT0EgcHVibGljYXRpb25zIGFyZSBpbiBvdXIgTkFSQ0lTIGRhdGEuDQoNCg0KRmluYWxseSwgd2Ugb25seSBtaXNzIHB1YmxpY2F0aW9uIGRhdGEgZm9yIDAuMjUlIG9mIHRoZSBwcm9mZXNzb3JzICgxNykuDQpgYGB7ciBldmFsID0gVH0NCmxlbmd0aCh3aGljaChpcy5uYShwcm9mZXNzb3JfY292ZXJhZ2UkbmFyY2lzX3B1YnMpKSkNCmxlbmd0aCh3aGljaChpcy5uYShwcm9mZXNzb3JfY292ZXJhZ2UkbmFyY2lzX3B1YnMpKSkvbnJvdyhwcm9mZXNzb3JfY292ZXJhZ2UpKjEwMA0KDQoNCmxlbmd0aCh3aGljaChpcy5uYShwcm9mZXNzb3JfY292ZXJhZ2Ukb2FfcHVicykpKQ0KbGVuZ3RoKHdoaWNoKGlzLm5hKHByb2Zlc3Nvcl9jb3ZlcmFnZSRvYV9wdWJzKSkpL25yb3cocHJvZmVzc29yX2NvdmVyYWdlKSoxMDANCmBgYA0K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("OpenAlex_Altmetric_data_download.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
