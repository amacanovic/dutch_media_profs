<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ana Macanovic" />

<meta name="date" content="2024-03-19" />

<title>Visualisations_interdisciplinary</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a>
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="index.html">Code homepage</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="glyphicon glyphicon glyphicon glyphicon-list"></span>
     
    Scripts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="SQL_tutorial.html">Intro: SQL tutorial</a>
    </li>
    <li>
      <a href="OpenAlex_Altmetric_data_download.html">1. Open Alex and Altmetric data download</a>
    </li>
    <li>
      <a href="Gender_inference.html">2. Gender inference</a>
    </li>
    <li>
      <a href="Grant_parsing.html">3. Grant parsing</a>
    </li>
    <li>
      <a href="Lexis_nexis_parser.html">4. Lexis data parser</a>
    </li>
    <li>
      <a href="Mention_url_extraction.html">5. Mention URL extraction</a>
    </li>
    <li>
      <a href="Data_descriptives.html">5. Database description and coverage</a>
    </li>
    <li>
      <a href="Panel_data_compilation.html">6. Panel data compilation</a>
    </li>
    <li>
      <a href="exploring_fame.html">7. Share of women in fame plots</a>
    </li>
    <li>
      <a href="Various_plots.html">8. Data plots</a>
    </li>
    <li>
      <a href="Various_regressions.html">9. Regression models</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/amacanovic/dutch_media_profs">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Visualisations_interdisciplinary</h1>
<h4 class="author">Ana Macanovic</h4>
<h4 class="date">2024-03-19</h4>

</div>


<p>Testing some visualisations for an interdisciplinary journal
approach.</p>
<pre class="r"><code>options(width = 120)</code></pre>
<p>Load the packages:</p>
<pre class="r"><code>library(groundhog)
packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;tidyr&quot;, 
                      &quot;tidyverse&quot;, &quot;RPostgres&quot;, &quot;lubridate&quot;, &quot;psych&quot;,
                      &quot;gridExtra&quot;,&quot;ggplot2&quot;, &quot;scales&quot;,
                      &quot;panelr&quot;, &quot;skimr&quot;, &quot;cowplot&quot;, &quot;rstatix&quot;,
                      &quot;lmtest&quot;, &quot;sandwich&quot;, &quot;poweRlaw&quot;)
groundhog.library(packages_to_load, date = &quot;2023-12-01&quot;)</code></pre>
<pre class="r"><code>port &lt;- 5432
user &lt;- &quot;postgres&quot;
password &lt;- &quot;dutchmediaprofssql&quot;
database_name &lt;- &quot;postgres&quot;

con &lt;- RPostgres::dbConnect(RPostgres::Postgres(),
                 dbname= database_name,
                 port = port,
                 user = user, 
                 password = password)</code></pre>
<div id="panel-based" class="section level1" number="1">
<h1><span class="header-section-number">1</span> PANEL BASED</h1>
<p>Loading the data:</p>
<pre class="r"><code>prof_panel &lt;- read_csv(&quot;panel_datasets/prof_year_p_c_g_a_t_l_l_20_3.csv&quot;)
prof_panel_coa &lt;- read_csv(&quot;panel_datasets/prof_panel_combined_no_lexis_19_3.csv&quot;)

# combine the two, since the latter mixes nexis data
lexis_data &lt;- prof_panel %&gt;%
  select(profile_id, year, contains(&quot;lexis&quot;))

prof_panel_coa &lt;- merge(prof_panel_coa,
                        lexis_data,
                        by= c(&quot;profile_id&quot;, &quot;year&quot;))

# recode the fields
prof_panel_coa &lt;- prof_panel_coa %&gt;% 
  mutate(general_field = case_match(
    overall_field,
    &quot;Arts and Humanities&quot;  ~ &quot;Arts &amp; Humanities&quot;,
    c(&quot;Biochemistry, Genetics and Molecular Biology&quot;,&quot;Agricultural and Biological Sciences&quot;,
      &quot;Chemical Engineering&quot;, &quot;Chemistry&quot;,  &quot;Computer Science&quot;, &quot;Decision Sciences&quot;,
      &quot;Earth and Planetary Sciences&quot;, &quot;Energy&quot;, &quot;Engineering&quot;, &quot;Environmental Science&quot;,
      &quot;Immunology and Microbiology&quot;, &quot;Materials Science&quot;, &quot;Mathematics&quot;, &quot;Neuroscience&quot;, 
      &quot;Physics and Astronomy&quot; ) ~ &quot;STEM&quot;,
    c(&quot;Dentistry&quot;, &quot;Health Professions&quot;, &quot;Medicine&quot;) ~ &quot;Medicine&quot;,
    c(&quot;Business, Management and Accounting&quot;, &quot;Economics, Econometrics and Finance&quot;,
      &quot;Psychology&quot;, &quot;Social Sciences&quot;) ~ &quot;Social sciences&quot;))</code></pre>
<p>Select relevant columns and tidy everything up, getting the latest
observations for each professor; and then also pooling them into N years
since first pub:</p>
<pre class="r"><code>prof_panel_sel &lt;- prof_panel_coa %&gt;%
  # but not 2024
  filter(year &lt; 2024 &amp; !is.na(year))%&gt;%
  group_by(profile_id)%&gt;%
  slice(which.max(year))%&gt;%
  select(-contains(&quot;_l&quot;))%&gt;%
  select(profile_id:years_since_first_pub, overall_field:overall_subfield, count_pubs:attn_twitter_by_total, lexis_national:lexis_all_total)

# tidy up mentions
prof_panel_sel$online_news_total &lt;- prof_panel_sel$attn_news_by_total + prof_panel_sel$attn_blogs_by_total
prof_panel_sel$twitter_total &lt;- prof_panel_sel$attn_twitter_by_total
prof_panel_sel$news_total &lt;- prof_panel_sel$lexis_all_total

prof_panel_sel$citations_total &lt;- prof_panel_sel$cited_by_total_all
prof_panel_sel$pubs_total &lt;- prof_panel_sel$count_pubs_total

# recode the fields
prof_panel_sel &lt;- prof_panel_sel %&gt;% 
  mutate(general_field = case_match(
    overall_field,
    &quot;Arts and Humanities&quot;  ~ &quot;Arts &amp; Humanities&quot;,
    c(&quot;Biochemistry, Genetics and Molecular Biology&quot;,&quot;Agricultural and Biological Sciences&quot;,
      &quot;Chemical Engineering&quot;, &quot;Chemistry&quot;,  &quot;Computer Science&quot;, &quot;Decision Sciences&quot;,
      &quot;Earth and Planetary Sciences&quot;, &quot;Energy&quot;, &quot;Engineering&quot;, &quot;Environmental Science&quot;,
      &quot;Immunology and Microbiology&quot;, &quot;Materials Science&quot;, &quot;Mathematics&quot;, &quot;Neuroscience&quot;, 
      &quot;Physics and Astronomy&quot; ) ~ &quot;STEM&quot;,
    c(&quot;Dentistry&quot;, &quot;Health Professions&quot;, &quot;Medicine&quot;) ~ &quot;Medicine&quot;,
    c(&quot;Business, Management and Accounting&quot;, &quot;Economics, Econometrics and Finance&quot;,
      &quot;Psychology&quot;, &quot;Social Sciences&quot;) ~ &quot;Social sciences&quot;))

# get groups per years since entry
prof_panel_sel$entry_batch &lt;- cut(prof_panel_sel$years_since_first_pub, breaks = seq(0, 50, by=10))
prof_panel_sel$years_since_entry &lt;- paste(&quot;up to&quot;, str_remove(str_split_i(as.character(prof_panel_sel$entry_batch), &quot;,&quot;, 2),&quot;]&quot;))</code></pre>
<p>And now leave only those professors for whom we actually have lexis
data:</p>
<pre class="r"><code># ones we collected
lexis_list &lt;- as.data.frame(str_remove(list.files(path = &quot;../lexis_crawl/downloads/zipfiles&quot;,
                                                               pattern=&quot;*.zip&quot;, 
                                                               full.names = F), &quot;.zip&quot;))
colnames(lexis_list) &lt;- &quot;profile_id&quot;
# minus ones that are incomplete
missing_indices &lt;- read_csv(&quot;../lexis_crawl/missing_indices.csv&quot;)

lexis_list &lt;- filter(lexis_list, ! profile_id %in% missing_indices$profile_id)

prof_panel_filter &lt;- filter(prof_panel_sel,
                            str_remove(profile_id, &quot;https://www.narcis.nl/person/RecordID/&quot;) %in% lexis_list$profile_id)

# once again, select relevant fields for convenience
prof_panel_filter &lt;- prof_panel_filter %&gt;%
  select(profile_id:overall_field, online_news_total:years_since_entry)

prof_panel_filter_plot &lt;- prof_panel_filter %&gt;%
  pivot_longer(online_news_total:pubs_total, names_to = &quot;measure&quot;, values_to = &quot;n&quot;) </code></pre>
<div id="means-comparison" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Means comparison</h2>
<div id="overall" class="section level3" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> Overall</h3>
<pre class="r"><code>overall_comparisons &lt;- data.frame(matrix(NA, ncol = 6, nrow = 1))
i &lt;- 1
overall_comparisons[i, 1] &lt;- &quot;overall&quot;
overall_comparisons[i, 2] &lt;- round(wilcox.test(pubs_total ~ inferred_gender, data=prof_panel_filter, paired=FALSE)$p.value, 5)
overall_comparisons[i, 3] &lt;- round(wilcox.test(citations_total ~ inferred_gender, data=prof_panel_filter, paired=FALSE)$p.value, 5)
overall_comparisons[i, 4] &lt;- round(wilcox.test(news_total ~ inferred_gender, data=prof_panel_filter, paired=FALSE)$p.value, 5)
overall_comparisons[i, 5] &lt;- round(wilcox.test(online_news_total ~ inferred_gender, data=prof_panel_filter, paired=FALSE)$p.value, 5)
overall_comparisons[i, 6] &lt;- round(wilcox.test(twitter_total ~ inferred_gender, data=prof_panel_filter, paired=FALSE)$p.value, 5)

colnames(overall_comparisons) &lt;- c(&quot;field&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)


overall_comparisons</code></pre>
<pre><code>##     field pubs_total citations_total news_total online_news_total twitter_total
## 1 overall          0               0          0            0.4848       0.83489</code></pre>
</div>
<div id="within-fields" class="section level3" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> Within fields</h3>
<pre class="r"><code>fields &lt;- unique(prof_panel_filter$general_field)
fields &lt;- fields[!is.na(fields)]
field_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(fields)))

for (i in 1:length(fields)){
  field &lt;- fields[i]
  data &lt;- filter(prof_panel_filter, 
                 general_field == field)
  field_comparisons[i, 1] &lt;- field
  field_comparisons[i, 2] &lt;- nrow(data)
  field_comparisons[i, 3] &lt;- round(wilcox.test(pubs_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 4] &lt;- round(wilcox.test(citations_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 5] &lt;- round(wilcox.test(news_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 6] &lt;- round(wilcox.test(online_news_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 7] &lt;- round(wilcox.test(twitter_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
}

colnames(field_comparisons) &lt;- c(&quot;field&quot;,&quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
field_comparisons</code></pre>
<pre><code>##               field profs pubs_total citations_total news_total online_news_total twitter_total
## 1              STEM  1509    0.00000         0.00950    0.00000           0.06138       0.87128
## 2   Social sciences  1662    0.00008         0.10965    0.00001           0.00102       0.20872
## 3 Arts &amp; Humanities   236    0.88367         0.19316    0.37921           0.24937       0.12828
## 4          Medicine  1140    0.00000         0.00000    0.21203           0.05471       0.23977</code></pre>
</div>
<div id="within-year-groups" class="section level3" number="1.1.3">
<h3><span class="header-section-number">1.1.3</span> Within year
groups</h3>
<pre class="r"><code>year_groups &lt;- unique(prof_panel_filter$years_since_entry)
year_groups &lt;- year_groups[! year_groups == &quot;up to NA&quot;]
years &lt;- c(&quot;up to 10&quot;,&quot;up to 20&quot;, &quot;up to 30&quot;, &quot;up to 40&quot;, &quot;up to 50&quot;)
year_groups &lt;- year_groups[order(match(year_groups,years))]
year_groups_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(year_groups)))

for (i in 1:length(year_groups)){
  year_group &lt;- year_groups[i]
  data &lt;- filter(prof_panel_filter, 
                 years_since_entry == year_group)
  
  year_groups_comparisons[i, 1] &lt;- year_group
  year_groups_comparisons[i, 2] &lt;- nrow(data)
  year_groups_comparisons[i, 3] &lt;- round(wilcox.test(pubs_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 4] &lt;- round(wilcox.test(citations_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 5] &lt;- round(wilcox.test(news_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 6] &lt;- round(wilcox.test(online_news_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  year_groups_comparisons[i, 7] &lt;- round(wilcox.test(twitter_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
}

colnames(year_groups_comparisons) &lt;- c(&quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
year_groups_comparisons</code></pre>
<pre><code>##      field profs pubs_total citations_total news_total online_news_total twitter_total
## 1 up to 10    50    0.81488         0.82567    0.60042           0.56610       0.22022
## 2 up to 20   350    0.49527         0.57000    0.20087           0.28821       0.20877
## 3 up to 30  1626    0.00145         0.01648    0.07753           0.03531       0.35962
## 4 up to 40  1924    0.00000         0.00187    0.00096           0.25420       0.53708
## 5 up to 50   580    0.00024         0.00379    0.98569           0.92722       0.98554</code></pre>
</div>
</div>
<div id="distributions-comparison" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Distributions
comparison</h2>
<div id="overall-1" class="section level3" number="1.2.1">
<h3><span class="header-section-number">1.2.1</span> Overall</h3>
<pre class="r"><code>overall_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = 1))
i &lt;- 1
women &lt;- filter(prof_panel_filter, inferred_gender == &quot;w&quot;)
men &lt;- filter(prof_panel_filter, inferred_gender == &quot;m&quot;)

overall_dist_comparisons[i, 1] &lt;- &quot;overall&quot;
overall_dist_comparisons[i, 2] &lt;- nrow(prof_panel_filter)
overall_dist_comparisons[i, 3] &lt;- round(ks.test(women$pubs_total, men$pubs_total)$p.value, 5)
overall_dist_comparisons[i, 4] &lt;- round(ks.test(women$citations_total, men$citations_total)$p.value, 5)
overall_dist_comparisons[i, 5] &lt;- round(ks.test(women$news_total, men$news_total)$p.value, 5)
overall_dist_comparisons[i, 6] &lt;- round(ks.test(women$online_news_total, men$online_news_total)$p.value, 5)
overall_dist_comparisons[i, 7] &lt;- round(ks.test(women$twitter_total, men$twitter_total)$p.value, 5)

colnames(overall_dist_comparisons) &lt;- c(&quot;overall&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)


overall_dist_comparisons</code></pre>
<pre><code>##   overall profs pubs_total citations_total news_total online_news_total twitter_total
## 1 overall  4549          0               0      1e-05           0.24017       0.58063</code></pre>
</div>
<div id="within-fields-1" class="section level3" number="1.2.2">
<h3><span class="header-section-number">1.2.2</span> Within fields</h3>
<pre class="r"><code>fields &lt;- unique(prof_panel_filter$general_field)
fields &lt;- fields[!is.na(fields)]
field_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(fields)))

for (i in 1:length(fields)){
  field &lt;- fields[i]
  data &lt;- filter(prof_panel_filter, 
                 general_field == field)
  women &lt;- filter(data, inferred_gender == &quot;w&quot;)
  men &lt;- filter(data, inferred_gender == &quot;m&quot;)
  
  field_dist_comparisons[i, 1] &lt;- field
  field_dist_comparisons[i, 2] &lt;- nrow(data)
  field_dist_comparisons[i, 3] &lt;- round(ks.test(women$pubs_total, men$pubs_total)$p.value, 5)
  field_dist_comparisons[i, 4] &lt;- round(ks.test(women$citations_total, men$citations_total)$p.value, 5)
  field_dist_comparisons[i, 5] &lt;- round(ks.test(women$news_total, men$news_total)$p.value, 5)
  field_dist_comparisons[i, 6] &lt;- round(ks.test(women$online_news_total, men$online_news_total)$p.value, 5)
  field_dist_comparisons[i, 7] &lt;- round(ks.test(women$twitter_total, men$twitter_total)$p.value, 5)
}

colnames(field_dist_comparisons) &lt;- c(&quot;field&quot;,&quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
field_dist_comparisons</code></pre>
<pre><code>##               field profs pubs_total citations_total news_total online_news_total twitter_total
## 1              STEM  1509    0.00000         0.00480    0.00000           0.03455       0.78429
## 2   Social sciences  1662    0.00000         0.10569    0.00003           0.00629       0.23937
## 3 Arts &amp; Humanities   236    0.93623         0.07077    0.35506           0.85952       0.45567
## 4          Medicine  1140    0.00001         0.00001    0.10994           0.04047       0.09037</code></pre>
</div>
<div id="within-year-groups-1" class="section level3" number="1.2.3">
<h3><span class="header-section-number">1.2.3</span> Within year
groups</h3>
<pre class="r"><code>year_groups &lt;- unique(prof_panel_filter$years_since_entry)
year_groups &lt;- year_groups[! year_groups == &quot;up to NA&quot;]
years &lt;- c(&quot;up to 10&quot;,&quot;up to 20&quot;, &quot;up to 30&quot;, &quot;up to 40&quot;, &quot;up to 50&quot;)
year_groups &lt;- year_groups[order(match(year_groups,years))]
year_groups_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(year_groups)))

for (i in 1:length(year_groups)){
  year_group &lt;- year_groups[i]
  data &lt;- filter(prof_panel_filter, 
                 years_since_entry == year_group)
  
  women &lt;- filter(data, inferred_gender == &quot;w&quot;)
  men &lt;- filter(data, inferred_gender == &quot;m&quot;)
  
  year_groups_dist_comparisons[i, 1] &lt;- year_group
  year_groups_dist_comparisons[i, 2] &lt;- nrow(data)
  year_groups_dist_comparisons[i, 3] &lt;- round(ks.test(women$pubs_total, men$pubs_total)$p.value, 5)
  year_groups_dist_comparisons[i, 4] &lt;- round(ks.test(women$citations_total, men$citations_total)$p.value, 5)
  year_groups_dist_comparisons[i, 5] &lt;- round(ks.test(women$news_total, men$news_total)$p.value, 5)
  year_groups_dist_comparisons[i, 6] &lt;- round(ks.test(women$online_news_total, men$online_news_total)$p.value, 5)
  year_groups_dist_comparisons[i, 7] &lt;- round(ks.test(women$twitter_total, men$twitter_total)$p.value, 5)
}

colnames(year_groups_dist_comparisons) &lt;- c(&quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
year_groups_dist_comparisons</code></pre>
<pre><code>##      field profs pubs_total citations_total news_total online_news_total twitter_total
## 1 up to 10    50    0.89753         0.75928    0.86712           0.72628       0.34175
## 2 up to 20   350    0.07748         0.43032    0.51082           0.27836       0.62906
## 3 up to 30  1626    0.00039         0.04232    0.03112           0.01137       0.33798
## 4 up to 40  1924    0.00004         0.01270    0.00061           0.18374       0.94458
## 5 up to 50   580    0.00086         0.01060    0.91078           0.96744       1.00000</code></pre>
</div>
<div id="within-year-groups-and-fields" class="section level3"
number="1.2.4">
<h3><span class="header-section-number">1.2.4</span> Within year groups
and fields</h3>
<pre class="r"><code>year_groups_field_dist_comparisons &lt;- data.frame(matrix(NA, ncol = 8, nrow = length(year_groups)*length(fields)))
row_index &lt;- 0

for (i in 1:length(year_groups)){
  year_group &lt;- year_groups[i]
  
  for (j in 1:length(fields)){
    field &lt;- fields[j]
    data &lt;- filter(prof_panel_filter, 
                   years_since_entry == year_group &amp; general_field == field)
    
    women &lt;- filter(data, inferred_gender == &quot;w&quot;)
    men &lt;- filter(data, inferred_gender == &quot;m&quot;)
    
    if (length(unique(data$inferred_gender)) != 2){
      year_groups_field_dist_comparisons[row_index+j, 1] &lt;- year_group
      year_groups_field_dist_comparisons[row_index+j, 2] &lt;- field
      year_groups_field_dist_comparisons[row_index+j, 3] &lt;- nrow(data)
      year_groups_field_dist_comparisons[row_index+j, 4] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 5] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 6] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 7] &lt;- NA
      year_groups_field_dist_comparisons[row_index+j, 8] &lt;- NA
    }else{
      if (length(which(colSums(data[c(&quot;online_news_total&quot;, &quot;news_total&quot;, &quot;twitter_total&quot;, &quot;citations_total&quot;, &quot;pubs_total&quot;)]) == 0)) &gt; 0){
        year_groups_field_dist_comparisons[row_index+j, 1] &lt;- year_group
        year_groups_field_dist_comparisons[row_index+j, 2] &lt;- field
        year_groups_field_dist_comparisons[row_index+j, 3] &lt;- nrow(data)
        year_groups_field_dist_comparisons[row_index+j, 4] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 5] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 6] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 7] &lt;- NA
        year_groups_field_dist_comparisons[row_index+j, 8] &lt;- NA
        
      }else{
        year_groups_field_dist_comparisons[row_index+j, 1] &lt;- year_group
        year_groups_field_dist_comparisons[row_index+j, 2] &lt;- field
        year_groups_field_dist_comparisons[row_index+j, 3] &lt;- nrow(data)
        year_groups_field_dist_comparisons[row_index+j, 4] &lt;- round(ks.test(women$pubs_total, men$pubs_total)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 5] &lt;- round(ks.test(women$citations_total, men$citations_total)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 6] &lt;- round(ks.test(women$news_total, men$news_total)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 7] &lt;- round(ks.test(women$online_news_total, men$online_news_total)$p.value, 5)
        year_groups_field_dist_comparisons[row_index+j, 8] &lt;- round(ks.test(women$twitter_total, men$twitter_total)$p.value, 5)
      }
    }
  }
  row_index &lt;- row_index + 4 
}

colnames(year_groups_field_dist_comparisons) &lt;- c(&quot;year_group&quot;, &quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                       &quot;news_total&quot;, &quot;online_news_total&quot;, &quot;twitter_total&quot;)
year_groups_field_dist_comparisons</code></pre>
<pre><code>##    year_group             field profs pubs_total citations_total news_total online_news_total twitter_total
## 1    up to 10              STEM    10    1.00000         0.80000    0.80000           1.00000       0.60000
## 2    up to 10   Social sciences    29    0.84008         0.60000    0.90421           0.65686       0.04615
## 3    up to 10 Arts &amp; Humanities     4         NA              NA         NA                NA            NA
## 4    up to 10          Medicine     7    0.88571         0.90000    1.00000           0.88571       0.42857
## 5    up to 20              STEM    74    0.31648         0.87622    0.85620           0.58458       0.97277
## 6    up to 20   Social sciences   216    0.02452         0.12537    0.59155           0.11647       0.83428
## 7    up to 20 Arts &amp; Humanities    14    0.85315         0.03030    0.19247           0.46853       0.69231
## 8    up to 20          Medicine    45    0.45218         0.16537    0.53203           0.67445       0.19455
## 9    up to 30              STEM   473    0.17063         0.48704    0.26844           0.03831       0.97060
## 10   up to 30   Social sciences   708    0.00928         0.31053    0.00262           0.22241       0.07097
## 11   up to 30 Arts &amp; Humanities    87    0.62521         0.27907    0.18913           0.73977       0.50518
## 12   up to 30          Medicine   358    0.05715         0.29809    0.64205           0.43233       0.29257
## 13   up to 40              STEM   689    0.00597         0.20212    0.00002           0.44229       0.89180
## 14   up to 40   Social sciences   554    0.00262         0.54583    0.02571           0.11072       0.21282
## 15   up to 40 Arts &amp; Humanities   105    0.71735         0.59864    0.45983           0.13518       0.09461
## 16   up to 40          Medicine   575    0.01949         0.03580    0.29458           0.19979       0.73989
## 17   up to 50              STEM   260    0.56101         0.53838    0.34549           0.45133       0.89130
## 18   up to 50   Social sciences   142    0.02146         0.29256    0.83899           0.42349       0.50057
## 19   up to 50 Arts &amp; Humanities    24    0.31338         0.97591    0.31338           0.77640       0.89460
## 20   up to 50          Medicine   154    0.11137         0.00387    0.85853           0.92515       0.99875</code></pre>
</div>
</div>
<div id="histograms" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Histograms</h2>
<div id="entry" class="section level3" number="1.3.1">
<h3><span class="header-section-number">1.3.1</span> Entry</h3>
<p>Get women counts per year group to compare:</p>
<pre class="r"><code>count_profs &lt;- prof_panel_filter_plot %&gt;%
  filter(years_since_entry != &quot;up to NA&quot;)%&gt;%
  group_by(inferred_gender, years_since_entry)%&gt;%
  summarise(n_gender = n())

count_profs_2 &lt;- prof_panel_filter_plot%&gt;%
  filter(years_since_entry != &quot;up to NA&quot;)%&gt;%
  group_by(years_since_entry)%&gt;%
  summarise(n_all = n())

count_profs &lt;- merge(count_profs,
                     count_profs_2,
                     by = &quot;years_since_entry&quot;)

count_profs$share_gender &lt;- round(count_profs$n_gender / count_profs$n_all * 100, 1)
count_profs$label_gender &lt;- ifelse(count_profs$inferred_gender == &quot;w&quot;, paste0(&quot;% women = &quot;, count_profs$share_gender),
                            &quot;&quot;)</code></pre>
<p>Compare distributions between men and women:</p>
<ol style="list-style-type: decimal">
<li>Publications</li>
</ol>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;pubs_total&quot; &amp; years_since_entry != &quot;up to NA&quot;)%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(2, 2),  rep(3, 2), rep(4, 2), rep(8.5, 2), rep(17, 2)),
                                  y = c(rep(10, 2),  rep(10, 2), rep(68, 2), rep(150, 2), rep(48, 2)), 
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Publications&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total publications since entry&quot;)+
  facet_wrap(. ~ years_since_entry, nrow = 2, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-16-1.png" width="960" />
2. Citations</p>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;citations_total&quot; &amp; years_since_entry != &quot;up to NA&quot;)%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(4, 2),  rep(6, 2), rep(7.5, 2), rep(9, 2), rep(17.5, 2)),
                                  y = c(rep(5, 2),  rep(8, 2), rep(50, 2), rep(110, 2), rep(40, 2)), 
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Citations&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total citations since entry&quot;)+
  facet_wrap(. ~ years_since_entry, nrow = 2, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-17-1.png" width="960" />
3. Lexis news sources</p>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;news_total&quot; &amp; years_since_entry != &quot;up to NA&quot;)%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(5, 2),  rep(3, 2), rep(4, 2), rep(4, 2), rep(3, 2)),
                                  y = c(rep(5, 2),  rep(7, 2), rep(45, 2), rep(80, 2), rep(30, 2)), 
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Lexis Mentions&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total Lexis mentions since entry&quot;)+
  facet_wrap(. ~ years_since_entry, nrow = 2, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-18-1.png" width="960" /></p>
<ol start="4" style="list-style-type: decimal">
<li>Online news attention</li>
</ol>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;online_news_total&quot; &amp; years_since_entry != &quot;up to NA&quot;)%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(3, 2),  rep(3.5, 2), rep(5, 2), rep(5, 2), rep(6, 2)),
                                  y = c(rep(10, 2),  rep(10, 2), rep(68, 2), rep(80, 2), rep(30, 2)), 
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Online News Fetures&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total online news mentions since entry&quot;)+
  facet_wrap(. ~ years_since_entry, nrow = 2, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-19-1.png" width="960" /></p>
<ol start="5" style="list-style-type: decimal">
<li>Twitter attention</li>
</ol>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;twitter_total&quot; &amp; years_since_entry != &quot;up to NA&quot;)%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(35, 2),  rep(4, 2), rep(6, 2), rep(6, 2), rep(6, 2)),
                                  y = c(rep(5, 2),  rep(5, 2), rep(20, 2), rep(45, 2), rep(15, 2)), 
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Twitter Fetures&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total twitter mentions since entry&quot;)+
  facet_wrap(. ~ years_since_entry, nrow = 2, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-20-1.png" width="960" /></p>
</div>
<div id="field" class="section level3" number="1.3.2">
<h3><span class="header-section-number">1.3.2</span> Field</h3>
<p>Get women counts per year group to compare:</p>
<pre class="r"><code>count_profs &lt;- prof_panel_filter_plot %&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(inferred_gender, general_field)%&gt;%
  summarise(n_gender = n())

count_profs_2 &lt;- prof_panel_filter_plot%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field)%&gt;%
  summarise(n_all = n())

count_profs &lt;- merge(count_profs,
                     count_profs_2,
                     by = &quot;general_field&quot;)

count_profs$share_gender &lt;- round(count_profs$n_gender / count_profs$n_all * 100, 1)
count_profs$label_gender &lt;- ifelse(count_profs$inferred_gender == &quot;w&quot;, paste0(&quot;% women = &quot;, count_profs$share_gender),
                            &quot;&quot;)</code></pre>
<p>Compare distributions between men and women:</p>
<ol style="list-style-type: decimal">
<li>Publications</li>
</ol>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;pubs_total&quot; &amp; years_since_entry != &quot;up to NA&quot; &amp; !is.na(general_field))%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(6.5, 2),  rep(5.5, 2), rep(4.5, 2), rep(5, 2)),
                                  y = c(rep(18, 2),  rep(75, 2), rep(86, 2), rep(120, 2)),
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Publications&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total publications since entry&quot;)+
  facet_wrap(general_field ~ ., ncol = 4, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-22-1.png" width="1152" />
2. Citations</p>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;citations_total&quot; &amp; years_since_entry != &quot;up to NA&quot;&amp; !is.na(general_field))%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(6.5, 2),  rep(30, 2), rep(12, 2), rep(10, 2)),
                                  y = c(rep(14, 2),  rep(70, 2), rep(70, 2), rep(90, 2)),
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Citations&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total citations since entry&quot;)+
  facet_wrap(general_field ~ ., ncol = 4, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-23-1.png" width="1152" />
3. Lexis news sources</p>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;news_total&quot; &amp; years_since_entry != &quot;up to NA&quot;&amp; !is.na(general_field))%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(4.5, 2),  rep(4, 2), rep(4.5, 2), rep(4.5, 2)),
                                  y = c(rep(12, 2),  rep(40, 2), rep(50, 2), rep(50, 2)),
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Lexis Mentions&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total Lexis mentions since entry&quot;)+
  facet_wrap(general_field ~ ., ncol = 4, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-24-1.png" width="1152" /></p>
<ol start="4" style="list-style-type: decimal">
<li>Online news attention</li>
</ol>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;online_news_total&quot; &amp; years_since_entry != &quot;up to NA&quot;&amp; !is.na(general_field))%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(2.5, 2),  rep(5.5, 2), rep(5, 2), rep(5, 2)),
                                  y = c(rep(30, 2),  rep(40, 2), rep(65, 2), rep(65, 2)),
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Online News Fetures&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total online news mentions since entry&quot;)+
  facet_wrap(general_field ~ ., ncol = 4, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-25-1.png" width="1152" /></p>
<ol start="5" style="list-style-type: decimal">
<li>Twitter attention</li>
</ol>
<pre class="r"><code>prof_panel_filter_plot %&gt;%
  filter(measure == &quot;twitter_total&quot; &amp; years_since_entry != &quot;up to NA&quot;&amp; !is.na(general_field))%&gt;%
  ggplot(., aes(x=n, color=inferred_gender)) +
  geom_histogram(fill=&quot;white&quot;, position=&quot;dodge&quot;,bins = 40)+
  scale_x_log10()+
  geom_text(data=count_profs, aes(x = c(rep(4, 2),  rep(7, 2), rep(7, 2), rep(7, 2)),
                                  y = c(rep(10, 2),  rep(25, 2), rep(25, 2), rep(35, 2)),
                                  label=label_gender),
            size = 3.5)+
  xlab(&quot;Log Total Twitter Fetures&quot;)+
  ylab(&quot;Count&quot;)+
  labs(color=&#39;Inferred gender&#39;)+
  ggtitle(&quot;Histograms: total twitter mentions since entry&quot;)+
  facet_wrap(general_field ~ ., ncol = 4, scales = &quot;free&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-26-1.png" width="1152" /></p>
</div>
</div>
</div>
<div id="cdf-plots" class="section level1" number="2">
<h1><span class="header-section-number">2</span> CDF Plots</h1>
<p>Plotting the CDFs:</p>
<pre class="r"><code>ggplot(prof_panel_filter_plot, aes(x = n, col = measure),log=&#39;x&#39;)+
  stat_ecdf(lwd = 1.2)+
  scale_x_log10()+
  xlab(&quot;Log(n)&quot;)+
  ylab(&quot;ECDF&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<p>Break this down by gender:</p>
<pre class="r"><code>cols_of_interest &lt;- c(&quot;pubs_total&quot;, &quot;citations_total&quot;,
                      &quot;news_total&quot;, &quot;online_news_total&quot;,
                      &quot;twitter_total&quot;)

titles &lt;- c(&quot;Total Publications&quot;,
             &quot;Total Citations&quot;,
             &quot;Total Lexis mentions&quot;,
             &quot;Total Online News mentions&quot;,
             &quot;Total Twitter mentions&quot;)

cdf_plots &lt;- list()

for (i in 1:length(cols_of_interest)){
  
  data &lt;- filter(prof_panel_filter_plot,
                 measure == cols_of_interest[i])

  plotje &lt;- ggplot(data, aes(x = n, col = inferred_gender),log=&#39;x&#39;)+
    stat_ecdf(lwd = 1.2)+
    scale_x_log10()+
    xlab(&quot;Log(n)&quot;)+
    ylab(&quot;ECDF&quot;)+
    ggtitle(titles[i])+
    scale_color_manual(values=c(&quot;w&quot; = &quot;#E69F00&quot;, &quot;m&quot;= &quot;#56B4E9&quot;))+
    theme_minimal()
  
  cdf_plots[[i]] &lt;- plotje
}</code></pre>
<p>Plot the CDFs next to each other:</p>
<pre class="r"><code>legend &lt;- get_legend(
  # create some space to the left of the legend
  cdf_plots[[1]]
)

(cowplot::plot_grid(cdf_plots[[1]] + theme(legend.position=&quot;none&quot;), 
           cdf_plots[[2]] + theme(legend.position=&quot;none&quot;),
           cdf_plots[[3]] + theme(legend.position=&quot;none&quot;), 
           cdf_plots[[4]] + theme(legend.position=&quot;none&quot;),
           cdf_plots[[5]] + theme(legend.position=&quot;none&quot;),
           legend,
           ncol = 2))</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-29-1.png" width="576" />
## Log-log plots</p>
<div id="log-log-of-the-frequency-distribution" class="section level3"
number="2.0.1">
<h3><span class="header-section-number">2.0.1</span> Log-log of the
frequency distribution</h3>
<pre class="r"><code>cols_of_interest &lt;- c(&quot;pubs_total&quot;, &quot;citations_total&quot;,
                      &quot;news_total&quot;, &quot;online_news_total&quot;,
                      &quot;twitter_total&quot;)

titles &lt;- c(&quot;Total Publications&quot;,
             &quot;Total Citations&quot;,
             &quot;Total Lexis mentions&quot;,
             &quot;Total Online News mentions&quot;,
             &quot;Total Twitter mentions&quot;)

plotting_all &lt;- data.frame(matrix(NA, ncol = 4, nrow = 0))
colnames(plotting_all) &lt;- c(&quot;x&quot;, &quot;pk&quot;, &quot;k&quot;, &quot;measure&quot;)

for (i in 1:length(cols_of_interest)){
  column_of_interest &lt;- cols_of_interest[i]
  # organize data into a df
  x &lt;- filter(prof_panel_filter, !is.na(get(column_of_interest)))
  x &lt;- x[[column_of_interest]]
  x &lt;- sort(x, decreasing = TRUE)

  plotting_df &lt;- data.frame(x = x,
                            pk &lt;- 1-ecdf(x)(x),
                            k &lt;- seq_along(x))
  
  plotting_df$measure &lt;- column_of_interest
  colnames(plotting_df) &lt;- c(&quot;x&quot;, &quot;pk&quot;, &quot;k&quot;, &quot;measure&quot;)
  
  plotting_all &lt;- rbind(plotting_all,
                        plotting_df)

}</code></pre>
<p>Here is the plot:</p>
<pre class="r"><code>plotting_all %&gt;%
  ggplot(aes(x=x, y = pk, color = measure, group = measure)) + geom_point(alpha=0.2)+
  scale_x_log10()+
  scale_y_log10()+
  ylab(&quot;Proportion of profs&quot;)+
  xlab(&quot;Number&quot;)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
<div id="fitting-different-distributions" class="section level3"
number="2.0.2">
<h3><span class="header-section-number">2.0.2</span> Fitting different
distributions</h3>
<pre class="r"><code>cols_of_interest &lt;- c(&quot;pubs_total&quot;, &quot;citations_total&quot;,
                      &quot;news_total&quot;, &quot;online_news_total&quot;,
                      &quot;twitter_total&quot;)

titles &lt;- c(&quot;Total Publications&quot;,
             &quot;Total Citations&quot;,
             &quot;Total Lexis mentions&quot;,
             &quot;Total Online News mentions&quot;,
             &quot;Total Twitter mentions&quot;)

power_law_plots &lt;- list()
p_values &lt;- list()

for (i in 1:length(cols_of_interest)){
  column_of_interest &lt;- cols_of_interest[i]
  # organize data into a df
  x &lt;- filter(prof_panel_filter, !is.na(get(column_of_interest)))
  x &lt;- x[[column_of_interest]]
  
  x &lt;- x[!is.na(x)]
  x &lt;- x[x != 0]
  # fit a power law distribution
  pl_est &lt;- displ$new(x)
  pl_est$setXmin(estimate_xmin(pl_est))
  #pl_est$setXmin(1)
  pl_est$setPars(estimate_pars(pl_est))
  
  # fit log-normal model
  ln_est &lt;- dislnorm$new(x)
  ln_est$setXmin(pl_est$getXmin())
  ln_est$setPars(estimate_pars(ln_est))
  
  # compare the distributions
  comp = compare_distributions(pl_est, ln_est)
  p_values[[i]] &lt;- comp$p_two_sided
  
  
  plot.new() ## clean up device
  ## Plot the data (from xmin)
  plot(pl_est, ylab = &quot;CDF&quot;, xlab = &quot;n&quot;,  main=titles[i])
  ## Add in the fitted distribution
  lines(pl_est, col = 2)
  lines(ln_est, col = 3)
  p &lt;- recordPlot()
  
  power_law_plots[[i]] &lt;- p
  
  
}</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-32-1.png" width="672" /><img src="Various_plots_files/figure-html/unnamed-chunk-32-2.png" width="672" /><img src="Various_plots_files/figure-html/unnamed-chunk-32-3.png" width="672" /><img src="Various_plots_files/figure-html/unnamed-chunk-32-4.png" width="672" /><img src="Various_plots_files/figure-html/unnamed-chunk-32-5.png" width="672" /></p>
<pre class="r"><code>plot.new()
for (i in 1:length(power_law_plots)){
  plot &lt;- power_law_plots[[i]]
  #plot.new() 
  print(plot)
}</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-33-1.png" width="480" /></p>
<pre class="r"><code>p_values</code></pre>
<pre><code>## [[1]]
## [1] 0.5429114
## 
## [[2]]
## [1] 0.2343458
## 
## [[3]]
## [1] 7.449671e-08
## 
## [[4]]
## [1] 0.2454641
## 
## [[5]]
## [1] 0.4801399</code></pre>
</div>
<div id="share-women-as-in-the-pnas-paper" class="section level2"
number="2.1">
<h2><span class="header-section-number">2.1</span> Share women as in the
PNAS paper</h2>
<p>Get the top 25/15/5/1% per field:</p>
<pre class="r"><code>top_25_field &lt;- prof_panel_filter_plot %&gt;%
  group_by(general_field, measure)%&gt;%
  filter(quantile(n, 0.75, na.rm = TRUE)&lt;n)%&gt;%
  select(general_field,profile_id, measure)

top_25_field$top_25 &lt;- &quot;yes&quot;

prof_panel_filter_plot_top &lt;- merge(prof_panel_filter_plot,
                                    top_25_field,
                                    by = c(&quot;general_field&quot;, &quot;profile_id&quot;, &quot;measure&quot;),
                                    all.x = TRUE)

prof_panel_filter_plot_top$top_25 &lt;- ifelse(is.na(prof_panel_filter_plot_top$top_25),
                                            &quot;no&quot;,
                                            prof_panel_filter_plot_top$top_25)

top_15_field &lt;- prof_panel_filter_plot %&gt;%
  group_by(general_field, measure)%&gt;%
  filter(quantile(n, 0.85, na.rm = TRUE)&lt;n)%&gt;%
  select(general_field,profile_id, measure)

top_15_field$top_15 &lt;- &quot;yes&quot;

prof_panel_filter_plot_top &lt;- merge(prof_panel_filter_plot_top,
                                    top_15_field,
                                    by = c(&quot;general_field&quot;, &quot;profile_id&quot;, &quot;measure&quot;),
                                    all.x = TRUE)

prof_panel_filter_plot_top$top_15 &lt;- ifelse(is.na(prof_panel_filter_plot_top$top_15),
                                            &quot;no&quot;,
                                            prof_panel_filter_plot_top$top_15)

top_5_field &lt;- prof_panel_filter_plot %&gt;%
  group_by(general_field, measure)%&gt;%
  filter(quantile(n, 0.95, na.rm = TRUE)&lt;n)%&gt;%
  select(general_field,profile_id, measure)

top_5_field$top_5 &lt;- &quot;yes&quot;

prof_panel_filter_plot_top &lt;- merge(prof_panel_filter_plot_top,
                                    top_5_field,
                                    by = c(&quot;general_field&quot;, &quot;profile_id&quot;, &quot;measure&quot;),
                                    all.x = TRUE)

prof_panel_filter_plot_top$top_5 &lt;- ifelse(is.na(prof_panel_filter_plot_top$top_5),
                                            &quot;no&quot;,
                                            prof_panel_filter_plot_top$top_5)

top_1_field &lt;- prof_panel_filter_plot %&gt;%
  group_by(general_field, measure)%&gt;%
  filter(quantile(n, 0.99, na.rm = TRUE)&lt;n)%&gt;%
  select(general_field,profile_id, measure)

top_1_field$top_1 &lt;- &quot;yes&quot;

prof_panel_filter_plot_top &lt;- merge(prof_panel_filter_plot_top,
                                    top_1_field,
                                    by = c(&quot;general_field&quot;, &quot;profile_id&quot;, &quot;measure&quot;),
                                    all.x = TRUE)

prof_panel_filter_plot_top$top_1 &lt;- ifelse(is.na(prof_panel_filter_plot_top$top_1),
                                            &quot;no&quot;,
                                            prof_panel_filter_plot_top$top_1)</code></pre>
<div id="of-women-among-all-profs" class="section level3"
number="2.1.1">
<h3><span class="header-section-number">2.1.1</span> % of women among
all profs</h3>
<p>Share of women in general</p>
<pre class="r"><code># share women per measure
top_field_s_w &lt;- prof_panel_filter_plot_top %&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field, measure)%&gt;%
  summarise(count = sum(n, na.rm = TRUE),
            n_w = sum(n[inferred_gender == &quot;w&quot;], na.rm = TRUE))%&gt;%
  mutate(share_w = round(n_w / count, 3)*100)

# share women in per field
s_w_overall &lt;- prof_panel_filter_plot %&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(general_field)%&gt;%
  summarise(count = n(),
            n_w = sum(inferred_gender == &quot;w&quot;))%&gt;%
  mutate(share_w = round(n_w / count, 3)*100)

s_w_overall$measure &lt;- &quot;overall&quot;
s_w_overall &lt;- s_w_overall[colnames(top_field_s_w)]

# merge
top_field_s_w &lt;- rbind(top_field_s_w,
                          s_w_overall)

colnames(s_w_overall)[5] &lt;- &quot;share_w_overall&quot;

top_field_s_w &lt;- merge(top_field_s_w,
                                 s_w_overall[c(&quot;general_field&quot;, &quot;share_w_overall&quot;)],
                                 by = &quot;general_field&quot;)

top_field_s_w$share_w_overall[c(2:6, 8:12, 14:18, 20:24)] &lt;- NA</code></pre>
<p>Plot this out:</p>
<pre class="r"><code>top_field_s_w$measure &lt;- factor(top_field_s_w$measure, 
                                   levels = c(&quot;overall&quot;, 
                                               &quot;pubs_total&quot;, 
                                               &quot;citations_total&quot;, 
                                               &quot;news_total&quot;, 
                                               &quot;online_news_total&quot;, 
                                               &quot;twitter_total&quot;))

repr_all &lt;- top_field_s_w %&gt;%
  filter(measure != &quot;overall&quot;)%&gt;%
  ggplot(aes(y=share_w, x=general_field)) + 
  geom_point(aes(shape=measure, color=measure), position=position_dodge(width=0.2), stat=&quot;identity&quot;)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_w_overall, x=general_field), alpha=0.2, width = 0.2)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
  coord_flip()+
  xlab(&quot;Field&quot;)+
  ylab(&quot;% Women&quot;)+
  ggtitle(&quot;% of women compared to their share \namong professors&quot;)+
  theme(plot.title = element_text(size = 10))</code></pre>
</div>
<div id="of-women-in-top-n-of-profs" class="section level3"
number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> % of women in top
n% of profs</h3>
<p>Now, look at the share of women per top n:</p>
<pre class="r"><code>plotting_list &lt;- c(&quot;top_25&quot;, &quot;top_15&quot;, &quot;top_5&quot;, &quot;top_1&quot;)

for (top in plotting_list){
  # share women per measure
  top_n_field_s_w &lt;- prof_panel_filter_plot_top %&gt;%
    filter(!is.na(general_field))%&gt;%
    filter(!!as.symbol(top)  == &quot;yes&quot;)%&gt;%
    group_by(general_field, measure)%&gt;%
    summarise(n = n(),
              n_w = sum(inferred_gender == &quot;w&quot;))%&gt;%
    mutate(share_w = round(n_w / n, 3)*100)
  
  # share women in per field
  s_w_overall &lt;- prof_panel_filter_plot_top %&gt;%
    filter(!is.na(general_field))%&gt;%
    group_by(general_field)%&gt;%
    summarise(n = n(),
              n_w = sum(inferred_gender == &quot;w&quot;))%&gt;%
    mutate(share_w = round(n_w / n, 3)*100)
  
  s_w_overall$measure &lt;- &quot;overall&quot;
  s_w_overall &lt;- s_w_overall[colnames(top_n_field_s_w)]
  
  # merge
  top_n_field_s_w &lt;- rbind(top_n_field_s_w,
                            s_w_overall)
  
  colnames(s_w_overall)[5] &lt;- &quot;share_w_overall&quot;
  
  top_n_field_s_w &lt;- merge(top_n_field_s_w,
                            s_w_overall[c(&quot;general_field&quot;, &quot;share_w_overall&quot;)],
                            by = &quot;general_field&quot;)
  
  top_n_field_s_w$share_w_overall[c(2:6, 8:12, 14:18, 20:24)] &lt;- NA
  
  top_n_field_s_w$measure &lt;- factor(top_n_field_s_w$measure, 
                                    levels = c(&quot;overall&quot;, 
                                               &quot;pubs_total&quot;, 
                                               &quot;citations_total&quot;, 
                                               &quot;news_total&quot;, 
                                               &quot;online_news_total&quot;, 
                                               &quot;twitter_total&quot;))
  
  repr_top_n &lt;- top_n_field_s_w %&gt;%
    filter(measure != &quot;overall&quot;)%&gt;%
    ggplot(aes(y=share_w, x=general_field)) + 
    geom_point(aes(shape=measure, color=measure), position=position_dodge(width=0.2), stat=&quot;identity&quot;)+
    geom_bar(stat=&quot;identity&quot;, aes(y=share_w_overall, x=general_field), alpha=0.2, width = 0.2)+
    guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
    coord_flip()+
    xlab(&quot;Field&quot;)+
    ylab(&quot;% Women&quot;)+
    ggtitle(paste0(&quot;% of women among top &quot;, str_remove(top,&quot;top_&quot;), &quot;% profs per measure \ncompared to their share among professors&quot;))+
    theme(plot.title = element_text(size = 10))
  
  assign(paste0(&quot;repr_&quot;, top), repr_top_n)
  
}</code></pre>
<p>Plot this out:</p>
<pre class="r"><code>legend &lt;- get_legend(
  # create some space to the left of the legend
  repr_all
)

(cowplot::plot_grid(repr_all + theme(legend.position=&quot;none&quot;), 
           repr_top_25 + theme(legend.position=&quot;none&quot;,
                               axis.title.y=element_blank(),
                               axis.text.y=element_blank()),
           repr_top_15 + theme(legend.position=&quot;none&quot;,
                               axis.title.y=element_blank(),
                               axis.text.y=element_blank()),
           repr_top_5 + theme(legend.position=&quot;none&quot;),
           repr_top_1 + theme(legend.position=&quot;none&quot;,
                               axis.title.y=element_blank(),
                               axis.text.y=element_blank()),
           legend,
           ncol = 3,
           rel_widths = c(1, 0.75, 0.75)))</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-38-1.png" width="1152" /></p>
<pre class="r"><code># I&#39;m such an artist :D</code></pre>
</div>
</div>
</div>
<div id="paper-based" class="section level1" number="3">
<h1><span class="header-section-number">3</span> PAPER-BASED</h1>
<pre class="r"><code>port &lt;- 5432
user &lt;- &quot;postgres&quot;
password &lt;- &quot;dutchmediaprofssql&quot;
database_name &lt;- &quot;postgres&quot;

con &lt;- RPostgres::dbConnect(RPostgres::Postgres(),
                 dbname= database_name,
                 port = port,
                 user = user, 
                 password = password)</code></pre>
<p>Load different types of attention:</p>
<pre class="r"><code>pub_news &lt;- dbReadTable(con, &quot;altmetric_pub_att_news&quot;)
pub_blogs &lt;- dbReadTable(con, &quot;altmetric_pub_att_blogs&quot;)
twitter_attn &lt;- dbGetQuery(con, statement = &quot;select * from altmetric_prof_attention where \&quot;mention_type\&quot;=&#39;tweet&#39;&quot;)
lexis_data &lt;- dbReadTable(con, &quot;lexis_nexis_mentions&quot;)
prof_gender &lt;- dbReadTable(con, &quot;gender_table&quot;)
  
# get single authored papers
# loading the paper info
oa_pubs_unique &lt;- dbReadTable(con, &quot;oa_prof_pubs_unique&quot;)
#prof - pub matching
oa_prof_pub_matching &lt;- dbReadTable(con, &quot;oa_prof_pub_match&quot;)
# prof unique pub list 
oa_prof_pubs_unique &lt;- merge(oa_pubs_unique,
                             oa_prof_pub_matching[c(&quot;id&quot;, &quot;au_id&quot;, &quot;au_display_name&quot;, &quot;profile_id&quot;)],
                             all.x = TRUE,
                             all.y = TRUE,
                             by = &quot;id&quot;)

coauthor_info &lt;- dbGetQuery(con, &quot;select \&quot;id\&quot;, \&quot;au_id\&quot; FROM oa_coauthor_info;&quot;)

oa_prof_pubs_unique_single_au &lt;- filter(oa_prof_pubs_unique, 
                                        ! id %in% coauthor_info$id)</code></pre>
<p>Merge lexis and twitter data with gender:</p>
<pre class="r"><code>lexis_data &lt;- merge(lexis_data, 
                    prof_gender[c(&quot;profile_id&quot;, &quot;inferred_gender&quot;)],
                    by = &quot;profile_id&quot;)

twitter_attn &lt;- merge(twitter_attn,
                      prof_gender[c(&quot;profile_id&quot;, &quot;inferred_gender&quot;)],
                      by = &quot;profile_id&quot;)</code></pre>
<p>Tidy up the attention sources:</p>
<pre class="r"><code># merge the papers with their authors
attention_news_profs &lt;- merge(pub_news,
                        oa_prof_pub_matching[c(&quot;id&quot;, &quot;profile_id&quot;)],
                        by = &quot;id&quot;)

# merge the papers with their authors
attention_blogs_profs &lt;- merge(pub_blogs,
                        oa_prof_pub_matching[c(&quot;id&quot;, &quot;profile_id&quot;)],
                        by = &quot;id&quot;)

# get a year from the &quot;posted on&quot; string
attention_news_profs$year &lt;- year(as_date(attention_news_profs$posted_on))
attention_blogs_profs$year &lt;- year(as_date(attention_blogs_profs$posted_on))

# merge these two together
online_news_blogs &lt;- rbind(attention_news_profs[c(&quot;id&quot;, &quot;title&quot;, &quot;url&quot;, &quot;posted_on&quot;, &quot;summary&quot;, 
                                                  &quot;author_name&quot;, &quot;author_url&quot;, &quot;profile_id&quot;,  &quot;year&quot; )],
                           attention_blogs_profs[c(&quot;id&quot;, &quot;title&quot;, &quot;url&quot;, &quot;posted_on&quot;, &quot;summary&quot;, 
                                                  &quot;author_name&quot;, &quot;author_url&quot;, &quot;profile_id&quot;,  &quot;year&quot; )])

online_news_blogs &lt;- merge(online_news_blogs, 
                           prof_gender[c(&quot;profile_id&quot;, &quot;inferred_gender&quot;)],
                           by = &quot;profile_id&quot;)</code></pre>
<p>Get professor gender as well as their main field:</p>
<pre class="r"><code># fetch the topics
oa_pubs_topics &lt;- dbReadTable(con, &quot;oa_pubs_topics&quot;)

oa_pubs_topics &lt;- merge(oa_prof_pub_matching,
                        oa_pubs_topics,
                        by = &quot;id&quot;,
                        all.x = TRUE)

oa_pubs_topics &lt;- merge(oa_pubs_topics,
                        oa_pubs_unique[c(&quot;id&quot;, &quot;publication_year&quot;)],
                        by = &quot;id&quot;)

# and get the fields
prof_total_field &lt;- oa_pubs_topics %&gt;%
  group_by(profile_id, field_display_name) %&gt;%
  summarise(n = n())%&gt;%
  slice_max(n, with_ties = FALSE)%&gt;%
  select(-n)

colnames(prof_total_field)[2] &lt;- c(&quot;overall_field&quot; )

# recode the fields
prof_total_field &lt;- prof_total_field %&gt;% 
  mutate(general_field = case_match(
    overall_field,
    &quot;Arts and Humanities&quot;  ~ &quot;Arts &amp; Humanities&quot;,
    c(&quot;Biochemistry, Genetics and Molecular Biology&quot;,&quot;Agricultural and Biological Sciences&quot;,
      &quot;Chemical Engineering&quot;, &quot;Chemistry&quot;,  &quot;Computer Science&quot;, &quot;Decision Sciences&quot;,
      &quot;Earth and Planetary Sciences&quot;, &quot;Energy&quot;, &quot;Engineering&quot;, &quot;Environmental Science&quot;,
      &quot;Immunology and Microbiology&quot;, &quot;Materials Science&quot;, &quot;Mathematics&quot;, &quot;Neuroscience&quot;, 
      &quot;Physics and Astronomy&quot; ) ~ &quot;STEM&quot;,
    c(&quot;Dentistry&quot;, &quot;Health Professions&quot;, &quot;Medicine&quot;) ~ &quot;Medicine&quot;,
    c(&quot;Business, Management and Accounting&quot;, &quot;Economics, Econometrics and Finance&quot;,
      &quot;Psychology&quot;, &quot;Social Sciences&quot;) ~ &quot;Social sciences&quot;))</code></pre>
<p>Merge attention and field:</p>
<pre class="r"><code>online_news_blogs &lt;- merge(online_news_blogs,
                           prof_total_field[c(&quot;profile_id&quot;, &quot;general_field&quot;)],
                           by = &quot;profile_id&quot;)

# denote if single-authored paper
online_news_blogs$single_au &lt;- ifelse(online_news_blogs$id %in% oa_prof_pubs_unique_single_au$id, &quot;yes&quot;, &quot;no&quot;)

lexis_data &lt;- merge(lexis_data,
                    prof_total_field[c(&quot;profile_id&quot;, &quot;general_field&quot;)],
                    by = &quot;profile_id&quot;)

twitter_attn &lt;- merge(twitter_attn,
                      prof_total_field[c(&quot;profile_id&quot;, &quot;general_field&quot;)],
                      by = &quot;profile_id&quot;)</code></pre>
<p>Gender inequality for single authored papers:</p>
<pre class="r"><code>online_att_all &lt;- online_news_blogs %&gt;%
  group_by(inferred_gender, general_field)%&gt;%
  summarise(all_attn = n())%&gt;%
  group_by(general_field)%&gt;%
  mutate(share_attn = all_attn/sum(all_attn))

colnames(online_att_all)[2] &lt;- &quot;general_field&quot;

share_prof_field &lt;- merge(prof_gender,
                          prof_total_field,
                          by = &quot;profile_id&quot;)%&gt;%
  filter(!is.na(general_field))%&gt;%
  group_by(inferred_gender, general_field)%&gt;%
    summarise(all_prof = n())%&gt;%
  group_by(general_field)%&gt;%
  mutate(share_prof = all_prof/sum(all_prof))

online_att_all &lt;- merge(online_att_all,
                        share_prof_field,
                        by= c(&quot;inferred_gender&quot;, &quot;general_field&quot;))

online_att_all_avg &lt;- online_news_blogs %&gt;%
  group_by(profile_id, inferred_gender, general_field)%&gt;%
  summarise(count = n())%&gt;%
  group_by(inferred_gender, general_field)%&gt;%
  summarise(mean_n = mean(count, na.rm = TRUE),
            sd = sd(count, na.rm = TRUE),
            n = n()) %&gt;%
  mutate(se = sd / sqrt(n),
         lower.ci = mean_n - qt(1 - (0.05 / 2), n - 1) * se,
         upper.ci = mean_n + qt(1 - (0.05 / 2), n - 1) * se)


online_att_single &lt;- online_news_blogs %&gt;%
   filter(single_au == &quot;yes&quot;)%&gt;%
   group_by(inferred_gender, general_field)%&gt;%
   summarise(all_attn = n())%&gt;%
   group_by(general_field)%&gt;%
   mutate(share = all_attn/sum(all_attn))

colnames(online_att_single)[2] &lt;- &quot;general_field&quot;

online_att_single &lt;- merge(online_att_single,
                        share_prof_field,
                        by= c(&quot;inferred_gender&quot;, &quot;general_field&quot;))

online_att_single_avg &lt;- online_news_blogs %&gt;%
  filter(single_au == &quot;yes&quot;)%&gt;%
  group_by(profile_id, inferred_gender, general_field)%&gt;%
  summarise(count = n())%&gt;%
  group_by(inferred_gender, general_field)%&gt;%
  summarise(mean_n = mean(count, na.rm = TRUE),
            sd = sd(count, na.rm = TRUE),
            n = n()) %&gt;%
  mutate(se = sd / sqrt(n),
         lower.ci = mean_n - qt(1 - (0.05 / 2), n - 1) * se,
         upper.ci = mean_n + qt(1 - (0.05 / 2), n - 1) * se)</code></pre>
<p>Plot average attention counts: 1. Overall</p>
<p>Shares</p>
<pre class="r"><code>share_attn_all &lt;- online_att_all %&gt;%
  ggplot(aes(x=as.factor(general_field))) +
  geom_bar(aes(y=share_attn, fill = as.factor(inferred_gender)), position = position_dodge(width = 0.9), stat=&quot;identity&quot;, alpha=0.7)+
  geom_point(aes(y=share_prof, color = as.factor(inferred_gender)), position = position_dodge(width = 0.9))</code></pre>
<p>Averages</p>
<pre class="r"><code>avg_attn_all &lt;-online_att_all_avg %&gt;%
ggplot(aes(x=as.factor(general_field), y=mean_n)) +
  geom_bar(aes(fill = as.factor(inferred_gender)), position = position_dodge(width = 0.9), stat=&quot;identity&quot;, alpha=0.7)+
  geom_errorbar(aes(x=as.factor(general_field), ymin=lower.ci, ymax=upper.ci, group = inferred_gender), width=0.1, alpha=0.9, size=0.6, position=position_dodge(1))</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Single author:</li>
</ol>
<p>Shares:</p>
<pre class="r"><code>share_attn_single &lt;-online_att_single %&gt;%
  ggplot(aes(x=as.factor(general_field))) +
  geom_bar(aes(y=share, fill = as.factor(inferred_gender)), position = position_dodge(width = 0.9), stat=&quot;identity&quot;, alpha=0.7)+
  geom_point(aes(y=share_prof, color = as.factor(inferred_gender)), position = position_dodge(width = 0.9))</code></pre>
<p>Averages:</p>
<pre class="r"><code>avg_attn_single &lt;- online_att_single_avg %&gt;%
ggplot(aes(x=as.factor(general_field), y=mean_n)) +
  geom_bar(aes(fill = as.factor(inferred_gender)), position = position_dodge(width = 0.9), stat=&quot;identity&quot;, alpha=0.7)+
  geom_errorbar(aes(x=as.factor(general_field), ymin=lower.ci, ymax=upper.ci, group = inferred_gender), width=0.1, alpha=0.9, size=0.6, position=position_dodge(1))</code></pre>
<p>Shares of attention combined:</p>
<pre class="r"><code>legend &lt;- get_legend(
  # create some space to the left of the legend
  share_attn_all+ guides(fill=guide_legend(title=&quot;Share attention&quot;),
                         color=guide_legend(title=&quot;Share professors&quot;))
)

cowplot::plot_grid(share_attn_all + ggtitle(&quot;Attn. to all papers&quot;)+ theme(legend.position=&quot;none&quot;)+ylab(&quot;Share&quot;)+xlab(&quot;Field&quot;), 
             share_attn_single + ggtitle(&quot;Attn. to single author papers&quot;)+xlab(&quot;Field&quot;)+ theme(legend.position=&quot;none&quot;)+ylab(&quot;Share&quot;),
             legend,
             rel_widths = c(1, 1, 0.3),
             nrow = 1)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-50-1.png" width="960" />
Average mentions combined:</p>
<pre class="r"><code>legend &lt;- get_legend(
  # create some space to the left of the legend
  avg_attn_all+ guides(fill=guide_legend(title=&quot;Average attention&quot;))
)

cowplot::plot_grid(avg_attn_all + ggtitle(&quot;Avg. mentions - all papers&quot;)+ theme(legend.position=&quot;none&quot;)+ylab(&quot;Share&quot;)+xlab(&quot;Field&quot;), 
             avg_attn_single + ggtitle(&quot;Avg. mentions - single author papers&quot;)+xlab(&quot;Field&quot;)+ theme(legend.position=&quot;none&quot;)+ylab(&quot;Share&quot;)+ylim(0,25),
             legend,
             rel_widths = c(1, 1, 0.3),
             nrow = 1)</code></pre>
<p><img src="Various_plots_files/figure-html/unnamed-chunk-51-1.png" width="960" /></p>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlZpc3VhbGlzYXRpb25zX2ludGVyZGlzY2lwbGluYXJ5Ig0KYXV0aG9yOiAiQW5hIE1hY2Fub3ZpYyINCmRhdGU6ICIyMDI0LTAzLTE5Ig0Kb3V0cHV0OiBodG1sX2RvY3VtZW50DQotLS0NCg0KVGVzdGluZyBzb21lIHZpc3VhbGlzYXRpb25zIGZvciBhbiBpbnRlcmRpc2NpcGxpbmFyeSBqb3VybmFsIGFwcHJvYWNoLg0KYGBge3J9DQpvcHRpb25zKHdpZHRoID0gMTIwKQ0KYGBgDQoNCmBgYHtyIGluY2x1ZGU9RkFMU0V9DQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpDQprbml0cjo6b3B0c19jaHVuayRzZXQod2FybmluZyA9IEZBTFNFKQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGNhY2hlID0gRkFMU0UsIGNhY2hlLmxhenkgPSBGQUxTRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChtZXNzYWdlID0gRkFMU0UpDQpgYGANCg0KTG9hZCB0aGUgcGFja2FnZXM6DQpgYGB7ciBtZXNzYWdlPSAgRiwgd2FybmluZyA9IEYsIGV2YWwgPSBULCBlY2hvPVR9DQpsaWJyYXJ5KGdyb3VuZGhvZykNCnBhY2thZ2VzX3RvX2xvYWQgPC0gYygicmVhZHIiLCAiZHBseXIiLCAidGlkeXIiLCANCiAgICAgICAgICAgICAgICAgICAgICAidGlkeXZlcnNlIiwgIlJQb3N0Z3JlcyIsICJsdWJyaWRhdGUiLCAicHN5Y2giLA0KICAgICAgICAgICAgICAgICAgICAgICJncmlkRXh0cmEiLCJnZ3Bsb3QyIiwgInNjYWxlcyIsDQogICAgICAgICAgICAgICAgICAgICAgInBhbmVsciIsICJza2ltciIsICJjb3dwbG90IiwgInJzdGF0aXgiLA0KICAgICAgICAgICAgICAgICAgICAgICJsbXRlc3QiLCAic2FuZHdpY2giLCAicG93ZVJsYXciKQ0KZ3JvdW5kaG9nLmxpYnJhcnkocGFja2FnZXNfdG9fbG9hZCwgZGF0ZSA9ICIyMDIzLTEyLTAxIikNCg0KYGBgDQoNCmBgYHtyfQ0KcG9ydCA8LSA1NDMyDQp1c2VyIDwtICJwb3N0Z3JlcyINCnBhc3N3b3JkIDwtICJkdXRjaG1lZGlhcHJvZnNzcWwiDQpkYXRhYmFzZV9uYW1lIDwtICJwb3N0Z3JlcyINCg0KY29uIDwtIFJQb3N0Z3Jlczo6ZGJDb25uZWN0KFJQb3N0Z3Jlczo6UG9zdGdyZXMoKSwNCiAgICAgICAgICAgICAgICAgZGJuYW1lPSBkYXRhYmFzZV9uYW1lLA0KICAgICAgICAgICAgICAgICBwb3J0ID0gcG9ydCwNCiAgICAgICAgICAgICAgICAgdXNlciA9IHVzZXIsIA0KICAgICAgICAgICAgICAgICBwYXNzd29yZCA9IHBhc3N3b3JkKQ0KYGBgDQoNCiMgUEFORUwgQkFTRUQNCkxvYWRpbmcgdGhlIGRhdGE6DQpgYGB7cn0NCnByb2ZfcGFuZWwgPC0gcmVhZF9jc3YoInBhbmVsX2RhdGFzZXRzL3Byb2ZfeWVhcl9wX2NfZ19hX3RfbF9sXzIwXzMuY3N2IikNCnByb2ZfcGFuZWxfY29hIDwtIHJlYWRfY3N2KCJwYW5lbF9kYXRhc2V0cy9wcm9mX3BhbmVsX2NvbWJpbmVkX25vX2xleGlzXzE5XzMuY3N2IikNCg0KIyBjb21iaW5lIHRoZSB0d28sIHNpbmNlIHRoZSBsYXR0ZXIgbWl4ZXMgbmV4aXMgZGF0YQ0KbGV4aXNfZGF0YSA8LSBwcm9mX3BhbmVsICU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZCwgeWVhciwgY29udGFpbnMoImxleGlzIikpDQoNCnByb2ZfcGFuZWxfY29hIDwtIG1lcmdlKHByb2ZfcGFuZWxfY29hLA0KICAgICAgICAgICAgICAgICAgICAgICAgbGV4aXNfZGF0YSwNCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5PSBjKCJwcm9maWxlX2lkIiwgInllYXIiKSkNCg0KIyByZWNvZGUgdGhlIGZpZWxkcw0KcHJvZl9wYW5lbF9jb2EgPC0gcHJvZl9wYW5lbF9jb2EgJT4lIA0KICBtdXRhdGUoZ2VuZXJhbF9maWVsZCA9IGNhc2VfbWF0Y2goDQogICAgb3ZlcmFsbF9maWVsZCwNCiAgICAiQXJ0cyBhbmQgSHVtYW5pdGllcyIgIH4gIkFydHMgJiBIdW1hbml0aWVzIiwNCiAgICBjKCJCaW9jaGVtaXN0cnksIEdlbmV0aWNzIGFuZCBNb2xlY3VsYXIgQmlvbG9neSIsIkFncmljdWx0dXJhbCBhbmQgQmlvbG9naWNhbCBTY2llbmNlcyIsDQogICAgICAiQ2hlbWljYWwgRW5naW5lZXJpbmciLCAiQ2hlbWlzdHJ5IiwgICJDb21wdXRlciBTY2llbmNlIiwgIkRlY2lzaW9uIFNjaWVuY2VzIiwNCiAgICAgICJFYXJ0aCBhbmQgUGxhbmV0YXJ5IFNjaWVuY2VzIiwgIkVuZXJneSIsICJFbmdpbmVlcmluZyIsICJFbnZpcm9ubWVudGFsIFNjaWVuY2UiLA0KICAgICAgIkltbXVub2xvZ3kgYW5kIE1pY3JvYmlvbG9neSIsICJNYXRlcmlhbHMgU2NpZW5jZSIsICJNYXRoZW1hdGljcyIsICJOZXVyb3NjaWVuY2UiLCANCiAgICAgICJQaHlzaWNzIGFuZCBBc3Ryb25vbXkiICkgfiAiU1RFTSIsDQogICAgYygiRGVudGlzdHJ5IiwgIkhlYWx0aCBQcm9mZXNzaW9ucyIsICJNZWRpY2luZSIpIH4gIk1lZGljaW5lIiwNCiAgICBjKCJCdXNpbmVzcywgTWFuYWdlbWVudCBhbmQgQWNjb3VudGluZyIsICJFY29ub21pY3MsIEVjb25vbWV0cmljcyBhbmQgRmluYW5jZSIsDQogICAgICAiUHN5Y2hvbG9neSIsICJTb2NpYWwgU2NpZW5jZXMiKSB+ICJTb2NpYWwgc2NpZW5jZXMiKSkNCg0KYGBgDQoNClNlbGVjdCByZWxldmFudCBjb2x1bW5zIGFuZCB0aWR5IGV2ZXJ5dGhpbmcgdXAsIGdldHRpbmcgdGhlIGxhdGVzdCBvYnNlcnZhdGlvbnMgZm9yIGVhY2gNCnByb2Zlc3NvcjsgYW5kIHRoZW4gYWxzbyBwb29saW5nIHRoZW0gaW50byBOIHllYXJzIHNpbmNlIGZpcnN0IHB1YjoNCmBgYHtyfQ0KcHJvZl9wYW5lbF9zZWwgPC0gcHJvZl9wYW5lbF9jb2EgJT4lDQogICMgYnV0IG5vdCAyMDI0DQogIGZpbHRlcih5ZWFyIDwgMjAyNCAmICFpcy5uYSh5ZWFyKSklPiUNCiAgZ3JvdXBfYnkocHJvZmlsZV9pZCklPiUNCiAgc2xpY2Uod2hpY2gubWF4KHllYXIpKSU+JQ0KICBzZWxlY3QoLWNvbnRhaW5zKCJfbCIpKSU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZDp5ZWFyc19zaW5jZV9maXJzdF9wdWIsIG92ZXJhbGxfZmllbGQ6b3ZlcmFsbF9zdWJmaWVsZCwgY291bnRfcHViczphdHRuX3R3aXR0ZXJfYnlfdG90YWwsIGxleGlzX25hdGlvbmFsOmxleGlzX2FsbF90b3RhbCkNCg0KIyB0aWR5IHVwIG1lbnRpb25zDQpwcm9mX3BhbmVsX3NlbCRvbmxpbmVfbmV3c190b3RhbCA8LSBwcm9mX3BhbmVsX3NlbCRhdHRuX25ld3NfYnlfdG90YWwgKyBwcm9mX3BhbmVsX3NlbCRhdHRuX2Jsb2dzX2J5X3RvdGFsDQpwcm9mX3BhbmVsX3NlbCR0d2l0dGVyX3RvdGFsIDwtIHByb2ZfcGFuZWxfc2VsJGF0dG5fdHdpdHRlcl9ieV90b3RhbA0KcHJvZl9wYW5lbF9zZWwkbmV3c190b3RhbCA8LSBwcm9mX3BhbmVsX3NlbCRsZXhpc19hbGxfdG90YWwNCg0KcHJvZl9wYW5lbF9zZWwkY2l0YXRpb25zX3RvdGFsIDwtIHByb2ZfcGFuZWxfc2VsJGNpdGVkX2J5X3RvdGFsX2FsbA0KcHJvZl9wYW5lbF9zZWwkcHVic190b3RhbCA8LSBwcm9mX3BhbmVsX3NlbCRjb3VudF9wdWJzX3RvdGFsDQoNCiMgcmVjb2RlIHRoZSBmaWVsZHMNCnByb2ZfcGFuZWxfc2VsIDwtIHByb2ZfcGFuZWxfc2VsICU+JSANCiAgbXV0YXRlKGdlbmVyYWxfZmllbGQgPSBjYXNlX21hdGNoKA0KICAgIG92ZXJhbGxfZmllbGQsDQogICAgIkFydHMgYW5kIEh1bWFuaXRpZXMiICB+ICJBcnRzICYgSHVtYW5pdGllcyIsDQogICAgYygiQmlvY2hlbWlzdHJ5LCBHZW5ldGljcyBhbmQgTW9sZWN1bGFyIEJpb2xvZ3kiLCJBZ3JpY3VsdHVyYWwgYW5kIEJpb2xvZ2ljYWwgU2NpZW5jZXMiLA0KICAgICAgIkNoZW1pY2FsIEVuZ2luZWVyaW5nIiwgIkNoZW1pc3RyeSIsICAiQ29tcHV0ZXIgU2NpZW5jZSIsICJEZWNpc2lvbiBTY2llbmNlcyIsDQogICAgICAiRWFydGggYW5kIFBsYW5ldGFyeSBTY2llbmNlcyIsICJFbmVyZ3kiLCAiRW5naW5lZXJpbmciLCAiRW52aXJvbm1lbnRhbCBTY2llbmNlIiwNCiAgICAgICJJbW11bm9sb2d5IGFuZCBNaWNyb2Jpb2xvZ3kiLCAiTWF0ZXJpYWxzIFNjaWVuY2UiLCAiTWF0aGVtYXRpY3MiLCAiTmV1cm9zY2llbmNlIiwgDQogICAgICAiUGh5c2ljcyBhbmQgQXN0cm9ub215IiApIH4gIlNURU0iLA0KICAgIGMoIkRlbnRpc3RyeSIsICJIZWFsdGggUHJvZmVzc2lvbnMiLCAiTWVkaWNpbmUiKSB+ICJNZWRpY2luZSIsDQogICAgYygiQnVzaW5lc3MsIE1hbmFnZW1lbnQgYW5kIEFjY291bnRpbmciLCAiRWNvbm9taWNzLCBFY29ub21ldHJpY3MgYW5kIEZpbmFuY2UiLA0KICAgICAgIlBzeWNob2xvZ3kiLCAiU29jaWFsIFNjaWVuY2VzIikgfiAiU29jaWFsIHNjaWVuY2VzIikpDQoNCiMgZ2V0IGdyb3VwcyBwZXIgeWVhcnMgc2luY2UgZW50cnkNCnByb2ZfcGFuZWxfc2VsJGVudHJ5X2JhdGNoIDwtIGN1dChwcm9mX3BhbmVsX3NlbCR5ZWFyc19zaW5jZV9maXJzdF9wdWIsIGJyZWFrcyA9IHNlcSgwLCA1MCwgYnk9MTApKQ0KcHJvZl9wYW5lbF9zZWwkeWVhcnNfc2luY2VfZW50cnkgPC0gcGFzdGUoInVwIHRvIiwgc3RyX3JlbW92ZShzdHJfc3BsaXRfaShhcy5jaGFyYWN0ZXIocHJvZl9wYW5lbF9zZWwkZW50cnlfYmF0Y2gpLCAiLCIsIDIpLCJdIikpDQpgYGANCg0KQW5kIG5vdyBsZWF2ZSBvbmx5IHRob3NlIHByb2Zlc3NvcnMgZm9yIHdob20gd2UgYWN0dWFsbHkgaGF2ZSBsZXhpcyBkYXRhOg0KYGBge3Igd2FybmluZyA9IEZ9DQojIG9uZXMgd2UgY29sbGVjdGVkDQpsZXhpc19saXN0IDwtIGFzLmRhdGEuZnJhbWUoc3RyX3JlbW92ZShsaXN0LmZpbGVzKHBhdGggPSAiLi4vbGV4aXNfY3Jhd2wvZG93bmxvYWRzL3ppcGZpbGVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm49IiouemlwIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsLm5hbWVzID0gRiksICIuemlwIikpDQpjb2xuYW1lcyhsZXhpc19saXN0KSA8LSAicHJvZmlsZV9pZCINCiMgbWludXMgb25lcyB0aGF0IGFyZSBpbmNvbXBsZXRlDQptaXNzaW5nX2luZGljZXMgPC0gcmVhZF9jc3YoIi4uL2xleGlzX2NyYXdsL21pc3NpbmdfaW5kaWNlcy5jc3YiKQ0KDQpsZXhpc19saXN0IDwtIGZpbHRlcihsZXhpc19saXN0LCAhIHByb2ZpbGVfaWQgJWluJSBtaXNzaW5nX2luZGljZXMkcHJvZmlsZV9pZCkNCg0KcHJvZl9wYW5lbF9maWx0ZXIgPC0gZmlsdGVyKHByb2ZfcGFuZWxfc2VsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cl9yZW1vdmUocHJvZmlsZV9pZCwgImh0dHBzOi8vd3d3Lm5hcmNpcy5ubC9wZXJzb24vUmVjb3JkSUQvIikgJWluJSBsZXhpc19saXN0JHByb2ZpbGVfaWQpDQoNCiMgb25jZSBhZ2Fpbiwgc2VsZWN0IHJlbGV2YW50IGZpZWxkcyBmb3IgY29udmVuaWVuY2UNCnByb2ZfcGFuZWxfZmlsdGVyIDwtIHByb2ZfcGFuZWxfZmlsdGVyICU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZDpvdmVyYWxsX2ZpZWxkLCBvbmxpbmVfbmV3c190b3RhbDp5ZWFyc19zaW5jZV9lbnRyeSkNCg0KcHJvZl9wYW5lbF9maWx0ZXJfcGxvdCA8LSBwcm9mX3BhbmVsX2ZpbHRlciAlPiUNCiAgcGl2b3RfbG9uZ2VyKG9ubGluZV9uZXdzX3RvdGFsOnB1YnNfdG90YWwsIG5hbWVzX3RvID0gIm1lYXN1cmUiLCB2YWx1ZXNfdG8gPSAibiIpIA0KYGBgDQoNCiMjIE1lYW5zIGNvbXBhcmlzb24NCg0KIyMjIE92ZXJhbGwNCmBgYHtyfQ0Kb3ZlcmFsbF9jb21wYXJpc29ucyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IDYsIG5yb3cgPSAxKSkNCmkgPC0gMQ0Kb3ZlcmFsbF9jb21wYXJpc29uc1tpLCAxXSA8LSAib3ZlcmFsbCINCm92ZXJhbGxfY29tcGFyaXNvbnNbaSwgMl0gPC0gcm91bmQod2lsY294LnRlc3QocHVic190b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1wcm9mX3BhbmVsX2ZpbHRlciwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0Kb3ZlcmFsbF9jb21wYXJpc29uc1tpLCAzXSA8LSByb3VuZCh3aWxjb3gudGVzdChjaXRhdGlvbnNfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9cHJvZl9wYW5lbF9maWx0ZXIsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCm92ZXJhbGxfY29tcGFyaXNvbnNbaSwgNF0gPC0gcm91bmQod2lsY294LnRlc3QobmV3c190b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1wcm9mX3BhbmVsX2ZpbHRlciwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0Kb3ZlcmFsbF9jb21wYXJpc29uc1tpLCA1XSA8LSByb3VuZCh3aWxjb3gudGVzdChvbmxpbmVfbmV3c190b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1wcm9mX3BhbmVsX2ZpbHRlciwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0Kb3ZlcmFsbF9jb21wYXJpc29uc1tpLCA2XSA8LSByb3VuZCh3aWxjb3gudGVzdCh0d2l0dGVyX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPXByb2ZfcGFuZWxfZmlsdGVyLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQoNCmNvbG5hbWVzKG92ZXJhbGxfY29tcGFyaXNvbnMpIDwtIGMoImZpZWxkIiwgInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuZXdzX3RvdGFsIiwgIm9ubGluZV9uZXdzX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiKQ0KDQoNCm92ZXJhbGxfY29tcGFyaXNvbnMNCmBgYA0KDQoNCiMjIyBXaXRoaW4gZmllbGRzDQoNCmBgYHtyfQ0KZmllbGRzIDwtIHVuaXF1ZShwcm9mX3BhbmVsX2ZpbHRlciRnZW5lcmFsX2ZpZWxkKQ0KZmllbGRzIDwtIGZpZWxkc1shaXMubmEoZmllbGRzKV0NCmZpZWxkX2NvbXBhcmlzb25zIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNywgbnJvdyA9IGxlbmd0aChmaWVsZHMpKSkNCg0KZm9yIChpIGluIDE6bGVuZ3RoKGZpZWxkcykpew0KICBmaWVsZCA8LSBmaWVsZHNbaV0NCiAgZGF0YSA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIA0KICAgICAgICAgICAgICAgICBnZW5lcmFsX2ZpZWxkID09IGZpZWxkKQ0KICBmaWVsZF9jb21wYXJpc29uc1tpLCAxXSA8LSBmaWVsZA0KICBmaWVsZF9jb21wYXJpc29uc1tpLCAyXSA8LSBucm93KGRhdGEpDQogIGZpZWxkX2NvbXBhcmlzb25zW2ksIDNdIDwtIHJvdW5kKHdpbGNveC50ZXN0KHB1YnNfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9jb21wYXJpc29uc1tpLCA0XSA8LSByb3VuZCh3aWxjb3gudGVzdChjaXRhdGlvbnNfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9jb21wYXJpc29uc1tpLCA1XSA8LSByb3VuZCh3aWxjb3gudGVzdChuZXdzX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgZmllbGRfY29tcGFyaXNvbnNbaSwgNl0gPC0gcm91bmQod2lsY294LnRlc3Qob25saW5lX25ld3NfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9jb21wYXJpc29uc1tpLCA3XSA8LSByb3VuZCh3aWxjb3gudGVzdCh0d2l0dGVyX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCn0NCg0KY29sbmFtZXMoZmllbGRfY29tcGFyaXNvbnMpIDwtIGMoImZpZWxkIiwicHJvZnMiLCAicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5ld3NfdG90YWwiLCAib25saW5lX25ld3NfdG90YWwiLCAidHdpdHRlcl90b3RhbCIpDQpmaWVsZF9jb21wYXJpc29ucw0KYGBgDQoNCiMjIyBXaXRoaW4geWVhciBncm91cHMNCmBgYHtyfQ0KeWVhcl9ncm91cHMgPC0gdW5pcXVlKHByb2ZfcGFuZWxfZmlsdGVyJHllYXJzX3NpbmNlX2VudHJ5KQ0KeWVhcl9ncm91cHMgPC0geWVhcl9ncm91cHNbISB5ZWFyX2dyb3VwcyA9PSAidXAgdG8gTkEiXQ0KeWVhcnMgPC0gYygidXAgdG8gMTAiLCJ1cCB0byAyMCIsICJ1cCB0byAzMCIsICJ1cCB0byA0MCIsICJ1cCB0byA1MCIpDQp5ZWFyX2dyb3VwcyA8LSB5ZWFyX2dyb3Vwc1tvcmRlcihtYXRjaCh5ZWFyX2dyb3Vwcyx5ZWFycykpXQ0KeWVhcl9ncm91cHNfY29tcGFyaXNvbnMgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSA3LCBucm93ID0gbGVuZ3RoKHllYXJfZ3JvdXBzKSkpDQoNCmZvciAoaSBpbiAxOmxlbmd0aCh5ZWFyX2dyb3Vwcykpew0KICB5ZWFyX2dyb3VwIDwtIHllYXJfZ3JvdXBzW2ldDQogIGRhdGEgPC0gZmlsdGVyKHByb2ZfcGFuZWxfZmlsdGVyLCANCiAgICAgICAgICAgICAgICAgeWVhcnNfc2luY2VfZW50cnkgPT0geWVhcl9ncm91cCkNCiAgDQogIHllYXJfZ3JvdXBzX2NvbXBhcmlzb25zW2ksIDFdIDwtIHllYXJfZ3JvdXANCiAgeWVhcl9ncm91cHNfY29tcGFyaXNvbnNbaSwgMl0gPC0gbnJvdyhkYXRhKQ0KICB5ZWFyX2dyb3Vwc19jb21wYXJpc29uc1tpLCAzXSA8LSByb3VuZCh3aWxjb3gudGVzdChwdWJzX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgeWVhcl9ncm91cHNfY29tcGFyaXNvbnNbaSwgNF0gPC0gcm91bmQod2lsY294LnRlc3QoY2l0YXRpb25zX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgeWVhcl9ncm91cHNfY29tcGFyaXNvbnNbaSwgNV0gPC0gcm91bmQod2lsY294LnRlc3QobmV3c190b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2NvbXBhcmlzb25zW2ksIDZdIDwtIHJvdW5kKHdpbGNveC50ZXN0KG9ubGluZV9uZXdzX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgeWVhcl9ncm91cHNfY29tcGFyaXNvbnNbaSwgN10gPC0gcm91bmQod2lsY294LnRlc3QodHdpdHRlcl90b3RhbCB+IGluZmVycmVkX2dlbmRlciwgZGF0YT1kYXRhLCBwYWlyZWQ9RkFMU0UpJHAudmFsdWUsIDUpDQp9DQoNCmNvbG5hbWVzKHllYXJfZ3JvdXBzX2NvbXBhcmlzb25zKSA8LSBjKCJmaWVsZCIsICJwcm9mcyIsICJwdWJzX3RvdGFsIiwgImNpdGF0aW9uc190b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmV3c190b3RhbCIsICJvbmxpbmVfbmV3c190b3RhbCIsICJ0d2l0dGVyX3RvdGFsIikNCnllYXJfZ3JvdXBzX2NvbXBhcmlzb25zDQpgYGANCg0KIyMgRGlzdHJpYnV0aW9ucyBjb21wYXJpc29uDQoNCiMjIyBPdmVyYWxsDQpgYGB7cn0NCm92ZXJhbGxfZGlzdF9jb21wYXJpc29ucyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IDcsIG5yb3cgPSAxKSkNCmkgPC0gMQ0Kd29tZW4gPC0gZmlsdGVyKHByb2ZfcGFuZWxfZmlsdGVyLCBpbmZlcnJlZF9nZW5kZXIgPT0gInciKQ0KbWVuIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgaW5mZXJyZWRfZ2VuZGVyID09ICJtIikNCg0Kb3ZlcmFsbF9kaXN0X2NvbXBhcmlzb25zW2ksIDFdIDwtICJvdmVyYWxsIg0Kb3ZlcmFsbF9kaXN0X2NvbXBhcmlzb25zW2ksIDJdIDwtIG5yb3cocHJvZl9wYW5lbF9maWx0ZXIpDQpvdmVyYWxsX2Rpc3RfY29tcGFyaXNvbnNbaSwgM10gPC0gcm91bmQoa3MudGVzdCh3b21lbiRwdWJzX3RvdGFsLCBtZW4kcHVic190b3RhbCkkcC52YWx1ZSwgNSkNCm92ZXJhbGxfZGlzdF9jb21wYXJpc29uc1tpLCA0XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJGNpdGF0aW9uc190b3RhbCwgbWVuJGNpdGF0aW9uc190b3RhbCkkcC52YWx1ZSwgNSkNCm92ZXJhbGxfZGlzdF9jb21wYXJpc29uc1tpLCA1XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJG5ld3NfdG90YWwsIG1lbiRuZXdzX3RvdGFsKSRwLnZhbHVlLCA1KQ0Kb3ZlcmFsbF9kaXN0X2NvbXBhcmlzb25zW2ksIDZdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kb25saW5lX25ld3NfdG90YWwsIG1lbiRvbmxpbmVfbmV3c190b3RhbCkkcC52YWx1ZSwgNSkNCm92ZXJhbGxfZGlzdF9jb21wYXJpc29uc1tpLCA3XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJHR3aXR0ZXJfdG90YWwsIG1lbiR0d2l0dGVyX3RvdGFsKSRwLnZhbHVlLCA1KQ0KDQpjb2xuYW1lcyhvdmVyYWxsX2Rpc3RfY29tcGFyaXNvbnMpIDwtIGMoIm92ZXJhbGwiLCAicHJvZnMiLCAicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5ld3NfdG90YWwiLCAib25saW5lX25ld3NfdG90YWwiLCAidHdpdHRlcl90b3RhbCIpDQoNCg0Kb3ZlcmFsbF9kaXN0X2NvbXBhcmlzb25zDQpgYGANCg0KDQojIyMgV2l0aGluIGZpZWxkcw0KDQpgYGB7cn0NCmZpZWxkcyA8LSB1bmlxdWUocHJvZl9wYW5lbF9maWx0ZXIkZ2VuZXJhbF9maWVsZCkNCmZpZWxkcyA8LSBmaWVsZHNbIWlzLm5hKGZpZWxkcyldDQpmaWVsZF9kaXN0X2NvbXBhcmlzb25zIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNywgbnJvdyA9IGxlbmd0aChmaWVsZHMpKSkNCg0KZm9yIChpIGluIDE6bGVuZ3RoKGZpZWxkcykpew0KICBmaWVsZCA8LSBmaWVsZHNbaV0NCiAgZGF0YSA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIA0KICAgICAgICAgICAgICAgICBnZW5lcmFsX2ZpZWxkID09IGZpZWxkKQ0KICB3b21lbiA8LSBmaWx0ZXIoZGF0YSwgaW5mZXJyZWRfZ2VuZGVyID09ICJ3IikNCiAgbWVuIDwtIGZpbHRlcihkYXRhLCBpbmZlcnJlZF9nZW5kZXIgPT0gIm0iKQ0KICANCiAgZmllbGRfZGlzdF9jb21wYXJpc29uc1tpLCAxXSA8LSBmaWVsZA0KICBmaWVsZF9kaXN0X2NvbXBhcmlzb25zW2ksIDJdIDwtIG5yb3coZGF0YSkNCiAgZmllbGRfZGlzdF9jb21wYXJpc29uc1tpLCAzXSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJHB1YnNfdG90YWwsIG1lbiRwdWJzX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9kaXN0X2NvbXBhcmlzb25zW2ksIDRdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kY2l0YXRpb25zX3RvdGFsLCBtZW4kY2l0YXRpb25zX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9kaXN0X2NvbXBhcmlzb25zW2ksIDVdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kbmV3c190b3RhbCwgbWVuJG5ld3NfdG90YWwpJHAudmFsdWUsIDUpDQogIGZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbaSwgNl0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRvbmxpbmVfbmV3c190b3RhbCwgbWVuJG9ubGluZV9uZXdzX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9kaXN0X2NvbXBhcmlzb25zW2ksIDddIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kdHdpdHRlcl90b3RhbCwgbWVuJHR3aXR0ZXJfdG90YWwpJHAudmFsdWUsIDUpDQp9DQoNCmNvbG5hbWVzKGZpZWxkX2Rpc3RfY29tcGFyaXNvbnMpIDwtIGMoImZpZWxkIiwicHJvZnMiLCAicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5ld3NfdG90YWwiLCAib25saW5lX25ld3NfdG90YWwiLCAidHdpdHRlcl90b3RhbCIpDQpmaWVsZF9kaXN0X2NvbXBhcmlzb25zDQpgYGANCg0KIyMjIFdpdGhpbiB5ZWFyIGdyb3Vwcw0KYGBge3J9DQp5ZWFyX2dyb3VwcyA8LSB1bmlxdWUocHJvZl9wYW5lbF9maWx0ZXIkeWVhcnNfc2luY2VfZW50cnkpDQp5ZWFyX2dyb3VwcyA8LSB5ZWFyX2dyb3Vwc1shIHllYXJfZ3JvdXBzID09ICJ1cCB0byBOQSJdDQp5ZWFycyA8LSBjKCJ1cCB0byAxMCIsInVwIHRvIDIwIiwgInVwIHRvIDMwIiwgInVwIHRvIDQwIiwgInVwIHRvIDUwIikNCnllYXJfZ3JvdXBzIDwtIHllYXJfZ3JvdXBzW29yZGVyKG1hdGNoKHllYXJfZ3JvdXBzLHllYXJzKSldDQp5ZWFyX2dyb3Vwc19kaXN0X2NvbXBhcmlzb25zIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gNywgbnJvdyA9IGxlbmd0aCh5ZWFyX2dyb3VwcykpKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgoeWVhcl9ncm91cHMpKXsNCiAgeWVhcl9ncm91cCA8LSB5ZWFyX2dyb3Vwc1tpXQ0KICBkYXRhIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgDQogICAgICAgICAgICAgICAgIHllYXJzX3NpbmNlX2VudHJ5ID09IHllYXJfZ3JvdXApDQogIA0KICB3b21lbiA8LSBmaWx0ZXIoZGF0YSwgaW5mZXJyZWRfZ2VuZGVyID09ICJ3IikNCiAgbWVuIDwtIGZpbHRlcihkYXRhLCBpbmZlcnJlZF9nZW5kZXIgPT0gIm0iKQ0KICANCiAgeWVhcl9ncm91cHNfZGlzdF9jb21wYXJpc29uc1tpLCAxXSA8LSB5ZWFyX2dyb3VwDQogIHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnNbaSwgMl0gPC0gbnJvdyhkYXRhKQ0KICB5ZWFyX2dyb3Vwc19kaXN0X2NvbXBhcmlzb25zW2ksIDNdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kcHVic190b3RhbCwgbWVuJHB1YnNfdG90YWwpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnNbaSwgNF0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRjaXRhdGlvbnNfdG90YWwsIG1lbiRjaXRhdGlvbnNfdG90YWwpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnNbaSwgNV0gPC0gcm91bmQoa3MudGVzdCh3b21lbiRuZXdzX3RvdGFsLCBtZW4kbmV3c190b3RhbCkkcC52YWx1ZSwgNSkNCiAgeWVhcl9ncm91cHNfZGlzdF9jb21wYXJpc29uc1tpLCA2XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJG9ubGluZV9uZXdzX3RvdGFsLCBtZW4kb25saW5lX25ld3NfdG90YWwpJHAudmFsdWUsIDUpDQogIHllYXJfZ3JvdXBzX2Rpc3RfY29tcGFyaXNvbnNbaSwgN10gPC0gcm91bmQoa3MudGVzdCh3b21lbiR0d2l0dGVyX3RvdGFsLCBtZW4kdHdpdHRlcl90b3RhbCkkcC52YWx1ZSwgNSkNCn0NCg0KY29sbmFtZXMoeWVhcl9ncm91cHNfZGlzdF9jb21wYXJpc29ucykgPC0gYygiZmllbGQiLCAicHJvZnMiLCAicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5ld3NfdG90YWwiLCAib25saW5lX25ld3NfdG90YWwiLCAidHdpdHRlcl90b3RhbCIpDQp5ZWFyX2dyb3Vwc19kaXN0X2NvbXBhcmlzb25zDQpgYGANCiMjIyBXaXRoaW4geWVhciBncm91cHMgYW5kIGZpZWxkcw0KYGBge3Igd2FybmluZyA9IEZ9DQp5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zIDwtIGRhdGEuZnJhbWUobWF0cml4KE5BLCBuY29sID0gOCwgbnJvdyA9IGxlbmd0aCh5ZWFyX2dyb3VwcykqbGVuZ3RoKGZpZWxkcykpKQ0Kcm93X2luZGV4IDwtIDANCg0KZm9yIChpIGluIDE6bGVuZ3RoKHllYXJfZ3JvdXBzKSl7DQogIHllYXJfZ3JvdXAgPC0geWVhcl9ncm91cHNbaV0NCiAgDQogIGZvciAoaiBpbiAxOmxlbmd0aChmaWVsZHMpKXsNCiAgICBmaWVsZCA8LSBmaWVsZHNbal0NCiAgICBkYXRhIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgDQogICAgICAgICAgICAgICAgICAgeWVhcnNfc2luY2VfZW50cnkgPT0geWVhcl9ncm91cCAmIGdlbmVyYWxfZmllbGQgPT0gZmllbGQpDQogICAgDQogICAgd29tZW4gPC0gZmlsdGVyKGRhdGEsIGluZmVycmVkX2dlbmRlciA9PSAidyIpDQogICAgbWVuIDwtIGZpbHRlcihkYXRhLCBpbmZlcnJlZF9nZW5kZXIgPT0gIm0iKQ0KICAgIA0KICAgIGlmIChsZW5ndGgodW5pcXVlKGRhdGEkaW5mZXJyZWRfZ2VuZGVyKSkgIT0gMil7DQogICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAxXSA8LSB5ZWFyX2dyb3VwDQogICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAyXSA8LSBmaWVsZA0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgM10gPC0gbnJvdyhkYXRhKQ0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNF0gPC0gTkENCiAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDVdIDwtIE5BDQogICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA2XSA8LSBOQQ0KICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgN10gPC0gTkENCiAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDhdIDwtIE5BDQogICAgfWVsc2V7DQogICAgICBpZiAobGVuZ3RoKHdoaWNoKGNvbFN1bXMoZGF0YVtjKCJvbmxpbmVfbmV3c190b3RhbCIsICJuZXdzX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwgInB1YnNfdG90YWwiKV0pID09IDApKSA+IDApew0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAxXSA8LSB5ZWFyX2dyb3VwDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDJdIDwtIGZpZWxkDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDNdIDwtIG5yb3coZGF0YSkNCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNF0gPC0gTkENCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNV0gPC0gTkENCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgNl0gPC0gTkENCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgN10gPC0gTkENCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgOF0gPC0gTkENCiAgICAgICAgDQogICAgICB9ZWxzZXsNCiAgICAgICAgeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29uc1tyb3dfaW5kZXgraiwgMV0gPC0geWVhcl9ncm91cA0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAyXSA8LSBmaWVsZA0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCAzXSA8LSBucm93KGRhdGEpDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDRdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kcHVic190b3RhbCwgbWVuJHB1YnNfdG90YWwpJHAudmFsdWUsIDUpDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDVdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kY2l0YXRpb25zX3RvdGFsLCBtZW4kY2l0YXRpb25zX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA2XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJG5ld3NfdG90YWwsIG1lbiRuZXdzX3RvdGFsKSRwLnZhbHVlLCA1KQ0KICAgICAgICB5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zW3Jvd19pbmRleCtqLCA3XSA8LSByb3VuZChrcy50ZXN0KHdvbWVuJG9ubGluZV9uZXdzX3RvdGFsLCBtZW4kb25saW5lX25ld3NfdG90YWwpJHAudmFsdWUsIDUpDQogICAgICAgIHllYXJfZ3JvdXBzX2ZpZWxkX2Rpc3RfY29tcGFyaXNvbnNbcm93X2luZGV4K2osIDhdIDwtIHJvdW5kKGtzLnRlc3Qod29tZW4kdHdpdHRlcl90b3RhbCwgbWVuJHR3aXR0ZXJfdG90YWwpJHAudmFsdWUsIDUpDQogICAgICB9DQogICAgfQ0KICB9DQogIHJvd19pbmRleCA8LSByb3dfaW5kZXggKyA0IA0KfQ0KDQpjb2xuYW1lcyh5ZWFyX2dyb3Vwc19maWVsZF9kaXN0X2NvbXBhcmlzb25zKSA8LSBjKCJ5ZWFyX2dyb3VwIiwgImZpZWxkIiwgInByb2ZzIiwgInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuZXdzX3RvdGFsIiwgIm9ubGluZV9uZXdzX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiKQ0KeWVhcl9ncm91cHNfZmllbGRfZGlzdF9jb21wYXJpc29ucw0KYGBgDQoNCiMjIEhpc3RvZ3JhbXMNCiMjIyBFbnRyeQ0KDQpHZXQgd29tZW4gY291bnRzIHBlciB5ZWFyIGdyb3VwIHRvIGNvbXBhcmU6DQpgYGB7cn0NCmNvdW50X3Byb2ZzIDwtIHByb2ZfcGFuZWxfZmlsdGVyX3Bsb3QgJT4lDQogIGZpbHRlcih5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiKSU+JQ0KICBncm91cF9ieShpbmZlcnJlZF9nZW5kZXIsIHllYXJzX3NpbmNlX2VudHJ5KSU+JQ0KICBzdW1tYXJpc2Uobl9nZW5kZXIgPSBuKCkpDQoNCmNvdW50X3Byb2ZzXzIgPC0gcHJvZl9wYW5lbF9maWx0ZXJfcGxvdCU+JQ0KICBmaWx0ZXIoeWVhcnNfc2luY2VfZW50cnkgIT0gInVwIHRvIE5BIiklPiUNCiAgZ3JvdXBfYnkoeWVhcnNfc2luY2VfZW50cnkpJT4lDQogIHN1bW1hcmlzZShuX2FsbCA9IG4oKSkNCg0KY291bnRfcHJvZnMgPC0gbWVyZ2UoY291bnRfcHJvZnMsDQogICAgICAgICAgICAgICAgICAgICBjb3VudF9wcm9mc18yLA0KICAgICAgICAgICAgICAgICAgICAgYnkgPSAieWVhcnNfc2luY2VfZW50cnkiKQ0KDQpjb3VudF9wcm9mcyRzaGFyZV9nZW5kZXIgPC0gcm91bmQoY291bnRfcHJvZnMkbl9nZW5kZXIgLyBjb3VudF9wcm9mcyRuX2FsbCAqIDEwMCwgMSkNCmNvdW50X3Byb2ZzJGxhYmVsX2dlbmRlciA8LSBpZmVsc2UoY291bnRfcHJvZnMkaW5mZXJyZWRfZ2VuZGVyID09ICJ3IiwgcGFzdGUwKCIlIHdvbWVuID0gIiwgY291bnRfcHJvZnMkc2hhcmVfZ2VuZGVyKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAiIikNCmBgYA0KDQpDb21wYXJlIGRpc3RyaWJ1dGlvbnMgYmV0d2VlbiBtZW4gYW5kIHdvbWVuOg0KDQoxLiBQdWJsaWNhdGlvbnMNCmBgYHtyIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD02LCB3YXJuaW5nPUZ9DQpwcm9mX3BhbmVsX2ZpbHRlcl9wbG90ICU+JQ0KICBmaWx0ZXIobWVhc3VyZSA9PSAicHVic190b3RhbCIgJiB5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiKSU+JQ0KICBnZ3Bsb3QoLiwgYWVzKHg9biwgY29sb3I9aW5mZXJyZWRfZ2VuZGVyKSkgKw0KICBnZW9tX2hpc3RvZ3JhbShmaWxsPSJ3aGl0ZSIsIHBvc2l0aW9uPSJkb2RnZSIsYmlucyA9IDQwKSsNCiAgc2NhbGVfeF9sb2cxMCgpKw0KICBnZW9tX3RleHQoZGF0YT1jb3VudF9wcm9mcywgYWVzKHggPSBjKHJlcCgyLCAyKSwgIHJlcCgzLCAyKSwgcmVwKDQsIDIpLCByZXAoOC41LCAyKSwgcmVwKDE3LCAyKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMocmVwKDEwLCAyKSwgIHJlcCgxMCwgMiksIHJlcCg2OCwgMiksIHJlcCgxNTAsIDIpLCByZXAoNDgsIDIpKSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9bGFiZWxfZ2VuZGVyKSwNCiAgICAgICAgICAgIHNpemUgPSAzLjUpKw0KICB4bGFiKCJMb2cgVG90YWwgUHVibGljYXRpb25zIikrDQogIHlsYWIoIkNvdW50IikrDQogIGxhYnMoY29sb3I9J0luZmVycmVkIGdlbmRlcicpKw0KICBnZ3RpdGxlKCJIaXN0b2dyYW1zOiB0b3RhbCBwdWJsaWNhdGlvbnMgc2luY2UgZW50cnkiKSsNCiAgZmFjZXRfd3JhcCguIH4geWVhcnNfc2luY2VfZW50cnksIG5yb3cgPSAyLCBzY2FsZXMgPSAiZnJlZSIpDQpgYGANCjIuIENpdGF0aW9ucw0KYGBge3IgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTYsIHdhcm5pbmc9Rn0NCnByb2ZfcGFuZWxfZmlsdGVyX3Bsb3QgJT4lDQogIGZpbHRlcihtZWFzdXJlID09ICJjaXRhdGlvbnNfdG90YWwiICYgeWVhcnNfc2luY2VfZW50cnkgIT0gInVwIHRvIE5BIiklPiUNCiAgZ2dwbG90KC4sIGFlcyh4PW4sIGNvbG9yPWluZmVycmVkX2dlbmRlcikpICsNCiAgZ2VvbV9oaXN0b2dyYW0oZmlsbD0id2hpdGUiLCBwb3NpdGlvbj0iZG9kZ2UiLGJpbnMgPSA0MCkrDQogIHNjYWxlX3hfbG9nMTAoKSsNCiAgZ2VvbV90ZXh0KGRhdGE9Y291bnRfcHJvZnMsIGFlcyh4ID0gYyhyZXAoNCwgMiksICByZXAoNiwgMiksIHJlcCg3LjUsIDIpLCByZXAoOSwgMiksIHJlcCgxNy41LCAyKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMocmVwKDUsIDIpLCAgcmVwKDgsIDIpLCByZXAoNTAsIDIpLCByZXAoMTEwLCAyKSwgcmVwKDQwLCAyKSksIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPWxhYmVsX2dlbmRlciksDQogICAgICAgICAgICBzaXplID0gMy41KSsNCiAgeGxhYigiTG9nIFRvdGFsIENpdGF0aW9ucyIpKw0KICB5bGFiKCJDb3VudCIpKw0KICBsYWJzKGNvbG9yPSdJbmZlcnJlZCBnZW5kZXInKSsNCiAgZ2d0aXRsZSgiSGlzdG9ncmFtczogdG90YWwgY2l0YXRpb25zIHNpbmNlIGVudHJ5IikrDQogIGZhY2V0X3dyYXAoLiB+IHllYXJzX3NpbmNlX2VudHJ5LCBucm93ID0gMiwgc2NhbGVzID0gImZyZWUiKQ0KYGBgDQozLiBMZXhpcyBuZXdzIHNvdXJjZXMNCg0KYGBge3IgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTYsIHdhcm5pbmcgPSBGfQ0KcHJvZl9wYW5lbF9maWx0ZXJfcGxvdCAlPiUNCiAgZmlsdGVyKG1lYXN1cmUgPT0gIm5ld3NfdG90YWwiICYgeWVhcnNfc2luY2VfZW50cnkgIT0gInVwIHRvIE5BIiklPiUNCiAgZ2dwbG90KC4sIGFlcyh4PW4sIGNvbG9yPWluZmVycmVkX2dlbmRlcikpICsNCiAgZ2VvbV9oaXN0b2dyYW0oZmlsbD0id2hpdGUiLCBwb3NpdGlvbj0iZG9kZ2UiLGJpbnMgPSA0MCkrDQogIHNjYWxlX3hfbG9nMTAoKSsNCiAgZ2VvbV90ZXh0KGRhdGE9Y291bnRfcHJvZnMsIGFlcyh4ID0gYyhyZXAoNSwgMiksICByZXAoMywgMiksIHJlcCg0LCAyKSwgcmVwKDQsIDIpLCByZXAoMywgMikpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjKHJlcCg1LCAyKSwgIHJlcCg3LCAyKSwgcmVwKDQ1LCAyKSwgcmVwKDgwLCAyKSwgcmVwKDMwLCAyKSksIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPWxhYmVsX2dlbmRlciksDQogICAgICAgICAgICBzaXplID0gMy41KSsNCiAgeGxhYigiTG9nIFRvdGFsIExleGlzIE1lbnRpb25zIikrDQogIHlsYWIoIkNvdW50IikrDQogIGxhYnMoY29sb3I9J0luZmVycmVkIGdlbmRlcicpKw0KICBnZ3RpdGxlKCJIaXN0b2dyYW1zOiB0b3RhbCBMZXhpcyBtZW50aW9ucyBzaW5jZSBlbnRyeSIpKw0KICBmYWNldF93cmFwKC4gfiB5ZWFyc19zaW5jZV9lbnRyeSwgbnJvdyA9IDIsIHNjYWxlcyA9ICJmcmVlIikNCmBgYA0KDQo0LiBPbmxpbmUgbmV3cyBhdHRlbnRpb24NCmBgYHtyIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD02LCB3YXJuaW5nID0gRn0NCnByb2ZfcGFuZWxfZmlsdGVyX3Bsb3QgJT4lDQogIGZpbHRlcihtZWFzdXJlID09ICJvbmxpbmVfbmV3c190b3RhbCIgJiB5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiKSU+JQ0KICBnZ3Bsb3QoLiwgYWVzKHg9biwgY29sb3I9aW5mZXJyZWRfZ2VuZGVyKSkgKw0KICBnZW9tX2hpc3RvZ3JhbShmaWxsPSJ3aGl0ZSIsIHBvc2l0aW9uPSJkb2RnZSIsYmlucyA9IDQwKSsNCiAgc2NhbGVfeF9sb2cxMCgpKw0KICBnZW9tX3RleHQoZGF0YT1jb3VudF9wcm9mcywgYWVzKHggPSBjKHJlcCgzLCAyKSwgIHJlcCgzLjUsIDIpLCByZXAoNSwgMiksIHJlcCg1LCAyKSwgcmVwKDYsIDIpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYyhyZXAoMTAsIDIpLCAgcmVwKDEwLCAyKSwgcmVwKDY4LCAyKSwgcmVwKDgwLCAyKSwgcmVwKDMwLCAyKSksIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPWxhYmVsX2dlbmRlciksDQogICAgICAgICAgICBzaXplID0gMy41KSsNCiAgeGxhYigiTG9nIFRvdGFsIE9ubGluZSBOZXdzIEZldHVyZXMiKSsNCiAgeWxhYigiQ291bnQiKSsNCiAgbGFicyhjb2xvcj0nSW5mZXJyZWQgZ2VuZGVyJykrDQogIGdndGl0bGUoIkhpc3RvZ3JhbXM6IHRvdGFsIG9ubGluZSBuZXdzIG1lbnRpb25zIHNpbmNlIGVudHJ5IikrDQogIGZhY2V0X3dyYXAoLiB+IHllYXJzX3NpbmNlX2VudHJ5LCBucm93ID0gMiwgc2NhbGVzID0gImZyZWUiKQ0KYGBgDQoNCjUuIFR3aXR0ZXIgYXR0ZW50aW9uDQpgYGB7ciBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9Niwgd2FybmluZyA9IEZ9DQpwcm9mX3BhbmVsX2ZpbHRlcl9wbG90ICU+JQ0KICBmaWx0ZXIobWVhc3VyZSA9PSAidHdpdHRlcl90b3RhbCIgJiB5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiKSU+JQ0KICBnZ3Bsb3QoLiwgYWVzKHg9biwgY29sb3I9aW5mZXJyZWRfZ2VuZGVyKSkgKw0KICBnZW9tX2hpc3RvZ3JhbShmaWxsPSJ3aGl0ZSIsIHBvc2l0aW9uPSJkb2RnZSIsYmlucyA9IDQwKSsNCiAgc2NhbGVfeF9sb2cxMCgpKw0KICBnZW9tX3RleHQoZGF0YT1jb3VudF9wcm9mcywgYWVzKHggPSBjKHJlcCgzNSwgMiksICByZXAoNCwgMiksIHJlcCg2LCAyKSwgcmVwKDYsIDIpLCByZXAoNiwgMikpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjKHJlcCg1LCAyKSwgIHJlcCg1LCAyKSwgcmVwKDIwLCAyKSwgcmVwKDQ1LCAyKSwgcmVwKDE1LCAyKSksIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPWxhYmVsX2dlbmRlciksDQogICAgICAgICAgICBzaXplID0gMy41KSsNCiAgeGxhYigiTG9nIFRvdGFsIFR3aXR0ZXIgRmV0dXJlcyIpKw0KICB5bGFiKCJDb3VudCIpKw0KICBsYWJzKGNvbG9yPSdJbmZlcnJlZCBnZW5kZXInKSsNCiAgZ2d0aXRsZSgiSGlzdG9ncmFtczogdG90YWwgdHdpdHRlciBtZW50aW9ucyBzaW5jZSBlbnRyeSIpKw0KICBmYWNldF93cmFwKC4gfiB5ZWFyc19zaW5jZV9lbnRyeSwgbnJvdyA9IDIsIHNjYWxlcyA9ICJmcmVlIikNCmBgYA0KDQojIyMgRmllbGQNCg0KR2V0IHdvbWVuIGNvdW50cyBwZXIgeWVhciBncm91cCB0byBjb21wYXJlOg0KYGBge3J9DQpjb3VudF9wcm9mcyA8LSBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90ICU+JQ0KICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBncm91cF9ieShpbmZlcnJlZF9nZW5kZXIsIGdlbmVyYWxfZmllbGQpJT4lDQogIHN1bW1hcmlzZShuX2dlbmRlciA9IG4oKSkNCg0KY291bnRfcHJvZnNfMiA8LSBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90JT4lDQogIGZpbHRlcighaXMubmEoZ2VuZXJhbF9maWVsZCkpJT4lDQogIGdyb3VwX2J5KGdlbmVyYWxfZmllbGQpJT4lDQogIHN1bW1hcmlzZShuX2FsbCA9IG4oKSkNCg0KY291bnRfcHJvZnMgPC0gbWVyZ2UoY291bnRfcHJvZnMsDQogICAgICAgICAgICAgICAgICAgICBjb3VudF9wcm9mc18yLA0KICAgICAgICAgICAgICAgICAgICAgYnkgPSAiZ2VuZXJhbF9maWVsZCIpDQoNCmNvdW50X3Byb2ZzJHNoYXJlX2dlbmRlciA8LSByb3VuZChjb3VudF9wcm9mcyRuX2dlbmRlciAvIGNvdW50X3Byb2ZzJG5fYWxsICogMTAwLCAxKQ0KY291bnRfcHJvZnMkbGFiZWxfZ2VuZGVyIDwtIGlmZWxzZShjb3VudF9wcm9mcyRpbmZlcnJlZF9nZW5kZXIgPT0gInciLCBwYXN0ZTAoIiUgd29tZW4gPSAiLCBjb3VudF9wcm9mcyRzaGFyZV9nZW5kZXIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICIiKQ0KYGBgDQpDb21wYXJlIGRpc3RyaWJ1dGlvbnMgYmV0d2VlbiBtZW4gYW5kIHdvbWVuOg0KDQoxLiBQdWJsaWNhdGlvbnMNCmBgYHtyIGZpZy53aWR0aD0xMiwgZmlnLmhlaWdodD00LCB3YXJuaW5nPUZ9DQpwcm9mX3BhbmVsX2ZpbHRlcl9wbG90ICU+JQ0KICBmaWx0ZXIobWVhc3VyZSA9PSAicHVic190b3RhbCIgJiB5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiICYgIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBnZ3Bsb3QoLiwgYWVzKHg9biwgY29sb3I9aW5mZXJyZWRfZ2VuZGVyKSkgKw0KICBnZW9tX2hpc3RvZ3JhbShmaWxsPSJ3aGl0ZSIsIHBvc2l0aW9uPSJkb2RnZSIsYmlucyA9IDQwKSsNCiAgc2NhbGVfeF9sb2cxMCgpKw0KICBnZW9tX3RleHQoZGF0YT1jb3VudF9wcm9mcywgYWVzKHggPSBjKHJlcCg2LjUsIDIpLCAgcmVwKDUuNSwgMiksIHJlcCg0LjUsIDIpLCByZXAoNSwgMikpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjKHJlcCgxOCwgMiksICByZXAoNzUsIDIpLCByZXAoODYsIDIpLCByZXAoMTIwLCAyKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9bGFiZWxfZ2VuZGVyKSwNCiAgICAgICAgICAgIHNpemUgPSAzLjUpKw0KICB4bGFiKCJMb2cgVG90YWwgUHVibGljYXRpb25zIikrDQogIHlsYWIoIkNvdW50IikrDQogIGxhYnMoY29sb3I9J0luZmVycmVkIGdlbmRlcicpKw0KICBnZ3RpdGxlKCJIaXN0b2dyYW1zOiB0b3RhbCBwdWJsaWNhdGlvbnMgc2luY2UgZW50cnkiKSsNCiAgZmFjZXRfd3JhcChnZW5lcmFsX2ZpZWxkIH4gLiwgbmNvbCA9IDQsIHNjYWxlcyA9ICJmcmVlIikNCmBgYA0KMi4gQ2l0YXRpb25zDQpgYGB7ciBmaWcud2lkdGg9MTIsIGZpZy5oZWlnaHQ9NCwgd2FybmluZz1GfQ0KcHJvZl9wYW5lbF9maWx0ZXJfcGxvdCAlPiUNCiAgZmlsdGVyKG1lYXN1cmUgPT0gImNpdGF0aW9uc190b3RhbCIgJiB5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiJiAhaXMubmEoZ2VuZXJhbF9maWVsZCkpJT4lDQogIGdncGxvdCguLCBhZXMoeD1uLCBjb2xvcj1pbmZlcnJlZF9nZW5kZXIpKSArDQogIGdlb21faGlzdG9ncmFtKGZpbGw9IndoaXRlIiwgcG9zaXRpb249ImRvZGdlIixiaW5zID0gNDApKw0KICBzY2FsZV94X2xvZzEwKCkrDQogIGdlb21fdGV4dChkYXRhPWNvdW50X3Byb2ZzLCBhZXMoeCA9IGMocmVwKDYuNSwgMiksICByZXAoMzAsIDIpLCByZXAoMTIsIDIpLCByZXAoMTAsIDIpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYyhyZXAoMTQsIDIpLCAgcmVwKDcwLCAyKSwgcmVwKDcwLCAyKSwgcmVwKDkwLCAyKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9bGFiZWxfZ2VuZGVyKSwNCiAgICAgICAgICAgIHNpemUgPSAzLjUpKw0KICB4bGFiKCJMb2cgVG90YWwgQ2l0YXRpb25zIikrDQogIHlsYWIoIkNvdW50IikrDQogIGxhYnMoY29sb3I9J0luZmVycmVkIGdlbmRlcicpKw0KICBnZ3RpdGxlKCJIaXN0b2dyYW1zOiB0b3RhbCBjaXRhdGlvbnMgc2luY2UgZW50cnkiKSsNCiAgZmFjZXRfd3JhcChnZW5lcmFsX2ZpZWxkIH4gLiwgbmNvbCA9IDQsIHNjYWxlcyA9ICJmcmVlIikNCmBgYA0KMy4gTGV4aXMgbmV3cyBzb3VyY2VzDQoNCmBgYHtyIGZpZy53aWR0aD0xMiwgZmlnLmhlaWdodD00LCB3YXJuaW5nPUZ9DQpwcm9mX3BhbmVsX2ZpbHRlcl9wbG90ICU+JQ0KICBmaWx0ZXIobWVhc3VyZSA9PSAibmV3c190b3RhbCIgJiB5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiJiAhaXMubmEoZ2VuZXJhbF9maWVsZCkpJT4lDQogIGdncGxvdCguLCBhZXMoeD1uLCBjb2xvcj1pbmZlcnJlZF9nZW5kZXIpKSArDQogIGdlb21faGlzdG9ncmFtKGZpbGw9IndoaXRlIiwgcG9zaXRpb249ImRvZGdlIixiaW5zID0gNDApKw0KICBzY2FsZV94X2xvZzEwKCkrDQogIGdlb21fdGV4dChkYXRhPWNvdW50X3Byb2ZzLCBhZXMoeCA9IGMocmVwKDQuNSwgMiksICByZXAoNCwgMiksIHJlcCg0LjUsIDIpLCByZXAoNC41LCAyKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMocmVwKDEyLCAyKSwgIHJlcCg0MCwgMiksIHJlcCg1MCwgMiksIHJlcCg1MCwgMikpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPWxhYmVsX2dlbmRlciksDQogICAgICAgICAgICBzaXplID0gMy41KSsNCiAgeGxhYigiTG9nIFRvdGFsIExleGlzIE1lbnRpb25zIikrDQogIHlsYWIoIkNvdW50IikrDQogIGxhYnMoY29sb3I9J0luZmVycmVkIGdlbmRlcicpKw0KICBnZ3RpdGxlKCJIaXN0b2dyYW1zOiB0b3RhbCBMZXhpcyBtZW50aW9ucyBzaW5jZSBlbnRyeSIpKw0KICBmYWNldF93cmFwKGdlbmVyYWxfZmllbGQgfiAuLCBuY29sID0gNCwgc2NhbGVzID0gImZyZWUiKQ0KYGBgDQoNCjQuIE9ubGluZSBuZXdzIGF0dGVudGlvbg0KYGBge3IgZmlnLndpZHRoPTEyLCBmaWcuaGVpZ2h0PTQsIHdhcm5pbmc9Rn0NCnByb2ZfcGFuZWxfZmlsdGVyX3Bsb3QgJT4lDQogIGZpbHRlcihtZWFzdXJlID09ICJvbmxpbmVfbmV3c190b3RhbCIgJiB5ZWFyc19zaW5jZV9lbnRyeSAhPSAidXAgdG8gTkEiJiAhaXMubmEoZ2VuZXJhbF9maWVsZCkpJT4lDQogIGdncGxvdCguLCBhZXMoeD1uLCBjb2xvcj1pbmZlcnJlZF9nZW5kZXIpKSArDQogIGdlb21faGlzdG9ncmFtKGZpbGw9IndoaXRlIiwgcG9zaXRpb249ImRvZGdlIixiaW5zID0gNDApKw0KICBzY2FsZV94X2xvZzEwKCkrDQogIGdlb21fdGV4dChkYXRhPWNvdW50X3Byb2ZzLCBhZXMoeCA9IGMocmVwKDIuNSwgMiksICByZXAoNS41LCAyKSwgcmVwKDUsIDIpLCByZXAoNSwgMikpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjKHJlcCgzMCwgMiksICByZXAoNDAsIDIpLCByZXAoNjUsIDIpLCByZXAoNjUsIDIpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1sYWJlbF9nZW5kZXIpLA0KICAgICAgICAgICAgc2l6ZSA9IDMuNSkrDQogIHhsYWIoIkxvZyBUb3RhbCBPbmxpbmUgTmV3cyBGZXR1cmVzIikrDQogIHlsYWIoIkNvdW50IikrDQogIGxhYnMoY29sb3I9J0luZmVycmVkIGdlbmRlcicpKw0KICBnZ3RpdGxlKCJIaXN0b2dyYW1zOiB0b3RhbCBvbmxpbmUgbmV3cyBtZW50aW9ucyBzaW5jZSBlbnRyeSIpKw0KICBmYWNldF93cmFwKGdlbmVyYWxfZmllbGQgfiAuLCBuY29sID0gNCwgc2NhbGVzID0gImZyZWUiKQ0KYGBgDQoNCjUuIFR3aXR0ZXIgYXR0ZW50aW9uDQpgYGB7ciBmaWcud2lkdGg9MTIsIGZpZy5oZWlnaHQ9NCwgd2FybmluZz1GfQ0KcHJvZl9wYW5lbF9maWx0ZXJfcGxvdCAlPiUNCiAgZmlsdGVyKG1lYXN1cmUgPT0gInR3aXR0ZXJfdG90YWwiICYgeWVhcnNfc2luY2VfZW50cnkgIT0gInVwIHRvIE5BIiYgIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICBnZ3Bsb3QoLiwgYWVzKHg9biwgY29sb3I9aW5mZXJyZWRfZ2VuZGVyKSkgKw0KICBnZW9tX2hpc3RvZ3JhbShmaWxsPSJ3aGl0ZSIsIHBvc2l0aW9uPSJkb2RnZSIsYmlucyA9IDQwKSsNCiAgc2NhbGVfeF9sb2cxMCgpKw0KICBnZW9tX3RleHQoZGF0YT1jb3VudF9wcm9mcywgYWVzKHggPSBjKHJlcCg0LCAyKSwgIHJlcCg3LCAyKSwgcmVwKDcsIDIpLCByZXAoNywgMikpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjKHJlcCgxMCwgMiksICByZXAoMjUsIDIpLCByZXAoMjUsIDIpLCByZXAoMzUsIDIpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD1sYWJlbF9nZW5kZXIpLA0KICAgICAgICAgICAgc2l6ZSA9IDMuNSkrDQogIHhsYWIoIkxvZyBUb3RhbCBUd2l0dGVyIEZldHVyZXMiKSsNCiAgeWxhYigiQ291bnQiKSsNCiAgbGFicyhjb2xvcj0nSW5mZXJyZWQgZ2VuZGVyJykrDQogIGdndGl0bGUoIkhpc3RvZ3JhbXM6IHRvdGFsIHR3aXR0ZXIgbWVudGlvbnMgc2luY2UgZW50cnkiKSsNCiAgZmFjZXRfd3JhcChnZW5lcmFsX2ZpZWxkIH4gLiwgbmNvbCA9IDQsIHNjYWxlcyA9ICJmcmVlIikNCmBgYA0KDQojIENERiBQbG90cw0KDQpQbG90dGluZyB0aGUgQ0RGczoNCmBgYHtyfQ0KZ2dwbG90KHByb2ZfcGFuZWxfZmlsdGVyX3Bsb3QsIGFlcyh4ID0gbiwgY29sID0gbWVhc3VyZSksbG9nPSd4JykrDQogIHN0YXRfZWNkZihsd2QgPSAxLjIpKw0KICBzY2FsZV94X2xvZzEwKCkrDQogIHhsYWIoIkxvZyhuKSIpKw0KICB5bGFiKCJFQ0RGIikNCmBgYA0KDQpCcmVhayB0aGlzIGRvd24gYnkgZ2VuZGVyOg0KYGBge3J9DQpjb2xzX29mX2ludGVyZXN0IDwtIGMoInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAibmV3c190b3RhbCIsICJvbmxpbmVfbmV3c190b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAgInR3aXR0ZXJfdG90YWwiKQ0KDQp0aXRsZXMgPC0gYygiVG90YWwgUHVibGljYXRpb25zIiwNCiAgICAgICAgICAgICAiVG90YWwgQ2l0YXRpb25zIiwNCiAgICAgICAgICAgICAiVG90YWwgTGV4aXMgbWVudGlvbnMiLA0KICAgICAgICAgICAgICJUb3RhbCBPbmxpbmUgTmV3cyBtZW50aW9ucyIsDQogICAgICAgICAgICAgIlRvdGFsIFR3aXR0ZXIgbWVudGlvbnMiKQ0KDQpjZGZfcGxvdHMgPC0gbGlzdCgpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChjb2xzX29mX2ludGVyZXN0KSl7DQogIA0KICBkYXRhIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlcl9wbG90LA0KICAgICAgICAgICAgICAgICBtZWFzdXJlID09IGNvbHNfb2ZfaW50ZXJlc3RbaV0pDQoNCiAgcGxvdGplIDwtIGdncGxvdChkYXRhLCBhZXMoeCA9IG4sIGNvbCA9IGluZmVycmVkX2dlbmRlciksbG9nPSd4JykrDQogICAgc3RhdF9lY2RmKGx3ZCA9IDEuMikrDQogICAgc2NhbGVfeF9sb2cxMCgpKw0KICAgIHhsYWIoIkxvZyhuKSIpKw0KICAgIHlsYWIoIkVDREYiKSsNCiAgICBnZ3RpdGxlKHRpdGxlc1tpXSkrDQogICAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcz1jKCJ3IiA9ICIjRTY5RjAwIiwgIm0iPSAiIzU2QjRFOSIpKSsNCiAgICB0aGVtZV9taW5pbWFsKCkNCiAgDQogIGNkZl9wbG90c1tbaV1dIDwtIHBsb3RqZQ0KfQ0KYGBgDQoNClBsb3QgdGhlIENERnMgbmV4dCB0byBlYWNoIG90aGVyOg0KYGBge3IgZmlnLndpZHRoPTYsIGZpZy5oZWlnaHQ9OCwgd2FybmluZyA9IEZ9DQpsZWdlbmQgPC0gZ2V0X2xlZ2VuZCgNCiAgIyBjcmVhdGUgc29tZSBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgbGVnZW5kDQogIGNkZl9wbG90c1tbMV1dDQopDQoNCihjb3dwbG90OjpwbG90X2dyaWQoY2RmX3Bsb3RzW1sxXV0gKyB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiKSwgDQogICAgICAgICAgIGNkZl9wbG90c1tbMl1dICsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIiksDQogICAgICAgICAgIGNkZl9wbG90c1tbM11dICsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIiksIA0KICAgICAgICAgICBjZGZfcGxvdHNbWzRdXSArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIpLA0KICAgICAgICAgICBjZGZfcGxvdHNbWzVdXSArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIpLA0KICAgICAgICAgICBsZWdlbmQsDQogICAgICAgICAgIG5jb2wgPSAyKSkNCmBgYA0KIyMgTG9nLWxvZyBwbG90cw0KDQojIyMgTG9nLWxvZyBvZiB0aGUgZnJlcXVlbmN5IGRpc3RyaWJ1dGlvbg0KYGBge3J9DQpjb2xzX29mX2ludGVyZXN0IDwtIGMoInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAibmV3c190b3RhbCIsICJvbmxpbmVfbmV3c190b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAgInR3aXR0ZXJfdG90YWwiKQ0KDQp0aXRsZXMgPC0gYygiVG90YWwgUHVibGljYXRpb25zIiwNCiAgICAgICAgICAgICAiVG90YWwgQ2l0YXRpb25zIiwNCiAgICAgICAgICAgICAiVG90YWwgTGV4aXMgbWVudGlvbnMiLA0KICAgICAgICAgICAgICJUb3RhbCBPbmxpbmUgTmV3cyBtZW50aW9ucyIsDQogICAgICAgICAgICAgIlRvdGFsIFR3aXR0ZXIgbWVudGlvbnMiKQ0KDQpwbG90dGluZ19hbGwgPC0gZGF0YS5mcmFtZShtYXRyaXgoTkEsIG5jb2wgPSA0LCBucm93ID0gMCkpDQpjb2xuYW1lcyhwbG90dGluZ19hbGwpIDwtIGMoIngiLCAicGsiLCAiayIsICJtZWFzdXJlIikNCg0KZm9yIChpIGluIDE6bGVuZ3RoKGNvbHNfb2ZfaW50ZXJlc3QpKXsNCiAgY29sdW1uX29mX2ludGVyZXN0IDwtIGNvbHNfb2ZfaW50ZXJlc3RbaV0NCiAgIyBvcmdhbml6ZSBkYXRhIGludG8gYSBkZg0KICB4IDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgIWlzLm5hKGdldChjb2x1bW5fb2ZfaW50ZXJlc3QpKSkNCiAgeCA8LSB4W1tjb2x1bW5fb2ZfaW50ZXJlc3RdXQ0KICB4IDwtIHNvcnQoeCwgZGVjcmVhc2luZyA9IFRSVUUpDQoNCiAgcGxvdHRpbmdfZGYgPC0gZGF0YS5mcmFtZSh4ID0geCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwayA8LSAxLWVjZGYoeCkoeCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgayA8LSBzZXFfYWxvbmcoeCkpDQogIA0KICBwbG90dGluZ19kZiRtZWFzdXJlIDwtIGNvbHVtbl9vZl9pbnRlcmVzdA0KICBjb2xuYW1lcyhwbG90dGluZ19kZikgPC0gYygieCIsICJwayIsICJrIiwgIm1lYXN1cmUiKQ0KICANCiAgcGxvdHRpbmdfYWxsIDwtIHJiaW5kKHBsb3R0aW5nX2FsbCwNCiAgICAgICAgICAgICAgICAgICAgICAgIHBsb3R0aW5nX2RmKQ0KDQp9DQpgYGANCg0KSGVyZSBpcyB0aGUgcGxvdDoNCmBgYHtyfQ0KcGxvdHRpbmdfYWxsICU+JQ0KICBnZ3Bsb3QoYWVzKHg9eCwgeSA9IHBrLCBjb2xvciA9IG1lYXN1cmUsIGdyb3VwID0gbWVhc3VyZSkpICsgZ2VvbV9wb2ludChhbHBoYT0wLjIpKw0KICBzY2FsZV94X2xvZzEwKCkrDQogIHNjYWxlX3lfbG9nMTAoKSsNCiAgeWxhYigiUHJvcG9ydGlvbiBvZiBwcm9mcyIpKw0KICB4bGFiKCJOdW1iZXIiKQ0KYGBgDQoNCiMjIyBGaXR0aW5nIGRpZmZlcmVudCBkaXN0cmlidXRpb25zIA0KDQpgYGB7cn0NCmNvbHNfb2ZfaW50ZXJlc3QgPC0gYygicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICJuZXdzX3RvdGFsIiwgIm9ubGluZV9uZXdzX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAidHdpdHRlcl90b3RhbCIpDQoNCnRpdGxlcyA8LSBjKCJUb3RhbCBQdWJsaWNhdGlvbnMiLA0KICAgICAgICAgICAgICJUb3RhbCBDaXRhdGlvbnMiLA0KICAgICAgICAgICAgICJUb3RhbCBMZXhpcyBtZW50aW9ucyIsDQogICAgICAgICAgICAgIlRvdGFsIE9ubGluZSBOZXdzIG1lbnRpb25zIiwNCiAgICAgICAgICAgICAiVG90YWwgVHdpdHRlciBtZW50aW9ucyIpDQoNCnBvd2VyX2xhd19wbG90cyA8LSBsaXN0KCkNCnBfdmFsdWVzIDwtIGxpc3QoKQ0KDQpmb3IgKGkgaW4gMTpsZW5ndGgoY29sc19vZl9pbnRlcmVzdCkpew0KICBjb2x1bW5fb2ZfaW50ZXJlc3QgPC0gY29sc19vZl9pbnRlcmVzdFtpXQ0KICAjIG9yZ2FuaXplIGRhdGEgaW50byBhIGRmDQogIHggPC0gZmlsdGVyKHByb2ZfcGFuZWxfZmlsdGVyLCAhaXMubmEoZ2V0KGNvbHVtbl9vZl9pbnRlcmVzdCkpKQ0KICB4IDwtIHhbW2NvbHVtbl9vZl9pbnRlcmVzdF1dDQogIA0KICB4IDwtIHhbIWlzLm5hKHgpXQ0KICB4IDwtIHhbeCAhPSAwXQ0KICAjIGZpdCBhIHBvd2VyIGxhdyBkaXN0cmlidXRpb24NCiAgcGxfZXN0IDwtIGRpc3BsJG5ldyh4KQ0KICBwbF9lc3Qkc2V0WG1pbihlc3RpbWF0ZV94bWluKHBsX2VzdCkpDQogICNwbF9lc3Qkc2V0WG1pbigxKQ0KICBwbF9lc3Qkc2V0UGFycyhlc3RpbWF0ZV9wYXJzKHBsX2VzdCkpDQogIA0KICAjIGZpdCBsb2ctbm9ybWFsIG1vZGVsDQogIGxuX2VzdCA8LSBkaXNsbm9ybSRuZXcoeCkNCiAgbG5fZXN0JHNldFhtaW4ocGxfZXN0JGdldFhtaW4oKSkNCiAgbG5fZXN0JHNldFBhcnMoZXN0aW1hdGVfcGFycyhsbl9lc3QpKQ0KICANCiAgIyBjb21wYXJlIHRoZSBkaXN0cmlidXRpb25zDQogIGNvbXAgPSBjb21wYXJlX2Rpc3RyaWJ1dGlvbnMocGxfZXN0LCBsbl9lc3QpDQogIHBfdmFsdWVzW1tpXV0gPC0gY29tcCRwX3R3b19zaWRlZA0KICANCiAgDQogIHBsb3QubmV3KCkgIyMgY2xlYW4gdXAgZGV2aWNlDQogICMjIFBsb3QgdGhlIGRhdGEgKGZyb20geG1pbikNCiAgcGxvdChwbF9lc3QsIHlsYWIgPSAiQ0RGIiwgeGxhYiA9ICJuIiwgIG1haW49dGl0bGVzW2ldKQ0KICAjIyBBZGQgaW4gdGhlIGZpdHRlZCBkaXN0cmlidXRpb24NCiAgbGluZXMocGxfZXN0LCBjb2wgPSAyKQ0KICBsaW5lcyhsbl9lc3QsIGNvbCA9IDMpDQogIHAgPC0gcmVjb3JkUGxvdCgpDQogIA0KICBwb3dlcl9sYXdfcGxvdHNbW2ldXSA8LSBwDQogIA0KICANCn0NCg0KYGBgDQoNCmBgYHtyIGZpZy53aWR0aD01LCBmaWcuaGVpZ2h0PTV9DQpwbG90Lm5ldygpDQpmb3IgKGkgaW4gMTpsZW5ndGgocG93ZXJfbGF3X3Bsb3RzKSl7DQogIHBsb3QgPC0gcG93ZXJfbGF3X3Bsb3RzW1tpXV0NCiAgI3Bsb3QubmV3KCkgDQogIHByaW50KHBsb3QpDQp9DQoNCnBfdmFsdWVzDQpgYGANCg0KIyMgU2hhcmUgd29tZW4gYXMgaW4gdGhlIFBOQVMgcGFwZXINCg0KR2V0IHRoZSB0b3AgMjUvMTUvNS8xJSBwZXIgZmllbGQ6DQpgYGB7cn0NCnRvcF8yNV9maWVsZCA8LSBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90ICU+JQ0KICBncm91cF9ieShnZW5lcmFsX2ZpZWxkLCBtZWFzdXJlKSU+JQ0KICBmaWx0ZXIocXVhbnRpbGUobiwgMC43NSwgbmEucm0gPSBUUlVFKTxuKSU+JQ0KICBzZWxlY3QoZ2VuZXJhbF9maWVsZCxwcm9maWxlX2lkLCBtZWFzdXJlKQ0KDQp0b3BfMjVfZmllbGQkdG9wXzI1IDwtICJ5ZXMiDQoNCnByb2ZfcGFuZWxfZmlsdGVyX3Bsb3RfdG9wIDwtIG1lcmdlKHByb2ZfcGFuZWxfZmlsdGVyX3Bsb3QsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BfMjVfZmllbGQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IGMoImdlbmVyYWxfZmllbGQiLCAicHJvZmlsZV9pZCIsICJtZWFzdXJlIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueCA9IFRSVUUpDQoNCnByb2ZfcGFuZWxfZmlsdGVyX3Bsb3RfdG9wJHRvcF8yNSA8LSBpZmVsc2UoaXMubmEocHJvZl9wYW5lbF9maWx0ZXJfcGxvdF90b3AkdG9wXzI1KSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5vIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl9wYW5lbF9maWx0ZXJfcGxvdF90b3AkdG9wXzI1KQ0KDQp0b3BfMTVfZmllbGQgPC0gcHJvZl9wYW5lbF9maWx0ZXJfcGxvdCAlPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgbWVhc3VyZSklPiUNCiAgZmlsdGVyKHF1YW50aWxlKG4sIDAuODUsIG5hLnJtID0gVFJVRSk8biklPiUNCiAgc2VsZWN0KGdlbmVyYWxfZmllbGQscHJvZmlsZV9pZCwgbWVhc3VyZSkNCg0KdG9wXzE1X2ZpZWxkJHRvcF8xNSA8LSAieWVzIg0KDQpwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCA8LSBtZXJnZShwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF8xNV9maWVsZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gYygiZ2VuZXJhbF9maWVsZCIsICJwcm9maWxlX2lkIiwgIm1lYXN1cmUiKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbC54ID0gVFJVRSkNCg0KcHJvZl9wYW5lbF9maWx0ZXJfcGxvdF90b3AkdG9wXzE1IDwtIGlmZWxzZShpcy5uYShwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCR0b3BfMTUpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibm8iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCR0b3BfMTUpDQoNCnRvcF81X2ZpZWxkIDwtIHByb2ZfcGFuZWxfZmlsdGVyX3Bsb3QgJT4lDQogIGdyb3VwX2J5KGdlbmVyYWxfZmllbGQsIG1lYXN1cmUpJT4lDQogIGZpbHRlcihxdWFudGlsZShuLCAwLjk1LCBuYS5ybSA9IFRSVUUpPG4pJT4lDQogIHNlbGVjdChnZW5lcmFsX2ZpZWxkLHByb2ZpbGVfaWQsIG1lYXN1cmUpDQoNCnRvcF81X2ZpZWxkJHRvcF81IDwtICJ5ZXMiDQoNCnByb2ZfcGFuZWxfZmlsdGVyX3Bsb3RfdG9wIDwtIG1lcmdlKHByb2ZfcGFuZWxfZmlsdGVyX3Bsb3RfdG9wLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wXzVfZmllbGQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IGMoImdlbmVyYWxfZmllbGQiLCAicHJvZmlsZV9pZCIsICJtZWFzdXJlIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueCA9IFRSVUUpDQoNCnByb2ZfcGFuZWxfZmlsdGVyX3Bsb3RfdG9wJHRvcF81IDwtIGlmZWxzZShpcy5uYShwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCR0b3BfNSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJubyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZfcGFuZWxfZmlsdGVyX3Bsb3RfdG9wJHRvcF81KQ0KDQp0b3BfMV9maWVsZCA8LSBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90ICU+JQ0KICBncm91cF9ieShnZW5lcmFsX2ZpZWxkLCBtZWFzdXJlKSU+JQ0KICBmaWx0ZXIocXVhbnRpbGUobiwgMC45OSwgbmEucm0gPSBUUlVFKTxuKSU+JQ0KICBzZWxlY3QoZ2VuZXJhbF9maWVsZCxwcm9maWxlX2lkLCBtZWFzdXJlKQ0KDQp0b3BfMV9maWVsZCR0b3BfMSA8LSAieWVzIg0KDQpwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCA8LSBtZXJnZShwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF8xX2ZpZWxkLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSBjKCJnZW5lcmFsX2ZpZWxkIiwgInByb2ZpbGVfaWQiLCAibWVhc3VyZSIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsLnggPSBUUlVFKQ0KDQpwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCR0b3BfMSA8LSBpZmVsc2UoaXMubmEocHJvZl9wYW5lbF9maWx0ZXJfcGxvdF90b3AkdG9wXzEpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibm8iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCR0b3BfMSkNCmBgYA0KDQojIyMgJSBvZiB3b21lbiBhbW9uZyBhbGwgcHJvZnMNClNoYXJlIG9mIHdvbWVuIGluIGdlbmVyYWwNCmBgYHtyfQ0KIyBzaGFyZSB3b21lbiBwZXIgbWVhc3VyZQ0KdG9wX2ZpZWxkX3NfdyA8LSBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCAlPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCwgbWVhc3VyZSklPiUNCiAgc3VtbWFyaXNlKGNvdW50ID0gc3VtKG4sIG5hLnJtID0gVFJVRSksDQogICAgICAgICAgICBuX3cgPSBzdW0obltpbmZlcnJlZF9nZW5kZXIgPT0gInciXSwgbmEucm0gPSBUUlVFKSklPiUNCiAgbXV0YXRlKHNoYXJlX3cgPSByb3VuZChuX3cgLyBjb3VudCwgMykqMTAwKQ0KDQojIHNoYXJlIHdvbWVuIGluIHBlciBmaWVsZA0Kc193X292ZXJhbGwgPC0gcHJvZl9wYW5lbF9maWx0ZXJfcGxvdCAlPiUNCiAgZmlsdGVyKCFpcy5uYShnZW5lcmFsX2ZpZWxkKSklPiUNCiAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCklPiUNCiAgc3VtbWFyaXNlKGNvdW50ID0gbigpLA0KICAgICAgICAgICAgbl93ID0gc3VtKGluZmVycmVkX2dlbmRlciA9PSAidyIpKSU+JQ0KICBtdXRhdGUoc2hhcmVfdyA9IHJvdW5kKG5fdyAvIGNvdW50LCAzKSoxMDApDQoNCnNfd19vdmVyYWxsJG1lYXN1cmUgPC0gIm92ZXJhbGwiDQpzX3dfb3ZlcmFsbCA8LSBzX3dfb3ZlcmFsbFtjb2xuYW1lcyh0b3BfZmllbGRfc193KV0NCg0KIyBtZXJnZQ0KdG9wX2ZpZWxkX3NfdyA8LSByYmluZCh0b3BfZmllbGRfc193LA0KICAgICAgICAgICAgICAgICAgICAgICAgICBzX3dfb3ZlcmFsbCkNCg0KY29sbmFtZXMoc193X292ZXJhbGwpWzVdIDwtICJzaGFyZV93X292ZXJhbGwiDQoNCnRvcF9maWVsZF9zX3cgPC0gbWVyZ2UodG9wX2ZpZWxkX3NfdywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNfd19vdmVyYWxsW2MoImdlbmVyYWxfZmllbGQiLCAic2hhcmVfd19vdmVyYWxsIildLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAiZ2VuZXJhbF9maWVsZCIpDQoNCnRvcF9maWVsZF9zX3ckc2hhcmVfd19vdmVyYWxsW2MoMjo2LCA4OjEyLCAxNDoxOCwgMjA6MjQpXSA8LSBOQQ0KDQpgYGANCg0KUGxvdCB0aGlzIG91dDoNCmBgYHtyfQ0KdG9wX2ZpZWxkX3NfdyRtZWFzdXJlIDwtIGZhY3Rvcih0b3BfZmllbGRfc193JG1lYXN1cmUsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMgPSBjKCJvdmVyYWxsIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwdWJzX3RvdGFsIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXRhdGlvbnNfdG90YWwiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5ld3NfdG90YWwiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9ubGluZV9uZXdzX3RvdGFsIiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ0d2l0dGVyX3RvdGFsIikpDQoNCnJlcHJfYWxsIDwtIHRvcF9maWVsZF9zX3cgJT4lDQogIGZpbHRlcihtZWFzdXJlICE9ICJvdmVyYWxsIiklPiUNCiAgZ2dwbG90KGFlcyh5PXNoYXJlX3csIHg9Z2VuZXJhbF9maWVsZCkpICsgDQogIGdlb21fcG9pbnQoYWVzKHNoYXBlPW1lYXN1cmUsIGNvbG9yPW1lYXN1cmUpLCBwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSh3aWR0aD0wLjIpLCBzdGF0PSJpZGVudGl0eSIpKw0KICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIGFlcyh5PXNoYXJlX3dfb3ZlcmFsbCwgeD1nZW5lcmFsX2ZpZWxkKSwgYWxwaGE9MC4yLCB3aWR0aCA9IDAuMikrDQogIGd1aWRlcyhmaWxsID0gZ3VpZGVfbGVnZW5kKHJldmVyc2U9VFJVRSwgdGl0bGUgPSAiTWVhc3VyZSIpKSsNCiAgY29vcmRfZmxpcCgpKw0KICB4bGFiKCJGaWVsZCIpKw0KICB5bGFiKCIlIFdvbWVuIikrDQogIGdndGl0bGUoIiUgb2Ygd29tZW4gY29tcGFyZWQgdG8gdGhlaXIgc2hhcmUgXG5hbW9uZyBwcm9mZXNzb3JzIikrDQogIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSkNCg0KYGBgDQoNCiMjIyAlIG9mIHdvbWVuIGluIHRvcCBuJSBvZiBwcm9mcw0KTm93LCBsb29rIGF0IHRoZSBzaGFyZSBvZiB3b21lbiBwZXIgdG9wIG46DQpgYGB7ciB3YXJuaW5nID0gRn0NCnBsb3R0aW5nX2xpc3QgPC0gYygidG9wXzI1IiwgInRvcF8xNSIsICJ0b3BfNSIsICJ0b3BfMSIpDQoNCmZvciAodG9wIGluIHBsb3R0aW5nX2xpc3Qpew0KICAjIHNoYXJlIHdvbWVuIHBlciBtZWFzdXJlDQogIHRvcF9uX2ZpZWxkX3NfdyA8LSBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCAlPiUNCiAgICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICAgIGZpbHRlcighIWFzLnN5bWJvbCh0b3ApICA9PSAieWVzIiklPiUNCiAgICBncm91cF9ieShnZW5lcmFsX2ZpZWxkLCBtZWFzdXJlKSU+JQ0KICAgIHN1bW1hcmlzZShuID0gbigpLA0KICAgICAgICAgICAgICBuX3cgPSBzdW0oaW5mZXJyZWRfZ2VuZGVyID09ICJ3IikpJT4lDQogICAgbXV0YXRlKHNoYXJlX3cgPSByb3VuZChuX3cgLyBuLCAzKSoxMDApDQogIA0KICAjIHNoYXJlIHdvbWVuIGluIHBlciBmaWVsZA0KICBzX3dfb3ZlcmFsbCA8LSBwcm9mX3BhbmVsX2ZpbHRlcl9wbG90X3RvcCAlPiUNCiAgICBmaWx0ZXIoIWlzLm5hKGdlbmVyYWxfZmllbGQpKSU+JQ0KICAgIGdyb3VwX2J5KGdlbmVyYWxfZmllbGQpJT4lDQogICAgc3VtbWFyaXNlKG4gPSBuKCksDQogICAgICAgICAgICAgIG5fdyA9IHN1bShpbmZlcnJlZF9nZW5kZXIgPT0gInciKSklPiUNCiAgICBtdXRhdGUoc2hhcmVfdyA9IHJvdW5kKG5fdyAvIG4sIDMpKjEwMCkNCiAgDQogIHNfd19vdmVyYWxsJG1lYXN1cmUgPC0gIm92ZXJhbGwiDQogIHNfd19vdmVyYWxsIDwtIHNfd19vdmVyYWxsW2NvbG5hbWVzKHRvcF9uX2ZpZWxkX3NfdyldDQogIA0KICAjIG1lcmdlDQogIHRvcF9uX2ZpZWxkX3NfdyA8LSByYmluZCh0b3Bfbl9maWVsZF9zX3csDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc193X292ZXJhbGwpDQogIA0KICBjb2xuYW1lcyhzX3dfb3ZlcmFsbClbNV0gPC0gInNoYXJlX3dfb3ZlcmFsbCINCiAgDQogIHRvcF9uX2ZpZWxkX3NfdyA8LSBtZXJnZSh0b3Bfbl9maWVsZF9zX3csDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc193X292ZXJhbGxbYygiZ2VuZXJhbF9maWVsZCIsICJzaGFyZV93X292ZXJhbGwiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAiZ2VuZXJhbF9maWVsZCIpDQogIA0KICB0b3Bfbl9maWVsZF9zX3ckc2hhcmVfd19vdmVyYWxsW2MoMjo2LCA4OjEyLCAxNDoxOCwgMjA6MjQpXSA8LSBOQQ0KICANCiAgdG9wX25fZmllbGRfc193JG1lYXN1cmUgPC0gZmFjdG9yKHRvcF9uX2ZpZWxkX3NfdyRtZWFzdXJlLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVscyA9IGMoIm92ZXJhbGwiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInB1YnNfdG90YWwiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdGF0aW9uc190b3RhbCIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmV3c190b3RhbCIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib25saW5lX25ld3NfdG90YWwiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInR3aXR0ZXJfdG90YWwiKSkNCiAgDQogIHJlcHJfdG9wX24gPC0gdG9wX25fZmllbGRfc193ICU+JQ0KICAgIGZpbHRlcihtZWFzdXJlICE9ICJvdmVyYWxsIiklPiUNCiAgICBnZ3Bsb3QoYWVzKHk9c2hhcmVfdywgeD1nZW5lcmFsX2ZpZWxkKSkgKyANCiAgICBnZW9tX3BvaW50KGFlcyhzaGFwZT1tZWFzdXJlLCBjb2xvcj1tZWFzdXJlKSwgcG9zaXRpb249cG9zaXRpb25fZG9kZ2Uod2lkdGg9MC4yKSwgc3RhdD0iaWRlbnRpdHkiKSsNCiAgICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIGFlcyh5PXNoYXJlX3dfb3ZlcmFsbCwgeD1nZW5lcmFsX2ZpZWxkKSwgYWxwaGE9MC4yLCB3aWR0aCA9IDAuMikrDQogICAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZT1UUlVFLCB0aXRsZSA9ICJNZWFzdXJlIikpKw0KICAgIGNvb3JkX2ZsaXAoKSsNCiAgICB4bGFiKCJGaWVsZCIpKw0KICAgIHlsYWIoIiUgV29tZW4iKSsNCiAgICBnZ3RpdGxlKHBhc3RlMCgiJSBvZiB3b21lbiBhbW9uZyB0b3AgIiwgc3RyX3JlbW92ZSh0b3AsInRvcF8iKSwgIiUgcHJvZnMgcGVyIG1lYXN1cmUgXG5jb21wYXJlZCB0byB0aGVpciBzaGFyZSBhbW9uZyBwcm9mZXNzb3JzIikpKw0KICAgIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSkNCiAgDQogIGFzc2lnbihwYXN0ZTAoInJlcHJfIiwgdG9wKSwgcmVwcl90b3BfbikNCiAgDQp9DQpgYGANCg0KUGxvdCB0aGlzIG91dDoNCmBgYHtyIGZpZy53aWR0aD0xMiwgZmlnLmhlaWdodD03LCB3YXJuaW5nID0gRn0NCmxlZ2VuZCA8LSBnZXRfbGVnZW5kKA0KICAjIGNyZWF0ZSBzb21lIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBsZWdlbmQNCiAgcmVwcl9hbGwNCikNCg0KKGNvd3Bsb3Q6OnBsb3RfZ3JpZChyZXByX2FsbCArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIpLCANCiAgICAgICAgICAgcmVwcl90b3BfMjUgKyB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUueT1lbGVtZW50X2JsYW5rKCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50ZXh0Lnk9ZWxlbWVudF9ibGFuaygpKSwNCiAgICAgICAgICAgcmVwcl90b3BfMTUgKyB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUueT1lbGVtZW50X2JsYW5rKCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50ZXh0Lnk9ZWxlbWVudF9ibGFuaygpKSwNCiAgICAgICAgICAgcmVwcl90b3BfNSArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIpLA0KICAgICAgICAgICByZXByX3RvcF8xICsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlLnk9ZWxlbWVudF9ibGFuaygpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGV4dC55PWVsZW1lbnRfYmxhbmsoKSksDQogICAgICAgICAgIGxlZ2VuZCwNCiAgICAgICAgICAgbmNvbCA9IDMsDQogICAgICAgICAgIHJlbF93aWR0aHMgPSBjKDEsIDAuNzUsIDAuNzUpKSkNCg0KIyBJJ20gc3VjaCBhbiBhcnRpc3QgOkQNCmBgYA0KDQojIFBBUEVSLUJBU0VEDQpgYGB7cn0NCnBvcnQgPC0gNTQzMg0KdXNlciA8LSAicG9zdGdyZXMiDQpwYXNzd29yZCA8LSAiZHV0Y2htZWRpYXByb2Zzc3FsIg0KZGF0YWJhc2VfbmFtZSA8LSAicG9zdGdyZXMiDQoNCmNvbiA8LSBSUG9zdGdyZXM6OmRiQ29ubmVjdChSUG9zdGdyZXM6OlBvc3RncmVzKCksDQogICAgICAgICAgICAgICAgIGRibmFtZT0gZGF0YWJhc2VfbmFtZSwNCiAgICAgICAgICAgICAgICAgcG9ydCA9IHBvcnQsDQogICAgICAgICAgICAgICAgIHVzZXIgPSB1c2VyLCANCiAgICAgICAgICAgICAgICAgcGFzc3dvcmQgPSBwYXNzd29yZCkNCmBgYA0KDQoNCkxvYWQgZGlmZmVyZW50IHR5cGVzIG9mIGF0dGVudGlvbjoNCmBgYHtyfQ0KcHViX25ld3MgPC0gZGJSZWFkVGFibGUoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfbmV3cyIpDQpwdWJfYmxvZ3MgPC0gZGJSZWFkVGFibGUoY29uLCAiYWx0bWV0cmljX3B1Yl9hdHRfYmxvZ3MiKQ0KdHdpdHRlcl9hdHRuIDwtIGRiR2V0UXVlcnkoY29uLCBzdGF0ZW1lbnQgPSAic2VsZWN0ICogZnJvbSBhbHRtZXRyaWNfcHJvZl9hdHRlbnRpb24gd2hlcmUgXCJtZW50aW9uX3R5cGVcIj0ndHdlZXQnIikNCmxleGlzX2RhdGEgPC0gZGJSZWFkVGFibGUoY29uLCAibGV4aXNfbmV4aXNfbWVudGlvbnMiKQ0KcHJvZl9nZW5kZXIgPC0gZGJSZWFkVGFibGUoY29uLCAiZ2VuZGVyX3RhYmxlIikNCiAgDQojIGdldCBzaW5nbGUgYXV0aG9yZWQgcGFwZXJzDQojIGxvYWRpbmcgdGhlIHBhcGVyIGluZm8NCm9hX3B1YnNfdW5pcXVlIDwtIGRiUmVhZFRhYmxlKGNvbiwgIm9hX3Byb2ZfcHVic191bmlxdWUiKQ0KI3Byb2YgLSBwdWIgbWF0Y2hpbmcNCm9hX3Byb2ZfcHViX21hdGNoaW5nIDwtIGRiUmVhZFRhYmxlKGNvbiwgIm9hX3Byb2ZfcHViX21hdGNoIikNCiMgcHJvZiB1bmlxdWUgcHViIGxpc3QgDQpvYV9wcm9mX3B1YnNfdW5pcXVlIDwtIG1lcmdlKG9hX3B1YnNfdW5pcXVlLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYV9wcm9mX3B1Yl9tYXRjaGluZ1tjKCJpZCIsICJhdV9pZCIsICJhdV9kaXNwbGF5X25hbWUiLCAicHJvZmlsZV9pZCIpXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsLnggPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueSA9IFRSVUUsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gImlkIikNCg0KY29hdXRob3JfaW5mbyA8LSBkYkdldFF1ZXJ5KGNvbiwgInNlbGVjdCBcImlkXCIsIFwiYXVfaWRcIiBGUk9NIG9hX2NvYXV0aG9yX2luZm87IikNCg0Kb2FfcHJvZl9wdWJzX3VuaXF1ZV9zaW5nbGVfYXUgPC0gZmlsdGVyKG9hX3Byb2ZfcHVic191bmlxdWUsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEgaWQgJWluJSBjb2F1dGhvcl9pbmZvJGlkKQ0KDQpgYGANCg0KTWVyZ2UgbGV4aXMgYW5kIHR3aXR0ZXIgZGF0YSB3aXRoIGdlbmRlcjoNCmBgYHtyfQ0KbGV4aXNfZGF0YSA8LSBtZXJnZShsZXhpc19kYXRhLCANCiAgICAgICAgICAgICAgICAgICAgcHJvZl9nZW5kZXJbYygicHJvZmlsZV9pZCIsICJpbmZlcnJlZF9nZW5kZXIiKV0sDQogICAgICAgICAgICAgICAgICAgIGJ5ID0gInByb2ZpbGVfaWQiKQ0KDQp0d2l0dGVyX2F0dG4gPC0gbWVyZ2UodHdpdHRlcl9hdHRuLA0KICAgICAgICAgICAgICAgICAgICAgIHByb2ZfZ2VuZGVyW2MoInByb2ZpbGVfaWQiLCAiaW5mZXJyZWRfZ2VuZGVyIildLA0KICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gInByb2ZpbGVfaWQiKQ0KYGBgDQoNCg0KVGlkeSB1cCB0aGUgYXR0ZW50aW9uIHNvdXJjZXM6DQpgYGB7cn0NCiMgbWVyZ2UgdGhlIHBhcGVycyB3aXRoIHRoZWlyIGF1dGhvcnMNCmF0dGVudGlvbl9uZXdzX3Byb2ZzIDwtIG1lcmdlKHB1Yl9uZXdzLA0KICAgICAgICAgICAgICAgICAgICAgICAgb2FfcHJvZl9wdWJfbWF0Y2hpbmdbYygiaWQiLCAicHJvZmlsZV9pZCIpXSwNCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gImlkIikNCg0KIyBtZXJnZSB0aGUgcGFwZXJzIHdpdGggdGhlaXIgYXV0aG9ycw0KYXR0ZW50aW9uX2Jsb2dzX3Byb2ZzIDwtIG1lcmdlKHB1Yl9ibG9ncywNCiAgICAgICAgICAgICAgICAgICAgICAgIG9hX3Byb2ZfcHViX21hdGNoaW5nW2MoImlkIiwgInByb2ZpbGVfaWQiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICBieSA9ICJpZCIpDQoNCiMgZ2V0IGEgeWVhciBmcm9tIHRoZSAicG9zdGVkIG9uIiBzdHJpbmcNCmF0dGVudGlvbl9uZXdzX3Byb2ZzJHllYXIgPC0geWVhcihhc19kYXRlKGF0dGVudGlvbl9uZXdzX3Byb2ZzJHBvc3RlZF9vbikpDQphdHRlbnRpb25fYmxvZ3NfcHJvZnMkeWVhciA8LSB5ZWFyKGFzX2RhdGUoYXR0ZW50aW9uX2Jsb2dzX3Byb2ZzJHBvc3RlZF9vbikpDQoNCiMgbWVyZ2UgdGhlc2UgdHdvIHRvZ2V0aGVyDQpvbmxpbmVfbmV3c19ibG9ncyA8LSByYmluZChhdHRlbnRpb25fbmV3c19wcm9mc1tjKCJpZCIsICJ0aXRsZSIsICJ1cmwiLCAicG9zdGVkX29uIiwgInN1bW1hcnkiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF1dGhvcl9uYW1lIiwgImF1dGhvcl91cmwiLCAicHJvZmlsZV9pZCIsICAieWVhciIgKV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbnRpb25fYmxvZ3NfcHJvZnNbYygiaWQiLCAidGl0bGUiLCAidXJsIiwgInBvc3RlZF9vbiIsICJzdW1tYXJ5IiwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdXRob3JfbmFtZSIsICJhdXRob3JfdXJsIiwgInByb2ZpbGVfaWQiLCAgInllYXIiICldKQ0KDQpvbmxpbmVfbmV3c19ibG9ncyA8LSBtZXJnZShvbmxpbmVfbmV3c19ibG9ncywgDQogICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9mX2dlbmRlcltjKCJwcm9maWxlX2lkIiwgImluZmVycmVkX2dlbmRlciIpXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gInByb2ZpbGVfaWQiKQ0KDQpgYGANCg0KR2V0IHByb2Zlc3NvciBnZW5kZXIgYXMgd2VsbCBhcyB0aGVpciBtYWluIGZpZWxkOg0KYGBge3J9DQojIGZldGNoIHRoZSB0b3BpY3MNCm9hX3B1YnNfdG9waWNzIDwtIGRiUmVhZFRhYmxlKGNvbiwgIm9hX3B1YnNfdG9waWNzIikNCg0Kb2FfcHVic190b3BpY3MgPC0gbWVyZ2Uob2FfcHJvZl9wdWJfbWF0Y2hpbmcsDQogICAgICAgICAgICAgICAgICAgICAgICBvYV9wdWJzX3RvcGljcywNCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gImlkIiwNCiAgICAgICAgICAgICAgICAgICAgICAgIGFsbC54ID0gVFJVRSkNCg0Kb2FfcHVic190b3BpY3MgPC0gbWVyZ2Uob2FfcHVic190b3BpY3MsDQogICAgICAgICAgICAgICAgICAgICAgICBvYV9wdWJzX3VuaXF1ZVtjKCJpZCIsICJwdWJsaWNhdGlvbl95ZWFyIildLA0KICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAiaWQiKQ0KDQojIGFuZCBnZXQgdGhlIGZpZWxkcw0KcHJvZl90b3RhbF9maWVsZCA8LSBvYV9wdWJzX3RvcGljcyAlPiUNCiAgZ3JvdXBfYnkocHJvZmlsZV9pZCwgZmllbGRfZGlzcGxheV9uYW1lKSAlPiUNCiAgc3VtbWFyaXNlKG4gPSBuKCkpJT4lDQogIHNsaWNlX21heChuLCB3aXRoX3RpZXMgPSBGQUxTRSklPiUNCiAgc2VsZWN0KC1uKQ0KDQpjb2xuYW1lcyhwcm9mX3RvdGFsX2ZpZWxkKVsyXSA8LSBjKCJvdmVyYWxsX2ZpZWxkIiApDQoNCiMgcmVjb2RlIHRoZSBmaWVsZHMNCnByb2ZfdG90YWxfZmllbGQgPC0gcHJvZl90b3RhbF9maWVsZCAlPiUgDQogIG11dGF0ZShnZW5lcmFsX2ZpZWxkID0gY2FzZV9tYXRjaCgNCiAgICBvdmVyYWxsX2ZpZWxkLA0KICAgICJBcnRzIGFuZCBIdW1hbml0aWVzIiAgfiAiQXJ0cyAmIEh1bWFuaXRpZXMiLA0KICAgIGMoIkJpb2NoZW1pc3RyeSwgR2VuZXRpY3MgYW5kIE1vbGVjdWxhciBCaW9sb2d5IiwiQWdyaWN1bHR1cmFsIGFuZCBCaW9sb2dpY2FsIFNjaWVuY2VzIiwNCiAgICAgICJDaGVtaWNhbCBFbmdpbmVlcmluZyIsICJDaGVtaXN0cnkiLCAgIkNvbXB1dGVyIFNjaWVuY2UiLCAiRGVjaXNpb24gU2NpZW5jZXMiLA0KICAgICAgIkVhcnRoIGFuZCBQbGFuZXRhcnkgU2NpZW5jZXMiLCAiRW5lcmd5IiwgIkVuZ2luZWVyaW5nIiwgIkVudmlyb25tZW50YWwgU2NpZW5jZSIsDQogICAgICAiSW1tdW5vbG9neSBhbmQgTWljcm9iaW9sb2d5IiwgIk1hdGVyaWFscyBTY2llbmNlIiwgIk1hdGhlbWF0aWNzIiwgIk5ldXJvc2NpZW5jZSIsIA0KICAgICAgIlBoeXNpY3MgYW5kIEFzdHJvbm9teSIgKSB+ICJTVEVNIiwNCiAgICBjKCJEZW50aXN0cnkiLCAiSGVhbHRoIFByb2Zlc3Npb25zIiwgIk1lZGljaW5lIikgfiAiTWVkaWNpbmUiLA0KICAgIGMoIkJ1c2luZXNzLCBNYW5hZ2VtZW50IGFuZCBBY2NvdW50aW5nIiwgIkVjb25vbWljcywgRWNvbm9tZXRyaWNzIGFuZCBGaW5hbmNlIiwNCiAgICAgICJQc3ljaG9sb2d5IiwgIlNvY2lhbCBTY2llbmNlcyIpIH4gIlNvY2lhbCBzY2llbmNlcyIpKQ0KYGBgDQoNCk1lcmdlIGF0dGVudGlvbiBhbmQgZmllbGQ6DQpgYGB7cn0NCm9ubGluZV9uZXdzX2Jsb2dzIDwtIG1lcmdlKG9ubGluZV9uZXdzX2Jsb2dzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl90b3RhbF9maWVsZFtjKCJwcm9maWxlX2lkIiwgImdlbmVyYWxfZmllbGQiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9ICJwcm9maWxlX2lkIikNCg0KIyBkZW5vdGUgaWYgc2luZ2xlLWF1dGhvcmVkIHBhcGVyDQpvbmxpbmVfbmV3c19ibG9ncyRzaW5nbGVfYXUgPC0gaWZlbHNlKG9ubGluZV9uZXdzX2Jsb2dzJGlkICVpbiUgb2FfcHJvZl9wdWJzX3VuaXF1ZV9zaW5nbGVfYXUkaWQsICJ5ZXMiLCAibm8iKQ0KDQpsZXhpc19kYXRhIDwtIG1lcmdlKGxleGlzX2RhdGEsDQogICAgICAgICAgICAgICAgICAgIHByb2ZfdG90YWxfZmllbGRbYygicHJvZmlsZV9pZCIsICJnZW5lcmFsX2ZpZWxkIildLA0KICAgICAgICAgICAgICAgICAgICBieSA9ICJwcm9maWxlX2lkIikNCg0KdHdpdHRlcl9hdHRuIDwtIG1lcmdlKHR3aXR0ZXJfYXR0biwNCiAgICAgICAgICAgICAgICAgICAgICBwcm9mX3RvdGFsX2ZpZWxkW2MoInByb2ZpbGVfaWQiLCAiZ2VuZXJhbF9maWVsZCIpXSwNCiAgICAgICAgICAgICAgICAgICAgICBieSA9ICJwcm9maWxlX2lkIikNCmBgYA0KDQpHZW5kZXIgaW5lcXVhbGl0eSBmb3Igc2luZ2xlIGF1dGhvcmVkIHBhcGVyczoNCmBgYHtyfQ0Kb25saW5lX2F0dF9hbGwgPC0gb25saW5lX25ld3NfYmxvZ3MgJT4lDQogIGdyb3VwX2J5KGluZmVycmVkX2dlbmRlciwgZ2VuZXJhbF9maWVsZCklPiUNCiAgc3VtbWFyaXNlKGFsbF9hdHRuID0gbigpKSU+JQ0KICBncm91cF9ieShnZW5lcmFsX2ZpZWxkKSU+JQ0KICBtdXRhdGUoc2hhcmVfYXR0biA9IGFsbF9hdHRuL3N1bShhbGxfYXR0bikpDQoNCmNvbG5hbWVzKG9ubGluZV9hdHRfYWxsKVsyXSA8LSAiZ2VuZXJhbF9maWVsZCINCg0Kc2hhcmVfcHJvZl9maWVsZCA8LSBtZXJnZShwcm9mX2dlbmRlciwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZl90b3RhbF9maWVsZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAicHJvZmlsZV9pZCIpJT4lDQogIGZpbHRlcighaXMubmEoZ2VuZXJhbF9maWVsZCkpJT4lDQogIGdyb3VwX2J5KGluZmVycmVkX2dlbmRlciwgZ2VuZXJhbF9maWVsZCklPiUNCiAgICBzdW1tYXJpc2UoYWxsX3Byb2YgPSBuKCkpJT4lDQogIGdyb3VwX2J5KGdlbmVyYWxfZmllbGQpJT4lDQogIG11dGF0ZShzaGFyZV9wcm9mID0gYWxsX3Byb2Yvc3VtKGFsbF9wcm9mKSkNCg0Kb25saW5lX2F0dF9hbGwgPC0gbWVyZ2Uob25saW5lX2F0dF9hbGwsDQogICAgICAgICAgICAgICAgICAgICAgICBzaGFyZV9wcm9mX2ZpZWxkLA0KICAgICAgICAgICAgICAgICAgICAgICAgYnk9IGMoImluZmVycmVkX2dlbmRlciIsICJnZW5lcmFsX2ZpZWxkIikpDQoNCm9ubGluZV9hdHRfYWxsX2F2ZyA8LSBvbmxpbmVfbmV3c19ibG9ncyAlPiUNCiAgZ3JvdXBfYnkocHJvZmlsZV9pZCwgaW5mZXJyZWRfZ2VuZGVyLCBnZW5lcmFsX2ZpZWxkKSU+JQ0KICBzdW1tYXJpc2UoY291bnQgPSBuKCkpJT4lDQogIGdyb3VwX2J5KGluZmVycmVkX2dlbmRlciwgZ2VuZXJhbF9maWVsZCklPiUNCiAgc3VtbWFyaXNlKG1lYW5fbiA9IG1lYW4oY291bnQsIG5hLnJtID0gVFJVRSksDQogICAgICAgICAgICBzZCA9IHNkKGNvdW50LCBuYS5ybSA9IFRSVUUpLA0KICAgICAgICAgICAgbiA9IG4oKSkgJT4lDQogIG11dGF0ZShzZSA9IHNkIC8gc3FydChuKSwNCiAgICAgICAgIGxvd2VyLmNpID0gbWVhbl9uIC0gcXQoMSAtICgwLjA1IC8gMiksIG4gLSAxKSAqIHNlLA0KICAgICAgICAgdXBwZXIuY2kgPSBtZWFuX24gKyBxdCgxIC0gKDAuMDUgLyAyKSwgbiAtIDEpICogc2UpDQoNCg0Kb25saW5lX2F0dF9zaW5nbGUgPC0gb25saW5lX25ld3NfYmxvZ3MgJT4lDQogICBmaWx0ZXIoc2luZ2xlX2F1ID09ICJ5ZXMiKSU+JQ0KICAgZ3JvdXBfYnkoaW5mZXJyZWRfZ2VuZGVyLCBnZW5lcmFsX2ZpZWxkKSU+JQ0KICAgc3VtbWFyaXNlKGFsbF9hdHRuID0gbigpKSU+JQ0KICAgZ3JvdXBfYnkoZ2VuZXJhbF9maWVsZCklPiUNCiAgIG11dGF0ZShzaGFyZSA9IGFsbF9hdHRuL3N1bShhbGxfYXR0bikpDQoNCmNvbG5hbWVzKG9ubGluZV9hdHRfc2luZ2xlKVsyXSA8LSAiZ2VuZXJhbF9maWVsZCINCg0Kb25saW5lX2F0dF9zaW5nbGUgPC0gbWVyZ2Uob25saW5lX2F0dF9zaW5nbGUsDQogICAgICAgICAgICAgICAgICAgICAgICBzaGFyZV9wcm9mX2ZpZWxkLA0KICAgICAgICAgICAgICAgICAgICAgICAgYnk9IGMoImluZmVycmVkX2dlbmRlciIsICJnZW5lcmFsX2ZpZWxkIikpDQoNCm9ubGluZV9hdHRfc2luZ2xlX2F2ZyA8LSBvbmxpbmVfbmV3c19ibG9ncyAlPiUNCiAgZmlsdGVyKHNpbmdsZV9hdSA9PSAieWVzIiklPiUNCiAgZ3JvdXBfYnkocHJvZmlsZV9pZCwgaW5mZXJyZWRfZ2VuZGVyLCBnZW5lcmFsX2ZpZWxkKSU+JQ0KICBzdW1tYXJpc2UoY291bnQgPSBuKCkpJT4lDQogIGdyb3VwX2J5KGluZmVycmVkX2dlbmRlciwgZ2VuZXJhbF9maWVsZCklPiUNCiAgc3VtbWFyaXNlKG1lYW5fbiA9IG1lYW4oY291bnQsIG5hLnJtID0gVFJVRSksDQogICAgICAgICAgICBzZCA9IHNkKGNvdW50LCBuYS5ybSA9IFRSVUUpLA0KICAgICAgICAgICAgbiA9IG4oKSkgJT4lDQogIG11dGF0ZShzZSA9IHNkIC8gc3FydChuKSwNCiAgICAgICAgIGxvd2VyLmNpID0gbWVhbl9uIC0gcXQoMSAtICgwLjA1IC8gMiksIG4gLSAxKSAqIHNlLA0KICAgICAgICAgdXBwZXIuY2kgPSBtZWFuX24gKyBxdCgxIC0gKDAuMDUgLyAyKSwgbiAtIDEpICogc2UpDQoNCmBgYA0KDQpQbG90IGF2ZXJhZ2UgYXR0ZW50aW9uIGNvdW50czoNCjEuIE92ZXJhbGwNCg0KU2hhcmVzDQpgYGB7cn0NCnNoYXJlX2F0dG5fYWxsIDwtIG9ubGluZV9hdHRfYWxsICU+JQ0KICBnZ3Bsb3QoYWVzKHg9YXMuZmFjdG9yKGdlbmVyYWxfZmllbGQpKSkgKw0KICBnZW9tX2JhcihhZXMoeT1zaGFyZV9hdHRuLCBmaWxsID0gYXMuZmFjdG9yKGluZmVycmVkX2dlbmRlcikpLCBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC45KSwgc3RhdD0iaWRlbnRpdHkiLCBhbHBoYT0wLjcpKw0KICBnZW9tX3BvaW50KGFlcyh5PXNoYXJlX3Byb2YsIGNvbG9yID0gYXMuZmFjdG9yKGluZmVycmVkX2dlbmRlcikpLCBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC45KSkNCmBgYA0KDQoNCkF2ZXJhZ2VzDQpgYGB7cn0NCmF2Z19hdHRuX2FsbCA8LW9ubGluZV9hdHRfYWxsX2F2ZyAlPiUNCmdncGxvdChhZXMoeD1hcy5mYWN0b3IoZ2VuZXJhbF9maWVsZCksIHk9bWVhbl9uKSkgKw0KICBnZW9tX2JhcihhZXMoZmlsbCA9IGFzLmZhY3RvcihpbmZlcnJlZF9nZW5kZXIpKSwgcG9zaXRpb24gPSBwb3NpdGlvbl9kb2RnZSh3aWR0aCA9IDAuOSksIHN0YXQ9ImlkZW50aXR5IiwgYWxwaGE9MC43KSsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeD1hcy5mYWN0b3IoZ2VuZXJhbF9maWVsZCksIHltaW49bG93ZXIuY2ksIHltYXg9dXBwZXIuY2ksIGdyb3VwID0gaW5mZXJyZWRfZ2VuZGVyKSwgd2lkdGg9MC4xLCBhbHBoYT0wLjksIHNpemU9MC42LCBwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSgxKSkNCmBgYA0KDQoyLiBTaW5nbGUgYXV0aG9yOg0KDQpTaGFyZXM6DQpgYGB7cn0NCnNoYXJlX2F0dG5fc2luZ2xlIDwtb25saW5lX2F0dF9zaW5nbGUgJT4lDQogIGdncGxvdChhZXMoeD1hcy5mYWN0b3IoZ2VuZXJhbF9maWVsZCkpKSArDQogIGdlb21fYmFyKGFlcyh5PXNoYXJlLCBmaWxsID0gYXMuZmFjdG9yKGluZmVycmVkX2dlbmRlcikpLCBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC45KSwgc3RhdD0iaWRlbnRpdHkiLCBhbHBoYT0wLjcpKw0KICBnZW9tX3BvaW50KGFlcyh5PXNoYXJlX3Byb2YsIGNvbG9yID0gYXMuZmFjdG9yKGluZmVycmVkX2dlbmRlcikpLCBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC45KSkNCmBgYA0KDQpBdmVyYWdlczoNCmBgYHtyfQ0KYXZnX2F0dG5fc2luZ2xlIDwtIG9ubGluZV9hdHRfc2luZ2xlX2F2ZyAlPiUNCmdncGxvdChhZXMoeD1hcy5mYWN0b3IoZ2VuZXJhbF9maWVsZCksIHk9bWVhbl9uKSkgKw0KICBnZW9tX2JhcihhZXMoZmlsbCA9IGFzLmZhY3RvcihpbmZlcnJlZF9nZW5kZXIpKSwgcG9zaXRpb24gPSBwb3NpdGlvbl9kb2RnZSh3aWR0aCA9IDAuOSksIHN0YXQ9ImlkZW50aXR5IiwgYWxwaGE9MC43KSsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeD1hcy5mYWN0b3IoZ2VuZXJhbF9maWVsZCksIHltaW49bG93ZXIuY2ksIHltYXg9dXBwZXIuY2ksIGdyb3VwID0gaW5mZXJyZWRfZ2VuZGVyKSwgd2lkdGg9MC4xLCBhbHBoYT0wLjksIHNpemU9MC42LCBwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSgxKSkNCmBgYA0KDQoNClNoYXJlcyBvZiBhdHRlbnRpb24gY29tYmluZWQ6DQpgYGB7ciBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9NH0NCmxlZ2VuZCA8LSBnZXRfbGVnZW5kKA0KICAjIGNyZWF0ZSBzb21lIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBsZWdlbmQNCiAgc2hhcmVfYXR0bl9hbGwrIGd1aWRlcyhmaWxsPWd1aWRlX2xlZ2VuZCh0aXRsZT0iU2hhcmUgYXR0ZW50aW9uIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I9Z3VpZGVfbGVnZW5kKHRpdGxlPSJTaGFyZSBwcm9mZXNzb3JzIikpDQopDQoNCmNvd3Bsb3Q6OnBsb3RfZ3JpZChzaGFyZV9hdHRuX2FsbCArIGdndGl0bGUoIkF0dG4uIHRvIGFsbCBwYXBlcnMiKSsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIikreWxhYigiU2hhcmUiKSt4bGFiKCJGaWVsZCIpLCANCiAgICAgICAgICAgICBzaGFyZV9hdHRuX3NpbmdsZSArIGdndGl0bGUoIkF0dG4uIHRvIHNpbmdsZSBhdXRob3IgcGFwZXJzIikreGxhYigiRmllbGQiKSsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIikreWxhYigiU2hhcmUiKSwNCiAgICAgICAgICAgICBsZWdlbmQsDQogICAgICAgICAgICAgcmVsX3dpZHRocyA9IGMoMSwgMSwgMC4zKSwNCiAgICAgICAgICAgICBucm93ID0gMSkNCmBgYA0KQXZlcmFnZSBtZW50aW9ucyBjb21iaW5lZDoNCmBgYHtyIGZpZy53aWR0aD0xMCwgZmlnLmhlaWdodD00fQ0KbGVnZW5kIDwtIGdldF9sZWdlbmQoDQogICMgY3JlYXRlIHNvbWUgc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGxlZ2VuZA0KICBhdmdfYXR0bl9hbGwrIGd1aWRlcyhmaWxsPWd1aWRlX2xlZ2VuZCh0aXRsZT0iQXZlcmFnZSBhdHRlbnRpb24iKSkNCikNCg0KY293cGxvdDo6cGxvdF9ncmlkKGF2Z19hdHRuX2FsbCArIGdndGl0bGUoIkF2Zy4gbWVudGlvbnMgLSBhbGwgcGFwZXJzIikrIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIpK3lsYWIoIlNoYXJlIikreGxhYigiRmllbGQiKSwgDQogICAgICAgICAgICAgYXZnX2F0dG5fc2luZ2xlICsgZ2d0aXRsZSgiQXZnLiBtZW50aW9ucyAtIHNpbmdsZSBhdXRob3IgcGFwZXJzIikreGxhYigiRmllbGQiKSsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIikreWxhYigiU2hhcmUiKSt5bGltKDAsMjUpLA0KICAgICAgICAgICAgIGxlZ2VuZCwNCiAgICAgICAgICAgICByZWxfd2lkdGhzID0gYygxLCAxLCAwLjMpLA0KICAgICAgICAgICAgIG5yb3cgPSAxKQ0KYGBgDQoNCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("Various_plots.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
