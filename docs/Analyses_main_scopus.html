<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ana Macanovic" />

<meta name="date" content="2024-05-15" />

<title>Various analyses - May 2024, final dataset</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a>
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="index.html">Code homepage</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="glyphicon glyphicon glyphicon glyphicon-list"></span>
     
    Scripts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="SQL_tutorial.html">Intro: SQL tutorial</a>
    </li>
    <li>
      <a href="OpenAlex_Altmetric_data_download.html">Prep. 1: Open Alex and Altmetric data download</a>
    </li>
    <li>
      <a href="Gender_inference.html">Prep. 2: Gender inference</a>
    </li>
    <li>
      <a href="Grant_parsing.html">Prep. 3: Grant parsing</a>
    </li>
    <li>
      <a href="Lexis_nexis_parser.html">Prep. 4: Lexis data parser</a>
    </li>
    <li>
      <a href="Panel_data_compilation.html">Prep. 5: Panel data compilation</a>
    </li>
    <li>
      <a href="Analyses_main.html">Main analyses</a>
    </li>
    <li>
      <a href="Supplement_data_information.html">Supplement 1: Database description and coverage</a>
    </li>
    <li>
      <a href="Data_coverage.html">Supplement 2: NARCIS and OA database comparison</a>
    </li>
    <li>
      <a href="Analyses_supplemental.html">Supplement 3: Additional analyses and robustness checks</a>
    </li>
    <li>
      <a href="News_classification_other_functions.html">Supplement 4: Additional resources and functions</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/amacanovic/dutch_media_profs">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Various analyses - May 2024, final
dataset</h1>
<h4 class="author">Ana Macanovic</h4>
<h4 class="date">2024-05-15</h4>

</div>


<p>Load the packages:</p>
<pre class="r"><code>source(&quot;helper_functions.R&quot;)

packages_to_load &lt;- c(&quot;readr&quot;, &quot;dplyr&quot;, &quot;tidyr&quot;, 
                      &quot;ggplot2&quot;, &quot;cowplot&quot;,
                      &quot;tidyverse&quot;, &quot;RPostgres&quot;, 
                      &quot;lubridate&quot;, &quot;lmtest&quot;, 
                      &quot;sandwich&quot;, &quot;ggpubr&quot;, 
                      &quot;knitr&quot;, &quot;scales&quot;, 
                      &quot;ggeffects&quot;, &quot;flextable&quot;, 
                      &quot;officer&quot;)

fpackage_check(packages_to_load)


# For full reproducibility, load the packages with groundhog using the code below instead
# of the fpackage_check function

# library(groundhog)
# groundhog.library(packages_to_load, date = &quot;2024-4-23&quot;)</code></pre>
<pre class="r"><code>opts_chunk$set(echo = TRUE)
opts_chunk$set(eval = FALSE)
opts_chunk$set(warning = FALSE)
opts_chunk$set(message = FALSE)</code></pre>
<p>Load the panel and tidy up some columns:</p>
<pre class="r"><code>prof_panel &lt;- read_csv(&quot;panel_datasets/prof_panel_tidy_26_7.csv&quot;)

prof_panel_filter &lt;- filter(prof_panel,
                            year &lt; 2024 &amp; !is.na(overall_adj_domain))

prof_panel_filter$coa_online_all_total &lt;- prof_panel_filter$coa_online_news_total + prof_panel_filter$coa_blogs_total
prof_panel_filter$coa_online_all_total_l &lt;- prof_panel_filter$coa_online_news_total_l + prof_panel_filter$coa_blogs_total_l
prof_panel_filter$coa_online_all &lt;- prof_panel_filter$coa_online_news + prof_panel_filter$coa_blogs
prof_panel_filter$coa_online_all_l &lt;- prof_panel_filter$coa_online_news_l + prof_panel_filter$coa_blogs_l

prof_panel_filter$coa_tot_online_all_total &lt;- prof_panel_filter$coa_tot_online_news_total + prof_panel_filter$coa_tot_blogs_total
prof_panel_filter$coa_tot_online_all_total_l &lt;- prof_panel_filter$coa_tot_online_news_total_l + prof_panel_filter$coa_tot_blogs_total_l
prof_panel_filter$coa_tot_online_all &lt;- prof_panel_filter$coa_tot_online_news + prof_panel_filter$coa_tot_blogs
prof_panel_filter$coa_tot_online_all_l &lt;- prof_panel_filter$coa_tot_online_news + prof_panel_filter$coa_tot_blogs_l

prof_panel_filter$coa_online_all &lt;- prof_panel_filter$coa_online_news + prof_panel_filter$coa_blogs</code></pre>
<div
id="average-numbers-of-mentions-and-comparison-per-gender-figure-1a"
class="section level1" number="1">
<h1><span class="header-section-number">1</span> Average numbers of
mentions and comparison per gender (Figure 1A)</h1>
<pre class="r"><code>sources_check &lt;- prof_panel_filter %&gt;%
  group_by(profile_id)%&gt;%
  filter(year == max(year) &amp; !is.na(overall_adj_domain))</code></pre>
<p>Within-field comparison:</p>
<pre class="r"><code>fields &lt;- unique(prof_panel_filter$overall_adj_domain)
fields &lt;- fields[!is.na(fields)]
field_comparisons &lt;- data.frame(matrix(NA, ncol = 7, nrow = length(fields)))

for (i in 1:length(fields)){
  field &lt;- fields[i]
  data &lt;- filter(sources_check, 
                 overall_adj_domain == field)
  field_comparisons[i, 1] &lt;- field
  field_comparisons[i, 2] &lt;- nrow(data)
  field_comparisons[i, 3] &lt;- round(t.test(count_pubs_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 4] &lt;- round(t.test(cited_by_total_all ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 5] &lt;- round(t.test(news_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 6] &lt;- round(t.test(alt_online_all_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
  field_comparisons[i, 7] &lt;- round(t.test(alt_twitter_total ~ inferred_gender, data=data, paired=FALSE)$p.value, 5)
}

colnames(field_comparisons) &lt;- c(&quot;field&quot;, &quot;profs&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                 &quot;total&quot;, &quot;online_total&quot;, &quot;twitter_total&quot;)
field_comparisons$comparison &lt;-  &quot;ttest&quot;


mean_values_field &lt;- sources_check %&gt;%
  filter(!is.na(overall_adj_domain))%&gt;%
  group_by(inferred_gender, overall_adj_domain)%&gt;%
  summarise(pubs_total = mean(count_pubs_total, na.rm = TRUE),
            citations_total = mean(cited_by_total_all, na.rm = TRUE),
            total = mean(news_all_total, na.rm = TRUE),
            online_total = mean(alt_online_all_total, na.rm = TRUE),
            twitter_total =  mean(alt_twitter_total, na.rm = TRUE))%&gt;%
  mutate(across(2:6, \(x) round(x, 2)))

#mean_values_field$field &lt;- &quot;overall&quot;
colnames(mean_values_field)[1] &lt;- &quot;comparison&quot;
colnames(mean_values_field)[2] &lt;- &quot;field&quot;
mean_values_field &lt;- mean_values_field[c(&quot;comparison&quot;, &quot;field&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                             &quot;total&quot;, &quot;online_total&quot;, &quot;twitter_total&quot;)]

field_comparisons &lt;- field_comparisons[c(&quot;comparison&quot;, &quot;field&quot;, &quot;pubs_total&quot;, &quot;citations_total&quot;,
                                             &quot;total&quot;, &quot;online_total&quot;, &quot;twitter_total&quot;)]

field_comparisons &lt;- rbind(mean_values_field,
                           field_comparisons)

field_comparisons &lt;- field_comparisons %&gt;%
  arrange(field)</code></pre>
<p>Plot the means comparison:</p>
<pre class="r"><code>field_comparisons_plot &lt;- filter(field_comparisons, comparison != &quot;ttest&quot;)

field_comparisons_plot$field &lt;- factor(field_comparisons_plot$field,
                                   levels = c(&quot;Physical Sciences&quot;,
                                              &quot;Life Sciences&quot;,
                                              &quot;Health Sciences&quot;,
                                              &quot;Social Sciences&quot;,
                                              &quot;Arts and Humanities&quot;))
field_comparisons_plot$comparison &lt;- ordered(field_comparisons_plot$comparison,
                                   levels = c(&quot;m&quot;, &quot;w&quot;))

significance_testing &lt;-  field_comparisons

significance_testing &lt;-  significance_testing %&gt;%
  filter(comparison == &quot;ttest&quot;)%&gt;%
  mutate_at(vars(`online_total`, `total`, `twitter_total`), .funs = list(
    ~case_when(
      . &lt;= 0.001 ~ &#39;***&#39;,
      . &lt;= 0.01 ~ &#39;**&#39;,
      . &lt;= 0.05 ~ &#39;*&#39;,
      . &lt;= 0.1 ~ &#39;.&#39;,
      . &gt; 0.1 ~ &#39;&#39;
    )))

significance_testing$field &lt;- factor(significance_testing$field,
                                   levels = c(&quot;Arts and Humanities&quot;,
                                              &quot;Social Sciences&quot;,
                                              &quot;Health Sciences&quot;,
                                              &quot;Life Sciences&quot;,
                                              &quot;Physical Sciences&quot;))
significance_testing &lt;- significance_testing %&gt;%
  arrange(field)

significance_testing$group1 &lt;- &quot;m&quot;
significance_testing$group2 &lt;- &quot;w&quot;
significance_testing$x &lt;- c(1,2,3,4, 5)
significance_testing$xmin &lt;- c(0.75,1.75,2.75,3.75, 4.75)
significance_testing$xmax &lt;- c(1.25,2.25, 3.25,4.25, 5.25)
significance_testing$comparison &lt;- &quot;m&quot;


average_news &lt;- field_comparisons_plot %&gt;%
   filter(comparison != &quot;ttest&quot;)%&gt;%
   ggplot(aes(x=fct_rev(field), y=total, fill = comparison)) + 
   geom_bar(position=position_dodge(.5),stat=&quot;identity&quot;, alpha=1, width = 0.5)+
   guides(fill = guide_legend(reverse = FALSE, title = &quot;Inferred gender&quot;))+
   scale_fill_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;) , labels = c(&quot;Men&quot;, &quot;Women&quot;))+
   ggtitle(&quot;Printed news attention&quot;)+
   stat_pvalue_manual(
     significance_testing,
     y.position = c(95, 158, 100, 80, 100),
     label.size = 3,
     coord.flip = TRUE,
     tip.length = 0.005,
     label = &quot;{total}&quot;,
     remove.bracket = FALSE,
     hide.ns = TRUE
   )+
  scale_y_continuous(limits = c(0, 160), breaks = seq(0, 160, by = 40))+
   ylab(&quot;Average mentions over lifetime&quot;)+
  xlab(&quot;Field&quot;)+
   labs(color = &quot;Inferred gender&quot;)+
   theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))+
  coord_flip()
 
average_online &lt;- field_comparisons_plot %&gt;%
   filter(comparison != &quot;ttest&quot;)%&gt;%
   ggplot(aes(x=fct_rev(field), y=online_total, fill = comparison)) + 
   geom_bar(position=position_dodge(.5),stat=&quot;identity&quot;, alpha=1, width = 0.5)+
   guides(fill = guide_legend(reverse = FALSE, title = &quot;Inferred gender&quot;))+
   scale_fill_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;) , labels = c(&quot;Men&quot;, &quot;Women&quot;))+
   ggtitle(&quot;Online news attention&quot;)+
  scale_y_continuous(limits = c(0, 212), breaks = seq(0, 212, by = 53))+
   stat_pvalue_manual(
     significance_testing,
     y.position = c(11, 43, 209, 170, 112),
     label.size = 3,
     coord.flip = TRUE,
     tip.length = 0.005,
     label = &quot;{online_total}&quot;,
   )+
   ylab(&quot;Average mentions over lifetime&quot;)+
   labs(color = &quot;Inferred gender&quot;)+
   theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))+
  coord_flip()+
  xlab(&quot;Field&quot;)


average_twitter &lt;- field_comparisons_plot %&gt;%
   filter(comparison != &quot;ttest&quot;)%&gt;%
   ggplot(aes(x=fct_rev(field), y=twitter_total, fill = comparison)) + 
   geom_bar(position=position_dodge(.5),stat=&quot;identity&quot;, alpha=1, width = 0.5)+
   guides(fill = guide_legend(reverse = FALSE, title = &quot;Inferred gender&quot;))+
   scale_fill_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;) , labels = c(&quot;Men&quot;, &quot;Women&quot;))+
   ggtitle(&quot;Twitter/X attention&quot;)+
   stat_pvalue_manual(
     significance_testing,
     y.position = c(50, 200, 1120, 1010, 440),
     label.size = 3,
     coord.flip = TRUE,
     tip.length = 0.005,
     label = &quot;{twitter_total}&quot;,
     remove.bracket = FALSE,
   )+
    scale_y_continuous(limits = c(0, 1200), breaks = seq(0, 1200, by = 300))+
   ylab(&quot;Average mentions over lifetime&quot;)+
   labs(color = &quot;Inferred gender&quot;)+
   theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))+
  coord_flip()+
  xlab(&quot;Field&quot;)</code></pre>
<p>Combine these plots into one (Figure 1, panel A):</p>
<pre class="r"><code>legend_average &lt;- get_legend(
  # create some space to the left of the legend
  average_news
)

combi_plot_averages &lt;- plot_grid(average_news + 
                                   theme(legend.position=&quot;none&quot;, 
                                         axis.title.x = element_blank(),
                                         axis.title.y=element_blank())
                                 + panel_border(), 
                                 average_online + theme(legend.position=&quot;none&quot;,
                                                        axis.title.x = element_blank(),
                                                        axis.title.y=element_blank(),
                                                        axis.text.y = element_blank())
                                 + panel_border(), 
                                 average_twitter + theme(legend.position=&quot;none&quot;,
                                                         axis.title.y=element_blank(),
                                                         axis.title.x = element_blank(),
                                                         axis.text.y = element_blank())
                                 + panel_border(), 
                                 legend_average,
                                 ncol = 4,
                                 rel_widths = c(1.3, 0.9, 0.9, 0.4))

combi_plot_averages</code></pre>
</div>
<div id="womens-representation-figure-1b" class="section level1"
number="2">
<h1><span class="header-section-number">2</span> Women’s representation
(Figure 1B)</h1>
<p>First, get representation per field in our dataset: (6791
professors)</p>
<pre class="r"><code>repr_field_2023 &lt;- prof_panel_filter %&gt;%
  group_by(profile_id)%&gt;%
  filter(year == max(year))%&gt;%
  filter(!is.na(overall_adj_domain))%&gt;%
  group_by(overall_adj_domain, inferred_gender)%&gt;%
  summarise(n = n())%&gt;%
  pivot_wider(values_from = n, names_from = inferred_gender)

repr_field_2023$share_women_field &lt;- repr_field_2023$w/(repr_field_2023$m+repr_field_2023$w)</code></pre>
<div id="among-top-n-researchers" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Among top N
researchers</h2>
<p>Now get the representation of women among the top 10% and 20% of
researchers in terms of total fame in their field in 2023 (based on
their entry batch):</p>
<pre class="r"><code># first, get the latest year in the panel for each prof
women_field_2023 &lt;- prof_panel_filter %&gt;%
  group_by(profile_id)%&gt;%
  filter(year == max(year))

# and now set the final year as 2023, assuming there was no attention after
# whatever the last year is in the dataset (quite some professors with
# 0 mentions even in this last year, so we want to keep them for correct
# shares)
women_field_2023$year &lt;- 2023

# get their decile based on their total performance within their genderal field
women_field_2023 &lt;- women_field_2023 %&gt;%
  filter(!is.na(overall_adj_domain))%&gt;%
  select(profile_id, year, inferred_gender, overall_adj_domain, count_pubs_total,
         cited_by_total_all, alt_online_all_total, news_all_total, alt_twitter_total)%&gt;%
  replace(is.na(.), 0)%&gt;%
  group_by(overall_adj_domain)%&gt;%
  mutate(`News` = ntile(-news_all_total, 10),
         `Online news` = ntile(-alt_online_all_total, 10),
         `Twitter` = ntile(-alt_twitter_total, 10))</code></pre>
<p>Get shares of women among top n% scientists per attention domain:</p>
<pre class="r"><code># rearrange the dataset to get counts of women and men in each decile
# then leave only top 10 and 20
share_women_field_2023 &lt;- women_field_2023 %&gt;%
  ungroup()%&gt;%
  select(profile_id, year, inferred_gender, overall_adj_domain, `News`:`Twitter`)%&gt;%
  pivot_longer(`News`:`Twitter`)%&gt;%
  group_by(overall_adj_domain, inferred_gender, name, value)%&gt;%
  summarise(n = n())%&gt;%
  pivot_wider(values_from = n, names_from = inferred_gender)%&gt;%
  replace(is.na(.), 0)%&gt;%
  group_by(overall_adj_domain, name)%&gt;%
  mutate(m = cumsum(m),
         w = cumsum(w))%&gt;%
  filter(value %in% c(1, 2))
 
share_women_field_2023$share_women &lt;- share_women_field_2023$w/(share_women_field_2023$m+share_women_field_2023$w) </code></pre>
<p>Combine the field representation with the attention
representation:</p>
<pre class="r"><code>repr_field_2023$name &lt;- &quot;overall&quot;
repr_field_2023$value &lt;- 0

repr_field_2023 &lt;- repr_field_2023[c(colnames(share_women_field_2023)[1:5],&quot;share_women_field&quot;)]

share_women_field_2023 &lt;- merge(share_women_field_2023,
                                repr_field_2023[c(&quot;overall_adj_domain&quot;, &quot;share_women_field&quot;)],
                                by = &quot;overall_adj_domain&quot;)

share_women_field_2023$share_women_field &lt;- ifelse(share_women_field_2023$name == &quot;News&quot;,
                                                   share_women_field_2023$share_women_field,
                                                   NA)</code></pre>
<p>Plot this out:</p>
<p>Top 10%:</p>
<pre class="r"><code>share_women_field_2023$overall_adj_domain &lt;- factor(share_women_field_2023$overall_adj_domain,
                                                    levels = c(&quot;Physical Sciences&quot;,
                                                               &quot;Life Sciences&quot;,
                                                               &quot;Health Sciences&quot;,
                                                               &quot;Social Sciences&quot;,
                                                               &quot;Arts and Humanities&quot;))

repr_attn_10 &lt;- share_women_field_2023 %&gt;%
  filter(value == 1 &amp; name %in% c(&quot;News&quot;, &quot;Online news&quot;, &quot;Twitter&quot;))%&gt;%
  ggplot(aes(y=share_women, x=fct_rev(overall_adj_domain))) + 
  geom_point(aes(shape=name, color=name), position=position_dodge(width=0.2), stat=&quot;identity&quot;, size = 2.5)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_women_field, x=overall_adj_domain), alpha=0.2, width = 0.4)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
  scale_color_discrete(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;))+
  scale_shape_discrete(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;))+
  scale_y_continuous(limits = c(0, 0.5), breaks = seq(0, 0.5, by = 0.125))+
  coord_flip()+
  xlab(&quot;&quot;)+
  ylab(&quot;% Women&quot;)+
  labs(color = &quot;Attention type&quot;,
       shape = &quot;Attention type&quot;)+
  ggtitle(&quot;Top 10% of attention domains&quot;)+
  theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))+
  panel_border()

repr_attn_20 &lt;- share_women_field_2023 %&gt;%
  filter(value == 2 &amp; name %in% c(&quot;News&quot;, &quot;Online news&quot;, &quot;Twitter&quot;))%&gt;%
  ggplot(aes(y=share_women, x= fct_rev(overall_adj_domain))) + 
  geom_point(aes(shape=name, color=name), position=position_dodge(width=0.2), stat=&quot;identity&quot;, size = 2.5)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_women_field, x=overall_adj_domain), alpha=0.2, width = 0.4)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+  
  scale_color_discrete(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;))+
  scale_shape_discrete(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;))+
  scale_y_continuous(limits = c(0, 0.5), breaks = seq(0, 0.5, by = 0.125))+
  coord_flip()+
  xlab(&quot;&quot;)+
  ylab(&quot;% Women&quot;)+
  labs(color = &quot;Attention type&quot;,
       shape = &quot;Attention type&quot;)+
  ggtitle(&quot;Top 20% of attention domains&quot;)+
  theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))+
  panel_border()</code></pre>
</div>
<div id="within-total-attention" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Within total
attention</h2>
<p>Now get the shares of attention given to women compared to their
share in the field:</p>
<pre class="r"><code># first, get the latest year in the panel for each prof
women_field_2023 &lt;- prof_panel_filter %&gt;%
  group_by(profile_id)%&gt;%
  filter(year == max(year))

# and now set the final year as 2023, assuming there was no attention after
# whatever the last year is in the dataset (quite some professors with
# 0 mentions even in this last year, so we want to keep them for correct
# shares)
women_field_2023$year &lt;- 2023

# get their decile based on their total performance within their entry batch
women_field_2023_attn_share &lt;- women_field_2023 %&gt;%
  filter(!is.na(overall_adj_domain))%&gt;%
  select(profile_id, year, inferred_gender, overall_adj_domain, count_pubs_total,
         cited_by_total_all, alt_online_all_total, news_all_total, alt_twitter_total)%&gt;%
  replace(is.na(.), 0)%&gt;%
  group_by(overall_adj_domain)%&gt;%
  summarise(
    pub_w = sum(count_pubs_total[inferred_gender == &quot;w&quot;]),
    cit_w = sum(cited_by_total_all[inferred_gender == &quot;w&quot;]), 
    online_w = sum(alt_online_all_total[inferred_gender == &quot;w&quot;]),
    news_w = sum(news_all_total[inferred_gender == &quot;w&quot;]),
    twitter_w = sum(alt_twitter_total[inferred_gender == &quot;w&quot;]),
    pub = sum(count_pubs_total),
    cit = sum(cited_by_total_all), 
    online = sum(alt_online_all_total),
    news = sum(news_all_total),
    twitter = sum(alt_twitter_total)
  )%&gt;%
  mutate(
         `Publications` = pub_w/pub,
         `Citations` = cit_w/cit,    
         `Online news` = online_w/online,
         `News` = news_w/news,
         `Twitter` = twitter_w/twitter)%&gt;%
  select(overall_adj_domain, `Publications`:`Twitter`)%&gt;%
  pivot_longer(!overall_adj_domain, names_to = &quot;name&quot;, values_to = &quot;share_women&quot;)</code></pre>
<p>Combine the field representation with the attention
representation:</p>
<pre class="r"><code>share_women_field_2023_attn_share &lt;- merge(women_field_2023_attn_share,
                                repr_field_2023[c(&quot;overall_adj_domain&quot;, &quot;share_women_field&quot;)],
                                by = &quot;overall_adj_domain&quot;)

share_women_field_2023_attn_share$share_women_field &lt;- ifelse(share_women_field_2023_attn_share$name == &quot;News&quot;,
                                                              share_women_field_2023_attn_share$share_women_field,
                                                              NA)</code></pre>
<p>Plot this out:</p>
<pre class="r"><code>share_women_field_2023_attn_share$overall_adj_domain &lt;- factor(share_women_field_2023_attn_share$overall_adj_domain,
                                                          levels = c(&quot;Physical Sciences&quot;,
                                                               &quot;Life Sciences&quot;,
                                                               &quot;Health Sciences&quot;,
                                                               &quot;Social Sciences&quot;,
                                                               &quot;Arts and Humanities&quot;))

repr_attn_share &lt;- share_women_field_2023_attn_share %&gt;%
  filter(name %in% c(&quot;News&quot;, &quot;Online news&quot;, &quot;Twitter&quot;))%&gt;%
  ggplot(aes(y=share_women, x=fct_rev(overall_adj_domain))) + 
  geom_point(aes(shape=name, color=name), position=position_dodge(width=0.2), stat=&quot;identity&quot;, size = 2.5)+
  geom_bar(stat=&quot;identity&quot;, aes(y=share_women_field, x=overall_adj_domain), alpha=0.2, width = 0.4)+
  guides(fill = guide_legend(reverse=TRUE, title = &quot;Measure&quot;))+
  scale_color_discrete(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;))+
  scale_shape_discrete(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;))+
  scale_y_continuous(limits = c(0, 0.5), breaks = seq(0, 0.5, by = 0.125))+
  coord_flip()+
  xlab(&quot;&quot;)+
  ylab(&quot;% Women&quot;)+
  labs(color = &quot;Attention type&quot;,
       shape = &quot;Attention type&quot;)+
  ggtitle(&quot;Total attention&quot;)+
  theme_minimal_vgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))+
  panel_border()</code></pre>
<p>Combine the plots for Figure 1, panel B:</p>
<pre class="r"><code>legend_share &lt;- get_legend(
  repr_attn_share
)


combi_plot &lt;- plot_grid(repr_attn_share + theme(legend.position=&quot;none&quot;, 
                                                axis.title.x = element_blank(),
                                                axis.title.y=element_blank()), 
                        repr_attn_10 + theme(legend.position=&quot;none&quot;,
                                             axis.title.x = element_blank(),
                                             axis.title.y=element_blank(),
                                             axis.text.y = element_blank()),
                        repr_attn_20 + theme(legend.position=&quot;none&quot;,
                                             axis.title.y=element_blank(),
                                             axis.title.x = element_blank(),
                                             axis.text.y = element_blank()),
                        legend_share,
                        
                        
                        ncol = 4,
                        rel_widths = c(1.3, 0.9, 0.9, 0.4))

combi_plot</code></pre>
<p>Print out Figure 1 in the main text.</p>
<pre class="r"><code>combi_plot_2 &lt;- plot_grid(
  combi_plot_averages,
  combi_plot,
  labels = c(&quot;A&quot;,&quot;B&quot;),
  ncol = 1,
  nrow = 2,
  rel.heights = c(1, 1),
  align = &#39;v&#39;,
  axis = &#39;l&#39;)

combi_plot_2

ggsave2(
  filename = &quot;results/supplement_figures/Figure_1_scopus.png&quot;,
  plot = combi_plot_2,
  width = 11,
  height = 7,
  units = c(&quot;in&quot;),
  dpi = 600,
  bg = &quot;white&quot;
)</code></pre>
</div>
</div>
<div id="regression-models" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Regression models</h1>
<p>First, obtain binary variables for any attention received that
year:</p>
<pre class="r"><code>prof_panel_filter$any_news &lt;- as.factor(ifelse(prof_panel_filter$news_all &gt; 0, 1, 0))
prof_panel_filter$any_news_l &lt;- as.factor(ifelse(prof_panel_filter$news_all_l &gt; 0, 1, 0))

prof_panel_filter$any_online_news &lt;- as.factor(ifelse(prof_panel_filter$alt_online_all &gt; 0, 1, 0))
prof_panel_filter$any_online_news_l &lt;- as.factor(ifelse(prof_panel_filter$alt_online_all_l &gt; 0, 1, 0))

prof_panel_filter$any_online_news_gen &lt;- as.factor(ifelse(prof_panel_filter$alt_online_general_all &gt; 0, 1, 0))
prof_panel_filter$any_online_news_gen_l &lt;- as.factor(ifelse(prof_panel_filter$alt_online_general_all_l &gt; 0, 1, 0))

prof_panel_filter$any_online_news_name &lt;- as.factor(ifelse(prof_panel_filter$alt_online_name_all &gt; 0, 1, 0))
prof_panel_filter$any_online_news_name_l &lt;- as.factor(ifelse(prof_panel_filter$alt_online_name_all_l &gt; 0, 1, 0))

prof_panel_filter$any_twitter &lt;- as.factor(ifelse(prof_panel_filter$alt_twitter &gt; 0, 1, 0))
prof_panel_filter$any_twitter_l &lt;- as.factor(ifelse(prof_panel_filter$alt_twitter_l &gt; 0, 1, 0))</code></pre>
<p>Then, construct a binary variables for belonging to the top 10/20% in
the attention for each source.</p>
<pre class="r"><code>panel_filter_long &lt;- prof_panel_filter %&gt;%
  pivot_longer(c(alt_online_all, alt_online_name_all, news_all, alt_twitter), names_to = &quot;measure&quot;, values_to = &quot;value&quot;)

top_10_attn &lt;- panel_filter_long %&gt;%
  filter(!is.na(overall_adj_domain) &amp; !is.na(year) &amp; year &gt; 2011)%&gt;%
  group_by(overall_adj_domain, year, measure)%&gt;%
  filter(quantile(value, 0.90, na.rm = TRUE)&lt;=value)%&gt;%
  select(profile_id, overall_adj_domain, year, measure, value)

top_10_attn$measure &lt;- paste0(top_10_attn$measure, &quot;_top_10&quot;)


top_10_attn &lt;- top_10_attn %&gt;%
  pivot_wider(names_from = &quot;measure&quot;)%&gt;%
  mutate(across(contains(&#39;top_10&#39;),  ~ifelse(is.na(.), 0, 1)))

prof_panel_filter &lt;- merge(prof_panel_filter,
                           top_10_attn[c(&quot;year&quot;, &quot;profile_id&quot;, &quot;overall_adj_domain&quot;, &quot;alt_online_all_top_10&quot;, &quot;alt_online_name_all_top_10&quot;, &quot;alt_twitter_top_10&quot;, &quot;news_all_top_10&quot;)],
                           by = c(&quot;profile_id&quot;, &quot;year&quot;, &quot;overall_adj_domain&quot;),
                           all.x = TRUE,
                           all.y = FALSE)

top_20_attn &lt;- panel_filter_long %&gt;%
  filter(!is.na(overall_adj_domain) &amp; !is.na(year) &amp; year &gt; 2011)%&gt;%
  group_by(overall_adj_domain, year, measure)%&gt;%
  filter(quantile(value, 0.80, na.rm = TRUE)&lt;=value)%&gt;%
  select(profile_id, overall_adj_domain, year, measure, value)

top_20_attn$measure &lt;- paste0(top_20_attn$measure, &quot;_top_20&quot;)


top_20_attn &lt;- top_20_attn %&gt;%
  pivot_wider(names_from = &quot;measure&quot;)%&gt;%
  mutate(across(contains(&#39;top_20&#39;),  ~ifelse(is.na(.), 0, 1)))

prof_panel_filter &lt;- merge(prof_panel_filter,
                           top_20_attn[c(&quot;year&quot;, &quot;profile_id&quot;, &quot;overall_adj_domain&quot;, &quot;alt_online_all_top_20&quot;, &quot;alt_online_name_all_top_20&quot;, &quot;alt_twitter_top_20&quot;, &quot;news_all_top_20&quot;)],
                           by = c(&quot;profile_id&quot;, &quot;year&quot;, &quot;overall_adj_domain&quot;),
                           all.x = TRUE,
                           all.y = FALSE)

prof_panel_filter &lt;- filter(prof_panel_filter, !is.na(overall_adj_domain))

# if NA, needs to be 0
prof_panel_filter &lt;- prof_panel_filter %&gt;%
  mutate(across(contains(&#39;top_10&#39;),  ~ifelse(is.na(.), 0, .)))%&gt;%
  mutate(across(contains(&#39;top_20&#39;),  ~ifelse(is.na(.), 0, .)))</code></pre>
<p>Log of variables:</p>
<pre class="r"><code>prof_panel_filter$news_all_log &lt;- log(prof_panel_filter$news_all+1)
prof_panel_filter$news_all_l_log &lt;- log(prof_panel_filter$news_all_l+1)

prof_panel_filter$alt_online_all_log &lt;- log(prof_panel_filter$alt_online_all+1)
prof_panel_filter$alt_online_all_l_log &lt;- log(prof_panel_filter$alt_online_all_l+1)

prof_panel_filter$alt_twitter_log &lt;- log(prof_panel_filter$alt_twitter+1)
prof_panel_filter$alt_twitter_l_log &lt;- log(prof_panel_filter$alt_twitter_l+1)
# there is a problem with this variable
prof_panel_filter$cited_by_total_all_l_log &lt;- log(prof_panel_filter$cited_by_total_all_l+1)
prof_panel_filter$cited_by_total_all_l_log[which(is.nan(prof_panel_filter$cited_by_total_all_l_log))] &lt;- NA
prof_panel_filter$cited_by_total_all_l_log[which(is.infinite(prof_panel_filter$cited_by_total_all_l_log))] &lt;- NA
prof_panel_filter$alt_online_all_total_l_log &lt;- log(prof_panel_filter$alt_online_all_total_l+1)
prof_panel_filter$alt_twitter_total_l_log &lt;- log(prof_panel_filter$alt_twitter_total_l+1)
prof_panel_filter$coa_tot_cited_by_total_l_log &lt;- log(prof_panel_filter$coa_tot_cited_by_total_l+1)
prof_panel_filter$coa_online_all_total_l_log &lt;- log(prof_panel_filter$coa_online_all_total_l+1)
prof_panel_filter$coa_twitter_total_l_log &lt;- log(prof_panel_filter$coa_twitter_total_l+1)

prof_panel_filter$news_all_total_l_log &lt;- log(prof_panel_filter$news_all_total_l+1)</code></pre>
<p>Split datasets per field:</p>
<pre class="r"><code>life &lt;- filter(prof_panel_filter, overall_adj_domain == &quot;Life Sciences&quot;)
phys &lt;- filter(prof_panel_filter, overall_adj_domain == &quot;Physical Sciences&quot;)
soc_sci &lt;- filter(prof_panel_filter, overall_adj_domain == &quot;Social Sciences&quot;)
arts &lt;- filter(prof_panel_filter, overall_adj_domain == &quot;Arts and Humanities&quot;)
health &lt;- filter(prof_panel_filter, overall_adj_domain == &quot;Health Sciences&quot;)</code></pre>
<div id="main-models" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Main models</h2>
<p>See “helper_functions.R” for details on the function we use to fit
the models.</p>
<p>This function returns a list containing:</p>
<ol style="list-style-type: decimal">
<li>the model coefficients</li>
<li>the prediction per gender</li>
<li>pairwise testing of significance of predictions for men and
women</li>
</ol>
<p>We then use this output to plot our results and output the final
model tables.</p>
<div id="news-attention" class="section level3" number="3.1.1">
<h3><span class="header-section-number">3.1.1</span> News attention</h3>
<p>News attention models, per field, controlling for: - last time
period’s news - total citations received up to the last period - total
online attention received up to the last period - total twitter
attention received up to the last period - total citations received by
all coauthors up to the last period - online attention received by all
coauthors up to the last period - twitter attention received by all
coauthors up to the last period - year control Individual clustered SE.
Models ran per each field separately.</p>
<pre class="r"><code>news_formula_main_model &lt;- &quot;news_all ~ inferred_gender + news_all_l + cited_by_total_all_l + alt_online_all_total_l + alt_twitter_total_l +coa_tot_cited_by_total_l + coa_tot_online_all_total_l + coa_tot_twitter_total_l+years_since_first_pub + as.factor(year)&quot;

news_main_model &lt;- lm_fitter_cl_robust_scopus(panel_dataset = prof_panel_filter,
                                       lm_formula = news_formula_main_model,
                                       year_cutoff_upper = 2023,
                                       year_cutoff_lower = 1973)</code></pre>
<p>Plot gender differences:</p>
<pre class="r"><code># use the pairwise comparisons to compare groups in the plot
p_values &lt;- news_main_model[[3]]
# manually add some elements we need to everything to look good
p_values$x &lt;- c(1, 2, 3, 4, 5)
p_values$groups &lt;- &#39;c(&quot;m&quot;, &quot;w&quot;)&#39;
p_values$xmin &lt;- c(0.8, 1.8, 2.8, 3.8, 4.8)
p_values$xmax &lt;- c(1.2, 2.2, 3.2, 4.2, 5.2)

predictions_plot &lt;- news_main_model[[2]]

news_gender_plot &lt;- predictions_plot %&gt;%
  ggplot(aes(x = field,
             y = predicted,
             ymin = conf.low,
             ymax = conf.high,
             color = x)) +
  geom_pointrange(position = position_dodge(width = 0.5),
                  size = 0.5)+
  ggtitle(&quot;Printed news attention prediction&quot;)+
  scale_y_continuous(limits = c(0, 10), breaks = seq(0, 10, by = 2))+
  stat_pvalue_manual(
    p_values,
    y.position = c(7.5, 5, 7.5, 9.4, 6.8),
    label.size = 3,
    tip.length = 0.003,
    label = &quot;{stars}&quot;,
    remove.bracket = FALSE,
  )+
  xlab(&quot;Field&quot;)+
  scale_x_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp;\n Humanities&quot;,
                            &quot;health&quot; = &quot;Medicine&quot;,
                            &quot;soc_sci&quot; = &quot;Social sciences&quot;,
                            &quot;life&quot; = &quot;Life sciences&quot;,
                            &quot;phys&quot; = &quot;Physical sciences&quot;))+
  ylab(&quot;Yearly attention&quot;)+
  labs(color = &quot;Inferred gender&quot;)+
  scale_color_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;), labels = c(&quot;Men&quot;, &quot;Women&quot;))+
  theme_minimal_hgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10, angle = 30, hjust = 0.9) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))</code></pre>
</div>
<div id="online-news-attention" class="section level3" number="3.1.2">
<h3><span class="header-section-number">3.1.2</span> Online news
attention</h3>
<p>Online news attention models, per field, controlling for: - last time
period’s online news news - total citations received up to the last
period - total news attention received up to the last period - total
twitter attention received up to the last period - total citations
received by all coauthors up to the last period - online attention
received by all coauthors up to the last period - twitter attention
received by all coauthors up to the last period - year control
Individual clustered SE.</p>
<pre class="r"><code>online_news_formula_main_model &lt;- &quot;alt_online_all ~ inferred_gender + alt_online_all_l + cited_by_total_all_l + news_all_total_l + alt_twitter_total_l +coa_tot_cited_by_total_l + coa_tot_online_all_total_l + coa_tot_twitter_total_l+years_since_first_pub + as.factor(year)&quot;

online_news_main_model &lt;- lm_fitter_cl_robust_scopus(panel_dataset = prof_panel_filter,
                                              lm_formula = online_news_formula_main_model,
                                              year_cutoff_upper = 2023,
                                              year_cutoff_lower = 1974)</code></pre>
<p>Plot gender differences:</p>
<pre class="r"><code># use the pairwise comparisons to compare groups in the plot
p_values &lt;- online_news_main_model[[3]]
# manually add some elements we need to everything to look good
p_values$x &lt;- c(1, 2, 3, 4, 5)
p_values$groups &lt;- &#39;c(&quot;m&quot;, &quot;w&quot;)&#39;
p_values$xmin &lt;- c(0.8, 1.8, 2.8, 3.8, 4.8)
p_values$xmax &lt;- c(1.2, 2.2, 3.2, 4.2, 5.2)

predictions_plot &lt;- online_news_main_model[[2]]


online_news_gender_plot &lt;- predictions_plot %&gt;%
  ggplot(aes(x = field,
             y = predicted,
             ymin = conf.low,
             ymax = conf.high,
             color = x)) +
  geom_pointrange(position = position_dodge(width = 0.5),
                  size = 0.5)+
  ggtitle(&quot;Online news attention prediction&quot;)+
  scale_y_continuous(limits = c(0, 25), breaks = seq(0, 25, by = 5))+
  stat_pvalue_manual(
    p_values,
    y.position = c(13.5, 15.5, 18.2, 6.5, 2.5),
    label.size = 3,
    tip.length = 0.003,
    label = &quot;{stars}&quot;,
    remove.bracket = FALSE,
  )+
  xlab(&quot;Field&quot;)+
  scale_x_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp;\n Humanities&quot;,
                            &quot;health&quot; = &quot;Medicine&quot;,
                            &quot;soc_sci&quot; = &quot;Social sciences&quot;,
                            &quot;life&quot; = &quot;Life sciences&quot;,
                            &quot;phys&quot; = &quot;Physical sciences&quot;))+
  ylab(&quot;Yearly attention&quot;)+
  labs(color = &quot;Inferred gender&quot;)+
  scale_color_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;), labels = c(&quot;Men&quot;, &quot;Women&quot;))+
  theme_minimal_hgrid()+
    theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10, angle = 30, hjust = 0.9) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))</code></pre>
</div>
<div id="twitterx-attention" class="section level3" number="3.1.3">
<h3><span class="header-section-number">3.1.3</span> Twitter/X
attention</h3>
<p>Twitter/X attention models, per field, controlling for: - last time
period’s twitter attention - total citations received up to the last
period - total online attention received up to the last period - total
news attention received up to the last period - total citations received
by all coauthors up to the last period - online attention received by
all coauthors up to the last period - twitter attention received by all
coauthors up to the last period - year control Individual clustered
SE.</p>
<pre class="r"><code>twitter_formula_main_model &lt;- &quot;alt_twitter ~ inferred_gender + alt_twitter_l + cited_by_total_all_l + news_all_total_l + alt_online_all_total_l +coa_tot_cited_by_total_l + coa_tot_online_all_total_l + coa_tot_twitter_total_l+years_since_first_pub + as.factor(year)&quot;

twitter_main_model &lt;- lm_fitter_cl_robust_scopus(panel_dataset = prof_panel_filter,
                                                 lm_formula = twitter_formula_main_model,
                                                 year_cutoff_upper = 2023,
                                                 year_cutoff_lower = 1974)</code></pre>
<p>Plot gender differences:</p>
<pre class="r"><code># use the pairwise comparisons to compare groups in the plot
p_values &lt;- twitter_main_model[[3]]
# manually add some elements we need to everything to look good
p_values$x &lt;- c(1, 2, 3, 4, 5)
p_values$groups &lt;- &#39;c(&quot;m&quot;, &quot;w&quot;)&#39;
p_values$xmin &lt;- c(0.8, 1.8, 2.8, 3.8, 4.8)
p_values$xmax &lt;- c(1.2, 2.2, 3.2, 4.2, 5.2)

predictions_plot &lt;- twitter_main_model[[2]]

twitter_gender_plot &lt;- predictions_plot %&gt;%
  ggplot(aes(x = field,
             y = predicted,
             ymin = conf.low,
             ymax = conf.high,
             color = x)) +
  geom_pointrange(position = position_dodge(width = 0.5),
                  size = 0.5)+
  #ylim(2, 5.5)+
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25))+
  ggtitle(&quot;Twitter/X attention prediction&quot;)+
  stat_pvalue_manual(
    p_values,
    y.position = c(38, 68, 93, 25, 8),
    label.size = 3,
    tip.length = 0.003,
    label = &quot;{stars}&quot;,
    remove.bracket = FALSE,
  )+
  xlab(&quot;Field&quot;)+
  scale_x_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp;\n Humanities&quot;,
                            &quot;health&quot; = &quot;Medicine&quot;,
                            &quot;soc_sci&quot; = &quot;Social sciences&quot;,
                            &quot;life&quot; = &quot;Life sciences&quot;,
                            &quot;phys&quot; = &quot;Physical sciences&quot;))+
  ylab(&quot;Yearly attention&quot;)+
  labs(color = &quot;Inferred gender&quot;)+
  scale_color_manual(values = c(&quot;#34d399&quot;, &quot;#fbbf24&quot;), labels = c(&quot;Men&quot;, &quot;Women&quot;))+
  theme_minimal_hgrid()+
  theme(plot.title = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 11),
        axis.text.x = element_text(size = 10, angle = 30, hjust = 0.9) ,
        axis.title.x = element_text(size = 11),
        legend.title=element_text(size=11), 
        legend.text=element_text(size=10))</code></pre>
</div>
<div id="combined-plots" class="section level3" number="3.1.4">
<h3><span class="header-section-number">3.1.4</span> Combined plots</h3>
<p>Combine this all to plot the coefficients in one plot.</p>
<p>First, prepare the dataframe:</p>
<pre class="r"><code>model_news &lt;- news_main_model[[1]]
model_online_news &lt;- online_news_main_model[[1]]
model_twitter &lt;- twitter_main_model[[1]]

model_news$model &lt;- &quot;News attention&quot;
model_online_news$model &lt;- &quot;Online news attention&quot;
model_twitter$model &lt;- &quot;Twitter attention&quot;

all_models_plot &lt;- rbind(model_news,
                         model_online_news,
                         model_twitter)

# do the t-1 of dependent as a single variable
all_models_plot$term &lt;- ifelse(all_models_plot$term %in% c(&quot;news_all_l&quot;,
                                                           &quot;alt_online_all_l&quot;,
                                                           &quot;alt_twitter_l&quot;), 
                               &quot;t_min_1&quot;, 
                               all_models_plot$term)


all_models_plot$term &lt;- ordered(all_models_plot$term,
                                levels = c(&quot;(Intercept)&quot;,
                                           &quot;inferred_genderw&quot;,
                                           &quot;t_min_1&quot;,
                                           &quot;cited_by_total_all_l&quot;,
                                           &quot;news_all_total_l&quot;,
                                           &quot;alt_online_all_total_l&quot;, 
                                           &quot;alt_twitter_total_l&quot;,
                                           &quot;coa_tot_cited_by_total_l&quot;,
                                           &quot;coa_tot_online_all_total_l&quot;,
                                           &quot;coa_tot_twitter_total_l&quot;,
                                           &quot;years_since_first_pub&quot;,
                                           &quot;as.factor(year)2014&quot;,
                                           &quot;as.factor(year)2015&quot;,
                                           &quot;as.factor(year)2016&quot;,
                                           &quot;as.factor(year)2017&quot;,
                                           &quot;as.factor(year)2018&quot;,
                                           &quot;as.factor(year)2019&quot;,
                                           &quot;as.factor(year)2020&quot;,
                                           &quot;as.factor(year)2021&quot;,
                                           &quot;as.factor(year)2022&quot;,
                                           &quot;as.factor(year)2023&quot;,
                                           &quot;R^2&quot;))

all_models_plot$model &lt;- ordered(all_models_plot$model,
                                 levels = c(&quot;News attention&quot;,
                                            &quot;Online news attention&quot;,
                                            &quot;Twitter attention&quot; ))


all_models_plot$field &lt;- ordered(all_models_plot$field,
                                 levels = c(&quot;phys&quot;,
                                            &quot;life&quot;,
                                            &quot;health&quot;,
                                            &quot;soc_sci&quot;,
                                            &quot;arts&quot;))

covariate_names &lt;- c(
  &#39;t_min_1&#39; = &quot;Dependent variable -\n previous period&quot;,
  &#39;news_all_l&#39;=&quot;News attention -\nprevious period&quot;,
  &#39;alt_online_all_l&#39; = &quot;Online news attention -\nprevious period&quot;,
  &#39;alt_twitter_l&#39; = &quot;Twitter attention -\nprevious period&quot;,
  &#39;cited_by_total_all_l&#39;=&quot;Total citations&quot;,
  &#39;news_all_total_l&#39;=&quot;Total printed news \nattention&quot;,
  &#39;alt_online_all_total_l&#39;=&quot;Total online news\n attention&quot;,
  &#39;alt_twitter_total_l&#39;=&quot;Total Twitter/X \nattention&quot;,
  &#39;coa_tot_cited_by_total_l&#39; = &quot;Coauthors&#39; total \ncitations&quot;,
  &#39;coa_tot_online_all_total_l&#39; = &quot;Coauthors&#39; total \nonline news attention&quot;,
  &#39;coa_tot_twitter_total_l&#39; = &quot;Coauthors&#39; total \nTwitter/X attention&quot;
)</code></pre>
<pre class="r"><code>legend &lt;- get_legend(
  # create some space to the left of the legend
  news_gender_plot
)

combi_plot_regression_pred &lt;- plot_grid(news_gender_plot + theme(legend.position=&quot;none&quot;, axis.title.x = element_blank()), 
                                        online_news_gender_plot + theme(legend.position=&quot;none&quot;, axis.title.x = element_blank()),
                                        twitter_gender_plot + theme(legend.position=&quot;none&quot;, axis.title.x = element_blank()),
                                        legend,
                                        ncol = 4,
                                        align = &#39;h&#39;,
                                        axis = &#39;tb&#39;,
                                        rel_widths = c(1, 1, 1, 0.4))</code></pre>
<p>Plot out selected regression coefficients for STEM:</p>
<pre class="r"><code># reorder the factor for Figure 2
all_models_plot$term &lt;- ordered(all_models_plot$term,
                                     levels = c(&quot;(Intercept)&quot;,
                                                &quot;inferred_genderw&quot;,
                                                &quot;cited_by_total_all_l&quot;,
                                                &quot;news_all_total_l&quot;,
                                                &quot;alt_online_all_total_l&quot;, 
                                                &quot;alt_twitter_total_l&quot;,
                                                &quot;coa_tot_cited_by_total_l&quot;,
                                                &quot;coa_tot_online_all_total_l&quot;,
                                                &quot;coa_tot_twitter_total_l&quot;,
                                                &quot;years_since_first_pub&quot;,
                                                &quot;t_min_1&quot;,
                                                &quot;as.factor(year)2014&quot;,
                                                &quot;as.factor(year)2015&quot;,
                                                &quot;as.factor(year)2016&quot;,
                                                &quot;as.factor(year)2017&quot;,
                                                &quot;as.factor(year)2018&quot;,
                                                &quot;as.factor(year)2019&quot;,
                                                &quot;as.factor(year)2020&quot;,
                                                &quot;as.factor(year)2021&quot;,
                                                &quot;as.factor(year)2022&quot;,
                                                &quot;as.factor(year)2023&quot;,
                                                &quot;R^2&quot;))


(selected_plot &lt;- all_models_plot %&gt;%
  filter(term %in% c(&quot;cited_by_total_all_l&quot;,
                     &quot;coa_tot_cited_by_total_l&quot;,
                     &quot;coa_tot_online_all_total_l&quot;,
                     &quot;coa_tot_twitter_total_l&quot;,
                     &quot;t_min_1&quot;) &amp; field == &quot;phys&quot;) %&gt;%
  ggplot(aes(Estimate, field, color = model, label = stars)) +
  geom_point(position = position_dodge(width = -0.7), size = 3) +
  geom_errorbar(aes(xmin = lower_ci, xmax = upper_ci),
                width=0,
                size=0.7,
                position = position_dodge(width = -0.7)) +
  geom_text(hjust=0, vjust=0, position = position_dodge(width = -0.7), size = 3.5)+
   scale_y_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp;\n Humanities&quot;,
                            &quot;health&quot; = &quot;Medicine&quot;,
                            &quot;soc_sci&quot; = &quot;Social sciences&quot;,
                            &quot;life&quot; = &quot;Life sciences&quot;,
                            &quot;phys&quot; = &quot;Physical sciences&quot;),
                       name = &quot;Field&quot;)+
  scale_color_manual(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;), values = c(&quot;#F8766D&quot;, &quot;#00BA38&quot;, &quot;#619CFF&quot;))+
  scale_x_continuous(
    n.breaks = 3,
    labels = function(x) format(x, scientific = TRUE))+
  # add in a dotted line at zero
  labs(
    x = &quot;Regression coefficient&quot;,
    y = NULL,
    color = &quot;Attention type&quot;
  ) + 
  geom_vline(xintercept = 0,  colour=&quot;black&quot;, linetype = &quot;longdash&quot;)+
  facet_wrap( ~ term, scales=&quot;free_x&quot;, labeller = as_labeller(covariate_names), ncol = 5)+
  theme_bw()+
   theme(plot.title = element_text(size = 10),
         axis.text.y = element_text(size = 10),
         axis.title.y = element_blank(),
         axis.text.x = element_text(size = 10, angle = 30, hjust = 0.9) ,
         axis.title.x = element_text(size = 11),
         legend.title=element_text(size=10), 
         legend.text=element_text(size=9),
         strip.text.x=element_text(size = 9)))</code></pre>
<pre class="r"><code>combi_plot_regression &lt;- plot_grid(
  combi_plot_regression_pred,
  selected_plot,
  ncol = 1,
  nrow = 2,
  axis = &#39;lr&#39;,
  labels = c(&quot;A&quot;, &quot;B&quot;)
)

combi_plot_regression

ggsave2(
  filename = &quot;results/supplement_figures/Figure_2_scopus.png&quot;,
  plot = combi_plot_regression,
  width = 11,
  height = 6,
  units = c(&quot;in&quot;),
  dpi = 600,
  bg = &quot;white&quot;
)</code></pre>
<p>And plot out the coefficients for all fields:</p>
<pre class="r"><code>(all_fields_plot &lt;- all_models_plot %&gt;%
  filter(term %in% c(&quot;cited_by_total_all_l&quot;,
                     &quot;coa_tot_cited_by_total_l&quot;,
                     &quot;coa_tot_online_all_total_l&quot;,
                     &quot;coa_tot_twitter_total_l&quot;,
                     &quot;t_min_1&quot;)) %&gt;%
  ggplot(aes(Estimate, field, color = model, label = stars)) +
  geom_point(position = position_dodge(width = -0.7), size = 3) +
  geom_errorbar(aes(xmin = lower_ci, xmax = upper_ci),
                width=0,
                size=0.7,
                position = position_dodge(width = -0.7)) +
  geom_text(hjust=0, vjust=0, position = position_dodge(width = -0.7), size = 3.5)+
   scale_y_discrete(labels=c(&quot;arts&quot; = &quot;Arts &amp; Humanities&quot;,
                             &quot;medicine&quot; = &quot;Medicine&quot;,
                             &quot;soc_sci&quot; = &quot;Social science&quot;,
                             &quot;stem&quot; = &quot;STEM&quot;),
                       name = &quot;Field&quot;)+
  scale_color_manual(labels = c(&quot;Printed news&quot;, &quot;Online news&quot;, &quot;Twitter/X&quot;), values = c(&quot;#F8766D&quot;, &quot;#00BA38&quot;, &quot;#619CFF&quot;))+
  scale_x_continuous(
    n.breaks = 3,
    labels = function(x) format(x, scientific = TRUE))+
  # add in a dotted line at zero
  labs(
    x = &quot;Regression coefficient&quot;,
    y = NULL,
    color = &quot;Attention type&quot;
  ) + 
  geom_vline(xintercept = 0,  colour=&quot;black&quot;, linetype = &quot;longdash&quot;)+
  facet_wrap( ~ term, scales=&quot;free_x&quot;, labeller = as_labeller(covariate_names), ncol = 5)+
  theme_bw()+
   theme(plot.title = element_text(size = 10),
         axis.text.y = element_text(size = 10),
         axis.title.y = element_blank(),
         axis.text.x = element_text(size = 10, angle = 30, hjust = 0.9) ,
         axis.title.x = element_text(size = 11),
         legend.title=element_text(size=10), 
         legend.text=element_text(size=9),
         strip.text.x=element_text(size = 9)))


# ggsave2(
#   filename = &quot;results/supplement_figures/Figure_2B_all_fields.png&quot;,
#   plot = all_fields_plot,
#   width = 12,
#   height = 4,
#   units = c(&quot;in&quot;),
#   dpi = 600,
#   bg = &quot;white&quot;
# )</code></pre>
<p>Print out the results into a table:</p>
<pre class="r"><code>options(scipen=999)

table_models &lt;- neat_regression_table(news_main_model[[1]],
                                      online_news_main_model[[1]],
                                      twitter_main_model[[1]])

table_models_save &lt;- table_models %&gt;%
  regulartable() %&gt;% 
  autofit()

# word_document_name &lt;-
#     read_docx() %&gt;%
#     body_add_flextable(table_models_save) %&gt;%
#     print(target = &quot;results/supplement_tables/main_model_table.docx&quot;)</code></pre>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlZhcmlvdXMgYW5hbHlzZXMgLSBNYXkgMjAyNCwgZmluYWwgZGF0YXNldCINCmF1dGhvcjogIkFuYSBNYWNhbm92aWMiDQpkYXRlOiAiMjAyNC0wNS0xNSINCi0tLQ0KDQoNCkxvYWQgdGhlIHBhY2thZ2VzOg0KYGBge3IgbWVzc2FnZT0gIEYsIHdhcm5pbmcgPSBGLCBldmFsID0gVH0NCnNvdXJjZSgiaGVscGVyX2Z1bmN0aW9ucy5SIikNCg0KcGFja2FnZXNfdG9fbG9hZCA8LSBjKCJyZWFkciIsICJkcGx5ciIsICJ0aWR5ciIsIA0KICAgICAgICAgICAgICAgICAgICAgICJnZ3Bsb3QyIiwgImNvd3Bsb3QiLA0KICAgICAgICAgICAgICAgICAgICAgICJ0aWR5dmVyc2UiLCAiUlBvc3RncmVzIiwgDQogICAgICAgICAgICAgICAgICAgICAgImx1YnJpZGF0ZSIsICJsbXRlc3QiLCANCiAgICAgICAgICAgICAgICAgICAgICAic2FuZHdpY2giLCAiZ2dwdWJyIiwgDQogICAgICAgICAgICAgICAgICAgICAgImtuaXRyIiwgInNjYWxlcyIsIA0KICAgICAgICAgICAgICAgICAgICAgICJnZ2VmZmVjdHMiLCAiZmxleHRhYmxlIiwgDQogICAgICAgICAgICAgICAgICAgICAgIm9mZmljZXIiKQ0KDQpmcGFja2FnZV9jaGVjayhwYWNrYWdlc190b19sb2FkKQ0KDQoNCiMgRm9yIGZ1bGwgcmVwcm9kdWNpYmlsaXR5LCBsb2FkIHRoZSBwYWNrYWdlcyB3aXRoIGdyb3VuZGhvZyB1c2luZyB0aGUgY29kZSBiZWxvdyBpbnN0ZWFkDQojIG9mIHRoZSBmcGFja2FnZV9jaGVjayBmdW5jdGlvbg0KDQojIGxpYnJhcnkoZ3JvdW5kaG9nKQ0KIyBncm91bmRob2cubGlicmFyeShwYWNrYWdlc190b19sb2FkLCBkYXRlID0gIjIwMjQtNC0yMyIpDQpgYGANCg0KDQpgYGB7cn0NCm9wdHNfY2h1bmskc2V0KGVjaG8gPSBUUlVFKQ0Kb3B0c19jaHVuayRzZXQoZXZhbCA9IEZBTFNFKQ0Kb3B0c19jaHVuayRzZXQod2FybmluZyA9IEZBTFNFKQ0Kb3B0c19jaHVuayRzZXQobWVzc2FnZSA9IEZBTFNFKQ0KYGBgDQoNCg0KTG9hZCB0aGUgcGFuZWwgYW5kIHRpZHkgdXAgc29tZSBjb2x1bW5zOg0KYGBge3Igd2FybmluZyA9IEYsIG1lc3NhZ2UgPSBGfQ0KcHJvZl9wYW5lbCA8LSByZWFkX2NzdigicGFuZWxfZGF0YXNldHMvcHJvZl9wYW5lbF90aWR5XzI2XzcuY3N2IikNCg0KcHJvZl9wYW5lbF9maWx0ZXIgPC0gZmlsdGVyKHByb2ZfcGFuZWwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA8IDIwMjQgJiAhaXMubmEob3ZlcmFsbF9hZGpfZG9tYWluKSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9hbGxfdG90YWwgPC0gcHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9uZXdzX3RvdGFsICsgcHJvZl9wYW5lbF9maWx0ZXIkY29hX2Jsb2dzX3RvdGFsDQpwcm9mX3BhbmVsX2ZpbHRlciRjb2Ffb25saW5lX2FsbF90b3RhbF9sIDwtIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV9vbmxpbmVfbmV3c190b3RhbF9sICsgcHJvZl9wYW5lbF9maWx0ZXIkY29hX2Jsb2dzX3RvdGFsX2wNCnByb2ZfcGFuZWxfZmlsdGVyJGNvYV9vbmxpbmVfYWxsIDwtIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV9vbmxpbmVfbmV3cyArIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV9ibG9ncw0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9hbGxfbCA8LSBwcm9mX3BhbmVsX2ZpbHRlciRjb2Ffb25saW5lX25ld3NfbCArIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV9ibG9nc19sDQoNCnByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3Rfb25saW5lX2FsbF90b3RhbCA8LSBwcm9mX3BhbmVsX2ZpbHRlciRjb2FfdG90X29ubGluZV9uZXdzX3RvdGFsICsgcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9ibG9nc190b3RhbA0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9vbmxpbmVfYWxsX3RvdGFsX2wgPC0gcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9vbmxpbmVfbmV3c190b3RhbF9sICsgcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9ibG9nc190b3RhbF9sDQpwcm9mX3BhbmVsX2ZpbHRlciRjb2FfdG90X29ubGluZV9hbGwgPC0gcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9vbmxpbmVfbmV3cyArIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3RfYmxvZ3MNCnByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3Rfb25saW5lX2FsbF9sIDwtIHByb2ZfcGFuZWxfZmlsdGVyJGNvYV90b3Rfb25saW5lX25ld3MgKyBwcm9mX3BhbmVsX2ZpbHRlciRjb2FfdG90X2Jsb2dzX2wNCg0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9hbGwgPC0gcHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9uZXdzICsgcHJvZl9wYW5lbF9maWx0ZXIkY29hX2Jsb2dzDQpgYGANCg0KIyBBdmVyYWdlIG51bWJlcnMgb2YgbWVudGlvbnMgYW5kIGNvbXBhcmlzb24gcGVyIGdlbmRlciAoRmlndXJlIDFBKQ0KDQpgYGB7cn0NCnNvdXJjZXNfY2hlY2sgPC0gcHJvZl9wYW5lbF9maWx0ZXIgJT4lDQogIGdyb3VwX2J5KHByb2ZpbGVfaWQpJT4lDQogIGZpbHRlcih5ZWFyID09IG1heCh5ZWFyKSAmICFpcy5uYShvdmVyYWxsX2Fkal9kb21haW4pKQ0KYGBgDQoNCldpdGhpbi1maWVsZCBjb21wYXJpc29uOg0KYGBge3J9DQpmaWVsZHMgPC0gdW5pcXVlKHByb2ZfcGFuZWxfZmlsdGVyJG92ZXJhbGxfYWRqX2RvbWFpbikNCmZpZWxkcyA8LSBmaWVsZHNbIWlzLm5hKGZpZWxkcyldDQpmaWVsZF9jb21wYXJpc29ucyA8LSBkYXRhLmZyYW1lKG1hdHJpeChOQSwgbmNvbCA9IDcsIG5yb3cgPSBsZW5ndGgoZmllbGRzKSkpDQoNCmZvciAoaSBpbiAxOmxlbmd0aChmaWVsZHMpKXsNCiAgZmllbGQgPC0gZmllbGRzW2ldDQogIGRhdGEgPC0gZmlsdGVyKHNvdXJjZXNfY2hlY2ssIA0KICAgICAgICAgICAgICAgICBvdmVyYWxsX2Fkal9kb21haW4gPT0gZmllbGQpDQogIGZpZWxkX2NvbXBhcmlzb25zW2ksIDFdIDwtIGZpZWxkDQogIGZpZWxkX2NvbXBhcmlzb25zW2ksIDJdIDwtIG5yb3coZGF0YSkNCiAgZmllbGRfY29tcGFyaXNvbnNbaSwgM10gPC0gcm91bmQodC50ZXN0KGNvdW50X3B1YnNfdG90YWwgfiBpbmZlcnJlZF9nZW5kZXIsIGRhdGE9ZGF0YSwgcGFpcmVkPUZBTFNFKSRwLnZhbHVlLCA1KQ0KICBmaWVsZF9jb21wYXJpc29uc1tpLCA0XSA8LSByb3VuZCh0LnRlc3QoY2l0ZWRfYnlfdG90YWxfYWxsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgZmllbGRfY29tcGFyaXNvbnNbaSwgNV0gPC0gcm91bmQodC50ZXN0KG5ld3NfYWxsX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgZmllbGRfY29tcGFyaXNvbnNbaSwgNl0gPC0gcm91bmQodC50ZXN0KGFsdF9vbmxpbmVfYWxsX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCiAgZmllbGRfY29tcGFyaXNvbnNbaSwgN10gPC0gcm91bmQodC50ZXN0KGFsdF90d2l0dGVyX3RvdGFsIH4gaW5mZXJyZWRfZ2VuZGVyLCBkYXRhPWRhdGEsIHBhaXJlZD1GQUxTRSkkcC52YWx1ZSwgNSkNCn0NCg0KY29sbmFtZXMoZmllbGRfY29tcGFyaXNvbnMpIDwtIGMoImZpZWxkIiwgInByb2ZzIiwgInB1YnNfdG90YWwiLCAiY2l0YXRpb25zX3RvdGFsIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ0b3RhbCIsICJvbmxpbmVfdG90YWwiLCAidHdpdHRlcl90b3RhbCIpDQpmaWVsZF9jb21wYXJpc29ucyRjb21wYXJpc29uIDwtICAidHRlc3QiDQoNCg0KbWVhbl92YWx1ZXNfZmllbGQgPC0gc291cmNlc19jaGVjayAlPiUNCiAgZmlsdGVyKCFpcy5uYShvdmVyYWxsX2Fkal9kb21haW4pKSU+JQ0KICBncm91cF9ieShpbmZlcnJlZF9nZW5kZXIsIG92ZXJhbGxfYWRqX2RvbWFpbiklPiUNCiAgc3VtbWFyaXNlKHB1YnNfdG90YWwgPSBtZWFuKGNvdW50X3B1YnNfdG90YWwsIG5hLnJtID0gVFJVRSksDQogICAgICAgICAgICBjaXRhdGlvbnNfdG90YWwgPSBtZWFuKGNpdGVkX2J5X3RvdGFsX2FsbCwgbmEucm0gPSBUUlVFKSwNCiAgICAgICAgICAgIHRvdGFsID0gbWVhbihuZXdzX2FsbF90b3RhbCwgbmEucm0gPSBUUlVFKSwNCiAgICAgICAgICAgIG9ubGluZV90b3RhbCA9IG1lYW4oYWx0X29ubGluZV9hbGxfdG90YWwsIG5hLnJtID0gVFJVRSksDQogICAgICAgICAgICB0d2l0dGVyX3RvdGFsID0gIG1lYW4oYWx0X3R3aXR0ZXJfdG90YWwsIG5hLnJtID0gVFJVRSkpJT4lDQogIG11dGF0ZShhY3Jvc3MoMjo2LCBcKHgpIHJvdW5kKHgsIDIpKSkNCg0KI21lYW5fdmFsdWVzX2ZpZWxkJGZpZWxkIDwtICJvdmVyYWxsIg0KY29sbmFtZXMobWVhbl92YWx1ZXNfZmllbGQpWzFdIDwtICJjb21wYXJpc29uIg0KY29sbmFtZXMobWVhbl92YWx1ZXNfZmllbGQpWzJdIDwtICJmaWVsZCINCm1lYW5fdmFsdWVzX2ZpZWxkIDwtIG1lYW5fdmFsdWVzX2ZpZWxkW2MoImNvbXBhcmlzb24iLCAiZmllbGQiLCAicHVic190b3RhbCIsICJjaXRhdGlvbnNfdG90YWwiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidG90YWwiLCAib25saW5lX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiKV0NCg0KZmllbGRfY29tcGFyaXNvbnMgPC0gZmllbGRfY29tcGFyaXNvbnNbYygiY29tcGFyaXNvbiIsICJmaWVsZCIsICJwdWJzX3RvdGFsIiwgImNpdGF0aW9uc190b3RhbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidG90YWwiLCAib25saW5lX3RvdGFsIiwgInR3aXR0ZXJfdG90YWwiKV0NCg0KZmllbGRfY29tcGFyaXNvbnMgPC0gcmJpbmQobWVhbl92YWx1ZXNfZmllbGQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9jb21wYXJpc29ucykNCg0KZmllbGRfY29tcGFyaXNvbnMgPC0gZmllbGRfY29tcGFyaXNvbnMgJT4lDQogIGFycmFuZ2UoZmllbGQpDQpgYGANCg0KUGxvdCB0aGUgbWVhbnMgY29tcGFyaXNvbjoNCmBgYHtyfQ0KZmllbGRfY29tcGFyaXNvbnNfcGxvdCA8LSBmaWx0ZXIoZmllbGRfY29tcGFyaXNvbnMsIGNvbXBhcmlzb24gIT0gInR0ZXN0IikNCg0KZmllbGRfY29tcGFyaXNvbnNfcGxvdCRmaWVsZCA8LSBmYWN0b3IoZmllbGRfY29tcGFyaXNvbnNfcGxvdCRmaWVsZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxzID0gYygiUGh5c2ljYWwgU2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJMaWZlIFNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiSGVhbHRoIFNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiU29jaWFsIFNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiQXJ0cyBhbmQgSHVtYW5pdGllcyIpKQ0KZmllbGRfY29tcGFyaXNvbnNfcGxvdCRjb21wYXJpc29uIDwtIG9yZGVyZWQoZmllbGRfY29tcGFyaXNvbnNfcGxvdCRjb21wYXJpc29uLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMgPSBjKCJtIiwgInciKSkNCg0Kc2lnbmlmaWNhbmNlX3Rlc3RpbmcgPC0gIGZpZWxkX2NvbXBhcmlzb25zDQoNCnNpZ25pZmljYW5jZV90ZXN0aW5nIDwtICBzaWduaWZpY2FuY2VfdGVzdGluZyAlPiUNCiAgZmlsdGVyKGNvbXBhcmlzb24gPT0gInR0ZXN0IiklPiUNCiAgbXV0YXRlX2F0KHZhcnMoYG9ubGluZV90b3RhbGAsIGB0b3RhbGAsIGB0d2l0dGVyX3RvdGFsYCksIC5mdW5zID0gbGlzdCgNCiAgICB+Y2FzZV93aGVuKA0KICAgICAgLiA8PSAwLjAwMSB+ICcqKionLA0KICAgICAgLiA8PSAwLjAxIH4gJyoqJywNCiAgICAgIC4gPD0gMC4wNSB+ICcqJywNCiAgICAgIC4gPD0gMC4xIH4gJy4nLA0KICAgICAgLiA+IDAuMSB+ICcnDQogICAgKSkpDQoNCnNpZ25pZmljYW5jZV90ZXN0aW5nJGZpZWxkIDwtIGZhY3RvcihzaWduaWZpY2FuY2VfdGVzdGluZyRmaWVsZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxzID0gYygiQXJ0cyBhbmQgSHVtYW5pdGllcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlNvY2lhbCBTY2llbmNlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkhlYWx0aCBTY2llbmNlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkxpZmUgU2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJQaHlzaWNhbCBTY2llbmNlcyIpKQ0Kc2lnbmlmaWNhbmNlX3Rlc3RpbmcgPC0gc2lnbmlmaWNhbmNlX3Rlc3RpbmcgJT4lDQogIGFycmFuZ2UoZmllbGQpDQoNCnNpZ25pZmljYW5jZV90ZXN0aW5nJGdyb3VwMSA8LSAibSINCnNpZ25pZmljYW5jZV90ZXN0aW5nJGdyb3VwMiA8LSAidyINCnNpZ25pZmljYW5jZV90ZXN0aW5nJHggPC0gYygxLDIsMyw0LCA1KQ0Kc2lnbmlmaWNhbmNlX3Rlc3RpbmckeG1pbiA8LSBjKDAuNzUsMS43NSwyLjc1LDMuNzUsIDQuNzUpDQpzaWduaWZpY2FuY2VfdGVzdGluZyR4bWF4IDwtIGMoMS4yNSwyLjI1LCAzLjI1LDQuMjUsIDUuMjUpDQpzaWduaWZpY2FuY2VfdGVzdGluZyRjb21wYXJpc29uIDwtICJtIg0KDQoNCmF2ZXJhZ2VfbmV3cyA8LSBmaWVsZF9jb21wYXJpc29uc19wbG90ICU+JQ0KICAgZmlsdGVyKGNvbXBhcmlzb24gIT0gInR0ZXN0IiklPiUNCiAgIGdncGxvdChhZXMoeD1mY3RfcmV2KGZpZWxkKSwgeT10b3RhbCwgZmlsbCA9IGNvbXBhcmlzb24pKSArIA0KICAgZ2VvbV9iYXIocG9zaXRpb249cG9zaXRpb25fZG9kZ2UoLjUpLHN0YXQ9ImlkZW50aXR5IiwgYWxwaGE9MSwgd2lkdGggPSAwLjUpKw0KICAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZSA9IEZBTFNFLCB0aXRsZSA9ICJJbmZlcnJlZCBnZW5kZXIiKSkrDQogICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjKCIjMzRkMzk5IiwgIiNmYmJmMjQiKSAsIGxhYmVscyA9IGMoIk1lbiIsICJXb21lbiIpKSsNCiAgIGdndGl0bGUoIlByaW50ZWQgbmV3cyBhdHRlbnRpb24iKSsNCiAgIHN0YXRfcHZhbHVlX21hbnVhbCgNCiAgICAgc2lnbmlmaWNhbmNlX3Rlc3RpbmcsDQogICAgIHkucG9zaXRpb24gPSBjKDk1LCAxNTgsIDEwMCwgODAsIDEwMCksDQogICAgIGxhYmVsLnNpemUgPSAzLA0KICAgICBjb29yZC5mbGlwID0gVFJVRSwNCiAgICAgdGlwLmxlbmd0aCA9IDAuMDA1LA0KICAgICBsYWJlbCA9ICJ7dG90YWx9IiwNCiAgICAgcmVtb3ZlLmJyYWNrZXQgPSBGQUxTRSwNCiAgICAgaGlkZS5ucyA9IFRSVUUNCiAgICkrDQogIHNjYWxlX3lfY29udGludW91cyhsaW1pdHMgPSBjKDAsIDE2MCksIGJyZWFrcyA9IHNlcSgwLCAxNjAsIGJ5ID0gNDApKSsNCiAgIHlsYWIoIkF2ZXJhZ2UgbWVudGlvbnMgb3ZlciBsaWZldGltZSIpKw0KICB4bGFiKCJGaWVsZCIpKw0KICAgbGFicyhjb2xvciA9ICJJbmZlcnJlZCBnZW5kZXIiKSsNCiAgIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSAsDQogICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF90ZXh0KHNpemU9MTEpLCANCiAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9MTApKSsNCiAgY29vcmRfZmxpcCgpDQogDQphdmVyYWdlX29ubGluZSA8LSBmaWVsZF9jb21wYXJpc29uc19wbG90ICU+JQ0KICAgZmlsdGVyKGNvbXBhcmlzb24gIT0gInR0ZXN0IiklPiUNCiAgIGdncGxvdChhZXMoeD1mY3RfcmV2KGZpZWxkKSwgeT1vbmxpbmVfdG90YWwsIGZpbGwgPSBjb21wYXJpc29uKSkgKyANCiAgIGdlb21fYmFyKHBvc2l0aW9uPXBvc2l0aW9uX2RvZGdlKC41KSxzdGF0PSJpZGVudGl0eSIsIGFscGhhPTEsIHdpZHRoID0gMC41KSsNCiAgIGd1aWRlcyhmaWxsID0gZ3VpZGVfbGVnZW5kKHJldmVyc2UgPSBGQUxTRSwgdGl0bGUgPSAiSW5mZXJyZWQgZ2VuZGVyIikpKw0KICAgc2NhbGVfZmlsbF9tYW51YWwodmFsdWVzID0gYygiIzM0ZDM5OSIsICIjZmJiZjI0IikgLCBsYWJlbHMgPSBjKCJNZW4iLCAiV29tZW4iKSkrDQogICBnZ3RpdGxlKCJPbmxpbmUgbmV3cyBhdHRlbnRpb24iKSsNCiAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cyA9IGMoMCwgMjEyKSwgYnJlYWtzID0gc2VxKDAsIDIxMiwgYnkgPSA1MykpKw0KICAgc3RhdF9wdmFsdWVfbWFudWFsKA0KICAgICBzaWduaWZpY2FuY2VfdGVzdGluZywNCiAgICAgeS5wb3NpdGlvbiA9IGMoMTEsIDQzLCAyMDksIDE3MCwgMTEyKSwNCiAgICAgbGFiZWwuc2l6ZSA9IDMsDQogICAgIGNvb3JkLmZsaXAgPSBUUlVFLA0KICAgICB0aXAubGVuZ3RoID0gMC4wMDUsDQogICAgIGxhYmVsID0gIntvbmxpbmVfdG90YWx9IiwNCiAgICkrDQogICB5bGFiKCJBdmVyYWdlIG1lbnRpb25zIG92ZXIgbGlmZXRpbWUiKSsNCiAgIGxhYnMoY29sb3IgPSAiSW5mZXJyZWQgZ2VuZGVyIikrDQogICB0aGVtZV9taW5pbWFsX3ZncmlkKCkrDQogIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgIGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCkgLA0KICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTExKSwgDQogICAgICAgIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTEwKSkrDQogIGNvb3JkX2ZsaXAoKSsNCiAgeGxhYigiRmllbGQiKQ0KDQoNCmF2ZXJhZ2VfdHdpdHRlciA8LSBmaWVsZF9jb21wYXJpc29uc19wbG90ICU+JQ0KICAgZmlsdGVyKGNvbXBhcmlzb24gIT0gInR0ZXN0IiklPiUNCiAgIGdncGxvdChhZXMoeD1mY3RfcmV2KGZpZWxkKSwgeT10d2l0dGVyX3RvdGFsLCBmaWxsID0gY29tcGFyaXNvbikpICsgDQogICBnZW9tX2Jhcihwb3NpdGlvbj1wb3NpdGlvbl9kb2RnZSguNSksc3RhdD0iaWRlbnRpdHkiLCBhbHBoYT0xLCB3aWR0aCA9IDAuNSkrDQogICBndWlkZXMoZmlsbCA9IGd1aWRlX2xlZ2VuZChyZXZlcnNlID0gRkFMU0UsIHRpdGxlID0gIkluZmVycmVkIGdlbmRlciIpKSsNCiAgIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGMoIiMzNGQzOTkiLCAiI2ZiYmYyNCIpICwgbGFiZWxzID0gYygiTWVuIiwgIldvbWVuIikpKw0KICAgZ2d0aXRsZSgiVHdpdHRlci9YIGF0dGVudGlvbiIpKw0KICAgc3RhdF9wdmFsdWVfbWFudWFsKA0KICAgICBzaWduaWZpY2FuY2VfdGVzdGluZywNCiAgICAgeS5wb3NpdGlvbiA9IGMoNTAsIDIwMCwgMTEyMCwgMTAxMCwgNDQwKSwNCiAgICAgbGFiZWwuc2l6ZSA9IDMsDQogICAgIGNvb3JkLmZsaXAgPSBUUlVFLA0KICAgICB0aXAubGVuZ3RoID0gMC4wMDUsDQogICAgIGxhYmVsID0gInt0d2l0dGVyX3RvdGFsfSIsDQogICAgIHJlbW92ZS5icmFja2V0ID0gRkFMU0UsDQogICApKw0KICAgIHNjYWxlX3lfY29udGludW91cyhsaW1pdHMgPSBjKDAsIDEyMDApLCBicmVha3MgPSBzZXEoMCwgMTIwMCwgYnkgPSAzMDApKSsNCiAgIHlsYWIoIkF2ZXJhZ2UgbWVudGlvbnMgb3ZlciBsaWZldGltZSIpKw0KICAgbGFicyhjb2xvciA9ICJJbmZlcnJlZCBnZW5kZXIiKSsNCiAgIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSAsDQogICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF90ZXh0KHNpemU9MTEpLCANCiAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9MTApKSsNCiAgY29vcmRfZmxpcCgpKw0KICB4bGFiKCJGaWVsZCIpDQpgYGANCg0KQ29tYmluZSB0aGVzZSBwbG90cyBpbnRvIG9uZSAoRmlndXJlIDEsIHBhbmVsIEEpOg0KYGBge3IgZmlnLndpZHRoPTEwLCBmaWcuaGVpZ2h0PTN9DQpsZWdlbmRfYXZlcmFnZSA8LSBnZXRfbGVnZW5kKA0KICAjIGNyZWF0ZSBzb21lIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBsZWdlbmQNCiAgYXZlcmFnZV9uZXdzDQopDQoNCmNvbWJpX3Bsb3RfYXZlcmFnZXMgPC0gcGxvdF9ncmlkKGF2ZXJhZ2VfbmV3cyArIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlLnk9ZWxlbWVudF9ibGFuaygpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBwYW5lbF9ib3JkZXIoKSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmVyYWdlX29ubGluZSArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50aXRsZS55PWVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X2JsYW5rKCkpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHBhbmVsX2JvcmRlcigpLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VfdHdpdHRlciArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlLnk9ZWxlbWVudF9ibGFuaygpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X2JsYW5rKCkpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHBhbmVsX2JvcmRlcigpLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZF9hdmVyYWdlLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmNvbCA9IDQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxfd2lkdGhzID0gYygxLjMsIDAuOSwgMC45LCAwLjQpKQ0KDQpjb21iaV9wbG90X2F2ZXJhZ2VzDQpgYGANCg0KDQojIFdvbWVuJ3MgcmVwcmVzZW50YXRpb24gKEZpZ3VyZSAxQikNCg0KRmlyc3QsIGdldCByZXByZXNlbnRhdGlvbiBwZXIgZmllbGQgaW4gb3VyIGRhdGFzZXQ6DQooNjc5MSBwcm9mZXNzb3JzKQ0KYGBge3J9DQpyZXByX2ZpZWxkXzIwMjMgPC0gcHJvZl9wYW5lbF9maWx0ZXIgJT4lDQogIGdyb3VwX2J5KHByb2ZpbGVfaWQpJT4lDQogIGZpbHRlcih5ZWFyID09IG1heCh5ZWFyKSklPiUNCiAgZmlsdGVyKCFpcy5uYShvdmVyYWxsX2Fkal9kb21haW4pKSU+JQ0KICBncm91cF9ieShvdmVyYWxsX2Fkal9kb21haW4sIGluZmVycmVkX2dlbmRlciklPiUNCiAgc3VtbWFyaXNlKG4gPSBuKCkpJT4lDQogIHBpdm90X3dpZGVyKHZhbHVlc19mcm9tID0gbiwgbmFtZXNfZnJvbSA9IGluZmVycmVkX2dlbmRlcikNCg0KcmVwcl9maWVsZF8yMDIzJHNoYXJlX3dvbWVuX2ZpZWxkIDwtIHJlcHJfZmllbGRfMjAyMyR3LyhyZXByX2ZpZWxkXzIwMjMkbStyZXByX2ZpZWxkXzIwMjMkdykNCg0KYGBgDQojIyBBbW9uZyB0b3AgTiByZXNlYXJjaGVycyANCk5vdyBnZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIHdvbWVuIGFtb25nIHRoZSB0b3AgMTAlIGFuZCAyMCUgb2YgcmVzZWFyY2hlcnMgaW4gdGVybXMNCm9mIHRvdGFsIGZhbWUgaW4gdGhlaXIgZmllbGQgaW4gMjAyMyAoYmFzZWQgb24gdGhlaXIgZW50cnkgYmF0Y2gpOg0KYGBge3J9DQojIGZpcnN0LCBnZXQgdGhlIGxhdGVzdCB5ZWFyIGluIHRoZSBwYW5lbCBmb3IgZWFjaCBwcm9mDQp3b21lbl9maWVsZF8yMDIzIDwtIHByb2ZfcGFuZWxfZmlsdGVyICU+JQ0KICBncm91cF9ieShwcm9maWxlX2lkKSU+JQ0KICBmaWx0ZXIoeWVhciA9PSBtYXgoeWVhcikpDQoNCiMgYW5kIG5vdyBzZXQgdGhlIGZpbmFsIHllYXIgYXMgMjAyMywgYXNzdW1pbmcgdGhlcmUgd2FzIG5vIGF0dGVudGlvbiBhZnRlcg0KIyB3aGF0ZXZlciB0aGUgbGFzdCB5ZWFyIGlzIGluIHRoZSBkYXRhc2V0IChxdWl0ZSBzb21lIHByb2Zlc3NvcnMgd2l0aA0KIyAwIG1lbnRpb25zIGV2ZW4gaW4gdGhpcyBsYXN0IHllYXIsIHNvIHdlIHdhbnQgdG8ga2VlcCB0aGVtIGZvciBjb3JyZWN0DQojIHNoYXJlcykNCndvbWVuX2ZpZWxkXzIwMjMkeWVhciA8LSAyMDIzDQoNCiMgZ2V0IHRoZWlyIGRlY2lsZSBiYXNlZCBvbiB0aGVpciB0b3RhbCBwZXJmb3JtYW5jZSB3aXRoaW4gdGhlaXIgZ2VuZGVyYWwgZmllbGQNCndvbWVuX2ZpZWxkXzIwMjMgPC0gd29tZW5fZmllbGRfMjAyMyAlPiUNCiAgZmlsdGVyKCFpcy5uYShvdmVyYWxsX2Fkal9kb21haW4pKSU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZCwgeWVhciwgaW5mZXJyZWRfZ2VuZGVyLCBvdmVyYWxsX2Fkal9kb21haW4sIGNvdW50X3B1YnNfdG90YWwsDQogICAgICAgICBjaXRlZF9ieV90b3RhbF9hbGwsIGFsdF9vbmxpbmVfYWxsX3RvdGFsLCBuZXdzX2FsbF90b3RhbCwgYWx0X3R3aXR0ZXJfdG90YWwpJT4lDQogIHJlcGxhY2UoaXMubmEoLiksIDApJT4lDQogIGdyb3VwX2J5KG92ZXJhbGxfYWRqX2RvbWFpbiklPiUNCiAgbXV0YXRlKGBOZXdzYCA9IG50aWxlKC1uZXdzX2FsbF90b3RhbCwgMTApLA0KICAgICAgICAgYE9ubGluZSBuZXdzYCA9IG50aWxlKC1hbHRfb25saW5lX2FsbF90b3RhbCwgMTApLA0KICAgICAgICAgYFR3aXR0ZXJgID0gbnRpbGUoLWFsdF90d2l0dGVyX3RvdGFsLCAxMCkpDQpgYGANCg0KR2V0IHNoYXJlcyBvZiB3b21lbiBhbW9uZyB0b3AgbiUgc2NpZW50aXN0cyBwZXIgYXR0ZW50aW9uIGRvbWFpbjoNCmBgYHtyfQ0KIyByZWFycmFuZ2UgdGhlIGRhdGFzZXQgdG8gZ2V0IGNvdW50cyBvZiB3b21lbiBhbmQgbWVuIGluIGVhY2ggZGVjaWxlDQojIHRoZW4gbGVhdmUgb25seSB0b3AgMTAgYW5kIDIwDQpzaGFyZV93b21lbl9maWVsZF8yMDIzIDwtIHdvbWVuX2ZpZWxkXzIwMjMgJT4lDQogIHVuZ3JvdXAoKSU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZCwgeWVhciwgaW5mZXJyZWRfZ2VuZGVyLCBvdmVyYWxsX2Fkal9kb21haW4sIGBOZXdzYDpgVHdpdHRlcmApJT4lDQogIHBpdm90X2xvbmdlcihgTmV3c2A6YFR3aXR0ZXJgKSU+JQ0KICBncm91cF9ieShvdmVyYWxsX2Fkal9kb21haW4sIGluZmVycmVkX2dlbmRlciwgbmFtZSwgdmFsdWUpJT4lDQogIHN1bW1hcmlzZShuID0gbigpKSU+JQ0KICBwaXZvdF93aWRlcih2YWx1ZXNfZnJvbSA9IG4sIG5hbWVzX2Zyb20gPSBpbmZlcnJlZF9nZW5kZXIpJT4lDQogIHJlcGxhY2UoaXMubmEoLiksIDApJT4lDQogIGdyb3VwX2J5KG92ZXJhbGxfYWRqX2RvbWFpbiwgbmFtZSklPiUNCiAgbXV0YXRlKG0gPSBjdW1zdW0obSksDQogICAgICAgICB3ID0gY3Vtc3VtKHcpKSU+JQ0KICBmaWx0ZXIodmFsdWUgJWluJSBjKDEsIDIpKQ0KIA0Kc2hhcmVfd29tZW5fZmllbGRfMjAyMyRzaGFyZV93b21lbiA8LSBzaGFyZV93b21lbl9maWVsZF8yMDIzJHcvKHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMkbStzaGFyZV93b21lbl9maWVsZF8yMDIzJHcpIA0KYGBgDQpDb21iaW5lIHRoZSBmaWVsZCByZXByZXNlbnRhdGlvbiB3aXRoIHRoZSBhdHRlbnRpb24gcmVwcmVzZW50YXRpb246DQpgYGB7cn0NCnJlcHJfZmllbGRfMjAyMyRuYW1lIDwtICJvdmVyYWxsIg0KcmVwcl9maWVsZF8yMDIzJHZhbHVlIDwtIDANCg0KcmVwcl9maWVsZF8yMDIzIDwtIHJlcHJfZmllbGRfMjAyM1tjKGNvbG5hbWVzKHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMpWzE6NV0sInNoYXJlX3dvbWVuX2ZpZWxkIildDQoNCnNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMgPC0gbWVyZ2Uoc2hhcmVfd29tZW5fZmllbGRfMjAyMywNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwcl9maWVsZF8yMDIzW2MoIm92ZXJhbGxfYWRqX2RvbWFpbiIsICJzaGFyZV93b21lbl9maWVsZCIpXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSAib3ZlcmFsbF9hZGpfZG9tYWluIikNCg0Kc2hhcmVfd29tZW5fZmllbGRfMjAyMyRzaGFyZV93b21lbl9maWVsZCA8LSBpZmVsc2Uoc2hhcmVfd29tZW5fZmllbGRfMjAyMyRuYW1lID09ICJOZXdzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMkc2hhcmVfd29tZW5fZmllbGQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOQSkNCmBgYA0KDQpQbG90IHRoaXMgb3V0Og0KDQpUb3AgMTAlOg0KYGBge3Igd2FybmluZyA9IEZ9DQoNCnNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMkb3ZlcmFsbF9hZGpfZG9tYWluIDwtIGZhY3RvcihzaGFyZV93b21lbl9maWVsZF8yMDIzJG92ZXJhbGxfYWRqX2RvbWFpbiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMgPSBjKCJQaHlzaWNhbCBTY2llbmNlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTGlmZSBTY2llbmNlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiSGVhbHRoIFNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJTb2NpYWwgU2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkFydHMgYW5kIEh1bWFuaXRpZXMiKSkNCg0KcmVwcl9hdHRuXzEwIDwtIHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjMgJT4lDQogIGZpbHRlcih2YWx1ZSA9PSAxICYgbmFtZSAlaW4lIGMoIk5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlciIpKSU+JQ0KICBnZ3Bsb3QoYWVzKHk9c2hhcmVfd29tZW4sIHg9ZmN0X3JldihvdmVyYWxsX2Fkal9kb21haW4pKSkgKyANCiAgZ2VvbV9wb2ludChhZXMoc2hhcGU9bmFtZSwgY29sb3I9bmFtZSksIHBvc2l0aW9uPXBvc2l0aW9uX2RvZGdlKHdpZHRoPTAuMiksIHN0YXQ9ImlkZW50aXR5Iiwgc2l6ZSA9IDIuNSkrDQogIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5IiwgYWVzKHk9c2hhcmVfd29tZW5fZmllbGQsIHg9b3ZlcmFsbF9hZGpfZG9tYWluKSwgYWxwaGE9MC4yLCB3aWR0aCA9IDAuNCkrDQogIGd1aWRlcyhmaWxsID0gZ3VpZGVfbGVnZW5kKHJldmVyc2U9VFJVRSwgdGl0bGUgPSAiTWVhc3VyZSIpKSsNCiAgc2NhbGVfY29sb3JfZGlzY3JldGUobGFiZWxzID0gYygiUHJpbnRlZCBuZXdzIiwgIk9ubGluZSBuZXdzIiwgIlR3aXR0ZXIvWCIpKSsNCiAgc2NhbGVfc2hhcGVfZGlzY3JldGUobGFiZWxzID0gYygiUHJpbnRlZCBuZXdzIiwgIk9ubGluZSBuZXdzIiwgIlR3aXR0ZXIvWCIpKSsNCiAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cyA9IGMoMCwgMC41KSwgYnJlYWtzID0gc2VxKDAsIDAuNSwgYnkgPSAwLjEyNSkpKw0KICBjb29yZF9mbGlwKCkrDQogIHhsYWIoIiIpKw0KICB5bGFiKCIlIFdvbWVuIikrDQogIGxhYnMoY29sb3IgPSAiQXR0ZW50aW9uIHR5cGUiLA0KICAgICAgIHNoYXBlID0gIkF0dGVudGlvbiB0eXBlIikrDQogIGdndGl0bGUoIlRvcCAxMCUgb2YgYXR0ZW50aW9uIGRvbWFpbnMiKSsNCiAgdGhlbWVfbWluaW1hbF92Z3JpZCgpKw0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApICwNCiAgICAgICAgYXhpcy50aXRsZS54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgIGxlZ2VuZC50aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xMSksIA0KICAgICAgICBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT0xMCkpKw0KICBwYW5lbF9ib3JkZXIoKQ0KDQpyZXByX2F0dG5fMjAgPC0gc2hhcmVfd29tZW5fZmllbGRfMjAyMyAlPiUNCiAgZmlsdGVyKHZhbHVlID09IDIgJiBuYW1lICVpbiUgYygiTmV3cyIsICJPbmxpbmUgbmV3cyIsICJUd2l0dGVyIikpJT4lDQogIGdncGxvdChhZXMoeT1zaGFyZV93b21lbiwgeD0gZmN0X3JldihvdmVyYWxsX2Fkal9kb21haW4pKSkgKyANCiAgZ2VvbV9wb2ludChhZXMoc2hhcGU9bmFtZSwgY29sb3I9bmFtZSksIHBvc2l0aW9uPXBvc2l0aW9uX2RvZGdlKHdpZHRoPTAuMiksIHN0YXQ9ImlkZW50aXR5Iiwgc2l6ZSA9IDIuNSkrDQogIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5IiwgYWVzKHk9c2hhcmVfd29tZW5fZmllbGQsIHg9b3ZlcmFsbF9hZGpfZG9tYWluKSwgYWxwaGE9MC4yLCB3aWR0aCA9IDAuNCkrDQogIGd1aWRlcyhmaWxsID0gZ3VpZGVfbGVnZW5kKHJldmVyc2U9VFJVRSwgdGl0bGUgPSAiTWVhc3VyZSIpKSsgIA0KICBzY2FsZV9jb2xvcl9kaXNjcmV0ZShsYWJlbHMgPSBjKCJQcmludGVkIG5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlci9YIikpKw0KICBzY2FsZV9zaGFwZV9kaXNjcmV0ZShsYWJlbHMgPSBjKCJQcmludGVkIG5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlci9YIikpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAwLjUpLCBicmVha3MgPSBzZXEoMCwgMC41LCBieSA9IDAuMTI1KSkrDQogIGNvb3JkX2ZsaXAoKSsNCiAgeGxhYigiIikrDQogIHlsYWIoIiUgV29tZW4iKSsNCiAgbGFicyhjb2xvciA9ICJBdHRlbnRpb24gdHlwZSIsDQogICAgICAgc2hhcGUgPSAiQXR0ZW50aW9uIHR5cGUiKSsNCiAgZ2d0aXRsZSgiVG9wIDIwJSBvZiBhdHRlbnRpb24gZG9tYWlucyIpKw0KICB0aGVtZV9taW5pbWFsX3ZncmlkKCkrDQogIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgYXhpcy50aXRsZS55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMSksDQogICAgICAgIGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCkgLA0KICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTExKSwgDQogICAgICAgIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTEwKSkrDQogIHBhbmVsX2JvcmRlcigpDQpgYGANCg0KIyMgV2l0aGluIHRvdGFsIGF0dGVudGlvbg0KDQpOb3cgZ2V0IHRoZSBzaGFyZXMgb2YgYXR0ZW50aW9uIGdpdmVuIHRvIHdvbWVuIGNvbXBhcmVkIHRvIHRoZWlyIHNoYXJlIGluIHRoZQ0KZmllbGQ6DQpgYGB7cn0NCiMgZmlyc3QsIGdldCB0aGUgbGF0ZXN0IHllYXIgaW4gdGhlIHBhbmVsIGZvciBlYWNoIHByb2YNCndvbWVuX2ZpZWxkXzIwMjMgPC0gcHJvZl9wYW5lbF9maWx0ZXIgJT4lDQogIGdyb3VwX2J5KHByb2ZpbGVfaWQpJT4lDQogIGZpbHRlcih5ZWFyID09IG1heCh5ZWFyKSkNCg0KIyBhbmQgbm93IHNldCB0aGUgZmluYWwgeWVhciBhcyAyMDIzLCBhc3N1bWluZyB0aGVyZSB3YXMgbm8gYXR0ZW50aW9uIGFmdGVyDQojIHdoYXRldmVyIHRoZSBsYXN0IHllYXIgaXMgaW4gdGhlIGRhdGFzZXQgKHF1aXRlIHNvbWUgcHJvZmVzc29ycyB3aXRoDQojIDAgbWVudGlvbnMgZXZlbiBpbiB0aGlzIGxhc3QgeWVhciwgc28gd2Ugd2FudCB0byBrZWVwIHRoZW0gZm9yIGNvcnJlY3QNCiMgc2hhcmVzKQ0Kd29tZW5fZmllbGRfMjAyMyR5ZWFyIDwtIDIwMjMNCg0KIyBnZXQgdGhlaXIgZGVjaWxlIGJhc2VkIG9uIHRoZWlyIHRvdGFsIHBlcmZvcm1hbmNlIHdpdGhpbiB0aGVpciBlbnRyeSBiYXRjaA0Kd29tZW5fZmllbGRfMjAyM19hdHRuX3NoYXJlIDwtIHdvbWVuX2ZpZWxkXzIwMjMgJT4lDQogIGZpbHRlcighaXMubmEob3ZlcmFsbF9hZGpfZG9tYWluKSklPiUNCiAgc2VsZWN0KHByb2ZpbGVfaWQsIHllYXIsIGluZmVycmVkX2dlbmRlciwgb3ZlcmFsbF9hZGpfZG9tYWluLCBjb3VudF9wdWJzX3RvdGFsLA0KICAgICAgICAgY2l0ZWRfYnlfdG90YWxfYWxsLCBhbHRfb25saW5lX2FsbF90b3RhbCwgbmV3c19hbGxfdG90YWwsIGFsdF90d2l0dGVyX3RvdGFsKSU+JQ0KICByZXBsYWNlKGlzLm5hKC4pLCAwKSU+JQ0KICBncm91cF9ieShvdmVyYWxsX2Fkal9kb21haW4pJT4lDQogIHN1bW1hcmlzZSgNCiAgICBwdWJfdyA9IHN1bShjb3VudF9wdWJzX3RvdGFsW2luZmVycmVkX2dlbmRlciA9PSAidyJdKSwNCiAgICBjaXRfdyA9IHN1bShjaXRlZF9ieV90b3RhbF9hbGxbaW5mZXJyZWRfZ2VuZGVyID09ICJ3Il0pLCANCiAgICBvbmxpbmVfdyA9IHN1bShhbHRfb25saW5lX2FsbF90b3RhbFtpbmZlcnJlZF9nZW5kZXIgPT0gInciXSksDQogICAgbmV3c193ID0gc3VtKG5ld3NfYWxsX3RvdGFsW2luZmVycmVkX2dlbmRlciA9PSAidyJdKSwNCiAgICB0d2l0dGVyX3cgPSBzdW0oYWx0X3R3aXR0ZXJfdG90YWxbaW5mZXJyZWRfZ2VuZGVyID09ICJ3Il0pLA0KICAgIHB1YiA9IHN1bShjb3VudF9wdWJzX3RvdGFsKSwNCiAgICBjaXQgPSBzdW0oY2l0ZWRfYnlfdG90YWxfYWxsKSwgDQogICAgb25saW5lID0gc3VtKGFsdF9vbmxpbmVfYWxsX3RvdGFsKSwNCiAgICBuZXdzID0gc3VtKG5ld3NfYWxsX3RvdGFsKSwNCiAgICB0d2l0dGVyID0gc3VtKGFsdF90d2l0dGVyX3RvdGFsKQ0KICApJT4lDQogIG11dGF0ZSgNCiAgICAgICAgIGBQdWJsaWNhdGlvbnNgID0gcHViX3cvcHViLA0KICAgICAgICAgYENpdGF0aW9uc2AgPSBjaXRfdy9jaXQsICAgIA0KICAgICAgICAgYE9ubGluZSBuZXdzYCA9IG9ubGluZV93L29ubGluZSwNCiAgICAgICAgIGBOZXdzYCA9IG5ld3Nfdy9uZXdzLA0KICAgICAgICAgYFR3aXR0ZXJgID0gdHdpdHRlcl93L3R3aXR0ZXIpJT4lDQogIHNlbGVjdChvdmVyYWxsX2Fkal9kb21haW4sIGBQdWJsaWNhdGlvbnNgOmBUd2l0dGVyYCklPiUNCiAgcGl2b3RfbG9uZ2VyKCFvdmVyYWxsX2Fkal9kb21haW4sIG5hbWVzX3RvID0gIm5hbWUiLCB2YWx1ZXNfdG8gPSAic2hhcmVfd29tZW4iKQ0KYGBgDQpDb21iaW5lIHRoZSBmaWVsZCByZXByZXNlbnRhdGlvbiB3aXRoIHRoZSBhdHRlbnRpb24gcmVwcmVzZW50YXRpb246DQpgYGB7cn0NCnNoYXJlX3dvbWVuX2ZpZWxkXzIwMjNfYXR0bl9zaGFyZSA8LSBtZXJnZSh3b21lbl9maWVsZF8yMDIzX2F0dG5fc2hhcmUsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcHJfZmllbGRfMjAyM1tjKCJvdmVyYWxsX2Fkal9kb21haW4iLCAic2hhcmVfd29tZW5fZmllbGQiKV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gIm92ZXJhbGxfYWRqX2RvbWFpbiIpDQoNCnNoYXJlX3dvbWVuX2ZpZWxkXzIwMjNfYXR0bl9zaGFyZSRzaGFyZV93b21lbl9maWVsZCA8LSBpZmVsc2Uoc2hhcmVfd29tZW5fZmllbGRfMjAyM19hdHRuX3NoYXJlJG5hbWUgPT0gIk5ld3MiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZV93b21lbl9maWVsZF8yMDIzX2F0dG5fc2hhcmUkc2hhcmVfd29tZW5fZmllbGQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5BKQ0KYGBgDQoNClBsb3QgdGhpcyBvdXQ6DQpgYGB7ciB3YXJuaW5nID0gRn0NCnNoYXJlX3dvbWVuX2ZpZWxkXzIwMjNfYXR0bl9zaGFyZSRvdmVyYWxsX2Fkal9kb21haW4gPC0gZmFjdG9yKHNoYXJlX3dvbWVuX2ZpZWxkXzIwMjNfYXR0bl9zaGFyZSRvdmVyYWxsX2Fkal9kb21haW4sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxzID0gYygiUGh5c2ljYWwgU2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkxpZmUgU2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkhlYWx0aCBTY2llbmNlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiU29jaWFsIFNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJBcnRzIGFuZCBIdW1hbml0aWVzIikpDQoNCnJlcHJfYXR0bl9zaGFyZSA8LSBzaGFyZV93b21lbl9maWVsZF8yMDIzX2F0dG5fc2hhcmUgJT4lDQogIGZpbHRlcihuYW1lICVpbiUgYygiTmV3cyIsICJPbmxpbmUgbmV3cyIsICJUd2l0dGVyIikpJT4lDQogIGdncGxvdChhZXMoeT1zaGFyZV93b21lbiwgeD1mY3RfcmV2KG92ZXJhbGxfYWRqX2RvbWFpbikpKSArIA0KICBnZW9tX3BvaW50KGFlcyhzaGFwZT1uYW1lLCBjb2xvcj1uYW1lKSwgcG9zaXRpb249cG9zaXRpb25fZG9kZ2Uod2lkdGg9MC4yKSwgc3RhdD0iaWRlbnRpdHkiLCBzaXplID0gMi41KSsNCiAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCBhZXMoeT1zaGFyZV93b21lbl9maWVsZCwgeD1vdmVyYWxsX2Fkal9kb21haW4pLCBhbHBoYT0wLjIsIHdpZHRoID0gMC40KSsNCiAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZT1UUlVFLCB0aXRsZSA9ICJNZWFzdXJlIikpKw0KICBzY2FsZV9jb2xvcl9kaXNjcmV0ZShsYWJlbHMgPSBjKCJQcmludGVkIG5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlci9YIikpKw0KICBzY2FsZV9zaGFwZV9kaXNjcmV0ZShsYWJlbHMgPSBjKCJQcmludGVkIG5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlci9YIikpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAwLjUpLCBicmVha3MgPSBzZXEoMCwgMC41LCBieSA9IDAuMTI1KSkrDQogIGNvb3JkX2ZsaXAoKSsNCiAgeGxhYigiIikrDQogIHlsYWIoIiUgV29tZW4iKSsNCiAgbGFicyhjb2xvciA9ICJBdHRlbnRpb24gdHlwZSIsDQogICAgICAgc2hhcGUgPSAiQXR0ZW50aW9uIHR5cGUiKSsNCiAgZ2d0aXRsZSgiVG90YWwgYXR0ZW50aW9uIikrDQogIHRoZW1lX21pbmltYWxfdmdyaWQoKSsNCiAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSAsDQogICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF90ZXh0KHNpemU9MTEpLCANCiAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9MTApKSsNCiAgcGFuZWxfYm9yZGVyKCkNCmBgYA0KDQpDb21iaW5lIHRoZSBwbG90cyBmb3IgRmlndXJlIDEsIHBhbmVsIEI6DQpgYGB7ciBmaWcud2lkdGg9MTAsIGZpZy5oZWlnaHQ9NH0NCmxlZ2VuZF9zaGFyZSA8LSBnZXRfbGVnZW5kKA0KICByZXByX2F0dG5fc2hhcmUNCikNCg0KDQpjb21iaV9wbG90IDwtIHBsb3RfZ3JpZChyZXByX2F0dG5fc2hhcmUgKyB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUueT1lbGVtZW50X2JsYW5rKCkpLCANCiAgICAgICAgICAgICAgICAgICAgICAgIHJlcHJfYXR0bl8xMCArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlLnk9ZWxlbWVudF9ibGFuaygpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X2JsYW5rKCkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgcmVwcl9hdHRuXzIwICsgdGhlbWUobGVnZW5kLnBvc2l0aW9uPSJub25lIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUueT1lbGVtZW50X2JsYW5rKCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfYmxhbmsoKSksDQogICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRfc2hhcmUsDQogICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgbmNvbCA9IDQsDQogICAgICAgICAgICAgICAgICAgICAgICByZWxfd2lkdGhzID0gYygxLjMsIDAuOSwgMC45LCAwLjQpKQ0KDQpjb21iaV9wbG90DQoNCmBgYA0KDQpQcmludCBvdXQgRmlndXJlIDEgaW4gdGhlIG1haW4gdGV4dC4NCmBgYHtyIGZpZy53aWR0aD0gMTEsIGZpZy5oZWlnaHQgPSA4LCB3YXJuaW5nID0gRiwgbWVzc2FnZSA9IEZ9DQoNCmNvbWJpX3Bsb3RfMiA8LSBwbG90X2dyaWQoDQogIGNvbWJpX3Bsb3RfYXZlcmFnZXMsDQogIGNvbWJpX3Bsb3QsDQogIGxhYmVscyA9IGMoIkEiLCJCIiksDQogIG5jb2wgPSAxLA0KICBucm93ID0gMiwNCiAgcmVsLmhlaWdodHMgPSBjKDEsIDEpLA0KICBhbGlnbiA9ICd2JywNCiAgYXhpcyA9ICdsJykNCg0KY29tYmlfcGxvdF8yDQoNCmdnc2F2ZTIoDQogIGZpbGVuYW1lID0gInJlc3VsdHMvc3VwcGxlbWVudF9maWd1cmVzL0ZpZ3VyZV8xX3Njb3B1cy5wbmciLA0KICBwbG90ID0gY29tYmlfcGxvdF8yLA0KICB3aWR0aCA9IDExLA0KICBoZWlnaHQgPSA3LA0KICB1bml0cyA9IGMoImluIiksDQogIGRwaSA9IDYwMCwNCiAgYmcgPSAid2hpdGUiDQopDQoNCmBgYA0KDQojIFJlZ3Jlc3Npb24gbW9kZWxzDQoNCkZpcnN0LCBvYnRhaW4gYmluYXJ5IHZhcmlhYmxlcyBmb3IgYW55IGF0dGVudGlvbiByZWNlaXZlZCB0aGF0IHllYXI6DQpgYGB7cn0NCnByb2ZfcGFuZWxfZmlsdGVyJGFueV9uZXdzIDwtIGFzLmZhY3RvcihpZmVsc2UocHJvZl9wYW5lbF9maWx0ZXIkbmV3c19hbGwgPiAwLCAxLCAwKSkNCnByb2ZfcGFuZWxfZmlsdGVyJGFueV9uZXdzX2wgPC0gYXMuZmFjdG9yKGlmZWxzZShwcm9mX3BhbmVsX2ZpbHRlciRuZXdzX2FsbF9sID4gMCwgMSwgMCkpDQoNCnByb2ZfcGFuZWxfZmlsdGVyJGFueV9vbmxpbmVfbmV3cyA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfYWxsID4gMCwgMSwgMCkpDQpwcm9mX3BhbmVsX2ZpbHRlciRhbnlfb25saW5lX25ld3NfbCA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfYWxsX2wgPiAwLCAxLCAwKSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X29ubGluZV9uZXdzX2dlbiA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfZ2VuZXJhbF9hbGwgPiAwLCAxLCAwKSkNCnByb2ZfcGFuZWxfZmlsdGVyJGFueV9vbmxpbmVfbmV3c19nZW5fbCA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfZ2VuZXJhbF9hbGxfbCA+IDAsIDEsIDApKQ0KDQpwcm9mX3BhbmVsX2ZpbHRlciRhbnlfb25saW5lX25ld3NfbmFtZSA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfbmFtZV9hbGwgPiAwLCAxLCAwKSkNCnByb2ZfcGFuZWxfZmlsdGVyJGFueV9vbmxpbmVfbmV3c19uYW1lX2wgPC0gYXMuZmFjdG9yKGlmZWxzZShwcm9mX3BhbmVsX2ZpbHRlciRhbHRfb25saW5lX25hbWVfYWxsX2wgPiAwLCAxLCAwKSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X3R3aXR0ZXIgPC0gYXMuZmFjdG9yKGlmZWxzZShwcm9mX3BhbmVsX2ZpbHRlciRhbHRfdHdpdHRlciA+IDAsIDEsIDApKQ0KcHJvZl9wYW5lbF9maWx0ZXIkYW55X3R3aXR0ZXJfbCA8LSBhcy5mYWN0b3IoaWZlbHNlKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF90d2l0dGVyX2wgPiAwLCAxLCAwKSkNCmBgYA0KDQpUaGVuLCBjb25zdHJ1Y3QgYSBiaW5hcnkgdmFyaWFibGVzIGZvciBiZWxvbmdpbmcgdG8gdGhlIHRvcCAxMC8yMCUgaW4gdGhlIGF0dGVudGlvbiBmb3IgZWFjaCBzb3VyY2UuDQpgYGB7cn0NCnBhbmVsX2ZpbHRlcl9sb25nIDwtIHByb2ZfcGFuZWxfZmlsdGVyICU+JQ0KICBwaXZvdF9sb25nZXIoYyhhbHRfb25saW5lX2FsbCwgYWx0X29ubGluZV9uYW1lX2FsbCwgbmV3c19hbGwsIGFsdF90d2l0dGVyKSwgbmFtZXNfdG8gPSAibWVhc3VyZSIsIHZhbHVlc190byA9ICJ2YWx1ZSIpDQoNCnRvcF8xMF9hdHRuIDwtIHBhbmVsX2ZpbHRlcl9sb25nICU+JQ0KICBmaWx0ZXIoIWlzLm5hKG92ZXJhbGxfYWRqX2RvbWFpbikgJiAhaXMubmEoeWVhcikgJiB5ZWFyID4gMjAxMSklPiUNCiAgZ3JvdXBfYnkob3ZlcmFsbF9hZGpfZG9tYWluLCB5ZWFyLCBtZWFzdXJlKSU+JQ0KICBmaWx0ZXIocXVhbnRpbGUodmFsdWUsIDAuOTAsIG5hLnJtID0gVFJVRSk8PXZhbHVlKSU+JQ0KICBzZWxlY3QocHJvZmlsZV9pZCwgb3ZlcmFsbF9hZGpfZG9tYWluLCB5ZWFyLCBtZWFzdXJlLCB2YWx1ZSkNCg0KdG9wXzEwX2F0dG4kbWVhc3VyZSA8LSBwYXN0ZTAodG9wXzEwX2F0dG4kbWVhc3VyZSwgIl90b3BfMTAiKQ0KDQoNCnRvcF8xMF9hdHRuIDwtIHRvcF8xMF9hdHRuICU+JQ0KICBwaXZvdF93aWRlcihuYW1lc19mcm9tID0gIm1lYXN1cmUiKSU+JQ0KICBtdXRhdGUoYWNyb3NzKGNvbnRhaW5zKCd0b3BfMTAnKSwgIH5pZmVsc2UoaXMubmEoLiksIDAsIDEpKSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIgPC0gbWVyZ2UocHJvZl9wYW5lbF9maWx0ZXIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BfMTBfYXR0bltjKCJ5ZWFyIiwgInByb2ZpbGVfaWQiLCAib3ZlcmFsbF9hZGpfZG9tYWluIiwgImFsdF9vbmxpbmVfYWxsX3RvcF8xMCIsICJhbHRfb25saW5lX25hbWVfYWxsX3RvcF8xMCIsICJhbHRfdHdpdHRlcl90b3BfMTAiLCAibmV3c19hbGxfdG9wXzEwIildLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSBjKCJwcm9maWxlX2lkIiwgInllYXIiLCAib3ZlcmFsbF9hZGpfZG9tYWluIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwueSA9IEZBTFNFKQ0KDQp0b3BfMjBfYXR0biA8LSBwYW5lbF9maWx0ZXJfbG9uZyAlPiUNCiAgZmlsdGVyKCFpcy5uYShvdmVyYWxsX2Fkal9kb21haW4pICYgIWlzLm5hKHllYXIpICYgeWVhciA+IDIwMTEpJT4lDQogIGdyb3VwX2J5KG92ZXJhbGxfYWRqX2RvbWFpbiwgeWVhciwgbWVhc3VyZSklPiUNCiAgZmlsdGVyKHF1YW50aWxlKHZhbHVlLCAwLjgwLCBuYS5ybSA9IFRSVUUpPD12YWx1ZSklPiUNCiAgc2VsZWN0KHByb2ZpbGVfaWQsIG92ZXJhbGxfYWRqX2RvbWFpbiwgeWVhciwgbWVhc3VyZSwgdmFsdWUpDQoNCnRvcF8yMF9hdHRuJG1lYXN1cmUgPC0gcGFzdGUwKHRvcF8yMF9hdHRuJG1lYXN1cmUsICJfdG9wXzIwIikNCg0KDQp0b3BfMjBfYXR0biA8LSB0b3BfMjBfYXR0biAlPiUNCiAgcGl2b3Rfd2lkZXIobmFtZXNfZnJvbSA9ICJtZWFzdXJlIiklPiUNCiAgbXV0YXRlKGFjcm9zcyhjb250YWlucygndG9wXzIwJyksICB+aWZlbHNlKGlzLm5hKC4pLCAwLCAxKSkpDQoNCnByb2ZfcGFuZWxfZmlsdGVyIDwtIG1lcmdlKHByb2ZfcGFuZWxfZmlsdGVyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wXzIwX2F0dG5bYygieWVhciIsICJwcm9maWxlX2lkIiwgIm92ZXJhbGxfYWRqX2RvbWFpbiIsICJhbHRfb25saW5lX2FsbF90b3BfMjAiLCAiYWx0X29ubGluZV9uYW1lX2FsbF90b3BfMjAiLCAiYWx0X3R3aXR0ZXJfdG9wXzIwIiwgIm5ld3NfYWxsX3RvcF8yMCIpXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gYygicHJvZmlsZV9pZCIsICJ5ZWFyIiwgIm92ZXJhbGxfYWRqX2RvbWFpbiIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsLnggPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsLnkgPSBGQUxTRSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIgPC0gZmlsdGVyKHByb2ZfcGFuZWxfZmlsdGVyLCAhaXMubmEob3ZlcmFsbF9hZGpfZG9tYWluKSkNCg0KIyBpZiBOQSwgbmVlZHMgdG8gYmUgMA0KcHJvZl9wYW5lbF9maWx0ZXIgPC0gcHJvZl9wYW5lbF9maWx0ZXIgJT4lDQogIG11dGF0ZShhY3Jvc3MoY29udGFpbnMoJ3RvcF8xMCcpLCAgfmlmZWxzZShpcy5uYSguKSwgMCwgLikpKSU+JQ0KICBtdXRhdGUoYWNyb3NzKGNvbnRhaW5zKCd0b3BfMjAnKSwgIH5pZmVsc2UoaXMubmEoLiksIDAsIC4pKSkNCmBgYA0KTG9nIG9mIHZhcmlhYmxlczoNCmBgYHtyfQ0KcHJvZl9wYW5lbF9maWx0ZXIkbmV3c19hbGxfbG9nIDwtIGxvZyhwcm9mX3BhbmVsX2ZpbHRlciRuZXdzX2FsbCsxKQ0KcHJvZl9wYW5lbF9maWx0ZXIkbmV3c19hbGxfbF9sb2cgPC0gbG9nKHByb2ZfcGFuZWxfZmlsdGVyJG5ld3NfYWxsX2wrMSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9hbGxfbG9nIDwtIGxvZyhwcm9mX3BhbmVsX2ZpbHRlciRhbHRfb25saW5lX2FsbCsxKQ0KcHJvZl9wYW5lbF9maWx0ZXIkYWx0X29ubGluZV9hbGxfbF9sb2cgPC0gbG9nKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfYWxsX2wrMSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIkYWx0X3R3aXR0ZXJfbG9nIDwtIGxvZyhwcm9mX3BhbmVsX2ZpbHRlciRhbHRfdHdpdHRlcisxKQ0KcHJvZl9wYW5lbF9maWx0ZXIkYWx0X3R3aXR0ZXJfbF9sb2cgPC0gbG9nKHByb2ZfcGFuZWxfZmlsdGVyJGFsdF90d2l0dGVyX2wrMSkNCiMgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhpcyB2YXJpYWJsZQ0KcHJvZl9wYW5lbF9maWx0ZXIkY2l0ZWRfYnlfdG90YWxfYWxsX2xfbG9nIDwtIGxvZyhwcm9mX3BhbmVsX2ZpbHRlciRjaXRlZF9ieV90b3RhbF9hbGxfbCsxKQ0KcHJvZl9wYW5lbF9maWx0ZXIkY2l0ZWRfYnlfdG90YWxfYWxsX2xfbG9nW3doaWNoKGlzLm5hbihwcm9mX3BhbmVsX2ZpbHRlciRjaXRlZF9ieV90b3RhbF9hbGxfbF9sb2cpKV0gPC0gTkENCnByb2ZfcGFuZWxfZmlsdGVyJGNpdGVkX2J5X3RvdGFsX2FsbF9sX2xvZ1t3aGljaChpcy5pbmZpbml0ZShwcm9mX3BhbmVsX2ZpbHRlciRjaXRlZF9ieV90b3RhbF9hbGxfbF9sb2cpKV0gPC0gTkENCnByb2ZfcGFuZWxfZmlsdGVyJGFsdF9vbmxpbmVfYWxsX3RvdGFsX2xfbG9nIDwtIGxvZyhwcm9mX3BhbmVsX2ZpbHRlciRhbHRfb25saW5lX2FsbF90b3RhbF9sKzEpDQpwcm9mX3BhbmVsX2ZpbHRlciRhbHRfdHdpdHRlcl90b3RhbF9sX2xvZyA8LSBsb2cocHJvZl9wYW5lbF9maWx0ZXIkYWx0X3R3aXR0ZXJfdG90YWxfbCsxKQ0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sX2xvZyA8LSBsb2cocHJvZl9wYW5lbF9maWx0ZXIkY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sKzEpDQpwcm9mX3BhbmVsX2ZpbHRlciRjb2Ffb25saW5lX2FsbF90b3RhbF9sX2xvZyA8LSBsb2cocHJvZl9wYW5lbF9maWx0ZXIkY29hX29ubGluZV9hbGxfdG90YWxfbCsxKQ0KcHJvZl9wYW5lbF9maWx0ZXIkY29hX3R3aXR0ZXJfdG90YWxfbF9sb2cgPC0gbG9nKHByb2ZfcGFuZWxfZmlsdGVyJGNvYV90d2l0dGVyX3RvdGFsX2wrMSkNCg0KcHJvZl9wYW5lbF9maWx0ZXIkbmV3c19hbGxfdG90YWxfbF9sb2cgPC0gbG9nKHByb2ZfcGFuZWxfZmlsdGVyJG5ld3NfYWxsX3RvdGFsX2wrMSkNCg0KYGBgDQoNClNwbGl0IGRhdGFzZXRzIHBlciBmaWVsZDoNCmBgYHtyfQ0KbGlmZSA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIG92ZXJhbGxfYWRqX2RvbWFpbiA9PSAiTGlmZSBTY2llbmNlcyIpDQpwaHlzIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgb3ZlcmFsbF9hZGpfZG9tYWluID09ICJQaHlzaWNhbCBTY2llbmNlcyIpDQpzb2Nfc2NpIDwtIGZpbHRlcihwcm9mX3BhbmVsX2ZpbHRlciwgb3ZlcmFsbF9hZGpfZG9tYWluID09ICJTb2NpYWwgU2NpZW5jZXMiKQ0KYXJ0cyA8LSBmaWx0ZXIocHJvZl9wYW5lbF9maWx0ZXIsIG92ZXJhbGxfYWRqX2RvbWFpbiA9PSAiQXJ0cyBhbmQgSHVtYW5pdGllcyIpDQpoZWFsdGggPC0gZmlsdGVyKHByb2ZfcGFuZWxfZmlsdGVyLCBvdmVyYWxsX2Fkal9kb21haW4gPT0gIkhlYWx0aCBTY2llbmNlcyIpDQpgYGANCg0KIyMgTWFpbiBtb2RlbHMNCg0KU2VlICJoZWxwZXJfZnVuY3Rpb25zLlIiIGZvciBkZXRhaWxzIG9uIHRoZSBmdW5jdGlvbiB3ZSB1c2UgdG8gZml0IHRoZSBtb2RlbHMuDQoNClRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGxpc3QgY29udGFpbmluZzoNCg0KMS4gdGhlIG1vZGVsIGNvZWZmaWNpZW50cw0KMi4gdGhlIHByZWRpY3Rpb24gcGVyIGdlbmRlcg0KMy4gcGFpcndpc2UgdGVzdGluZyBvZiBzaWduaWZpY2FuY2Ugb2YgcHJlZGljdGlvbnMgZm9yIG1lbiBhbmQgd29tZW4NCg0KV2UgdGhlbiB1c2UgdGhpcyBvdXRwdXQgdG8gcGxvdCBvdXIgcmVzdWx0cyBhbmQgb3V0cHV0IHRoZSBmaW5hbCBtb2RlbA0KdGFibGVzLg0KDQojIyMgTmV3cyBhdHRlbnRpb24NCg0KTmV3cyBhdHRlbnRpb24gbW9kZWxzLCBwZXIgZmllbGQsIGNvbnRyb2xsaW5nIGZvcjoNCi0gbGFzdCB0aW1lIHBlcmlvZCdzIG5ld3MNCi0gdG90YWwgY2l0YXRpb25zIHJlY2VpdmVkIHVwIHRvIHRoZSBsYXN0IHBlcmlvZA0KLSB0b3RhbCBvbmxpbmUgYXR0ZW50aW9uIHJlY2VpdmVkIHVwIHRvICB0aGUgbGFzdCBwZXJpb2QNCi0gdG90YWwgdHdpdHRlciBhdHRlbnRpb24gcmVjZWl2ZWQgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHRvdGFsIGNpdGF0aW9ucyByZWNlaXZlZCBieSBhbGwgY29hdXRob3JzIHVwIHRvIHRoZSBsYXN0IHBlcmlvZA0KLSBvbmxpbmUgYXR0ZW50aW9uIHJlY2VpdmVkIGJ5IGFsbCBjb2F1dGhvcnMgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHR3aXR0ZXIgYXR0ZW50aW9uIHJlY2VpdmVkIGJ5IGFsbCBjb2F1dGhvcnMgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHllYXIgY29udHJvbA0KSW5kaXZpZHVhbCBjbHVzdGVyZWQgU0UuIE1vZGVscyByYW4gcGVyIGVhY2ggZmllbGQgc2VwYXJhdGVseS4gDQoNCmBgYHtyIHdhcm5pbmcgPSBGfQ0KbmV3c19mb3JtdWxhX21haW5fbW9kZWwgPC0gIm5ld3NfYWxsIH4gaW5mZXJyZWRfZ2VuZGVyICsgbmV3c19hbGxfbCArIGNpdGVkX2J5X3RvdGFsX2FsbF9sICsgYWx0X29ubGluZV9hbGxfdG90YWxfbCArIGFsdF90d2l0dGVyX3RvdGFsX2wgK2NvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArIGNvYV90b3Rfb25saW5lX2FsbF90b3RhbF9sICsgY29hX3RvdF90d2l0dGVyX3RvdGFsX2wreWVhcnNfc2luY2VfZmlyc3RfcHViICsgYXMuZmFjdG9yKHllYXIpIg0KDQpuZXdzX21haW5fbW9kZWwgPC0gbG1fZml0dGVyX2NsX3JvYnVzdF9zY29wdXMocGFuZWxfZGF0YXNldCA9IHByb2ZfcGFuZWxfZmlsdGVyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG1fZm9ybXVsYSA9IG5ld3NfZm9ybXVsYV9tYWluX21vZGVsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhcl9jdXRvZmZfdXBwZXIgPSAyMDIzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhcl9jdXRvZmZfbG93ZXIgPSAxOTczKQ0KYGBgDQoNClBsb3QgZ2VuZGVyIGRpZmZlcmVuY2VzOg0KYGBge3IgZmlnLmhlaWdodD0zLCBmaWdoLndpZHRoID0gNH0NCiMgdXNlIHRoZSBwYWlyd2lzZSBjb21wYXJpc29ucyB0byBjb21wYXJlIGdyb3VwcyBpbiB0aGUgcGxvdA0KcF92YWx1ZXMgPC0gbmV3c19tYWluX21vZGVsW1szXV0NCiMgbWFudWFsbHkgYWRkIHNvbWUgZWxlbWVudHMgd2UgbmVlZCB0byBldmVyeXRoaW5nIHRvIGxvb2sgZ29vZA0KcF92YWx1ZXMkeCA8LSBjKDEsIDIsIDMsIDQsIDUpDQpwX3ZhbHVlcyRncm91cHMgPC0gJ2MoIm0iLCAidyIpJw0KcF92YWx1ZXMkeG1pbiA8LSBjKDAuOCwgMS44LCAyLjgsIDMuOCwgNC44KQ0KcF92YWx1ZXMkeG1heCA8LSBjKDEuMiwgMi4yLCAzLjIsIDQuMiwgNS4yKQ0KDQpwcmVkaWN0aW9uc19wbG90IDwtIG5ld3NfbWFpbl9tb2RlbFtbMl1dDQoNCm5ld3NfZ2VuZGVyX3Bsb3QgPC0gcHJlZGljdGlvbnNfcGxvdCAlPiUNCiAgZ2dwbG90KGFlcyh4ID0gZmllbGQsDQogICAgICAgICAgICAgeSA9IHByZWRpY3RlZCwNCiAgICAgICAgICAgICB5bWluID0gY29uZi5sb3csDQogICAgICAgICAgICAgeW1heCA9IGNvbmYuaGlnaCwNCiAgICAgICAgICAgICBjb2xvciA9IHgpKSArDQogIGdlb21fcG9pbnRyYW5nZShwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC41KSwNCiAgICAgICAgICAgICAgICAgIHNpemUgPSAwLjUpKw0KICBnZ3RpdGxlKCJQcmludGVkIG5ld3MgYXR0ZW50aW9uIHByZWRpY3Rpb24iKSsNCiAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cyA9IGMoMCwgMTApLCBicmVha3MgPSBzZXEoMCwgMTAsIGJ5ID0gMikpKw0KICBzdGF0X3B2YWx1ZV9tYW51YWwoDQogICAgcF92YWx1ZXMsDQogICAgeS5wb3NpdGlvbiA9IGMoNy41LCA1LCA3LjUsIDkuNCwgNi44KSwNCiAgICBsYWJlbC5zaXplID0gMywNCiAgICB0aXAubGVuZ3RoID0gMC4wMDMsDQogICAgbGFiZWwgPSAie3N0YXJzfSIsDQogICAgcmVtb3ZlLmJyYWNrZXQgPSBGQUxTRSwNCiAgKSsNCiAgeGxhYigiRmllbGQiKSsNCiAgc2NhbGVfeF9kaXNjcmV0ZShsYWJlbHM9YygiYXJ0cyIgPSAiQXJ0cyAmXG4gSHVtYW5pdGllcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgImhlYWx0aCIgPSAiTWVkaWNpbmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb2Nfc2NpIiA9ICJTb2NpYWwgc2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsaWZlIiA9ICJMaWZlIHNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGh5cyIgPSAiUGh5c2ljYWwgc2NpZW5jZXMiKSkrDQogIHlsYWIoIlllYXJseSBhdHRlbnRpb24iKSsNCiAgbGFicyhjb2xvciA9ICJJbmZlcnJlZCBnZW5kZXIiKSsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IGMoIiMzNGQzOTkiLCAiI2ZiYmYyNCIpLCBsYWJlbHMgPSBjKCJNZW4iLCAiV29tZW4iKSkrDQogIHRoZW1lX21pbmltYWxfaGdyaWQoKSsNCiAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwLCBhbmdsZSA9IDMwLCBoanVzdCA9IDAuOSkgLA0KICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTExKSwgDQogICAgICAgIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTEwKSkNCmBgYA0KDQojIyMgT25saW5lIG5ld3MgYXR0ZW50aW9uDQoNCk9ubGluZSBuZXdzIGF0dGVudGlvbiBtb2RlbHMsIHBlciBmaWVsZCwgY29udHJvbGxpbmcgZm9yOg0KLSBsYXN0IHRpbWUgcGVyaW9kJ3Mgb25saW5lIG5ld3MgbmV3cw0KLSB0b3RhbCBjaXRhdGlvbnMgcmVjZWl2ZWQgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHRvdGFsIG5ld3MgYXR0ZW50aW9uIHJlY2VpdmVkIHVwIHRvICB0aGUgbGFzdCBwZXJpb2QNCi0gdG90YWwgdHdpdHRlciBhdHRlbnRpb24gcmVjZWl2ZWQgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHRvdGFsIGNpdGF0aW9ucyByZWNlaXZlZCBieSBhbGwgY29hdXRob3JzIHVwIHRvIHRoZSBsYXN0IHBlcmlvZA0KLSBvbmxpbmUgYXR0ZW50aW9uIHJlY2VpdmVkIGJ5IGFsbCBjb2F1dGhvcnMgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHR3aXR0ZXIgYXR0ZW50aW9uIHJlY2VpdmVkIGJ5IGFsbCBjb2F1dGhvcnMgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHllYXIgY29udHJvbA0KSW5kaXZpZHVhbCBjbHVzdGVyZWQgU0UuDQpgYGB7cn0NCm9ubGluZV9uZXdzX2Zvcm11bGFfbWFpbl9tb2RlbCA8LSAiYWx0X29ubGluZV9hbGwgfiBpbmZlcnJlZF9nZW5kZXIgKyBhbHRfb25saW5lX2FsbF9sICsgY2l0ZWRfYnlfdG90YWxfYWxsX2wgKyBuZXdzX2FsbF90b3RhbF9sICsgYWx0X3R3aXR0ZXJfdG90YWxfbCArY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sICsgY29hX3RvdF9vbmxpbmVfYWxsX3RvdGFsX2wgKyBjb2FfdG90X3R3aXR0ZXJfdG90YWxfbCt5ZWFyc19zaW5jZV9maXJzdF9wdWIgKyBhcy5mYWN0b3IoeWVhcikiDQoNCm9ubGluZV9uZXdzX21haW5fbW9kZWwgPC0gbG1fZml0dGVyX2NsX3JvYnVzdF9zY29wdXMocGFuZWxfZGF0YXNldCA9IHByb2ZfcGFuZWxfZmlsdGVyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxtX2Zvcm11bGEgPSBvbmxpbmVfbmV3c19mb3JtdWxhX21haW5fbW9kZWwsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhcl9jdXRvZmZfdXBwZXIgPSAyMDIzLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHllYXJfY3V0b2ZmX2xvd2VyID0gMTk3NCkNCmBgYA0KDQpQbG90IGdlbmRlciBkaWZmZXJlbmNlczoNCmBgYHtyIGZpZy5oZWlnaHQ9MywgZmlnaC53aWR0aCA9IDR9DQojIHVzZSB0aGUgcGFpcndpc2UgY29tcGFyaXNvbnMgdG8gY29tcGFyZSBncm91cHMgaW4gdGhlIHBsb3QNCnBfdmFsdWVzIDwtIG9ubGluZV9uZXdzX21haW5fbW9kZWxbWzNdXQ0KIyBtYW51YWxseSBhZGQgc29tZSBlbGVtZW50cyB3ZSBuZWVkIHRvIGV2ZXJ5dGhpbmcgdG8gbG9vayBnb29kDQpwX3ZhbHVlcyR4IDwtIGMoMSwgMiwgMywgNCwgNSkNCnBfdmFsdWVzJGdyb3VwcyA8LSAnYygibSIsICJ3IiknDQpwX3ZhbHVlcyR4bWluIDwtIGMoMC44LCAxLjgsIDIuOCwgMy44LCA0LjgpDQpwX3ZhbHVlcyR4bWF4IDwtIGMoMS4yLCAyLjIsIDMuMiwgNC4yLCA1LjIpDQoNCnByZWRpY3Rpb25zX3Bsb3QgPC0gb25saW5lX25ld3NfbWFpbl9tb2RlbFtbMl1dDQoNCg0Kb25saW5lX25ld3NfZ2VuZGVyX3Bsb3QgPC0gcHJlZGljdGlvbnNfcGxvdCAlPiUNCiAgZ2dwbG90KGFlcyh4ID0gZmllbGQsDQogICAgICAgICAgICAgeSA9IHByZWRpY3RlZCwNCiAgICAgICAgICAgICB5bWluID0gY29uZi5sb3csDQogICAgICAgICAgICAgeW1heCA9IGNvbmYuaGlnaCwNCiAgICAgICAgICAgICBjb2xvciA9IHgpKSArDQogIGdlb21fcG9pbnRyYW5nZShwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC41KSwNCiAgICAgICAgICAgICAgICAgIHNpemUgPSAwLjUpKw0KICBnZ3RpdGxlKCJPbmxpbmUgbmV3cyBhdHRlbnRpb24gcHJlZGljdGlvbiIpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAyNSksIGJyZWFrcyA9IHNlcSgwLCAyNSwgYnkgPSA1KSkrDQogIHN0YXRfcHZhbHVlX21hbnVhbCgNCiAgICBwX3ZhbHVlcywNCiAgICB5LnBvc2l0aW9uID0gYygxMy41LCAxNS41LCAxOC4yLCA2LjUsIDIuNSksDQogICAgbGFiZWwuc2l6ZSA9IDMsDQogICAgdGlwLmxlbmd0aCA9IDAuMDAzLA0KICAgIGxhYmVsID0gIntzdGFyc30iLA0KICAgIHJlbW92ZS5icmFja2V0ID0gRkFMU0UsDQogICkrDQogIHhsYWIoIkZpZWxkIikrDQogIHNjYWxlX3hfZGlzY3JldGUobGFiZWxzPWMoImFydHMiID0gIkFydHMgJlxuIEh1bWFuaXRpZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICJoZWFsdGgiID0gIk1lZGljaW5lIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAic29jX3NjaSIgPSAiU29jaWFsIHNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAibGlmZSIgPSAiTGlmZSBzY2llbmNlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgInBoeXMiID0gIlBoeXNpY2FsIHNjaWVuY2VzIikpKw0KICB5bGFiKCJZZWFybHkgYXR0ZW50aW9uIikrDQogIGxhYnMoY29sb3IgPSAiSW5mZXJyZWQgZ2VuZGVyIikrDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCIjMzRkMzk5IiwgIiNmYmJmMjQiKSwgbGFiZWxzID0gYygiTWVuIiwgIldvbWVuIikpKw0KICB0aGVtZV9taW5pbWFsX2hncmlkKCkrDQogICAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwLCBhbmdsZSA9IDMwLCBoanVzdCA9IDAuOSkgLA0KICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTExKSwgDQogICAgICAgIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTEwKSkNCg0KYGBgDQoNCiMjIyBUd2l0dGVyL1ggYXR0ZW50aW9uDQpUd2l0dGVyL1ggYXR0ZW50aW9uIG1vZGVscywgcGVyIGZpZWxkLCBjb250cm9sbGluZyBmb3I6DQotIGxhc3QgdGltZSBwZXJpb2QncyB0d2l0dGVyIGF0dGVudGlvbg0KLSB0b3RhbCBjaXRhdGlvbnMgcmVjZWl2ZWQgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIHRvdGFsIG9ubGluZSBhdHRlbnRpb24gcmVjZWl2ZWQgdXAgdG8gIHRoZSBsYXN0IHBlcmlvZA0KLSB0b3RhbCBuZXdzIGF0dGVudGlvbiByZWNlaXZlZCB1cCB0byB0aGUgbGFzdCBwZXJpb2QNCi0gdG90YWwgY2l0YXRpb25zIHJlY2VpdmVkIGJ5IGFsbCBjb2F1dGhvcnMgdXAgdG8gdGhlIGxhc3QgcGVyaW9kDQotIG9ubGluZSBhdHRlbnRpb24gcmVjZWl2ZWQgYnkgYWxsIGNvYXV0aG9ycyB1cCB0byB0aGUgbGFzdCBwZXJpb2QNCi0gdHdpdHRlciBhdHRlbnRpb24gcmVjZWl2ZWQgYnkgYWxsIGNvYXV0aG9ycyB1cCB0byB0aGUgbGFzdCBwZXJpb2QNCi0geWVhciBjb250cm9sDQpJbmRpdmlkdWFsIGNsdXN0ZXJlZCBTRS4NCmBgYHtyfQ0KdHdpdHRlcl9mb3JtdWxhX21haW5fbW9kZWwgPC0gImFsdF90d2l0dGVyIH4gaW5mZXJyZWRfZ2VuZGVyICsgYWx0X3R3aXR0ZXJfbCArIGNpdGVkX2J5X3RvdGFsX2FsbF9sICsgbmV3c19hbGxfdG90YWxfbCArIGFsdF9vbmxpbmVfYWxsX3RvdGFsX2wgK2NvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCArIGNvYV90b3Rfb25saW5lX2FsbF90b3RhbF9sICsgY29hX3RvdF90d2l0dGVyX3RvdGFsX2wreWVhcnNfc2luY2VfZmlyc3RfcHViICsgYXMuZmFjdG9yKHllYXIpIg0KDQp0d2l0dGVyX21haW5fbW9kZWwgPC0gbG1fZml0dGVyX2NsX3JvYnVzdF9zY29wdXMocGFuZWxfZGF0YXNldCA9IHByb2ZfcGFuZWxfZmlsdGVyLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxtX2Zvcm11bGEgPSB0d2l0dGVyX2Zvcm11bGFfbWFpbl9tb2RlbCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyX2N1dG9mZl91cHBlciA9IDIwMjMsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhcl9jdXRvZmZfbG93ZXIgPSAxOTc0KQ0KYGBgDQoNClBsb3QgZ2VuZGVyIGRpZmZlcmVuY2VzOg0KYGBge3IgZmlnLmhlaWdodD0zLCBmaWdoLndpZHRoID0gNH0NCiMgdXNlIHRoZSBwYWlyd2lzZSBjb21wYXJpc29ucyB0byBjb21wYXJlIGdyb3VwcyBpbiB0aGUgcGxvdA0KcF92YWx1ZXMgPC0gdHdpdHRlcl9tYWluX21vZGVsW1szXV0NCiMgbWFudWFsbHkgYWRkIHNvbWUgZWxlbWVudHMgd2UgbmVlZCB0byBldmVyeXRoaW5nIHRvIGxvb2sgZ29vZA0KcF92YWx1ZXMkeCA8LSBjKDEsIDIsIDMsIDQsIDUpDQpwX3ZhbHVlcyRncm91cHMgPC0gJ2MoIm0iLCAidyIpJw0KcF92YWx1ZXMkeG1pbiA8LSBjKDAuOCwgMS44LCAyLjgsIDMuOCwgNC44KQ0KcF92YWx1ZXMkeG1heCA8LSBjKDEuMiwgMi4yLCAzLjIsIDQuMiwgNS4yKQ0KDQpwcmVkaWN0aW9uc19wbG90IDwtIHR3aXR0ZXJfbWFpbl9tb2RlbFtbMl1dDQoNCnR3aXR0ZXJfZ2VuZGVyX3Bsb3QgPC0gcHJlZGljdGlvbnNfcGxvdCAlPiUNCiAgZ2dwbG90KGFlcyh4ID0gZmllbGQsDQogICAgICAgICAgICAgeSA9IHByZWRpY3RlZCwNCiAgICAgICAgICAgICB5bWluID0gY29uZi5sb3csDQogICAgICAgICAgICAgeW1heCA9IGNvbmYuaGlnaCwNCiAgICAgICAgICAgICBjb2xvciA9IHgpKSArDQogIGdlb21fcG9pbnRyYW5nZShwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gMC41KSwNCiAgICAgICAgICAgICAgICAgIHNpemUgPSAwLjUpKw0KICAjeWxpbSgyLCA1LjUpKw0KICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAxMDApLCBicmVha3MgPSBzZXEoMCwgMTAwLCBieSA9IDI1KSkrDQogIGdndGl0bGUoIlR3aXR0ZXIvWCBhdHRlbnRpb24gcHJlZGljdGlvbiIpKw0KICBzdGF0X3B2YWx1ZV9tYW51YWwoDQogICAgcF92YWx1ZXMsDQogICAgeS5wb3NpdGlvbiA9IGMoMzgsIDY4LCA5MywgMjUsIDgpLA0KICAgIGxhYmVsLnNpemUgPSAzLA0KICAgIHRpcC5sZW5ndGggPSAwLjAwMywNCiAgICBsYWJlbCA9ICJ7c3RhcnN9IiwNCiAgICByZW1vdmUuYnJhY2tldCA9IEZBTFNFLA0KICApKw0KICB4bGFiKCJGaWVsZCIpKw0KICBzY2FsZV94X2Rpc2NyZXRlKGxhYmVscz1jKCJhcnRzIiA9ICJBcnRzICZcbiBIdW1hbml0aWVzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaGVhbHRoIiA9ICJNZWRpY2luZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgInNvY19zY2kiID0gIlNvY2lhbCBzY2llbmNlcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgImxpZmUiID0gIkxpZmUgc2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwaHlzIiA9ICJQaHlzaWNhbCBzY2llbmNlcyIpKSsNCiAgeWxhYigiWWVhcmx5IGF0dGVudGlvbiIpKw0KICBsYWJzKGNvbG9yID0gIkluZmVycmVkIGdlbmRlciIpKw0KICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gYygiIzM0ZDM5OSIsICIjZmJiZjI0IiksIGxhYmVscyA9IGMoIk1lbiIsICJXb21lbiIpKSsNCiAgdGhlbWVfbWluaW1hbF9oZ3JpZCgpKw0KICB0aGVtZShwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTAsIGFuZ2xlID0gMzAsIGhqdXN0ID0gMC45KSAsDQogICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF90ZXh0KHNpemU9MTEpLCANCiAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9MTApKQ0KYGBgDQoNCiMjIyBDb21iaW5lZCBwbG90cw0KQ29tYmluZSB0aGlzIGFsbCB0byBwbG90IHRoZSBjb2VmZmljaWVudHMgaW4gb25lIHBsb3QuDQoNCkZpcnN0LCBwcmVwYXJlIHRoZSBkYXRhZnJhbWU6DQpgYGB7cn0NCm1vZGVsX25ld3MgPC0gbmV3c19tYWluX21vZGVsW1sxXV0NCm1vZGVsX29ubGluZV9uZXdzIDwtIG9ubGluZV9uZXdzX21haW5fbW9kZWxbWzFdXQ0KbW9kZWxfdHdpdHRlciA8LSB0d2l0dGVyX21haW5fbW9kZWxbWzFdXQ0KDQptb2RlbF9uZXdzJG1vZGVsIDwtICJOZXdzIGF0dGVudGlvbiINCm1vZGVsX29ubGluZV9uZXdzJG1vZGVsIDwtICJPbmxpbmUgbmV3cyBhdHRlbnRpb24iDQptb2RlbF90d2l0dGVyJG1vZGVsIDwtICJUd2l0dGVyIGF0dGVudGlvbiINCg0KYWxsX21vZGVsc19wbG90IDwtIHJiaW5kKG1vZGVsX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxfb25saW5lX25ld3MsDQogICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxfdHdpdHRlcikNCg0KIyBkbyB0aGUgdC0xIG9mIGRlcGVuZGVudCBhcyBhIHNpbmdsZSB2YXJpYWJsZQ0KYWxsX21vZGVsc19wbG90JHRlcm0gPC0gaWZlbHNlKGFsbF9tb2RlbHNfcGxvdCR0ZXJtICVpbiUgYygibmV3c19hbGxfbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhbHRfb25saW5lX2FsbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFsdF90d2l0dGVyX2wiKSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRfbWluXzEiLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxfbW9kZWxzX3Bsb3QkdGVybSkNCg0KDQphbGxfbW9kZWxzX3Bsb3QkdGVybSA8LSBvcmRlcmVkKGFsbF9tb2RlbHNfcGxvdCR0ZXJtLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMgPSBjKCIoSW50ZXJjZXB0KSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImluZmVycmVkX2dlbmRlcnciLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ0X21pbl8xIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2l0ZWRfYnlfdG90YWxfYWxsX2wiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuZXdzX2FsbF90b3RhbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWx0X29ubGluZV9hbGxfdG90YWxfbCIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhbHRfdHdpdHRlcl90b3RhbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29hX3RvdF9vbmxpbmVfYWxsX3RvdGFsX2wiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2FfdG90X3R3aXR0ZXJfdG90YWxfbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInllYXJzX3NpbmNlX2ZpcnN0X3B1YiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTQiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhcy5mYWN0b3IoeWVhcikyMDE1IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXMuZmFjdG9yKHllYXIpMjAxNiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTciLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhcy5mYWN0b3IoeWVhcikyMDE4IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXMuZmFjdG9yKHllYXIpMjAxOSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMjAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhcy5mYWN0b3IoeWVhcikyMDIxIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXMuZmFjdG9yKHllYXIpMjAyMiIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMjMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJSXjIiKSkNCg0KYWxsX21vZGVsc19wbG90JG1vZGVsIDwtIG9yZGVyZWQoYWxsX21vZGVsc19wbG90JG1vZGVsLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxzID0gYygiTmV3cyBhdHRlbnRpb24iLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiT25saW5lIG5ld3MgYXR0ZW50aW9uIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlR3aXR0ZXIgYXR0ZW50aW9uIiApKQ0KDQoNCmFsbF9tb2RlbHNfcGxvdCRmaWVsZCA8LSBvcmRlcmVkKGFsbF9tb2RlbHNfcGxvdCRmaWVsZCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVscyA9IGMoInBoeXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibGlmZSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJoZWFsdGgiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic29jX3NjaSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhcnRzIikpDQoNCmNvdmFyaWF0ZV9uYW1lcyA8LSBjKA0KICAndF9taW5fMScgPSAiRGVwZW5kZW50IHZhcmlhYmxlIC1cbiBwcmV2aW91cyBwZXJpb2QiLA0KICAnbmV3c19hbGxfbCc9Ik5ld3MgYXR0ZW50aW9uIC1cbnByZXZpb3VzIHBlcmlvZCIsDQogICdhbHRfb25saW5lX2FsbF9sJyA9ICJPbmxpbmUgbmV3cyBhdHRlbnRpb24gLVxucHJldmlvdXMgcGVyaW9kIiwNCiAgJ2FsdF90d2l0dGVyX2wnID0gIlR3aXR0ZXIgYXR0ZW50aW9uIC1cbnByZXZpb3VzIHBlcmlvZCIsDQogICdjaXRlZF9ieV90b3RhbF9hbGxfbCc9IlRvdGFsIGNpdGF0aW9ucyIsDQogICduZXdzX2FsbF90b3RhbF9sJz0iVG90YWwgcHJpbnRlZCBuZXdzIFxuYXR0ZW50aW9uIiwNCiAgJ2FsdF9vbmxpbmVfYWxsX3RvdGFsX2wnPSJUb3RhbCBvbmxpbmUgbmV3c1xuIGF0dGVudGlvbiIsDQogICdhbHRfdHdpdHRlcl90b3RhbF9sJz0iVG90YWwgVHdpdHRlci9YIFxuYXR0ZW50aW9uIiwNCiAgJ2NvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCcgPSAiQ29hdXRob3JzJyB0b3RhbCBcbmNpdGF0aW9ucyIsDQogICdjb2FfdG90X29ubGluZV9hbGxfdG90YWxfbCcgPSAiQ29hdXRob3JzJyB0b3RhbCBcbm9ubGluZSBuZXdzIGF0dGVudGlvbiIsDQogICdjb2FfdG90X3R3aXR0ZXJfdG90YWxfbCcgPSAiQ29hdXRob3JzJyB0b3RhbCBcblR3aXR0ZXIvWCBhdHRlbnRpb24iDQopDQpgYGANCg0KDQpgYGB7ciBmaWcud2lkdGg9IDEyLCBmaWcuaGVpZ2h0ID0gNCwgd2FybmluZyA9IEZ9DQpsZWdlbmQgPC0gZ2V0X2xlZ2VuZCgNCiAgIyBjcmVhdGUgc29tZSBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgbGVnZW5kDQogIG5ld3NfZ2VuZGVyX3Bsb3QNCikNCg0KY29tYmlfcGxvdF9yZWdyZXNzaW9uX3ByZWQgPC0gcGxvdF9ncmlkKG5ld3NfZ2VuZGVyX3Bsb3QgKyB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiLCBheGlzLnRpdGxlLnggPSBlbGVtZW50X2JsYW5rKCkpLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmxpbmVfbmV3c19nZW5kZXJfcGxvdCArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIsIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfYmxhbmsoKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdpdHRlcl9nZW5kZXJfcGxvdCArIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIsIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfYmxhbmsoKSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5jb2wgPSA0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduID0gJ2gnLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMgPSAndGInLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbF93aWR0aHMgPSBjKDEsIDEsIDEsIDAuNCkpDQpgYGANCg0KUGxvdCBvdXQgc2VsZWN0ZWQgcmVncmVzc2lvbiBjb2VmZmljaWVudHMgZm9yIFNURU06DQpgYGB7ciBmaWcud2lkdGg9MTIsIGZpZy5oZWlnaHQ9IDQsIHdhcm5pbmcgPSBGfQ0KIyByZW9yZGVyIHRoZSBmYWN0b3IgZm9yIEZpZ3VyZSAyDQphbGxfbW9kZWxzX3Bsb3QkdGVybSA8LSBvcmRlcmVkKGFsbF9tb2RlbHNfcGxvdCR0ZXJtLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVscyA9IGMoIihJbnRlcmNlcHQpIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbmZlcnJlZF9nZW5kZXJ3IiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXRlZF9ieV90b3RhbF9hbGxfbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmV3c19hbGxfdG90YWxfbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWx0X29ubGluZV9hbGxfdG90YWxfbCIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFsdF90d2l0dGVyX3RvdGFsX2wiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvYV90b3RfY2l0ZWRfYnlfdG90YWxfbCIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29hX3RvdF9vbmxpbmVfYWxsX3RvdGFsX2wiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvYV90b3RfdHdpdHRlcl90b3RhbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ5ZWFyc19zaW5jZV9maXJzdF9wdWIiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRfbWluXzEiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTQiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTYiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTciLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTgiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMTkiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMjAiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMjEiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMjIiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzLmZhY3Rvcih5ZWFyKTIwMjMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlJeMiIpKQ0KDQoNCihzZWxlY3RlZF9wbG90IDwtIGFsbF9tb2RlbHNfcGxvdCAlPiUNCiAgZmlsdGVyKHRlcm0gJWluJSBjKCJjaXRlZF9ieV90b3RhbF9hbGxfbCIsDQogICAgICAgICAgICAgICAgICAgICAiY29hX3RvdF9jaXRlZF9ieV90b3RhbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfdG90X29ubGluZV9hbGxfdG90YWxfbCIsDQogICAgICAgICAgICAgICAgICAgICAiY29hX3RvdF90d2l0dGVyX3RvdGFsX2wiLA0KICAgICAgICAgICAgICAgICAgICAgInRfbWluXzEiKSAmIGZpZWxkID09ICJwaHlzIikgJT4lDQogIGdncGxvdChhZXMoRXN0aW1hdGUsIGZpZWxkLCBjb2xvciA9IG1vZGVsLCBsYWJlbCA9IHN0YXJzKSkgKw0KICBnZW9tX3BvaW50KHBvc2l0aW9uID0gcG9zaXRpb25fZG9kZ2Uod2lkdGggPSAtMC43KSwgc2l6ZSA9IDMpICsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeG1pbiA9IGxvd2VyX2NpLCB4bWF4ID0gdXBwZXJfY2kpLA0KICAgICAgICAgICAgICAgIHdpZHRoPTAsDQogICAgICAgICAgICAgICAgc2l6ZT0wLjcsDQogICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbl9kb2RnZSh3aWR0aCA9IC0wLjcpKSArDQogIGdlb21fdGV4dChoanVzdD0wLCB2anVzdD0wLCBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gLTAuNyksIHNpemUgPSAzLjUpKw0KICAgc2NhbGVfeV9kaXNjcmV0ZShsYWJlbHM9YygiYXJ0cyIgPSAiQXJ0cyAmXG4gSHVtYW5pdGllcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgImhlYWx0aCIgPSAiTWVkaWNpbmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb2Nfc2NpIiA9ICJTb2NpYWwgc2NpZW5jZXMiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsaWZlIiA9ICJMaWZlIHNjaWVuY2VzIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGh5cyIgPSAiUGh5c2ljYWwgc2NpZW5jZXMiKSwNCiAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICJGaWVsZCIpKw0KICBzY2FsZV9jb2xvcl9tYW51YWwobGFiZWxzID0gYygiUHJpbnRlZCBuZXdzIiwgIk9ubGluZSBuZXdzIiwgIlR3aXR0ZXIvWCIpLCB2YWx1ZXMgPSBjKCIjRjg3NjZEIiwgIiMwMEJBMzgiLCAiIzYxOUNGRiIpKSsNCiAgc2NhbGVfeF9jb250aW51b3VzKA0KICAgIG4uYnJlYWtzID0gMywNCiAgICBsYWJlbHMgPSBmdW5jdGlvbih4KSBmb3JtYXQoeCwgc2NpZW50aWZpYyA9IFRSVUUpKSsNCiAgIyBhZGQgaW4gYSBkb3R0ZWQgbGluZSBhdCB6ZXJvDQogIGxhYnMoDQogICAgeCA9ICJSZWdyZXNzaW9uIGNvZWZmaWNpZW50IiwNCiAgICB5ID0gTlVMTCwNCiAgICBjb2xvciA9ICJBdHRlbnRpb24gdHlwZSINCiAgKSArIA0KICBnZW9tX3ZsaW5lKHhpbnRlcmNlcHQgPSAwLCAgY29sb3VyPSJibGFjayIsIGxpbmV0eXBlID0gImxvbmdkYXNoIikrDQogIGZhY2V0X3dyYXAoIH4gdGVybSwgc2NhbGVzPSJmcmVlX3giLCBsYWJlbGxlciA9IGFzX2xhYmVsbGVyKGNvdmFyaWF0ZV9uYW1lcyksIG5jb2wgPSA1KSsNCiAgdGhlbWVfYncoKSsNCiAgIHRoZW1lKHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCksDQogICAgICAgICBheGlzLnRpdGxlLnkgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTAsIGFuZ2xlID0gMzAsIGhqdXN0ID0gMC45KSAsDQogICAgICAgICBheGlzLnRpdGxlLnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDExKSwNCiAgICAgICAgIGxlZ2VuZC50aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xMCksIA0KICAgICAgICAgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9OSksDQogICAgICAgICBzdHJpcC50ZXh0Lng9ZWxlbWVudF90ZXh0KHNpemUgPSA5KSkpDQpgYGANCg0KYGBge3IgZmlnLmhlaWdodD04LCBmaWcud2lkdGg9MTMsIHdhcm5pbmcgPSBGfQ0KY29tYmlfcGxvdF9yZWdyZXNzaW9uIDwtIHBsb3RfZ3JpZCgNCiAgY29tYmlfcGxvdF9yZWdyZXNzaW9uX3ByZWQsDQogIHNlbGVjdGVkX3Bsb3QsDQogIG5jb2wgPSAxLA0KICBucm93ID0gMiwNCiAgYXhpcyA9ICdscicsDQogIGxhYmVscyA9IGMoIkEiLCAiQiIpDQopDQoNCmNvbWJpX3Bsb3RfcmVncmVzc2lvbg0KDQpnZ3NhdmUyKA0KICBmaWxlbmFtZSA9ICJyZXN1bHRzL3N1cHBsZW1lbnRfZmlndXJlcy9GaWd1cmVfMl9zY29wdXMucG5nIiwNCiAgcGxvdCA9IGNvbWJpX3Bsb3RfcmVncmVzc2lvbiwNCiAgd2lkdGggPSAxMSwNCiAgaGVpZ2h0ID0gNiwNCiAgdW5pdHMgPSBjKCJpbiIpLA0KICBkcGkgPSA2MDAsDQogIGJnID0gIndoaXRlIg0KKQ0KDQpgYGANCg0KQW5kIHBsb3Qgb3V0IHRoZSBjb2VmZmljaWVudHMgZm9yIGFsbCBmaWVsZHM6DQpgYGB7cn0NCihhbGxfZmllbGRzX3Bsb3QgPC0gYWxsX21vZGVsc19wbG90ICU+JQ0KICBmaWx0ZXIodGVybSAlaW4lIGMoImNpdGVkX2J5X3RvdGFsX2FsbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfdG90X2NpdGVkX2J5X3RvdGFsX2wiLA0KICAgICAgICAgICAgICAgICAgICAgImNvYV90b3Rfb25saW5lX2FsbF90b3RhbF9sIiwNCiAgICAgICAgICAgICAgICAgICAgICJjb2FfdG90X3R3aXR0ZXJfdG90YWxfbCIsDQogICAgICAgICAgICAgICAgICAgICAidF9taW5fMSIpKSAlPiUNCiAgZ2dwbG90KGFlcyhFc3RpbWF0ZSwgZmllbGQsIGNvbG9yID0gbW9kZWwsIGxhYmVsID0gc3RhcnMpKSArDQogIGdlb21fcG9pbnQocG9zaXRpb24gPSBwb3NpdGlvbl9kb2RnZSh3aWR0aCA9IC0wLjcpLCBzaXplID0gMykgKw0KICBnZW9tX2Vycm9yYmFyKGFlcyh4bWluID0gbG93ZXJfY2ksIHhtYXggPSB1cHBlcl9jaSksDQogICAgICAgICAgICAgICAgd2lkdGg9MCwNCiAgICAgICAgICAgICAgICBzaXplPTAuNywNCiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX2RvZGdlKHdpZHRoID0gLTAuNykpICsNCiAgZ2VvbV90ZXh0KGhqdXN0PTAsIHZqdXN0PTAsIHBvc2l0aW9uID0gcG9zaXRpb25fZG9kZ2Uod2lkdGggPSAtMC43KSwgc2l6ZSA9IDMuNSkrDQogICBzY2FsZV95X2Rpc2NyZXRlKGxhYmVscz1jKCJhcnRzIiA9ICJBcnRzICYgSHVtYW5pdGllcyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZWRpY2luZSIgPSAiTWVkaWNpbmUiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic29jX3NjaSIgPSAiU29jaWFsIHNjaWVuY2UiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RlbSIgPSAiU1RFTSIpLA0KICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gIkZpZWxkIikrDQogIHNjYWxlX2NvbG9yX21hbnVhbChsYWJlbHMgPSBjKCJQcmludGVkIG5ld3MiLCAiT25saW5lIG5ld3MiLCAiVHdpdHRlci9YIiksIHZhbHVlcyA9IGMoIiNGODc2NkQiLCAiIzAwQkEzOCIsICIjNjE5Q0ZGIikpKw0KICBzY2FsZV94X2NvbnRpbnVvdXMoDQogICAgbi5icmVha3MgPSAzLA0KICAgIGxhYmVscyA9IGZ1bmN0aW9uKHgpIGZvcm1hdCh4LCBzY2llbnRpZmljID0gVFJVRSkpKw0KICAjIGFkZCBpbiBhIGRvdHRlZCBsaW5lIGF0IHplcm8NCiAgbGFicygNCiAgICB4ID0gIlJlZ3Jlc3Npb24gY29lZmZpY2llbnQiLA0KICAgIHkgPSBOVUxMLA0KICAgIGNvbG9yID0gIkF0dGVudGlvbiB0eXBlIg0KICApICsgDQogIGdlb21fdmxpbmUoeGludGVyY2VwdCA9IDAsICBjb2xvdXI9ImJsYWNrIiwgbGluZXR5cGUgPSAibG9uZ2Rhc2giKSsNCiAgZmFjZXRfd3JhcCggfiB0ZXJtLCBzY2FsZXM9ImZyZWVfeCIsIGxhYmVsbGVyID0gYXNfbGFiZWxsZXIoY292YXJpYXRlX25hbWVzKSwgbmNvbCA9IDUpKw0KICB0aGVtZV9idygpKw0KICAgdGhlbWUocGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTApLA0KICAgICAgICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEwKSwNCiAgICAgICAgIGF4aXMudGl0bGUueSA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgIGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxMCwgYW5nbGUgPSAzMCwgaGp1c3QgPSAwLjkpICwNCiAgICAgICAgIGF4aXMudGl0bGUueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTEpLA0KICAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTEwKSwgDQogICAgICAgICBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT05KSwNCiAgICAgICAgIHN0cmlwLnRleHQueD1lbGVtZW50X3RleHQoc2l6ZSA9IDkpKSkNCg0KDQojIGdnc2F2ZTIoDQojICAgZmlsZW5hbWUgPSAicmVzdWx0cy9zdXBwbGVtZW50X2ZpZ3VyZXMvRmlndXJlXzJCX2FsbF9maWVsZHMucG5nIiwNCiMgICBwbG90ID0gYWxsX2ZpZWxkc19wbG90LA0KIyAgIHdpZHRoID0gMTIsDQojICAgaGVpZ2h0ID0gNCwNCiMgICB1bml0cyA9IGMoImluIiksDQojICAgZHBpID0gNjAwLA0KIyAgIGJnID0gIndoaXRlIg0KIyApDQpgYGANCg0KUHJpbnQgb3V0IHRoZSByZXN1bHRzIGludG8gYSB0YWJsZToNCmBgYHtyfQ0Kb3B0aW9ucyhzY2lwZW49OTk5KQ0KDQp0YWJsZV9tb2RlbHMgPC0gbmVhdF9yZWdyZXNzaW9uX3RhYmxlKG5ld3NfbWFpbl9tb2RlbFtbMV1dLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmxpbmVfbmV3c19tYWluX21vZGVsW1sxXV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3aXR0ZXJfbWFpbl9tb2RlbFtbMV1dKQ0KDQp0YWJsZV9tb2RlbHNfc2F2ZSA8LSB0YWJsZV9tb2RlbHMgJT4lDQogIHJlZ3VsYXJ0YWJsZSgpICU+JSANCiAgYXV0b2ZpdCgpDQoNCiMgd29yZF9kb2N1bWVudF9uYW1lIDwtDQojICAgICByZWFkX2RvY3goKSAlPiUNCiMgICAgIGJvZHlfYWRkX2ZsZXh0YWJsZSh0YWJsZV9tb2RlbHNfc2F2ZSkgJT4lDQojICAgICBwcmludCh0YXJnZXQgPSAicmVzdWx0cy9zdXBwbGVtZW50X3RhYmxlcy9tYWluX21vZGVsX3RhYmxlLmRvY3giKQ0KYGBgDQo=</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("Analyses_main_scopus.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
